Directory structure:
└── code/
    ├── README.md
    ├── CHANGELOG.md
    ├── LICENSE
    ├── analysis_options.yaml
    ├── melos.yaml
    ├── pubspec.lock
    ├── pubspec.yaml
    ├── .metadata
    ├── chatbot_example/
    │   ├── README.md
    │   ├── analysis_options.yaml
    │   ├── apphosting.yaml
    │   ├── devtools_options.yaml
    │   ├── firebase.json
    │   ├── pubspec.lock
    │   ├── pubspec.yaml
    │   ├── pubspec_overrides.yaml
    │   ├── .firebaserc
    │   ├── .gitignore
    │   ├── .metadata
    │   ├── android/
    │   │   ├── gradle.properties
    │   │   ├── .gitignore
    │   │   ├── app/
    │   │   │   └── src/
    │   │   │       ├── debug/
    │   │   │       │   └── AndroidManifest.xml
    │   │   │       ├── main/
    │   │   │       │   ├── AndroidManifest.xml
    │   │   │       │   ├── kotlin/
    │   │   │       │   │   └── com/
    │   │   │       │   │       └── example/
    │   │   │       │   │           └── likeminds_chatbot_flutter_sample/
    │   │   │       │   │               └── MainActivity.kt
    │   │   │       │   └── res/
    │   │   │       │       ├── drawable/
    │   │   │       │       │   └── launch_background.xml
    │   │   │       │       ├── drawable-v21/
    │   │   │       │       │   └── launch_background.xml
    │   │   │       │       ├── mipmap-hdpi/
    │   │   │       │       ├── mipmap-mdpi/
    │   │   │       │       ├── mipmap-xhdpi/
    │   │   │       │       ├── mipmap-xxhdpi/
    │   │   │       │       ├── mipmap-xxxhdpi/
    │   │   │       │       ├── values/
    │   │   │       │       │   └── styles.xml
    │   │   │       │       └── values-night/
    │   │   │       │           └── styles.xml
    │   │   │       └── profile/
    │   │   │           └── AndroidManifest.xml
    │   │   └── gradle/
    │   │       └── wrapper/
    │   │           └── gradle-wrapper.properties
    │   ├── ios/
    │   │   ├── Podfile
    │   │   ├── Podfile.lock
    │   │   ├── .gitignore
    │   │   ├── Flutter/
    │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   ├── Debug.xcconfig
    │   │   │   └── Release.xcconfig
    │   │   ├── Runner/
    │   │   │   ├── AppDelegate.swift
    │   │   │   ├── Info.plist
    │   │   │   ├── Runner-Bridging-Header.h
    │   │   │   ├── Assets.xcassets/
    │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │       ├── README.md
    │   │   │   │       └── Contents.json
    │   │   │   └── Base.lproj/
    │   │   │       ├── LaunchScreen.storyboard
    │   │   │       └── Main.storyboard
    │   │   ├── Runner.xcodeproj/
    │   │   │   ├── project.pbxproj
    │   │   │   ├── project.xcworkspace/
    │   │   │   │   ├── contents.xcworkspacedata
    │   │   │   │   └── xcshareddata/
    │   │   │   │       ├── IDEWorkspaceChecks.plist
    │   │   │   │       └── WorkspaceSettings.xcsettings
    │   │   │   └── xcshareddata/
    │   │   │       └── xcschemes/
    │   │   │           └── Runner.xcscheme
    │   │   ├── Runner.xcworkspace/
    │   │   │   ├── contents.xcworkspacedata
    │   │   │   └── xcshareddata/
    │   │   │       ├── IDEWorkspaceChecks.plist
    │   │   │       └── WorkspaceSettings.xcsettings
    │   │   └── RunnerTests/
    │   │       └── RunnerTests.swift
    │   ├── lib/
    │   │   ├── app.dart
    │   │   ├── main.dart
    │   │   ├── onboarding/
    │   │   │   └── cred_screen.dart
    │   │   └── utils/
    │   │       ├── example_callback.dart
    │   │       ├── firebase_options.dart
    │   │       ├── mock_intiate_user.dart
    │   │       └── network_handling.dart
    │   ├── linux/
    │   │   ├── CMakeLists.txt
    │   │   ├── main.cc
    │   │   ├── my_application.cc
    │   │   ├── my_application.h
    │   │   ├── .gitignore
    │   │   └── flutter/
    │   │       ├── CMakeLists.txt
    │   │       ├── generated_plugin_registrant.cc
    │   │       ├── generated_plugin_registrant.h
    │   │       └── generated_plugins.cmake
    │   ├── macos/
    │   │   ├── Podfile
    │   │   ├── .gitignore
    │   │   ├── Flutter/
    │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   ├── Flutter-Release.xcconfig
    │   │   │   └── GeneratedPluginRegistrant.swift
    │   │   ├── Runner/
    │   │   │   ├── AppDelegate.swift
    │   │   │   ├── DebugProfile.entitlements
    │   │   │   ├── Info.plist
    │   │   │   ├── MainFlutterWindow.swift
    │   │   │   ├── Release.entitlements
    │   │   │   ├── Assets.xcassets/
    │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │       └── Contents.json
    │   │   │   ├── Base.lproj/
    │   │   │   │   └── MainMenu.xib
    │   │   │   └── Configs/
    │   │   │       ├── AppInfo.xcconfig
    │   │   │       ├── Debug.xcconfig
    │   │   │       ├── Release.xcconfig
    │   │   │       └── Warnings.xcconfig
    │   │   ├── Runner.xcodeproj/
    │   │   │   ├── project.pbxproj
    │   │   │   ├── project.xcworkspace/
    │   │   │   │   └── xcshareddata/
    │   │   │   │       └── IDEWorkspaceChecks.plist
    │   │   │   └── xcshareddata/
    │   │   │       └── xcschemes/
    │   │   │           └── Runner.xcscheme
    │   │   ├── Runner.xcworkspace/
    │   │   │   ├── contents.xcworkspacedata
    │   │   │   └── xcshareddata/
    │   │   │       └── IDEWorkspaceChecks.plist
    │   │   └── RunnerTests/
    │   │       └── RunnerTests.swift
    │   ├── test/
    │   │   └── widget_test.dart
    │   ├── web/
    │   │   ├── index.html
    │   │   ├── manifest.json
    │   │   └── icons/
    │   └── windows/
    │       ├── CMakeLists.txt
    │       ├── .gitignore
    │       ├── flutter/
    │       │   ├── CMakeLists.txt
    │       │   ├── generated_plugin_registrant.cc
    │       │   ├── generated_plugin_registrant.h
    │       │   └── generated_plugins.cmake
    │       └── runner/
    │           ├── CMakeLists.txt
    │           ├── Runner.rc
    │           ├── flutter_window.cpp
    │           ├── flutter_window.h
    │           ├── main.cpp
    │           ├── resource.h
    │           ├── runner.exe.manifest
    │           ├── utils.cpp
    │           ├── utils.h
    │           ├── win32_window.cpp
    │           ├── win32_window.h
    │           └── resources/
    ├── example/
    │   ├── README.md
    │   ├── analysis_options.yaml
    │   ├── devtools_options.yaml
    │   ├── firebase.json
    │   ├── pubspec.lock
    │   ├── pubspec.yaml
    │   ├── pubspec_overrides.yaml
    │   ├── .fvmrc
    │   ├── .gitignore
    │   ├── .metadata
    │   ├── android/
    │   │   ├── gradle.properties
    │   │   ├── .gitignore
    │   │   ├── app/
    │   │   │   ├── google-services.json
    │   │   │   └── src/
    │   │   │       ├── debug/
    │   │   │       │   └── AndroidManifest.xml
    │   │   │       ├── main/
    │   │   │       │   ├── AndroidManifest.xml
    │   │   │       │   ├── kotlin/
    │   │   │       │   │   └── com/
    │   │   │       │   │       └── example/
    │   │   │       │   │           └── likeminds_chat_flutter_sample/
    │   │   │       │   │               └── MainActivity.kt
    │   │   │       │   └── res/
    │   │   │       │       ├── drawable/
    │   │   │       │       │   └── launch_background.xml
    │   │   │       │       ├── drawable-v21/
    │   │   │       │       │   └── launch_background.xml
    │   │   │       │       ├── mipmap-hdpi/
    │   │   │       │       ├── mipmap-mdpi/
    │   │   │       │       ├── mipmap-xhdpi/
    │   │   │       │       ├── mipmap-xxhdpi/
    │   │   │       │       ├── mipmap-xxxhdpi/
    │   │   │       │       ├── values/
    │   │   │       │       │   └── styles.xml
    │   │   │       │       └── values-night/
    │   │   │       │           └── styles.xml
    │   │   │       └── profile/
    │   │   │           └── AndroidManifest.xml
    │   │   └── gradle/
    │   │       └── wrapper/
    │   │           └── gradle-wrapper.properties
    │   ├── ios/
    │   │   ├── Podfile
    │   │   ├── Podfile.lock
    │   │   ├── .gitignore
    │   │   ├── Flutter/
    │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   ├── Debug.xcconfig
    │   │   │   └── Release.xcconfig
    │   │   ├── Runner/
    │   │   │   ├── AppDelegate.swift
    │   │   │   ├── GoogleService-Info.plist
    │   │   │   ├── Info.plist
    │   │   │   ├── Runner-Bridging-Header.h
    │   │   │   ├── Runner.entitlements
    │   │   │   ├── Assets.xcassets/
    │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   │   └── Contents.json
    │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │       ├── README.md
    │   │   │   │       └── Contents.json
    │   │   │   └── Base.lproj/
    │   │   │       ├── LaunchScreen.storyboard
    │   │   │       └── Main.storyboard
    │   │   ├── Runner.xcodeproj/
    │   │   │   ├── project.pbxproj
    │   │   │   ├── project.xcworkspace/
    │   │   │   │   ├── contents.xcworkspacedata
    │   │   │   │   └── xcshareddata/
    │   │   │   │       ├── IDEWorkspaceChecks.plist
    │   │   │   │       └── WorkspaceSettings.xcsettings
    │   │   │   └── xcshareddata/
    │   │   │       └── xcschemes/
    │   │   │           └── Runner.xcscheme
    │   │   ├── Runner.xcworkspace/
    │   │   │   └── contents.xcworkspacedata
    │   │   └── RunnerTests/
    │   │       └── RunnerTests.swift
    │   ├── lib/
    │   │   ├── app.dart
    │   │   ├── main.dart
    │   │   ├── onboarding/
    │   │   │   └── cred_screen.dart
    │   │   ├── storybook/
    │   │   │   └── storybook.dart
    │   │   └── utils/
    │   │       ├── example_callback.dart
    │   │       ├── firebase_options.dart
    │   │       ├── mock_intiate_user.dart
    │   │       └── network_handling.dart
    │   ├── linux/
    │   │   ├── CMakeLists.txt
    │   │   ├── main.cc
    │   │   ├── my_application.cc
    │   │   ├── my_application.h
    │   │   ├── .gitignore
    │   │   └── flutter/
    │   │       ├── CMakeLists.txt
    │   │       ├── generated_plugin_registrant.cc
    │   │       ├── generated_plugin_registrant.h
    │   │       └── generated_plugins.cmake
    │   ├── macos/
    │   │   ├── Podfile
    │   │   ├── Podfile.lock
    │   │   ├── .gitignore
    │   │   ├── Flutter/
    │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   ├── Flutter-Release.xcconfig
    │   │   │   └── GeneratedPluginRegistrant.swift
    │   │   ├── Runner/
    │   │   │   ├── AppDelegate.swift
    │   │   │   ├── DebugProfile.entitlements
    │   │   │   ├── GoogleService-Info.plist
    │   │   │   ├── Info.plist
    │   │   │   ├── MainFlutterWindow.swift
    │   │   │   ├── Release.entitlements
    │   │   │   ├── Assets.xcassets/
    │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │       └── Contents.json
    │   │   │   ├── Base.lproj/
    │   │   │   │   └── MainMenu.xib
    │   │   │   └── Configs/
    │   │   │       ├── AppInfo.xcconfig
    │   │   │       ├── Debug.xcconfig
    │   │   │       ├── Release.xcconfig
    │   │   │       └── Warnings.xcconfig
    │   │   ├── Runner.xcodeproj/
    │   │   │   ├── project.pbxproj
    │   │   │   ├── project.xcworkspace/
    │   │   │   │   └── xcshareddata/
    │   │   │   │       └── IDEWorkspaceChecks.plist
    │   │   │   └── xcshareddata/
    │   │   │       └── xcschemes/
    │   │   │           └── Runner.xcscheme
    │   │   ├── Runner.xcworkspace/
    │   │   │   ├── contents.xcworkspacedata
    │   │   │   └── xcshareddata/
    │   │   │       └── IDEWorkspaceChecks.plist
    │   │   └── RunnerTests/
    │   │       └── RunnerTests.swift
    │   ├── test/
    │   │   └── widget_test.dart
    │   ├── web/
    │   │   ├── index.html
    │   │   ├── manifest.json
    │   │   └── icons/
    │   └── windows/
    │       ├── CMakeLists.txt
    │       ├── .gitignore
    │       ├── flutter/
    │       │   ├── CMakeLists.txt
    │       │   ├── generated_plugin_registrant.cc
    │       │   ├── generated_plugin_registrant.h
    │       │   └── generated_plugins.cmake
    │       └── runner/
    │           ├── CMakeLists.txt
    │           ├── Runner.rc
    │           ├── flutter_window.cpp
    │           ├── flutter_window.h
    │           ├── main.cpp
    │           ├── resource.h
    │           ├── runner.exe.manifest
    │           ├── utils.cpp
    │           ├── utils.h
    │           ├── win32_window.cpp
    │           ├── win32_window.h
    │           └── resources/
    ├── lib/
    │   ├── likeminds_chat_flutter.dart
    │   └── packages/
    │       ├── core/
    │       │   ├── README.md
    │       │   ├── CHANGELOG.md
    │       │   ├── LICENSE
    │       │   ├── analysis_options.yaml
    │       │   ├── devtools_options.yaml
    │       │   ├── pubspec.yaml
    │       │   ├── pubspec_overrides.yaml
    │       │   ├── .flutter-plugins
    │       │   ├── .flutter-plugins-dependencies
    │       │   ├── .gitignore
    │       │   ├── .metadata
    │       │   ├── .pubignore
    │       │   ├── assets/
    │       │   │   ├── icons/
    │       │   │   └── images/
    │       │   ├── lib/
    │       │   │   ├── likeminds_chat_flutter_core.dart
    │       │   │   ├── packages/
    │       │   │   │   ├── flutter_typeahead/
    │       │   │   │   │   ├── README.md
    │       │   │   │   │   ├── LICENSE
    │       │   │   │   │   └── lib/
    │       │   │   │   │       ├── flutter_typeahead.dart
    │       │   │   │   │       └── src/
    │       │   │   │   │           ├── keyboard_suggestion_selection_notifier.dart
    │       │   │   │   │           ├── should_refresh_suggestion_focus_index_notifier.dart
    │       │   │   │   │           ├── typedef.dart
    │       │   │   │   │           ├── utils.dart
    │       │   │   │   │           ├── cupertino/
    │       │   │   │   │           │   ├── field/
    │       │   │   │   │           │   │   ├── cupertino_text_field_configuration.dart
    │       │   │   │   │           │   │   ├── cupertino_typeahead_field.dart
    │       │   │   │   │           │   │   └── cupertino_typeahead_form_field.dart
    │       │   │   │   │           │   └── suggestions_box/
    │       │   │   │   │           │       ├── cupertino_suggestions_box.dart
    │       │   │   │   │           │       ├── cupertino_suggestions_box_controller.dart
    │       │   │   │   │           │       ├── cupertino_suggestions_box_decoration.dart
    │       │   │   │   │           │       └── cupertino_suggestions_list.dart
    │       │   │   │   │           └── material/
    │       │   │   │   │               ├── field/
    │       │   │   │   │               │   ├── text_field_configuration.dart
    │       │   │   │   │               │   ├── typeahead_field.dart
    │       │   │   │   │               │   └── typeahead_form_field.dart
    │       │   │   │   │               └── suggestions_box/
    │       │   │   │   │                   ├── suggestions_box.dart
    │       │   │   │   │                   ├── suggestions_box_controller.dart
    │       │   │   │   │                   ├── suggestions_box_decoration.dart
    │       │   │   │   │                   └── suggestions_list.dart
    │       │   │   │   └── pluralize/
    │       │   │   │       ├── pluralize.dart
    │       │   │   │       └── mixins/
    │       │   │   │           ├── pluralize_utils.dart
    │       │   │   │           └── data/
    │       │   │   │               ├── pluralize_irregular_data.dart
    │       │   │   │               ├── pluralize_plural_data.dart
    │       │   │   │               ├── pluralize_singular_data.dart
    │       │   │   │               └── pluralize_uncountable_data.dart
    │       │   │   └── src/
    │       │   │       ├── blocs/
    │       │   │       │   ├── blocs.dart
    │       │   │       │   ├── observer.dart
    │       │   │       │   ├── analytics/
    │       │   │       │   │   ├── analytics_bloc.dart
    │       │   │       │   │   ├── analytics_event.dart
    │       │   │       │   │   ├── analytics_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       └── fire_analytics_event_handler.dart
    │       │   │       │   ├── chatroom/
    │       │   │       │   │   ├── chatroom_bloc.dart
    │       │   │       │   │   ├── chatroom_event.dart
    │       │   │       │   │   ├── chatroom_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       └── fetch_chatroom_handler.dart
    │       │   │       │   ├── chatroom_action/
    │       │   │       │   │   ├── chatroom_action_bloc.dart
    │       │   │       │   │   ├── chatroom_action_event.dart
    │       │   │       │   │   ├── chatroom_action_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       ├── hide_emoji_keyboard_handler.dart
    │       │   │       │   │       ├── mark_read_chatroom_handler.dart
    │       │   │       │   │       ├── set_chatroom_topic_handler.dart
    │       │   │       │   │       └── show_emoji_keyboard_handler.dart
    │       │   │       │   ├── conversation/
    │       │   │       │   │   ├── conversation_bloc.dart
    │       │   │       │   │   ├── conversation_event.dart
    │       │   │       │   │   ├── conversation_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       ├── fetch_conversation_handler.dart
    │       │   │       │   │       ├── initialise_conversations_handler.dart
    │       │   │       │   │       ├── local_conversation_handler.dart
    │       │   │       │   │       ├── post_conversation_handler.dart
    │       │   │       │   │       ├── post_multimedia_conversation_handler.dart
    │       │   │       │   │       ├── post_poll_handler.dart
    │       │   │       │   │       └── update_conversation_handler.dart
    │       │   │       │   ├── conversation_action/
    │       │   │       │   │   ├── conversation_action_bloc.dart
    │       │   │       │   │   ├── conversation_action_event.dart
    │       │   │       │   │   ├── conversation_action_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       ├── delete_conversation_event_handler.dart
    │       │   │       │   │       ├── delete_reaction_handler.dart
    │       │   │       │   │       ├── edit_conversation_event_handler.dart
    │       │   │       │   │       ├── link_preview_removed_event_handler.dart
    │       │   │       │   │       ├── put_reaction_handler.dart
    │       │   │       │   │       ├── refresh_bar_event_handler.dart
    │       │   │       │   │       ├── reply_conversation_event_handler.dart
    │       │   │       │   │       └── text_change_event_handler.dart
    │       │   │       │   ├── dm/
    │       │   │       │   │   ├── dm_bloc.dart
    │       │   │       │   │   ├── dm_event.dart
    │       │   │       │   │   ├── dm_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       ├── fetch_event_handler.dart
    │       │   │       │   │       ├── parsing_result_handler.dart
    │       │   │       │   │       └── refresh_event_handler.dart
    │       │   │       │   ├── explore/
    │       │   │       │   │   └── bloc/
    │       │   │       │   │       ├── explore_bloc.dart
    │       │   │       │   │       ├── explore_event.dart
    │       │   │       │   │       ├── explore_state.dart
    │       │   │       │   │       └── handler/
    │       │   │       │   │           ├── fetch_explore_handler.dart
    │       │   │       │   │           ├── pin_explore_space_handler.dart
    │       │   │       │   │           └── refresh_explore_event_handler.dart
    │       │   │       │   ├── home/
    │       │   │       │   │   ├── home_bloc.dart
    │       │   │       │   │   ├── home_event.dart
    │       │   │       │   │   ├── home_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       ├── fetch_event_handler.dart
    │       │   │       │   │       ├── parsing_result_handler.dart
    │       │   │       │   │       └── refresh_event_handler.dart
    │       │   │       │   ├── moderation/
    │       │   │       │   │   ├── moderation_bloc.dart
    │       │   │       │   │   ├── moderation_event.dart
    │       │   │       │   │   ├── moderation_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       ├── fetch_report_tag_event_handler.dart
    │       │   │       │   │       └── post_report_event_handler.dart
    │       │   │       │   ├── participants/
    │       │   │       │   │   ├── participants_bloc.dart
    │       │   │       │   │   ├── participants_event.dart
    │       │   │       │   │   ├── participants_state.dart
    │       │   │       │   │   └── handler/
    │       │   │       │   │       └── get_participants_handler.dart
    │       │   │       │   └── profile/
    │       │   │       │       ├── profile_bloc.dart
    │       │   │       │       ├── profile_event.dart
    │       │   │       │       ├── profile_state.dart
    │       │   │       │       └── event_handler/
    │       │   │       │           ├── login_required_event_handler.dart
    │       │   │       │           ├── logout_event_handler.dart
    │       │   │       │           └── route_to_user_profile_event_handler.dart
    │       │   │       ├── convertors/
    │       │   │       │   ├── convertors.dart
    │       │   │       │   ├── attachment/
    │       │   │       │   │   └── attachment_convertor.dart
    │       │   │       │   ├── chatroom/
    │       │   │       │   │   └── chatroom_convertor.dart
    │       │   │       │   ├── conversation/
    │       │   │       │   │   └── conversation_convertor.dart
    │       │   │       │   ├── moderation/
    │       │   │       │   │   └── report_tag_convertor.dart
    │       │   │       │   ├── og_tag/
    │       │   │       │   │   └── og_tag_convertor.dart
    │       │   │       │   ├── poll/
    │       │   │       │   │   └── poll_option_convertor.dart
    │       │   │       │   ├── reaction/
    │       │   │       │   │   └── reaction_convertor.dart
    │       │   │       │   ├── tag/
    │       │   │       │   │   └── tag_convertor.dart
    │       │   │       │   ├── user/
    │       │   │       │   │   ├── sdk_client_info_convertor.dart
    │       │   │       │   │   └── user_convertor.dart
    │       │   │       │   └── widget/
    │       │   │       │       └── widget_convertor.dart
    │       │   │       ├── core/
    │       │   │       │   ├── core.dart
    │       │   │       │   └── configurations/
    │       │   │       │       ├── chat_builder.dart
    │       │   │       │       ├── chat_config.dart
    │       │   │       │       └── widget_source.dart
    │       │   │       ├── services/
    │       │   │       │   ├── lm_amazon_s3_service.dart
    │       │   │       │   └── media_service.dart
    │       │   │       ├── utils/
    │       │   │       │   ├── utils.dart
    │       │   │       │   ├── callback/
    │       │   │       │   │   └── lm_chat_callback.dart
    │       │   │       │   ├── chatroom/
    │       │   │       │   │   ├── chatroom_utils.dart
    │       │   │       │   │   └── explore_utils.dart
    │       │   │       │   ├── constants/
    │       │   │       │   │   ├── analytics.dart
    │       │   │       │   │   ├── assets.dart
    │       │   │       │   │   ├── enums.dart
    │       │   │       │   │   └── strings.dart
    │       │   │       │   ├── conversation/
    │       │   │       │   │   ├── conversation_action_helper.dart
    │       │   │       │   │   └── conversation_utils.dart
    │       │   │       │   ├── credentials/
    │       │   │       │   │   ├── credentials.dart
    │       │   │       │   │   ├── credentials.g.dart
    │       │   │       │   │   ├── giphy.dart
    │       │   │       │   │   └── giphy.g.dart
    │       │   │       │   ├── extension/
    │       │   │       │   │   ├── container_extension.dart
    │       │   │       │   │   ├── context_extension.dart
    │       │   │       │   │   ├── custom_pop_up_menu_extension.dart
    │       │   │       │   │   ├── extension.dart
    │       │   │       │   │   ├── list_extension.dart
    │       │   │       │   │   └── tab_bar_extension.dart
    │       │   │       │   ├── firebase/
    │       │   │       │   │   ├── firebase.dart
    │       │   │       │   │   ├── firebase_credentials.dart
    │       │   │       │   │   └── firebase_credentials.g.dart
    │       │   │       │   ├── media/
    │       │   │       │   │   ├── audio_handler.dart
    │       │   │       │   │   ├── media_handler.dart
    │       │   │       │   │   └── permission_handler.dart
    │       │   │       │   ├── member_rights/
    │       │   │       │   │   └── member_rights.dart
    │       │   │       │   ├── notifications/
    │       │   │       │   │   └── notification_handler.dart
    │       │   │       │   ├── preferences/
    │       │   │       │   │   └── preferences.dart
    │       │   │       │   └── realtime/
    │       │   │       │       └── realtime.dart
    │       │   │       ├── views/
    │       │   │       │   ├── views.dart
    │       │   │       │   ├── chatbot/
    │       │   │       │   │   └── init_chatbot.dart
    │       │   │       │   ├── chatroom/
    │       │   │       │   │   ├── chatroom.dart
    │       │   │       │   │   └── configurations/
    │       │   │       │   │       ├── builder.dart
    │       │   │       │   │       ├── config.dart
    │       │   │       │   │       ├── setting.dart
    │       │   │       │   │       └── style.dart
    │       │   │       │   ├── explore/
    │       │   │       │   │   ├── explore.dart
    │       │   │       │   │   └── configurations/
    │       │   │       │   │       ├── builder.dart
    │       │   │       │   │       ├── config.dart
    │       │   │       │   │       ├── setting.dart
    │       │   │       │   │       └── style.dart
    │       │   │       │   ├── home/
    │       │   │       │   │   ├── home.dart
    │       │   │       │   │   └── configurations/
    │       │   │       │   │       ├── builder.dart
    │       │   │       │   │       ├── config.dart
    │       │   │       │   │       ├── settings.dart
    │       │   │       │   │       └── style.dart
    │       │   │       │   ├── media/
    │       │   │       │   │   ├── media_forwarding.dart
    │       │   │       │   │   ├── media_preview.dart
    │       │   │       │   │   └── configurations/
    │       │   │       │   │       ├── forwarding/
    │       │   │       │   │       │   ├── builder.dart
    │       │   │       │   │       │   ├── config.dart
    │       │   │       │   │       │   ├── setting.dart
    │       │   │       │   │       │   └── style.dart
    │       │   │       │   │       └── preview/
    │       │   │       │   │           ├── builder.dart
    │       │   │       │   │           ├── config.dart
    │       │   │       │   │           ├── setting.dart
    │       │   │       │   │           └── style.dart
    │       │   │       │   ├── participants/
    │       │   │       │   │   ├── participants.dart
    │       │   │       │   │   └── configurations/
    │       │   │       │   │       ├── builder.dart
    │       │   │       │   │       ├── config.dart
    │       │   │       │   │       ├── setting.dart
    │       │   │       │   │       └── style.dart
    │       │   │       │   ├── poll/
    │       │   │       │   │   ├── create_poll.dart
    │       │   │       │   │   ├── poll_handler.dart
    │       │   │       │   │   ├── poll_result.dart
    │       │   │       │   │   └── configurations/
    │       │   │       │   │       ├── config.dart
    │       │   │       │   │       ├── create_poll_builder.dart
    │       │   │       │   │       ├── poll_result_builder.dart
    │       │   │       │   │       ├── setting.dart
    │       │   │       │   │       └── style.dart
    │       │   │       │   └── report/
    │       │   │       │       ├── report.dart
    │       │   │       │       └── configurations/
    │       │   │       │           ├── builder.dart
    │       │   │       │           ├── config.dart
    │       │   │       │           ├── setting.dart
    │       │   │       │           └── style.dart
    │       │   │       └── widgets/
    │       │   │           ├── widgets.dart
    │       │   │           ├── button/
    │       │   │           │   └── chatbot_button.dart
    │       │   │           ├── chatroom/
    │       │   │           │   ├── chatroom_bar.dart
    │       │   │           │   ├── chatroom_bar_header.dart
    │       │   │           │   ├── chatroom_bar_menu.dart
    │       │   │           │   └── chatroom_menu.dart
    │       │   │           ├── explore/
    │       │   │           │   ├── explore_join_button.dart
    │       │   │           │   └── explore_tile.dart
    │       │   │           ├── lists/
    │       │   │           │   ├── chatroom/
    │       │   │           │   │   ├── chatroom_list.dart
    │       │   │           │   │   └── dm_chatroom_list.dart
    │       │   │           │   └── conversation/
    │       │   │           │       ├── conversation_list.dart
    │       │   │           │       └── dm_conversation_list.dart
    │       │   │           └── text_field/
    │       │   │               └── text_field.dart
    │       │   └── test/
    │       │       └── likeminds_chat_flutter_core_test.dart
    │       └── ui/
    │           ├── README.md
    │           ├── CHANGELOG.md
    │           ├── LICENSE
    │           ├── analysis_options.yaml
    │           ├── devtools_options.yaml
    │           ├── pubspec.yaml
    │           ├── pubspec_overrides.yaml
    │           ├── .flutter-plugins
    │           ├── .flutter-plugins-dependencies
    │           ├── .gitignore
    │           ├── .metadata
    │           ├── .pubignore
    │           ├── assets/
    │           │   └── icons/
    │           ├── lib/
    │           │   ├── likeminds_chat_flutter_ui.dart
    │           │   ├── packages/
    │           │   │   ├── expandable_text/
    │           │   │   │   ├── expandable_text.dart
    │           │   │   │   └── text_parser.dart
    │           │   │   └── linkify/
    │           │   │       ├── linkify.dart
    │           │   │       └── src/
    │           │   │           ├── email.dart
    │           │   │           └── url.dart
    │           │   └── src/
    │           │       ├── models/
    │           │       │   ├── models.dart
    │           │       │   ├── attachment/
    │           │       │   │   └── attachment_view_data.dart
    │           │       │   ├── chatroom/
    │           │       │   │   └── chatroom_view_data.dart
    │           │       │   ├── conversation/
    │           │       │   │   ├── conversation_view_data.dart
    │           │       │   │   └── reaction_view_data.dart
    │           │       │   ├── delete/
    │           │       │   │   └── delete_reason_view_data.dart
    │           │       │   ├── media/
    │           │       │   │   ├── media_model.dart
    │           │       │   │   └── og_tags_view_data.dart
    │           │       │   ├── menu/
    │           │       │   │   └── menu_item_view_data.dart
    │           │       │   ├── moderation/
    │           │       │   │   └── report_tag_view_data.dart
    │           │       │   ├── poll/
    │           │       │   │   ├── poll_enum.dart
    │           │       │   │   └── poll_option_view_data.dart
    │           │       │   ├── sdk/
    │           │       │   │   └── sdk_client_info_view_data.dart
    │           │       │   ├── tag/
    │           │       │   │   └── tag_view_data.dart
    │           │       │   ├── user/
    │           │       │   │   └── user_view_data.dart
    │           │       │   └── widget/
    │           │       │       └── widget_view_data.dart
    │           │       ├── theme/
    │           │       │   └── theme.dart
    │           │       ├── utils/
    │           │       │   ├── enums.dart
    │           │       │   ├── helpers.dart
    │           │       │   ├── typedefs.dart
    │           │       │   ├── utils.dart
    │           │       │   ├── constants/
    │           │       │   │   ├── assets.dart
    │           │       │   │   └── constants.dart
    │           │       │   ├── conversation/
    │           │       │   │   └── conversation_utils.dart
    │           │       │   ├── helpers/
    │           │       │   │   ├── conversation_helper.dart
    │           │       │   │   ├── tagging_helper.dart
    │           │       │   │   └── text_helper.dart
    │           │       │   ├── media/
    │           │       │   │   ├── attachment_convertor.dart
    │           │       │   │   ├── audio_handler.dart
    │           │       │   │   └── media_utils.dart
    │           │       │   └── time_ago/
    │           │       │       ├── time_ago.dart
    │           │       │       └── time_ago_message.dart
    │           │       └── widgets/
    │           │           ├── widgets.dart
    │           │           ├── chatroom/
    │           │           │   └── chatroom_topic.dart
    │           │           ├── common/
    │           │           │   ├── buttons/
    │           │           │   │   ├── button.dart
    │           │           │   │   └── floating_action_button.dart
    │           │           │   ├── dialog/
    │           │           │   │   └── dialog.dart
    │           │           │   ├── extras/
    │           │           │   │   ├── appbar.dart
    │           │           │   │   ├── chip.dart
    │           │           │   │   └── loader.dart
    │           │           │   ├── icon/
    │           │           │   │   └── icon.dart
    │           │           │   ├── menu/
    │           │           │   │   ├── custom_pop_up_menu_style.dart
    │           │           │   │   ├── menu.dart
    │           │           │   │   └── menu_item.dart
    │           │           │   ├── sheets/
    │           │           │   │   └── bottom_sheet.dart
    │           │           │   ├── snackbar/
    │           │           │   │   └── snackbar.dart
    │           │           │   ├── text/
    │           │           │   │   └── text.dart
    │           │           │   └── tile/
    │           │           │       └── tile.dart
    │           │           ├── conversation/
    │           │           │   ├── chat_bubble.dart
    │           │           │   ├── chat_bubble_clipper.dart
    │           │           │   ├── chat_bubble_content.dart
    │           │           │   ├── chat_bubble_footer.dart
    │           │           │   ├── chat_bubble_header.dart
    │           │           │   ├── chat_bubble_media.dart
    │           │           │   ├── chat_bubble_reactions.dart
    │           │           │   ├── chat_bubble_reply.dart
    │           │           │   ├── chat_bubble_sides.dart
    │           │           │   └── chat_bubble_state.dart
    │           │           ├── media/
    │           │           │   ├── error.dart
    │           │           │   ├── gif.dart
    │           │           │   ├── image.dart
    │           │           │   ├── link_preview.dart
    │           │           │   ├── link_preview_bar.dart
    │           │           │   ├── video.dart
    │           │           │   ├── voice_note.dart
    │           │           │   └── document/
    │           │           │       ├── document.dart
    │           │           │       ├── preview.dart
    │           │           │       ├── thumbnail.dart
    │           │           │       └── tile.dart
    │           │           ├── paginated_list/
    │           │           │   ├── dual_side_paginated_list.dart
    │           │           │   ├── pagination_controller.dart
    │           │           │   └── pagination_utils.dart
    │           │           ├── poll/
    │           │           │   ├── poll.dart
    │           │           │   ├── poll_option.dart
    │           │           │   ├── poll_style.dart
    │           │           │   └── poll_utils.dart
    │           │           ├── profile/
    │           │           │   ├── profile_picture.dart
    │           │           │   └── user_tile.dart
    │           │           ├── reaction/
    │           │           │   ├── reaction.dart
    │           │           │   ├── reaction_bar.dart
    │           │           │   ├── reaction_bottom_sheet.dart
    │           │           │   └── reaction_emoji_keyboard.dart
    │           │           └── shimmers/
    │           │               ├── chatroom_skeleton.dart
    │           │               ├── document_shimmer.dart
    │           │               └── media_shimmer.dart
    │           └── test/
    │               └── likeminds_chat_flutter_ui_test.dart
    ├── .dart_tool/
    │   └── package_config.json
    └── .github/
        └── pull_request_template.md

================================================
File: README.md
================================================
# Official Flutter SDK for [LikeMinds Chat](https://likeminds.community/)



================================================
File: CHANGELOG.md
================================================
## 0.5.0

- Initial release of the LikeMinds Chat SDK monorepo

## 0.5.1

- Fixed a bug in Core package

## 0.6.0

- Added Support for chatroom
- Added conversation lists and actions
- enhancements and minor feature additions

## 0.6.1

- Added Support for block member
- Support for targetSDK v34 out of the box
- Updating dependencies to support Flutter `v3.22.0`

## 0.7.0

- Added multimedia support
- Added multimedia utils and handler functions

## 0.7.5

- Added support for Link Preview

## 0.8.0

- Added support for Tagging
- Added support for Reactions
- Added retry mechanism
- Added Analytics support

### 0.9.0

- Added support for poll
- Fixed Deleted text and link preview ui

### 0.10.0

- Added support for voice notes

### 0.11.0

- Added support for chatbot
- Added support for custom user roles

### 0.12.0

- Added support for poll configuration
- Added support for dark theme
- Added loads of UI/UX improvements

### 0.12.1

- Replaced `open_filex` with `open_file` plugin
- Removed `flutter_keyboard_visibility` plugin

### 0.13.0

- Added Custom Widget support in Chatroom
- Added Custom Chat Bubble Builder

### 0.14.0

- Fixed Customization misses across the SDK
- Added support for .svg `fileUrl` in `LMChatImage`

## 0.14.1

- Patch update for `likeminds_chat_fl: ^1.12.1`

## 0.15.0

- Fixed attachment menubar hanging issue
- Fixed link preview bug


================================================
File: LICENSE
================================================
TODO: Add your license here.



================================================
File: analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options



================================================
File: melos.yaml
================================================
name: likeminds_chat_flutter

packages:
  - lib/packages/*
  - example/
  - chatbot_example/

scripts:
  analyze:
    exec: dart analyze .

  clean:
    exec: fvm flutter clean .

  dry-run:
    exec: fvm flutter pub publish --dry-run

  test-dependencies:
    run: fvm spawn 3.10.2 pub get; fvm spawn stable pub get

  upgrade:
    exec: flutter pub upgrade



================================================
File: pubspec.lock
================================================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  ansi_styles:
    dependency: transitive
    description:
      name: ansi_styles
      sha256: "9c656cc12b3c27b17dd982b2cc5c0cfdfbdabd7bc8f3ae5e8542d9867b47ce8a"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.2+1"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: d2872f9c19731c2e5f10444b14686eb7cc85c76274bd6c16e1816bff9a3bab63
      url: "https://pub.dev"
    source: hosted
    version: "2.12.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  charcode:
    dependency: transitive
    description:
      name: charcode
      sha256: fb0f1107cac15a5ea6ef0a6ef71a807b9e4267c713bb93e00e92d737cc8dbd8a
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  cli_launcher:
    dependency: transitive
    description:
      name: cli_launcher
      sha256: "5e7e0282b79e8642edd6510ee468ae2976d847a0a29b3916e85f5fa1bfe24005"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.1"
  cli_util:
    dependency: transitive
    description:
      name: cli_util
      sha256: ff6785f7e9e3c38ac98b2fb035701789de90154024a75b6cb926445e83197d1c
      url: "https://pub.dev"
    source: hosted
    version: "0.4.2"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  conventional_commit:
    dependency: transitive
    description:
      name: conventional_commit
      sha256: dec15ad1118f029c618651a4359eb9135d8b88f761aa24e4016d061cd45948f2
      url: "https://pub.dev"
    source: hosted
    version: "0.6.0+1"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "6a95e56b2449df2273fd8c45a662d6947ce1ebb7aafe80e550a3f68297f3cacc"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.2"
  file:
    dependency: transitive
    description:
      name: file
      sha256: "1b92bec4fc2a72f59a8e15af5f52cd441e4a7860b49499d69dfa817af20e925d"
      url: "https://pub.dev"
    source: hosted
    version: "6.1.4"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: a25a15ebbdfc33ab1cd26c63a6ee519df92338a9c10f122adda92938253bef04
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  http:
    dependency: transitive
    description:
      name: http
      sha256: fe7ab022b76f3034adc518fb6ea04a82387620e19977665ea18d30a1cf43442f
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: c35baad643ba394b40aac41080300150a4f08fd0fd6a10378f8f7c6bc161acec
      url: "https://pub.dev"
    source: hosted
    version: "10.0.8"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: f8b613e7e6a13ec79cfdc0e97638fddb3ab848452eff057653abd3edba760573
      url: "https://pub.dev"
    source: hosted
    version: "3.0.9"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "6ba465d5d76e67ddf503e1161d1f4a6bc42306f9d66ca1e8f079a47290fb06d3"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: "0a217c6c989d21039f1498c3ed9f3ed71b354e69873f13a8dfc3c9fe76f1b452"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  melos:
    dependency: "direct dev"
    description:
      name: melos
      sha256: "96e64bbade5712c3f010137e195bca9f1b351fac34ab1f322af492ae34032067"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.0"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: e3641ec5d63ebf0d9b41bd43201a66e3fc79a65db5f61fc181f04cd27aab950c
      url: "https://pub.dev"
    source: hosted
    version: "1.16.0"
  mustache_template:
    dependency: transitive
    description:
      name: mustache_template
      sha256: a46e26f91445bfb0b60519be280555b06792460b27b19e2b19ad5b9740df5d1c
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "20fe868b6314b322ea036ba325e6fc0711a22948856475e2c2b6306e8ab39c2a"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.1"
  process:
    dependency: transitive
    description:
      name: process
      sha256: "53fd8db9cec1d37b0574e12f07520d582019cb6c44abf5479a01505099a34a09"
      url: "https://pub.dev"
    source: hosted
    version: "4.2.4"
  prompts:
    dependency: transitive
    description:
      name: prompts
      sha256: "3773b845e85a849f01e793c4fc18a45d52d7783b4cb6c0569fad19f9d0a774a1"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  pub_updater:
    dependency: transitive
    description:
      name: pub_updater
      sha256: b06600619c8c219065a548f8f7c192b3e080beff95488ed692780f48f69c0625
      url: "https://pub.dev"
    source: hosted
    version: "0.3.1"
  pubspec:
    dependency: transitive
    description:
      name: pubspec
      sha256: f534a50a2b4d48dc3bc0ec147c8bd7c304280fff23b153f3f11803c4d49d927e
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  quiver:
    dependency: transitive
    description:
      name: quiver
      sha256: ea0b925899e64ecdfbf9c7becb60d5b50e706ade44a85b2363be2a22d88117d2
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: fb31f383e2ee25fbbfe06b40fe21e1e458d14080e3c67e7ba0acfde4df4e0bbd
      url: "https://pub.dev"
    source: hosted
    version: "0.7.4"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uri:
    dependency: transitive
    description:
      name: uri
      sha256: "889eea21e953187c6099802b7b4cf5219ba8f3518f604a1033064d45b1b8268a"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: "80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "0968250880a6c5fe7edc067ed0a13d4bae1577fe2771dcf3010d52c4a9d3ca14"
      url: "https://pub.dev"
    source: hosted
    version: "14.3.1"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  yaml_edit:
    dependency: transitive
    description:
      name: yaml_edit
      sha256: fb38626579fb345ad00e674e2af3a5c9b0cc4b9bfb8fd7f7ff322c7c9e62aef5
      url: "https://pub.dev"
    source: hosted
    version: "2.2.2"
sdks:
  dart: ">=3.7.0-0 <4.0.0"
  flutter: ">=3.18.0-18.0.pre.54"



================================================
File: pubspec.yaml
================================================
name: likeminds_chat_flutter
description: The monorepo for LikeMinds Chat SDK Flutter, giving access to all our packages
version: 0.15.0
homepage: "https:likeminds.community"

environment:
  sdk: ">=3.1.0 <4.0.0"
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0
  melos: ^3.4.0



================================================
File: .metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e1e47221e86272429674bec4f1bd36acc4fc7b77"
  channel: "stable"

project_type: package



================================================
File: chatbot_example/README.md
================================================
# likeminds_chatbot_flutter_sample

A new Flutter project.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.



================================================
File: chatbot_example/analysis_options.yaml
================================================
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options



================================================
File: chatbot_example/apphosting.yaml
================================================
# Settings for Backend (on Cloud Run).
# See https://firebase.google.com/docs/app-hosting/configure#cloud-run
runConfig:
  minInstances: 0
  # maxInstances: 100
  # concurrency: 80
  # cpu: 1
  # memoryMiB: 512

# Environment variables and secrets.
# env:
  # Configure environment variables.
  # See https://firebase.google.com/docs/app-hosting/configure#user-defined-environment
  # - variable: MESSAGE
  #   value: Hello world!
  #   availability:
  #     - BUILD
  #     - RUNTIME

  # Grant access to secrets in Cloud Secret Manager.
  # See https://firebase.google.com/docs/app-hosting/configure#secret-parameters
  # - variable: MY_SECRET
  #   secret: mySecretRef



================================================
File: chatbot_example/devtools_options.yaml
================================================
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:



================================================
File: chatbot_example/firebase.json
================================================
{
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run build"
      ]
    }
  ]
}



================================================
File: chatbot_example/pubspec.lock
================================================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: "0b2f2bd91ba804e53a61d757b986f89f1f9eaed5b11e4b2f5a2468d86d6c9fc7"
      url: "https://pub.dev"
    source: hosted
    version: "67.0.0"
  _flutterfire_internals:
    dependency: transitive
    description:
      name: _flutterfire_internals
      sha256: eae3133cbb06de9205899b822e3897fc6a8bc278ad4c944b4ce612689369694b
      url: "https://pub.dev"
    source: hosted
    version: "1.3.47"
  amazon_cognito_identity_dart_2:
    dependency: transitive
    description:
      name: amazon_cognito_identity_dart_2
      sha256: "1b826c09fada5831ef39a05fdfade3b15560e4461df539323bb3b16aa1a27580"
      url: "https://pub.dev"
    source: hosted
    version: "3.7.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: "37577842a27e4338429a1cbc32679d508836510b056f1eedf0c8d20e39c1383d"
      url: "https://pub.dev"
    source: hosted
    version: "6.4.1"
  archive:
    dependency: transitive
    description:
      name: archive
      sha256: cb6a278ef2dbb298455e1a713bda08524a175630ec643a242c399c932a0a1f7d
      url: "https://pub.dev"
    source: hosted
    version: "3.6.1"
  args:
    dependency: transitive
    description:
      name: args
      sha256: bf9f5caeea8d8fe6721a9c358dd8a5c1947b27f1cfaa18b39c301273594919e6
      url: "https://pub.dev"
    source: hosted
    version: "2.6.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "947bfcf187f74dbc5e146c9eb9c0f10c9f8b30743e341481c1e2ed3ecc18c20c"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.0"
  bloc:
    dependency: transitive
    description:
      name: bloc
      sha256: "106842ad6569f0b60297619e9e0b1885c2fb9bf84812935490e6c5275777804e"
      url: "https://pub.dev"
    source: hosted
    version: "8.1.4"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "6cfb5af12253eaf2b368f07bacc5a80d1301a071c73360d746b7f2e32d762c66"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "80184af8b6cb3e5c1c4ec6d8544d27711700bc3e6d2efad04238c7b5290889f0"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: bf80fcfb46a29945b423bd9aad884590fb1dc69b330a4d4700cac476af1708d1
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  cached_network_image:
    dependency: transitive
    description:
      name: cached_network_image
      sha256: "7c1183e361e5c8b0a0f21a28401eecdbde252441106a9816400dd4c2b2424916"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.1"
  cached_network_image_platform_interface:
    dependency: transitive
    description:
      name: cached_network_image_platform_interface
      sha256: "35814b016e37fbdc91f7ae18c8caf49ba5c88501813f73ce8a07027a395e2829"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  cached_network_image_web:
    dependency: transitive
    description:
      name: cached_network_image_web
      sha256: "980842f4e8e2535b8dbd3d5ca0b1f0ba66bf61d14cc3a17a9b4788a3685ba062"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.1"
  carousel_slider:
    dependency: transitive
    description:
      name: carousel_slider
      sha256: "7b006ec356205054af5beaef62e2221160ea36b90fb70a35e4deacd49d0349ae"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: "04a925763edad70e8443c99234dc3328f442e811f1d8fd1a72f1c8ad0f69a605"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: feb6bed21949061731a7a75fc5d2aa727cf160b91af9a3e464c5e3a32e28b5ff
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: cb6d7f03e1de671e34607e909a7213e31d7752be4fb66a86d29fe1eb14bfb5cf
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: ee67cb0715911d28db6bf4af1026078bd6f0128b07a5f66fb2ed94ec6783c09a
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
  connectivity_plus:
    dependency: "direct main"
    description:
      name: connectivity_plus
      sha256: "876849631b0c7dc20f8b471a2a03142841b482438e3b707955464f5ffca3e4c3"
      url: "https://pub.dev"
    source: hosted
    version: "6.1.0"
  connectivity_plus_platform_interface:
    dependency: transitive
    description:
      name: connectivity_plus_platform_interface
      sha256: "42657c1715d48b167930d5f34d00222ac100475f73d10162ddf43e714932f204"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  cross_file:
    dependency: transitive
    description:
      name: cross_file
      sha256: "7caf6a750a0c04effbb52a676dce9a4a592e10ad35c34d6d2d0e4811160d5670"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.4+2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: "1e445881f28f22d6140f181e07737b22f1e099a5e1ff94b0af2f9e4a463f4855"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  curl_logger_dio_interceptor:
    dependency: transitive
    description:
      name: curl_logger_dio_interceptor
      sha256: f20d89187a321d2150e1412bca30ebf4d89130bafc648ce21bd4f1ef4062b214
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  custom_pop_up_menu:
    dependency: transitive
    description:
      name: custom_pop_up_menu
      sha256: eeac484c6ddffffb25e803dc2a5cc9381e700a29f074e9fcc76fe36b62fde850
      url: "https://pub.dev"
    source: hosted
    version: "1.2.4"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "99e066ce75c89d6b29903d788a7bb9369cf754f7b24bf70bf4b6d6d6b26853b9"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.6"
  date_format:
    dependency: transitive
    description:
      name: date_format
      sha256: a48254e60bdb7f1d5a15cac7f86e37491808056c0a99dbdc850841def4754ddc
      url: "https://pub.dev"
    source: hosted
    version: "2.0.9"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: "365c771ac3b0e58845f39ec6deebc76e3276aa9922b0cc60840712094d9047ac"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.10"
  device_info_plus:
    dependency: "direct main"
    description:
      name: device_info_plus
      sha256: a7fd703482b391a87d60b6061d04dfdeab07826b96f9abd8f5ed98068acc0074
      url: "https://pub.dev"
    source: hosted
    version: "10.1.2"
  device_info_plus_platform_interface:
    dependency: transitive
    description:
      name: device_info_plus_platform_interface
      sha256: "282d3cf731045a2feb66abfe61bbc40870ae50a3ed10a4d3d217556c35c8c2ba"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  dio:
    dependency: transitive
    description:
      name: dio
      sha256: "5598aa796bbf4699afd5c67c0f5f6e2ed542afc956884b9cd58c306966efc260"
      url: "https://pub.dev"
    source: hosted
    version: "5.7.0"
  dio_web_adapter:
    dependency: transitive
    description:
      name: dio_web_adapter
      sha256: "33259a9276d6cea88774a0000cfae0d861003497755969c92faa223108620dc8"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  emoji_picker_flutter:
    dependency: transitive
    description:
      name: emoji_picker_flutter
      sha256: "08567e6f914d36c32091a96cf2f51d2558c47aa2bd47a590dc4f50e42e0965f6"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0"
  envied:
    dependency: transitive
    description:
      name: envied
      sha256: bbff9c76120e4dc5e2e36a46690cf0a26feb65e7765633f4e8d916bcd173a450
      url: "https://pub.dev"
    source: hosted
    version: "0.5.4+1"
  equatable:
    dependency: transitive
    description:
      name: equatable
      sha256: "567c64b3cb4cf82397aac55f4f0cbd3ca20d77c6c03bedbc4ceaddc08904aef7"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.7"
  extended_image:
    dependency: transitive
    description:
      name: extended_image
      sha256: "69d4299043334ecece679996e47d0b0891cd8c29d8da0034868443506f1d9a78"
      url: "https://pub.dev"
    source: hosted
    version: "8.3.1"
  extended_image_library:
    dependency: transitive
    description:
      name: extended_image_library
      sha256: "9a94ec9314aa206cfa35f16145c3cd6e2c924badcc670eaaca8a3a8063a68cd7"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.5"
  extended_text_field:
    dependency: "direct overridden"
    description:
      name: extended_text_field
      sha256: "49d86de318dbee44304d38cfdf3b42d40daaba5c6090c58ccb1eda35fea92e61"
      url: "https://pub.dev"
    source: hosted
    version: "16.0.1"
  extended_text_library:
    dependency: transitive
    description:
      name: extended_text_library
      sha256: "13d99f8a10ead472d5e2cf4770d3d047203fe5054b152e9eb5dc692a71befbba"
      url: "https://pub.dev"
    source: hosted
    version: "12.0.1"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "511392330127add0b769b75a987850d136345d9227c6b94c96a04cf4a391bf78"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.1"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "16ed7b077ef01ad6170a3d0c57caa4a112a38d7a2ed5602e0aca9ca6f3d98da6"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  file_picker:
    dependency: transitive
    description:
      name: file_picker
      sha256: "16dc141db5a2ccc6520ebb6a2eb5945b1b09e95085c021d9f914f8ded7f1465c"
      url: "https://pub.dev"
    source: hosted
    version: "8.1.4"
  file_selector_linux:
    dependency: transitive
    description:
      name: file_selector_linux
      sha256: "54cbbd957e1156d29548c7d9b9ec0c0ebb6de0a90452198683a7d23aed617a33"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.3+2"
  file_selector_macos:
    dependency: transitive
    description:
      name: file_selector_macos
      sha256: "271ab9986df0c135d45c3cdb6bd0faa5db6f4976d3e4b437cf7d0f258d941bfc"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.4+2"
  file_selector_platform_interface:
    dependency: transitive
    description:
      name: file_selector_platform_interface
      sha256: a3994c26f10378a039faa11de174d7b78eb8f79e4dd0af2a451410c1a5c3f66b
      url: "https://pub.dev"
    source: hosted
    version: "2.6.2"
  file_selector_windows:
    dependency: transitive
    description:
      name: file_selector_windows
      sha256: "8f5d2f6590d51ecd9179ba39c64f722edc15226cc93dcc8698466ad36a4a85a4"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.3+3"
  firebase_core:
    dependency: "direct main"
    description:
      name: firebase_core
      sha256: fef81a53ba1ca618def1f8bef4361df07968434e62cb204c1fb90bb880a03da2
      url: "https://pub.dev"
    source: hosted
    version: "3.8.1"
  firebase_core_platform_interface:
    dependency: transitive
    description:
      name: firebase_core_platform_interface
      sha256: b94b217e3ad745e784960603d33d99471621ecca151c99c670869b76e50ad2a6
      url: "https://pub.dev"
    source: hosted
    version: "5.3.1"
  firebase_core_web:
    dependency: transitive
    description:
      name: firebase_core_web
      sha256: "9e69806bb3d905aeec3c1242e0e1475de6ea6d48f456af29d598fb229a2b4e5e"
      url: "https://pub.dev"
    source: hosted
    version: "2.18.2"
  firebase_database:
    dependency: transitive
    description:
      name: firebase_database
      sha256: "473c25413683c1c4c8d80918efdc1a232722624bad3b6edfed9fae52b8d927c1"
      url: "https://pub.dev"
    source: hosted
    version: "11.2.0"
  firebase_database_platform_interface:
    dependency: transitive
    description:
      name: firebase_database_platform_interface
      sha256: e83241bcbe4e1bcfcbfd12d0e2ef7706af009663d291efa96bc965adb9ded25d
      url: "https://pub.dev"
    source: hosted
    version: "0.2.5+47"
  firebase_database_web:
    dependency: transitive
    description:
      name: firebase_database_web
      sha256: "9f4048132a3645f1ad528c4839a7c15ad3ff922ee7761821ea9526ffd52735b7"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.6+5"
  firebase_messaging:
    dependency: "direct main"
    description:
      name: firebase_messaging
      sha256: "151a3ee68736abf293aab66d1317ade53c88abe1db09c75a0460aebf7767bbdf"
      url: "https://pub.dev"
    source: hosted
    version: "15.1.6"
  firebase_messaging_platform_interface:
    dependency: transitive
    description:
      name: firebase_messaging_platform_interface
      sha256: f331ee51e40c243f90cc7bc059222dfec4e5df53125b08d31fb28961b00d2a9d
      url: "https://pub.dev"
    source: hosted
    version: "4.5.49"
  firebase_messaging_web:
    dependency: transitive
    description:
      name: firebase_messaging_web
      sha256: efaf3fdc54cd77e0eedb8e75f7f01c808828c64d052ddbf94d3009974e47d30f
      url: "https://pub.dev"
    source: hosted
    version: "3.9.5"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_bloc:
    dependency: transitive
    description:
      name: flutter_bloc
      sha256: b594505eac31a0518bdcb4b5b79573b8d9117b193cc80cc12e17d639b10aa27a
      url: "https://pub.dev"
    source: hosted
    version: "8.1.6"
  flutter_cache_manager:
    dependency: transitive
    description:
      name: flutter_cache_manager
      sha256: "400b6592f16a4409a7f2bb929a9a7e38c72cceb8ffb99ee57bbf2cb2cecf8386"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.1"
  flutter_dotenv:
    dependency: "direct main"
    description:
      name: flutter_dotenv
      sha256: b7c7be5cd9f6ef7a78429cabd2774d3c4af50e79cb2b7593e3d5d763ef95c61b
      url: "https://pub.dev"
    source: hosted
    version: "5.2.1"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "3f41d009ba7172d5ff9be5f6e6e6abb4300e263aab8866d2a0842ed2a70f8f0c"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  flutter_localizations:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_plugin_android_lifecycle:
    dependency: transitive
    description:
      name: flutter_plugin_android_lifecycle
      sha256: "9ee02950848f61c4129af3d6ec84a1cfc0e47931abc746b03e7a3bc3e8ff6eda"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.22"
  flutter_sound:
    dependency: transitive
    description:
      name: flutter_sound
      sha256: d0c9c720f790e2068a5a6f7840f94b03ed5651ee82f43b0aeb9230e1c1ebe55d
      url: "https://pub.dev"
    source: hosted
    version: "9.17.5"
  flutter_sound_platform_interface:
    dependency: transitive
    description:
      name: flutter_sound_platform_interface
      sha256: "95dce405edf19a05a0cca9c31a5a6bf9327223bdc42453ee3bc905ae0e5f519a"
      url: "https://pub.dev"
    source: hosted
    version: "9.17.5"
  flutter_sound_web:
    dependency: transitive
    description:
      name: flutter_sound_web
      sha256: "2efe6de0925766bfaa90c9e6b8d7000fe0cc719b9bb9227642596f35563ba41e"
      url: "https://pub.dev"
    source: hosted
    version: "9.17.5"
  flutter_staggered_grid_view:
    dependency: transitive
    description:
      name: flutter_staggered_grid_view
      sha256: "19e7abb550c96fbfeb546b23f3ff356ee7c59a019a651f8f102a4ba9b7349395"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.0"
  flutter_svg:
    dependency: transitive
    description:
      name: flutter_svg
      sha256: "54900a1a1243f3c4a5506d853a2b5c2dbc38d5f27e52a52618a8054401431123"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.16"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  gif:
    dependency: transitive
    description:
      name: gif
      sha256: ade95694f1471da737922806818ffade2814d1d7f8d10af38ebcf36ace012bc0
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  giphy_get:
    dependency: transitive
    description:
      name: giphy_get
      sha256: "5a51c507bb52680da17d2f715d99f6beb638e69ac10e6cc1d53ae32d57b635b5"
      url: "https://pub.dev"
    source: hosted
    version: "3.5.6"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: "0e7014b3b7d4dac1ca4d6114f82bf1782ee86745b9b42a92c9289c23d8a0ab63"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  google_fonts:
    dependency: "direct main"
    description:
      name: google_fonts
      sha256: b1ac0fe2832c9cc95e5e88b57d627c5e68c223b9657f4b96e1487aa9098c7b82
      url: "https://pub.dev"
    source: hosted
    version: "6.2.1"
  hive:
    dependency: transitive
    description:
      name: hive
      sha256: "8dcf6db979d7933da8217edcec84e9df1bdb4e4edc7fc77dbd5aa74356d6d941"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.3"
  hive_flutter:
    dependency: transitive
    description:
      name: hive_flutter
      sha256: dca1da446b1d808a51689fb5d0c6c9510c0a2ba01e22805d492c73b68e33eecc
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  http:
    dependency: transitive
    description:
      name: http
      sha256: b9c29a161230ee03d3ccf545097fccd9b87a5264228c5d348202e0f0c28f9010
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  http_client_helper:
    dependency: transitive
    description:
      name: http_client_helper
      sha256: "8a9127650734da86b5c73760de2b404494c968a3fd55602045ffec789dac3cb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "2aa08ce0341cc9b354a498388e30986515406668dbcc4f7c950c3e715496693b"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.2"
  image:
    dependency: transitive
    description:
      name: image
      sha256: f31d52537dc417fdcde36088fdf11d191026fd5e4fae742491ebd40e5a8bea7d
      url: "https://pub.dev"
    source: hosted
    version: "4.3.0"
  image_picker:
    dependency: transitive
    description:
      name: image_picker
      sha256: "021834d9c0c3de46bf0fe40341fa07168407f694d9b2bb18d532dc1261867f7a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  image_picker_android:
    dependency: transitive
    description:
      name: image_picker_android
      sha256: "8c5abf0dcc24fe6e8e0b4a5c0b51a5cf30cefdf6407a3213dae61edc75a70f56"
      url: "https://pub.dev"
    source: hosted
    version: "0.8.12+12"
  image_picker_for_web:
    dependency: transitive
    description:
      name: image_picker_for_web
      sha256: "717eb042ab08c40767684327be06a5d8dbb341fe791d514e4b92c7bbe1b7bb83"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  image_picker_ios:
    dependency: transitive
    description:
      name: image_picker_ios
      sha256: "4f0568120c6fcc0aaa04511cb9f9f4d29fc3d0139884b1d06be88dcec7641d6b"
      url: "https://pub.dev"
    source: hosted
    version: "0.8.12+1"
  image_picker_linux:
    dependency: transitive
    description:
      name: image_picker_linux
      sha256: "4ed1d9bb36f7cd60aa6e6cd479779cc56a4cb4e4de8f49d487b1aaad831300fa"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1+1"
  image_picker_macos:
    dependency: transitive
    description:
      name: image_picker_macos
      sha256: "3f5ad1e8112a9a6111c46d0b57a7be2286a9a07fc6e1976fdf5be2bd31d4ff62"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1+1"
  image_picker_platform_interface:
    dependency: transitive
    description:
      name: image_picker_platform_interface
      sha256: "9ec26d410ff46f483c5519c29c02ef0e02e13a543f882b152d4bfd2f06802f80"
      url: "https://pub.dev"
    source: hosted
    version: "2.10.0"
  image_picker_windows:
    dependency: transitive
    description:
      name: image_picker_windows
      sha256: "6ad07afc4eb1bc25f3a01084d28520496c4a3bb0cb13685435838167c9dcedeb"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1+1"
  infinite_scroll_pagination:
    dependency: transitive
    description:
      name: infinite_scroll_pagination
      sha256: "4047eb8191e8b33573690922a9e995af64c3949dc87efc844f936b039ea279df"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  intl:
    dependency: transitive
    description:
      name: intl
      sha256: d6f56758b7d3014a48af9701c085700aac781a92a87a62b1333b46d8879661cf
      url: "https://pub.dev"
    source: hosted
    version: "0.19.0"
  js:
    dependency: "direct overridden"
    description:
      name: js
      sha256: c1b2e9b5ea78c45e1a0788d29606ba27dc5f71f019f32ca5140f61ef071838cf
      url: "https://pub.dev"
    source: hosted
    version: "0.7.1"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  json_serializable:
    dependency: transitive
    description:
      name: json_serializable
      sha256: ea1432d167339ea9b5bb153f0571d0039607a873d6e04e0117af043f14a1fd4b
      url: "https://pub.dev"
    source: hosted
    version: "6.8.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "3f87a60e8c63aecc975dda1ceedbc8f24de75f09e4856ea27daf8958f2f0ce05"
      url: "https://pub.dev"
    source: hosted
    version: "10.0.5"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "932549fb305594d82d7183ecd9fa93463e9914e1b67cacc34bc40906594a1806"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.5"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "6ba465d5d76e67ddf503e1161d1f4a6bc42306f9d66ca1e8f079a47290fb06d3"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  likeminds_chat_fl:
    dependency: "direct overridden"
    description:
      path: "../../LikeMinds-Flutter-GroupChat-SDK"
      relative: true
    source: path
    version: "1.12.0"
  likeminds_chat_flutter_core:
    dependency: "direct main"
    description:
      path: "../lib/packages/core"
      relative: true
    source: path
    version: "0.14.0"
  likeminds_chat_flutter_ui:
    dependency: "direct overridden"
    description:
      path: "../lib/packages/ui"
      relative: true
    source: path
    version: "0.14.0"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: "976c774dd944a42e83e2467f4cc670daef7eed6295b10b36ae8c85bcbf828235"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  logger:
    dependency: transitive
    description:
      name: logger
      sha256: be4b23575aac7ebf01f225a241eb7f6b5641eeaf43c6a8613510fc2f8cf187d1
      url: "https://pub.dev"
    source: hosted
    version: "2.5.0"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  lottie:
    dependency: transitive
    description:
      name: lottie
      sha256: "7afc60865a2429d994144f7d66ced2ae4305fe35d82890b8766e3359872d872c"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: d2323aa2060500f906aa31a895b4030b6da3ebdcc5619d14ce1aada65cd161cb
      url: "https://pub.dev"
    source: hosted
    version: "0.12.16+1"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  media_kit:
    dependency: transitive
    description:
      name: media_kit
      sha256: "1f1deee148533d75129a6f38251ff8388e33ee05fc2d20a6a80e57d6051b7b62"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.11"
  media_kit_libs_android_video:
    dependency: transitive
    description:
      name: media_kit_libs_android_video
      sha256: "9dd8012572e4aff47516e55f2597998f0a378e3d588d0fad0ca1f11a53ae090c"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.6"
  media_kit_libs_ios_video:
    dependency: transitive
    description:
      name: media_kit_libs_ios_video
      sha256: b5382994eb37a4564c368386c154ad70ba0cc78dacdd3fb0cd9f30db6d837991
      url: "https://pub.dev"
    source: hosted
    version: "1.1.4"
  media_kit_libs_linux:
    dependency: transitive
    description:
      name: media_kit_libs_linux
      sha256: e186891c31daa6bedab4d74dcdb4e8adfccc7d786bfed6ad81fe24a3b3010310
      url: "https://pub.dev"
    source: hosted
    version: "1.1.3"
  media_kit_libs_macos_video:
    dependency: transitive
    description:
      name: media_kit_libs_macos_video
      sha256: f26aa1452b665df288e360393758f84b911f70ffb3878032e1aabba23aa1032d
      url: "https://pub.dev"
    source: hosted
    version: "1.1.4"
  media_kit_libs_video:
    dependency: transitive
    description:
      name: media_kit_libs_video
      sha256: "20bb4aefa8fece282b59580e1cd8528117297083a6640c98c2e98cfc96b93288"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  media_kit_libs_windows_video:
    dependency: transitive
    description:
      name: media_kit_libs_windows_video
      sha256: "32654572167825c42c55466f5d08eee23ea11061c84aa91b09d0e0f69bdd0887"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.10"
  media_kit_native_event_loop:
    dependency: transitive
    description:
      name: media_kit_native_event_loop
      sha256: "7d82e3b3e9ded5c35c3146c5ba1da3118d1dd8ac3435bac7f29f458181471b40"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.9"
  media_kit_video:
    dependency: transitive
    description:
      name: media_kit_video
      sha256: "2cc3b966679963ba25a4ce5b771e532a521ebde7c6aa20e9802bec95d9916c8f"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.5"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: bdb68674043280c3428e9ec998512fb681678676b3c54e773629ffe74419f8c7
      url: "https://pub.dev"
    source: hosted
    version: "1.15.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  nested:
    dependency: transitive
    description:
      name: nested
      sha256: "03bac4c528c64c95c722ec99280375a6f2fc708eec17c7b3f07253b626cd2a20"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  nm:
    dependency: transitive
    description:
      name: nm
      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  octo_image:
    dependency: transitive
    description:
      name: octo_image
      sha256: "34faa6639a78c7e3cbe79be6f9f96535867e879748ade7d17c9b1ae7536293bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  open_file:
    dependency: transitive
    description:
      name: open_file
      sha256: d17e2bddf5b278cb2ae18393d0496aa4f162142ba97d1a9e0c30d476adf99c0e
      url: "https://pub.dev"
    source: hosted
    version: "3.5.10"
  open_file_android:
    dependency: transitive
    description:
      name: open_file_android
      sha256: "58141fcaece2f453a9684509a7275f231ac0e3d6ceb9a5e6de310a7dff9084aa"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.6"
  open_file_ios:
    dependency: transitive
    description:
      name: open_file_ios
      sha256: "02996f01e5f6863832068e97f8f3a5ef9b613516db6897f373b43b79849e4d07"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.3"
  open_file_linux:
    dependency: transitive
    description:
      name: open_file_linux
      sha256: d189f799eecbb139c97f8bc7d303f9e720954fa4e0fa1b0b7294767e5f2d7550
      url: "https://pub.dev"
    source: hosted
    version: "0.0.5"
  open_file_mac:
    dependency: transitive
    description:
      name: open_file_mac
      sha256: "1440b1e37ceb0642208cfeb2c659c6cda27b25187a90635c9d1acb7d0584d324"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.3"
  open_file_platform_interface:
    dependency: transitive
    description:
      name: open_file_platform_interface
      sha256: "101b424ca359632699a7e1213e83d025722ab668b9fd1412338221bf9b0e5757"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.3"
  open_file_web:
    dependency: transitive
    description:
      name: open_file_web
      sha256: e3dbc9584856283dcb30aef5720558b90f88036360bd078e494ab80a80130c4f
      url: "https://pub.dev"
    source: hosted
    version: "0.0.4"
  open_file_windows:
    dependency: transitive
    description:
      name: open_file_windows
      sha256: d26c31ddf935a94a1a3aa43a23f4fff8a5ff4eea395fe7a8cb819cf55431c875
      url: "https://pub.dev"
    source: hosted
    version: "0.0.3"
  overlay_support:
    dependency: transitive
    description:
      name: overlay_support
      sha256: fc39389bfd94e6985e1e13b2a88a125fc4027608485d2d4e2847afe1b2bb339c
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: "1c5b77ccc91e4823a5af61ee74e6b972db1ef98c2ff5a18d3161c982a55448bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  package_info_plus:
    dependency: transitive
    description:
      name: package_info_plus
      sha256: da8d9ac8c4b1df253d1a328b7bf01ae77ef132833479ab40763334db13b91cce
      url: "https://pub.dev"
    source: hosted
    version: "8.1.1"
  package_info_plus_platform_interface:
    dependency: transitive
    description:
      name: package_info_plus_platform_interface
      sha256: ac1f4a4847f1ade8e6a87d1f39f5d7c67490738642e2542f559ec38c37489a66
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "087ce49c3f0dc39180befefc60fdb4acd8f8620e5682fe2476afd0b3688bb4af"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.0"
  path_parsing:
    dependency: transitive
    description:
      name: path_parsing
      sha256: "883402936929eac138ee0a45da5b0f2c80f89913e6dc3bf77eb65b84b409c6ca"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  path_provider:
    dependency: transitive
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: "6f01f8e37ec30b07bc424b4deabac37cacb1bc7e2e515ad74486039918a37eb7"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.10"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: f234384a3fdd67f989b4d54a5d73ca2a6c422fa55ae694381ae0f4375cd1ea16
      url: "https://pub.dev"
    source: hosted
    version: "2.4.0"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  pdf_render:
    dependency: transitive
    description:
      name: pdf_render
      sha256: bacd2ad8f4f4c9821827003065f5c2f9ca474dd418ff29c68272aab4c0e1e88b
      url: "https://pub.dev"
    source: hosted
    version: "1.4.12"
  permission_handler:
    dependency: transitive
    description:
      name: permission_handler
      sha256: "18bf33f7fefbd812f37e72091a15575e72d5318854877e0e4035a24ac1113ecb"
      url: "https://pub.dev"
    source: hosted
    version: "11.3.1"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: "71bbecfee799e65aff7c744761a57e817e73b738fedf62ab7afd5593da21f9f1"
      url: "https://pub.dev"
    source: hosted
    version: "12.0.13"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: e6f6d73b12438ef13e648c4ae56bd106ec60d17e90a59c4545db6781229082a0
      url: "https://pub.dev"
    source: hosted
    version: "9.4.5"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+5"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: e9c8eadee926c4532d0305dff94b85bf961f16759c3af791486613152af4b4f9
      url: "https://pub.dev"
    source: hosted
    version: "4.2.3"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: c15605cd28af66339f8eb6fbe0e541bfe2d1b72d5825efc6598f3e0a31b9ad27
      url: "https://pub.dev"
    source: hosted
    version: "6.0.2"
  photo_view:
    dependency: transitive
    description:
      name: photo_view
      sha256: "1fc3d970a91295fbd1364296575f854c9863f225505c28c46e0a03e48960c75e"
      url: "https://pub.dev"
    source: hosted
    version: "0.15.0"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  provider:
    dependency: transitive
    description:
      name: provider
      sha256: c8a055ee5ce3fd98d6fc872478b03823ffdb448699c6ebdbbc71d59b596fd48c
      url: "https://pub.dev"
    source: hosted
    version: "6.1.2"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "40d3ab1bbd474c4c2328c91e3a7df8c6dd629b79ece4c4bd04bee496a224fb0c"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: c799b721d79eb6ee6fa56f00c04b472dcd44a30d258fac2174a6ec57302678f8
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  recase:
    dependency: transitive
    description:
      name: recase
      sha256: e4eb4ec2dcdee52dcf99cb4ceabaffc631d7424ee55e56f280bc039737f89213
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  rxdart:
    dependency: transitive
    description:
      name: rxdart
      sha256: "5c3004a4a8dbb94bd4bf5412a4def4acdaa12e12f269737a5751369e12d1a962"
      url: "https://pub.dev"
    source: hosted
    version: "0.28.0"
  safe_local_storage:
    dependency: transitive
    description:
      name: safe_local_storage
      sha256: ede4eb6cb7d88a116b3d3bf1df70790b9e2038bc37cb19112e381217c74d9440
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  screen_brightness:
    dependency: transitive
    description:
      name: screen_brightness
      sha256: ed8da4a4511e79422fc1aa88138e920e4008cd312b72cdaa15ccb426c0faaedd
      url: "https://pub.dev"
    source: hosted
    version: "0.2.2+1"
  screen_brightness_android:
    dependency: transitive
    description:
      name: screen_brightness_android
      sha256: "3df10961e3a9e968a5e076fe27e7f4741fa8a1d3950bdeb48cf121ed529d0caf"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0+2"
  screen_brightness_ios:
    dependency: transitive
    description:
      name: screen_brightness_ios
      sha256: "99adc3ca5490b8294284aad5fcc87f061ad685050e03cf45d3d018fe398fd9a2"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0"
  screen_brightness_macos:
    dependency: transitive
    description:
      name: screen_brightness_macos
      sha256: "64b34e7e3f4900d7687c8e8fb514246845a73ecec05ab53483ed025bd4a899fd"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0+1"
  screen_brightness_platform_interface:
    dependency: transitive
    description:
      name: screen_brightness_platform_interface
      sha256: b211d07f0c96637a15fb06f6168617e18030d5d74ad03795dd8547a52717c171
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0"
  screen_brightness_windows:
    dependency: transitive
    description:
      name: screen_brightness_windows
      sha256: "9261bf33d0fc2707d8cf16339ce25768100a65e70af0fcabaf032fc12408ba86"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3"
  shared_preferences:
    dependency: transitive
    description:
      name: shared_preferences
      sha256: "95f9997ca1fb9799d494d0cb2a780fd7be075818d59f00c43832ed112b158a82"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: "480ba4345773f56acda9abf5f50bd966f581dac5d514e5fc4a18c62976bbba7e"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "07e050c7cd39bad516f8d64c455f04508d09df104be326d8c02551590a0d513d"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.3"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: d2ca4132d3946fec2184261726b355836a82c33d7d5b67af32692aff18a4684e
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shimmer:
    dependency: transitive
    description:
      name: shimmer
      sha256: "5f88c883a22e9f9f299e5ba0e4f7e6054857224976a5d9f839d4ebdc94a14ac9"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.99"
  sliver_tools:
    dependency: transitive
    description:
      name: sliver_tools
      sha256: eae28220badfb9d0559207badcbbc9ad5331aac829a88cb0964d330d2a4636a6
      url: "https://pub.dev"
    source: hosted
    version: "0.2.12"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "14658ba5f669685cd3d63701d01b31ea748310f7ab854e471962670abcf57832"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  source_helper:
    dependency: transitive
    description:
      name: source_helper
      sha256: "6adebc0006c37dd63fe05bca0a929b99f06402fc95aa35bf36d67f5c06de01fd"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.4"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "53e943d4206a5e30df338fd4c6e7a077e02254531b138a15aec3bd143c1a8b3c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.0"
  sprintf:
    dependency: transitive
    description:
      name: sprintf
      sha256: "1fc9ffe69d4df602376b52949af107d8f5703b77cda567c4d7d86a0693120f23"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  sqflite:
    dependency: transitive
    description:
      name: sqflite
      sha256: a43e5a27235518c03ca238e7b4732cf35eabe863a369ceba6cbefa537a66f16d
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3+1"
  sqflite_common:
    dependency: transitive
    description:
      name: sqflite_common
      sha256: "3da423ce7baf868be70e2c0976c28a1bb2f73644268b7ffa7d2e08eab71f16a4"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "73713990125a6d93122541237550ee3352a2d84baad52d375a4cad2eb9b7ce0b"
      url: "https://pub.dev"
    source: hosted
    version: "1.11.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: ba2aa5d8cc609d96bbb2899c28934f9e1af5cddbd60a827822ea467161eb54e7
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "556692adab6cfa87322a115640c11f13cb77b3f076ddcc5d6ae3c20242bedcde"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  super_sliver_list:
    dependency: transitive
    description:
      name: super_sliver_list
      sha256: b1e1e64d08ce40e459b9bb5d9f8e361617c26b8c9f3bb967760b0f436b6e3f56
      url: "https://pub.dev"
    source: hosted
    version: "0.4.1"
  swipe_to_action:
    dependency: transitive
    description:
      name: swipe_to_action
      sha256: "0914f78df07a15b5fd97e800036fd63a2bcd4dbe67a4a514a597303806a361ea"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0"
  synchronized:
    dependency: transitive
    description:
      name: synchronized
      sha256: "539ef412b170d65ecdafd780f924e5be3f60032a1128df156adad6c5b373d558"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0+1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: a29248a84fbb7c79282b40b8c72a1209db169a2e0542bce341da992fe1bc7e84
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "5b8a98dafc4d5c4c9c72d8b31ab2b23fc13422348d2997120294d3bac86b4ddb"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.2"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: facc8d6582f16042dd49f2463ff1bd6e2c9ef9f3d5da3d9b087e244a7b564b3c
      url: "https://pub.dev"
    source: hosted
    version: "1.3.2"
  universal_platform:
    dependency: transitive
    description:
      name: universal_platform
      sha256: "64e16458a0ea9b99260ceb5467a214c1f298d647c659af1bff6d3bf82536b1ec"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  uri_parser:
    dependency: transitive
    description:
      name: uri_parser
      sha256: "6543c9fd86d2862fac55d800a43e67c0dcd1a41677cb69c2f8edfe73bbcf1835"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.2"
  url_launcher:
    dependency: transitive
    description:
      name: url_launcher
      sha256: "9d06212b1362abc2f0f0d78e6f09f726608c74e3b9462e8368bb03314aa8d603"
      url: "https://pub.dev"
    source: hosted
    version: "6.3.1"
  url_launcher_android:
    dependency: transitive
    description:
      name: url_launcher_android
      sha256: f0c73347dfcfa5b3db8bc06e1502668265d39c08f310c29bff4e28eea9699f79
      url: "https://pub.dev"
    source: hosted
    version: "6.3.9"
  url_launcher_ios:
    dependency: transitive
    description:
      name: url_launcher_ios
      sha256: e43b677296fadce447e987a2f519dcf5f6d1e527dc35d01ffab4fff5b8a7063e
      url: "https://pub.dev"
    source: hosted
    version: "6.3.1"
  url_launcher_linux:
    dependency: transitive
    description:
      name: url_launcher_linux
      sha256: "4e9ba368772369e3e08f231d2301b4ef72b9ff87c31192ef471b380ef29a4935"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  url_launcher_macos:
    dependency: transitive
    description:
      name: url_launcher_macos
      sha256: "769549c999acdb42b8bcfa7c43d72bf79a382ca7441ab18a808e101149daf672"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  url_launcher_platform_interface:
    dependency: transitive
    description:
      name: url_launcher_platform_interface
      sha256: "552f8a1e663569be95a8190206a38187b531910283c3e982193e4f2733f01029"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  url_launcher_web:
    dependency: transitive
    description:
      name: url_launcher_web
      sha256: "772638d3b34c779ede05ba3d38af34657a05ac55b06279ea6edd409e323dca8e"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3"
  url_launcher_windows:
    dependency: transitive
    description:
      name: url_launcher_windows
      sha256: "44cf3aabcedde30f2dba119a9dea3b0f2672fbe6fa96e85536251d678216b3c4"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  uuid:
    dependency: transitive
    description:
      name: uuid
      sha256: a5be9ef6618a7ac1e964353ef476418026db906c4facdedaa299b7a2e71690ff
      url: "https://pub.dev"
    source: hosted
    version: "4.5.1"
  vector_graphics:
    dependency: transitive
    description:
      name: vector_graphics
      sha256: "27d5fefe86fb9aace4a9f8375b56b3c292b64d8c04510df230f849850d912cb7"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.15"
  vector_graphics_codec:
    dependency: transitive
    description:
      name: vector_graphics_codec
      sha256: "2430b973a4ca3c4dbc9999b62b8c719a160100dcbae5c819bae0cacce32c9cdb"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.12"
  vector_graphics_compiler:
    dependency: transitive
    description:
      name: vector_graphics_compiler
      sha256: "1b4b9e706a10294258727674a340ae0d6e64a7231980f9f9a3d12e4b42407aad"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.16"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: "80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  video_thumbnail:
    dependency: transitive
    description:
      name: video_thumbnail
      sha256: "3455c189d3f0bb4e3fc2236475aa84fe598b9b2d0e08f43b9761f5bc44210016"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.3"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "5c5f338a667b4c644744b661f309fb8080bb94b18a7e91ef1dbd343bed00ed6d"
      url: "https://pub.dev"
    source: hosted
    version: "14.2.5"
  volume_controller:
    dependency: transitive
    description:
      name: volume_controller
      sha256: c71d4c62631305df63b72da79089e078af2659649301807fa746088f365cb48e
      url: "https://pub.dev"
    source: hosted
    version: "2.0.8"
  wakelock_plus:
    dependency: transitive
    description:
      name: wakelock_plus
      sha256: bf4ee6f17a2fa373ed3753ad0e602b7603f8c75af006d5b9bdade263928c0484
      url: "https://pub.dev"
    source: hosted
    version: "1.2.8"
  wakelock_plus_platform_interface:
    dependency: transitive
    description:
      name: wakelock_plus_platform_interface
      sha256: "422d1cdbb448079a8a62a5a770b69baa489f8f7ca21aef47800c726d404f9d16"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "3d2ad6751b3c16cf07c7fca317a1413b3f26530319181b37e3b9039b84fc01d8"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  web:
    dependency: transitive
    description:
      name: web
      sha256: cd3543bd5798f6ad290ea73d210f423502e71900302dde696f8bff84bf89a1cb
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: "68d1e89a91ed61ad9c370f9f8b6effed9ae5e0ede22a270bdfa6daf79fc2290a"
      url: "https://pub.dev"
    source: hosted
    version: "5.5.4"
  win32_registry:
    dependency: transitive
    description:
      name: win32_registry
      sha256: "21ec76dfc731550fd3e2ce7a33a9ea90b828fdf19a5c3bcf556fa992cfa99852"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.5"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: b015a8ad1c488f66851d762d3090a21c600e479dc75e68328c52774040cf9226
      url: "https://pub.dev"
    source: hosted
    version: "6.5.0"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: "75769501ea3489fca56601ff33454fe45507ea3bfb014161abc3b43ae25989d5"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
sdks:
  dart: ">=3.4.0 <4.0.0"
  flutter: ">=3.22.0"



================================================
File: chatbot_example/pubspec.yaml
================================================
name: likeminds_chatbot_flutter_sample
description: "A new Flutter project for testing out just the chatbot capabilities of LikeMinds Chat SDK."
publish_to: "none"
version: 1.0.0+1

environment:
  sdk: ">=3.1.0 <4.0.0"
  flutter: ">=3.10.2"

dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^1.0.2
  firebase_core:

  likeminds_chat_flutter_core: ^0.15.0
  google_fonts: ^6.2.0
  flutter_dotenv: ^5.1.0
  firebase_messaging: ^15.0.3
  device_info_plus: ^10.1.0
  connectivity_plus: ^6.0.3

dependency_overrides:
  js: ^0.7.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0

flutter:
  uses-material-design: true



================================================
File: chatbot_example/pubspec_overrides.yaml
================================================
# melos_managed_dependency_overrides: likeminds_chat_flutter_core,likeminds_chat_flutter_ui,js
dependency_overrides:
  likeminds_chat_fl:
    path: ../../LikeMinds-Flutter-GroupChat-SDK
  extended_text_field: ^16.0.0
  likeminds_chat_flutter_core:
    path: ../lib/packages/core
  likeminds_chat_flutter_ui:
    path: ../lib/packages/ui
  js: ^0.7.1



================================================
File: chatbot_example/.firebaserc
================================================
{
  "projects": {
    "default": "likeminds-sdk-app"
  }
}



================================================
File: chatbot_example/.gitignore
================================================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# FVM Version Cache
.fvm/


================================================
File: chatbot_example/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819
      base_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819
    - platform: android
      create_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819
      base_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
File: chatbot_example/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx4G -XX:MaxMetaspaceSize=2G -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true



================================================
File: chatbot_example/android/.gitignore
================================================
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks



================================================
File: chatbot_example/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
File: chatbot_example/android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO"/>
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <application
        android:label="likeminds_chatbot_flutter_sample"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>



================================================
File: chatbot_example/android/app/src/main/kotlin/com/example/likeminds_chatbot_flutter_sample/MainActivity.kt
================================================
package com.likeminds.chatbot.flutter.sample

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity()



================================================
File: chatbot_example/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
File: chatbot_example/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>








================================================
File: chatbot_example/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
File: chatbot_example/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
File: chatbot_example/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
File: chatbot_example/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.6.3-all.zip



================================================
File: chatbot_example/ios/Podfile
================================================
# Uncomment this line to define a global platform for your project
platform :ios, '14.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '14.0'
      config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'
    end
    target.build_configurations.each do |config|
      # You can remove unused permissions here
      # for more information: https://github.com/Baseflow/flutter-permission-handler/blob/main/permission_handler_apple/ios/Classes/PermissionHandlerEnums.h
      # e.g. when you don't need camera permission, just add 'PERMISSION_CAMERA=0'
      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= [
        '$(inherited)',

        ## dart: PermissionGroup.camera
        'PERMISSION_CAMERA=1',

        ## dart: PermissionGroup.microphone
        'PERMISSION_MICROPHONE=1',

        ## dart: PermissionGroup.photos
        'PERMISSION_PHOTOS=1',

        ## dart: PermissionGroup.notification
        'PERMISSION_NOTIFICATIONS=1',

        ## dart: PermissionGroup.mediaLibrary
        'PERMISSION_MEDIA_LIBRARY=1',
      ]

    end
  end
end



================================================
File: chatbot_example/ios/Podfile.lock
================================================
PODS:
  - connectivity_plus (0.0.1):
    - Flutter
    - FlutterMacOS
  - device_info_plus (0.0.1):
    - Flutter
  - DKImagePickerController/Core (4.3.9):
    - DKImagePickerController/ImageDataManager
    - DKImagePickerController/Resource
  - DKImagePickerController/ImageDataManager (4.3.9)
  - DKImagePickerController/PhotoGallery (4.3.9):
    - DKImagePickerController/Core
    - DKPhotoGallery
  - DKImagePickerController/Resource (4.3.9)
  - DKPhotoGallery (0.0.19):
    - DKPhotoGallery/Core (= 0.0.19)
    - DKPhotoGallery/Model (= 0.0.19)
    - DKPhotoGallery/Preview (= 0.0.19)
    - DKPhotoGallery/Resource (= 0.0.19)
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Core (0.0.19):
    - DKPhotoGallery/Model
    - DKPhotoGallery/Preview
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Model (0.0.19):
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Preview (0.0.19):
    - DKPhotoGallery/Model
    - DKPhotoGallery/Resource
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Resource (0.0.19):
    - SDWebImage
    - SwiftyGif
  - emoji_picker_flutter (0.0.1):
    - Flutter
  - file_picker (0.0.1):
    - DKImagePickerController/PhotoGallery
    - Flutter
  - Firebase/CoreOnly (11.4.0):
    - FirebaseCore (= 11.4.0)
  - Firebase/Database (11.4.0):
    - Firebase/CoreOnly
    - FirebaseDatabase (~> 11.4.0)
  - Firebase/Messaging (11.4.0):
    - Firebase/CoreOnly
    - FirebaseMessaging (~> 11.4.0)
  - firebase_core (3.8.1):
    - Firebase/CoreOnly (= 11.4.0)
    - Flutter
  - firebase_database (11.2.0):
    - Firebase/Database (= 11.4.0)
    - firebase_core
    - Flutter
  - firebase_messaging (15.1.6):
    - Firebase/Messaging (= 11.4.0)
    - firebase_core
    - Flutter
  - FirebaseAppCheckInterop (11.6.0)
  - FirebaseCore (11.4.0):
    - FirebaseCoreInternal (~> 11.0)
    - GoogleUtilities/Environment (~> 8.0)
    - GoogleUtilities/Logger (~> 8.0)
  - FirebaseCoreInternal (11.6.0):
    - "GoogleUtilities/NSData+zlib (~> 8.0)"
  - FirebaseDatabase (11.4.0):
    - FirebaseAppCheckInterop (~> 11.0)
    - FirebaseCore (~> 11.0)
    - FirebaseSharedSwift (~> 11.0)
    - GoogleUtilities/UserDefaults (~> 8.0)
    - leveldb-library (~> 1.22)
  - FirebaseInstallations (11.4.0):
    - FirebaseCore (~> 11.0)
    - GoogleUtilities/Environment (~> 8.0)
    - GoogleUtilities/UserDefaults (~> 8.0)
    - PromisesObjC (~> 2.4)
  - FirebaseMessaging (11.4.0):
    - FirebaseCore (~> 11.0)
    - FirebaseInstallations (~> 11.0)
    - GoogleDataTransport (~> 10.0)
    - GoogleUtilities/AppDelegateSwizzler (~> 8.0)
    - GoogleUtilities/Environment (~> 8.0)
    - GoogleUtilities/Reachability (~> 8.0)
    - GoogleUtilities/UserDefaults (~> 8.0)
    - nanopb (~> 3.30910.0)
  - FirebaseSharedSwift (11.6.0)
  - Flutter (1.0.0)
  - flutter_keyboard_visibility (0.0.1):
    - Flutter
  - flutter_sound (9.17.5):
    - Flutter
    - flutter_sound_core (= 9.17.5)
  - flutter_sound_core (9.17.5)
  - GoogleDataTransport (10.1.0):
    - nanopb (~> 3.30910.0)
    - PromisesObjC (~> 2.4)
  - GoogleUtilities/AppDelegateSwizzler (8.0.2):
    - GoogleUtilities/Environment
    - GoogleUtilities/Logger
    - GoogleUtilities/Network
    - GoogleUtilities/Privacy
  - GoogleUtilities/Environment (8.0.2):
    - GoogleUtilities/Privacy
  - GoogleUtilities/Logger (8.0.2):
    - GoogleUtilities/Environment
    - GoogleUtilities/Privacy
  - GoogleUtilities/Network (8.0.2):
    - GoogleUtilities/Logger
    - "GoogleUtilities/NSData+zlib"
    - GoogleUtilities/Privacy
    - GoogleUtilities/Reachability
  - "GoogleUtilities/NSData+zlib (8.0.2)":
    - GoogleUtilities/Privacy
  - GoogleUtilities/Privacy (8.0.2)
  - GoogleUtilities/Reachability (8.0.2):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - GoogleUtilities/UserDefaults (8.0.2):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - image_picker_ios (0.0.1):
    - Flutter
  - leveldb-library (1.22.6)
  - libwebp (1.3.2):
    - libwebp/demux (= 1.3.2)
    - libwebp/mux (= 1.3.2)
    - libwebp/sharpyuv (= 1.3.2)
    - libwebp/webp (= 1.3.2)
  - libwebp/demux (1.3.2):
    - libwebp/webp
  - libwebp/mux (1.3.2):
    - libwebp/demux
  - libwebp/sharpyuv (1.3.2)
  - libwebp/webp (1.3.2):
    - libwebp/sharpyuv
  - media_kit_libs_ios_video (1.0.4):
    - Flutter
  - media_kit_native_event_loop (1.0.0):
    - Flutter
  - media_kit_video (0.0.1):
    - Flutter
  - nanopb (3.30910.0):
    - nanopb/decode (= 3.30910.0)
    - nanopb/encode (= 3.30910.0)
  - nanopb/decode (3.30910.0)
  - nanopb/encode (3.30910.0)
  - open_filex (0.0.2):
    - Flutter
  - package_info_plus (0.4.5):
    - Flutter
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - pdf_render (0.0.1):
    - Flutter
  - permission_handler_apple (9.3.0):
    - Flutter
  - PromisesObjC (2.4.0)
  - screen_brightness_ios (0.1.0):
    - Flutter
  - SDWebImage (5.20.0):
    - SDWebImage/Core (= 5.20.0)
  - SDWebImage/Core (5.20.0)
  - shared_preferences_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - sqflite (0.0.3):
    - Flutter
    - FlutterMacOS
  - SwiftyGif (5.4.5)
  - url_launcher_ios (0.0.1):
    - Flutter
  - video_thumbnail (0.0.1):
    - Flutter
    - libwebp
  - volume_controller (0.0.1):
    - Flutter
  - wakelock_plus (0.0.1):
    - Flutter

DEPENDENCIES:
  - connectivity_plus (from `.symlinks/plugins/connectivity_plus/darwin`)
  - device_info_plus (from `.symlinks/plugins/device_info_plus/ios`)
  - emoji_picker_flutter (from `.symlinks/plugins/emoji_picker_flutter/ios`)
  - file_picker (from `.symlinks/plugins/file_picker/ios`)
  - firebase_core (from `.symlinks/plugins/firebase_core/ios`)
  - firebase_database (from `.symlinks/plugins/firebase_database/ios`)
  - firebase_messaging (from `.symlinks/plugins/firebase_messaging/ios`)
  - Flutter (from `Flutter`)
  - flutter_keyboard_visibility (from `.symlinks/plugins/flutter_keyboard_visibility/ios`)
  - flutter_sound (from `.symlinks/plugins/flutter_sound/ios`)
  - image_picker_ios (from `.symlinks/plugins/image_picker_ios/ios`)
  - media_kit_libs_ios_video (from `.symlinks/plugins/media_kit_libs_ios_video/ios`)
  - media_kit_native_event_loop (from `.symlinks/plugins/media_kit_native_event_loop/ios`)
  - media_kit_video (from `.symlinks/plugins/media_kit_video/ios`)
  - open_filex (from `.symlinks/plugins/open_filex/ios`)
  - package_info_plus (from `.symlinks/plugins/package_info_plus/ios`)
  - path_provider_foundation (from `.symlinks/plugins/path_provider_foundation/darwin`)
  - pdf_render (from `.symlinks/plugins/pdf_render/ios`)
  - permission_handler_apple (from `.symlinks/plugins/permission_handler_apple/ios`)
  - screen_brightness_ios (from `.symlinks/plugins/screen_brightness_ios/ios`)
  - shared_preferences_foundation (from `.symlinks/plugins/shared_preferences_foundation/darwin`)
  - sqflite (from `.symlinks/plugins/sqflite/darwin`)
  - url_launcher_ios (from `.symlinks/plugins/url_launcher_ios/ios`)
  - video_thumbnail (from `.symlinks/plugins/video_thumbnail/ios`)
  - volume_controller (from `.symlinks/plugins/volume_controller/ios`)
  - wakelock_plus (from `.symlinks/plugins/wakelock_plus/ios`)

SPEC REPOS:
  trunk:
    - DKImagePickerController
    - DKPhotoGallery
    - Firebase
    - FirebaseAppCheckInterop
    - FirebaseCore
    - FirebaseCoreInternal
    - FirebaseDatabase
    - FirebaseInstallations
    - FirebaseMessaging
    - FirebaseSharedSwift
    - flutter_sound_core
    - GoogleDataTransport
    - GoogleUtilities
    - leveldb-library
    - libwebp
    - nanopb
    - PromisesObjC
    - SDWebImage
    - SwiftyGif

EXTERNAL SOURCES:
  connectivity_plus:
    :path: ".symlinks/plugins/connectivity_plus/darwin"
  device_info_plus:
    :path: ".symlinks/plugins/device_info_plus/ios"
  emoji_picker_flutter:
    :path: ".symlinks/plugins/emoji_picker_flutter/ios"
  file_picker:
    :path: ".symlinks/plugins/file_picker/ios"
  firebase_core:
    :path: ".symlinks/plugins/firebase_core/ios"
  firebase_database:
    :path: ".symlinks/plugins/firebase_database/ios"
  firebase_messaging:
    :path: ".symlinks/plugins/firebase_messaging/ios"
  Flutter:
    :path: Flutter
  flutter_keyboard_visibility:
    :path: ".symlinks/plugins/flutter_keyboard_visibility/ios"
  flutter_sound:
    :path: ".symlinks/plugins/flutter_sound/ios"
  image_picker_ios:
    :path: ".symlinks/plugins/image_picker_ios/ios"
  media_kit_libs_ios_video:
    :path: ".symlinks/plugins/media_kit_libs_ios_video/ios"
  media_kit_native_event_loop:
    :path: ".symlinks/plugins/media_kit_native_event_loop/ios"
  media_kit_video:
    :path: ".symlinks/plugins/media_kit_video/ios"
  open_filex:
    :path: ".symlinks/plugins/open_filex/ios"
  package_info_plus:
    :path: ".symlinks/plugins/package_info_plus/ios"
  path_provider_foundation:
    :path: ".symlinks/plugins/path_provider_foundation/darwin"
  pdf_render:
    :path: ".symlinks/plugins/pdf_render/ios"
  permission_handler_apple:
    :path: ".symlinks/plugins/permission_handler_apple/ios"
  screen_brightness_ios:
    :path: ".symlinks/plugins/screen_brightness_ios/ios"
  shared_preferences_foundation:
    :path: ".symlinks/plugins/shared_preferences_foundation/darwin"
  sqflite:
    :path: ".symlinks/plugins/sqflite/darwin"
  url_launcher_ios:
    :path: ".symlinks/plugins/url_launcher_ios/ios"
  video_thumbnail:
    :path: ".symlinks/plugins/video_thumbnail/ios"
  volume_controller:
    :path: ".symlinks/plugins/volume_controller/ios"
  wakelock_plus:
    :path: ".symlinks/plugins/wakelock_plus/ios"

SPEC CHECKSUMS:
  connectivity_plus: 4c41c08fc6d7c91f63bc7aec70ffe3730b04f563
  device_info_plus: 97af1d7e84681a90d0693e63169a5d50e0839a0d
  DKImagePickerController: 946cec48c7873164274ecc4624d19e3da4c1ef3c
  DKPhotoGallery: b3834fecb755ee09a593d7c9e389d8b5d6deed60
  emoji_picker_flutter: fe2e6151c5b548e975d546e6eeb567daf0962a58
  file_picker: 09aa5ec1ab24135ccd7a1621c46c84134bfd6655
  Firebase: cf1b19f21410b029b6786a54e9764a0cacad3c99
  firebase_core: 418aed674e9a0b8b6088aec16cde82a811f6261f
  firebase_database: eaa98d5fd998bd2b76318df35b1ebe5dd12449b5
  firebase_messaging: 98619a0572d82cfb3668e78859ba9f1110e268c9
  FirebaseAppCheckInterop: 347aa09a805219a31249b58fc956888e9fcb314b
  FirebaseCore: e0510f1523bc0eb21653cac00792e1e2bd6f1771
  FirebaseCoreInternal: d98ab91e2d80a56d7b246856a8885443b302c0c2
  FirebaseDatabase: ccd11f02c170076ffeeef40020cbb2f6d33e718c
  FirebaseInstallations: 6ef4a1c7eb2a61ee1f74727d7f6ce2e72acf1414
  FirebaseMessaging: f8a160d99c2c2e5babbbcc90c4a3e15db036aee2
  FirebaseSharedSwift: a4e5dfca3e210633bb3a3dfb94176c019211948b
  Flutter: e0871f40cf51350855a761d2e70bf5af5b9b5de7
  flutter_keyboard_visibility: 0339d06371254c3eb25eeb90ba8d17dca8f9c069
  flutter_sound: d8bf9711570f368d74ecf2a408b5162070a0956c
  flutter_sound_core: fd7c34e5789d5d780556c33388fd40ff694d6b4c
  GoogleDataTransport: aae35b7ea0c09004c3797d53c8c41f66f219d6a7
  GoogleUtilities: 26a3abef001b6533cf678d3eb38fd3f614b7872d
  image_picker_ios: c560581cceedb403a6ff17f2f816d7fea1421fc1
  leveldb-library: cc8b8f8e013647a295ad3f8cd2ddf49a6f19be19
  libwebp: 1786c9f4ff8a279e4dac1e8f385004d5fc253009
  media_kit_libs_ios_video: a5fe24bc7875ccd6378a0978c13185e1344651c1
  media_kit_native_event_loop: e6b2ab20cf0746eb1c33be961fcf79667304fa2a
  media_kit_video: 5da63f157170e5bf303bf85453b7ef6971218a2e
  nanopb: fad817b59e0457d11a5dfbde799381cd727c1275
  open_filex: 6e26e659846ec990262224a12ef1c528bb4edbe4
  package_info_plus: c0502532a26c7662a62a356cebe2692ec5fe4ec4
  path_provider_foundation: 2b6b4c569c0fb62ec74538f866245ac84301af46
  pdf_render: 0b4e1a615aab83ce88b26c57753049424908a755
  permission_handler_apple: 9878588469a2b0d0fc1e048d9f43605f92e6cec2
  PromisesObjC: f5707f49cb48b9636751c5b2e7d227e43fba9f47
  screen_brightness_ios: 715ca807df953bf676d339f11464e438143ee625
  SDWebImage: 73c6079366fea25fa4bb9640d5fb58f0893facd8
  shared_preferences_foundation: fcdcbc04712aee1108ac7fda236f363274528f78
  sqflite: 673a0e54cc04b7d6dba8d24fb8095b31c3a99eec
  SwiftyGif: 706c60cf65fa2bc5ee0313beece843c8eb8194d4
  url_launcher_ios: 5334b05cef931de560670eeae103fd3e431ac3fe
  video_thumbnail: c4e2a3c539e247d4de13cd545344fd2d26ffafd1
  volume_controller: 531ddf792994285c9b17f9d8a7e4dcdd29b3eae9
  wakelock_plus: 78ec7c5b202cab7761af8e2b2b3d0671be6c4ae1

PODFILE CHECKSUM: 8b919f76ad31ec2432d8621ce03eea132ff63bc8

COCOAPODS: 1.15.2



================================================
File: chatbot_example/ios/.gitignore
================================================
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3



================================================
File: chatbot_example/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>12.0</string>
</dict>
</plist>



================================================
File: chatbot_example/ios/Flutter/Debug.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "Generated.xcconfig"



================================================
File: chatbot_example/ios/Flutter/Release.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "Generated.xcconfig"



================================================
File: chatbot_example/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}



================================================
File: chatbot_example/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Likeminds Chatbot Flutter Sample</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>likeminds_chatbot_flutter_sample</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
File: chatbot_example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
File: chatbot_example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
File: chatbot_example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
File: chatbot_example/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
File: chatbot_example/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
File: chatbot_example/ios/Runner.xcodeproj/project.pbxproj
================================================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
		A15184241BC7D8D25FEAC9A2 /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1A0E6C39117CD4DAB2B62104 /* Pods_RunnerTests.framework */; };
		E0E9A2F5AEE7BAFEF7B24FA0 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 2D4077F93292752F3282162F /* Pods_Runner.framework */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		1A0E6C39117CD4DAB2B62104 /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		2D4077F93292752F3282162F /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		44A0A7724FC59031F56ED13F /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		48B298B7A7FDC3C37BA28ABD /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		69176930AAE455753D4FAAB1 /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		9C6751C97B58D4ED85C236C9 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
		A50F8F3BFA366ECAA77B69D5 /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
		BDB25ACB35390DE9230E0FFB /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		04EF2B7076552A8C4F5ED9D1 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				A15184241BC7D8D25FEAC9A2 /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E0E9A2F5AEE7BAFEF7B24FA0 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		0D4060BE492783B8249D7FAA /* Pods */ = {
			isa = PBXGroup;
			children = (
				9C6751C97B58D4ED85C236C9 /* Pods-Runner.debug.xcconfig */,
				69176930AAE455753D4FAAB1 /* Pods-Runner.release.xcconfig */,
				A50F8F3BFA366ECAA77B69D5 /* Pods-Runner.profile.xcconfig */,
				48B298B7A7FDC3C37BA28ABD /* Pods-RunnerTests.debug.xcconfig */,
				44A0A7724FC59031F56ED13F /* Pods-RunnerTests.release.xcconfig */,
				BDB25ACB35390DE9230E0FFB /* Pods-RunnerTests.profile.xcconfig */,
			);
			name = Pods;
			path = Pods;
			sourceTree = "<group>";
		};
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		50A46CF8742C0575B7FAFA57 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				2D4077F93292752F3282162F /* Pods_Runner.framework */,
				1A0E6C39117CD4DAB2B62104 /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
				0D4060BE492783B8249D7FAA /* Pods */,
				50A46CF8742C0575B7FAFA57 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				0334843F842311B06C5AC1DC /* [CP] Check Pods Manifest.lock */,
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
				04EF2B7076552A8C4F5ED9D1 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				90DCF7A928BAAD19236C1829 /* [CP] Check Pods Manifest.lock */,
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
				D46140459AF32351876EE1A4 /* [CP] Embed Pods Frameworks */,
				EAF9A251F43E76DBCC7D7B34 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		0334843F842311B06C5AC1DC /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		90DCF7A928BAAD19236C1829 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
		D46140459AF32351876EE1A4 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Embed Pods Frameworks";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
		EAF9A251F43E76DBCC7D7B34 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = HPC929F5X6;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 48B298B7A7FDC3C37BA28ABD /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 44A0A7724FC59031F56ED13F /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = BDB25ACB35390DE9230E0FFB /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = HPC929F5X6;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = HPC929F5X6;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}



================================================
File: chatbot_example/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>



================================================
File: chatbot_example/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>



================================================
File: chatbot_example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
File: chatbot_example/ios/Runner.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>



================================================
File: chatbot_example/ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>



================================================
File: chatbot_example/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
File: chatbot_example/lib/app.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chatbot_flutter_sample/onboarding/cred_screen.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:likeminds_chatbot_flutter_sample/main.dart';

class LMChatbotApp extends StatelessWidget {
  const LMChatbotApp({super.key});

  @override
  Widget build(BuildContext context) {
    return OverlaySupport.global(
      toastTheme: ToastThemeData(
        background: Colors.black.withOpacity(0.6),
        textColor: Colors.white,
      ),
      child: MaterialApp(
        navigatorKey: rootNavigatorKey,
        title: 'Chat App for UI + SDK package',
        debugShowCheckedModeBanner: isDebug,
        scaffoldMessengerKey: rootScaffoldMessengerKey,
        theme: ThemeData.from(
          colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        ),
        home: const CredScreen(),
      ),
    );
  }
}

class LMChatbotHomeScreen extends StatefulWidget {
  final String? apiKey;

  final String? uuid;

  final String? userName;

  const LMChatbotHomeScreen({
    super.key,
    this.apiKey,
    this.uuid,
    this.userName,
  });

  @override
  State<LMChatbotHomeScreen> createState() => _LMChatbotHomeScreenState();
}

class _LMChatbotHomeScreenState extends State<LMChatbotHomeScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'Explore',
          style: TextStyle(fontWeight: FontWeight.w500),
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.search),
            onPressed: () {},
          ),
          IconButton(
            icon: const Icon(Icons.notifications_outlined),
            onPressed: () {},
          ),
          const CircleAvatar(
            radius: 15,
            backgroundColor: Colors.teal,
            child: Text(
              'NT',
              style: TextStyle(
                color: Colors.white,
                fontSize: 12,
              ),
            ),
          ),
          const SizedBox(width: 16),
        ],
      ),
      body: GridView.builder(
        padding: const EdgeInsets.all(16),
        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          childAspectRatio: 0.85,
          crossAxisSpacing: 16,
          mainAxisSpacing: 16,
        ),
        itemCount: 4,
        itemBuilder: (context, index) {
          return Container(
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                Container(
                  height: 12,
                  margin: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.grey.shade300,
                    borderRadius: BorderRadius.circular(6),
                  ),
                ),
              ],
            ),
          );
        },
      ),
      floatingActionButton: Padding(
        padding: const EdgeInsets.only(right: 12, bottom: 12),
        child: LMChatAIButton(
          props: LMChatAIButtonProps(
            apiKey: widget.apiKey,
            uuid: widget.uuid,
            userName: widget.userName,
          ),
        ),
      ),
    );
  }
}



================================================
File: chatbot_example/lib/main.dart
================================================
import 'dart:io';

import 'package:device_info_plus/device_info_plus.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chatbot_flutter_sample/app.dart';
import 'package:likeminds_chatbot_flutter_sample/utils/firebase_options.dart';

final GlobalKey<ScaffoldMessengerState> rootScaffoldMessengerKey =
    GlobalKey<ScaffoldMessengerState>();

final GlobalKey<NavigatorState> rootNavigatorKey = GlobalKey<NavigatorState>();

/// First level notification handler
/// Essential to declare it outside of any class or function as per Firebase docs
/// Call [LMChatNotificationHandler.instance.handleNotification] in this function
/// to handle notifications at the second level (inside the app)
/// Make sure to call [setupNotifications] before this function
@pragma('vm:entry-point')
Future<void> _handleNotification(RemoteMessage message) async {
  debugPrint("--- Notification received in LEVEL 1 ---");
  await LMChatNotificationHandler.instance
      .handleBackgroundNotification(message);
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  setupNotifications();
  await LMChatCore.instance.initialize(
    excludedConversationStates: [
      ConversationState.memberJoinedOpenChatroom,
      ConversationState.memberLeftOpenChatroom,
      ConversationState.memberLeftSecretChatroom,
      ConversationState.memberAddedToChatroom,
    ],
  );
  runApp(const LMChatbotApp());
}

/// Setup notifications
/// 1. Initialize Firebase
/// 2. Get device id - [deviceId]
/// 3. Get FCM token - [setupMessaging]
/// 4. Register device with LM - [LMChatNotificationHandler]
/// 5. Listen for FG and BG notifications
/// 6. Handle notifications - [_handleNotification]
void setupNotifications() async {
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  final devId = await deviceId();
  final fcmToken = await setupMessaging();
  if (fcmToken == null) {
    debugPrint("FCM token is null or permission declined");
    return;
  }
  // Register device with LM, and listen for notifications
  LMChatNotificationHandler.instance.init(deviceId: devId, fcmToken: fcmToken);
  FirebaseMessaging.onBackgroundMessage(_handleNotification);
  FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) async {
    debugPrint("---The app is opened from a notification---");
    await LMChatNotificationHandler.instance
        .handleNotification(message, false, rootNavigatorKey);
  });
  FirebaseMessaging.instance.getInitialMessage().then(
    (RemoteMessage? message) async {
      if (message != null) {
        debugPrint("---The terminated app is opened from a notification---");
        await LMChatNotificationHandler.instance
            .handleNotification(message, false, rootNavigatorKey);
      }
    },
  );
}

/// Get device id
/// 1. Get device info
/// 2. Get device id
/// 3. Return device id
Future<String> deviceId() async {
  final deviceInfo = await DeviceInfoPlugin().deviceInfo;
  final deviceId =
      deviceInfo.data["identifierForVendor"] ?? deviceInfo.data["id"];
  debugPrint("Device id - $deviceId");
  return deviceId.toString();
}

/// Setup Firebase messaging on your app
/// The UI package needs your Firebase instance to be initialized
/// 1. Get messaging instance
/// 2. Get FCM token
/// 3. Request permission
/// 4. Return FCM token
Future<String?> setupMessaging() async {
  final messaging = FirebaseMessaging.instance;
  messaging.setForegroundNotificationPresentationOptions(
    // alert: true,
    badge: true,
    sound: true,
  );
  await messaging.requestPermission(
    alert: true,
    announcement: false,
    badge: true,
    carPlay: false,
    criticalAlert: true,
    provisional: false,
    sound: true,
  );
  if (Platform.isIOS) {
    messaging.getAPNSToken();
  }
  final token = await messaging.getToken();
  debugPrint("Token - $token");
  return token.toString();
}



================================================
File: chatbot_example/lib/onboarding/cred_screen.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chatbot_flutter_sample/app.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chatbot_flutter_sample/utils/network_handling.dart';

/// The credentials screen for the app.
class CredScreen extends StatefulWidget {
  /// Constructor for the CredScreen
  const CredScreen({super.key});

  @override
  State<CredScreen> createState() => _CredScreenState();
}

class _CredScreenState extends State<CredScreen> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _userIdController = TextEditingController();
  final TextEditingController _apiKeyController = TextEditingController();
  late Color backgroundColor;

  final ButtonStyle buttonStyle = ElevatedButton.styleFrom(
    backgroundColor: Colors.white,
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(12),
    ),
    fixedSize: const Size(
      200,
      42,
    ),
  );
  late TextStyle buttonTextStyle = TextStyle(
    color: backgroundColor,
    fontSize: 18,
    fontWeight: FontWeight.bold,
  );

  @override
  void initState() {
    super.initState();
    NetworkConnectivity networkConnectivity = NetworkConnectivity.instance;
    networkConnectivity.initialise();
    _setTextFieldData();
  }

  @override
  void dispose() {
    _usernameController.dispose();
    _userIdController.dispose();
    _apiKeyController.dispose();
    super.dispose();
  }

  void _setTextFieldData() {
    User? user = LMChatCore.instance.lmChatClient.getLoggedInUser().data;
    String? apiKey = LMChatLocalPreference.instance
        .fetchCache(LMChatStringConstants.apiKey)
        ?.value as String?;
    if (user != null) {
      _usernameController.text = user.name;
      _userIdController.text = user.sdkClientInfo?.uuid ?? "";
    }
    if (apiKey != null) {
      _apiKeyController.text = apiKey;
    }
  }

  void _clearTextFieldData() {
    _usernameController.clear();
    _userIdController.clear();
    _apiKeyController.clear();
  }

  @override
  Widget build(BuildContext context) {
    backgroundColor = Theme.of(context).primaryColor;
    return Scaffold(
      resizeToAvoidBottomInset: true,
      backgroundColor: backgroundColor,
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 18.0),
        child: SingleChildScrollView(
          child: Column(
            children: [
              const SizedBox(height: 96),
              const Text(
                "LikeMinds Chat\nFlutter Sample App",
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 64),
              const Text(
                "Enter your credentials",
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 18),
              TextField(
                cursorColor: Colors.white,
                controller: _apiKeyController,
                style: const TextStyle(color: Colors.white),
                decoration: InputDecoration(
                  fillColor: Colors.white,
                  focusColor: Colors.white,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  labelText: 'API Key',
                  labelStyle: const TextStyle(
                    color: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              TextField(
                cursorColor: Colors.white,
                style: const TextStyle(color: Colors.white),
                controller: _usernameController,
                decoration: InputDecoration(
                  fillColor: Colors.white,
                  focusColor: Colors.white,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  labelText: 'Username',
                  labelStyle: const TextStyle(
                    color: Colors.white,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              TextField(
                cursorColor: Colors.white,
                controller: _userIdController,
                style: const TextStyle(color: Colors.white),
                decoration: InputDecoration(
                    fillColor: Colors.white,
                    focusColor: Colors.white,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                    labelText: 'User ID',
                    labelStyle: const TextStyle(
                      color: Colors.white,
                    )),
              ),
              const SizedBox(height: 48),
              const Text(
                "If no credentials are provided, the app will run with the default credentials.",
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 72),
              ElevatedButton(
                style: buttonStyle,
                onPressed: _onSubmit,
                child: Text(
                  "Submit",
                  style: buttonTextStyle,
                ),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                style: buttonStyle,
                onPressed: () async {
                  await LMChatLocalPreference.instance.clearLocalData();
                  _clearTextFieldData();
                  setState(() {});
                },
                child: Text(
                  "Clear Data",
                  style: buttonTextStyle,
                ),
              ),
              const SizedBox(height: 80),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _onSubmit() async {
    String apiKey = _apiKeyController.text;
    String username = _usernameController.text;
    String userId = _userIdController.text;
    if (apiKey.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Please enter the API Key"),
        ),
      );
      return;
    }
    if (userId.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Please enter the User ID"),
        ),
      );
    } else {
      final response = await LMChatCore.instance.showChatWithApiKey(
        apiKey: apiKey,
        uuid: userId,
        userName: username,
      );
      if (response.success) {
        MaterialPageRoute route = MaterialPageRoute(
          builder: (context) => LMChatbotHomeScreen(
            apiKey: apiKey,
            uuid: userId,
            userName: username,
          ),
        );
        Navigator.push(context, route);
      } else {
        toast(response.errorMessage ?? "An error occurred");
      }
    }
  }
}



================================================
File: chatbot_example/lib/utils/example_callback.dart
================================================
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';

/// ExampleCallback represents the callback to be implemented
/// on the customer's end to extend [LMChatSDKCallback]
class ExampleCallback extends LMChatSDKCallback {
  @override
  // A function that handles the event fired callback with the specified event key and properties map.
  void eventFiredCallback(String eventKey, Map<String, dynamic> propertiesMap) {
    debugPrint("EXAMPLE: eventFiredCallback: $eventKey, $propertiesMap");
  }

  @override
  // A function that indicates a login is required.
  void loginRequiredCallback() {
    debugPrint("EXAMPLE: loginRequiredCallback");
  }

  @override
  // A function that handles the logout callback.
  void logoutCallback() {
    debugPrint("EXAMPLE: logoutCallback");
  }

  @override
  // A function that handles the routing of profile callback.
  void profileRouteCallback({required String lmUserId}) {
    debugPrint("LM User ID caught in callback : $lmUserId");
  }

  @override
  // A function that handles access token expired and refreshed callback.
  void onAccessTokenExpiredAndRefreshed(
      String accessToken, String refreshToken) {
    debugPrint(
      "New access token: $accessToken, New refresh token: $refreshToken",
    );
  }

  @override
  // A function that handles expiry of refresh token callback.
  Future<LMAuthToken> onRefreshTokenExpired() {
    // TODO: implement onRefreshTokenExpired
    throw UnimplementedError();
  }
}



================================================
File: chatbot_example/lib/utils/firebase_options.dart
================================================
// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBoKIOckkZHY6MmBrEE59LtKpzeSglt53Y',
    appId: '1:317419981427:web:066d353b2223357cd2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    authDomain: 'likeminds-sdk-app.firebaseapp.com',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    measurementId: 'G-VDC4M3W7W5',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw',
    appId: '1:317419981427:android:383c84d581bad91bd2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    storageBucket: 'likeminds-sdk-app.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyAVmbe-8jgnO2MUnFotMdp2tmDVnwTZqfE',
    appId: '1:317419981427:ios:5c2e7053ed57f4b2d2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    iosBundleId: 'com.likeminds.chat.flutter.sample',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyAVmbe-8jgnO2MUnFotMdp2tmDVnwTZqfE',
    appId: '1:317419981427:ios:5c2e7053ed57f4b2d2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    iosBundleId: 'com.likeminds.chat.flutter.sample',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBoKIOckkZHY6MmBrEE59LtKpzeSglt53Y',
    appId: '1:317419981427:web:4437716c13e11f97d2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    authDomain: 'likeminds-sdk-app.firebaseapp.com',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    measurementId: 'G-597NEX8YCE',
  );

}


================================================
File: chatbot_example/lib/utils/mock_intiate_user.dart
================================================
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';

/// Mock function to initiate user
Future<(String, String)> mockInitiateUser({
  required String apiKey,
  required String userName,
  required String userId,
}) async {
  String host = "https://betaauth.likeminds.community";
  final dio = Dio();
  try {
    final Response response = await dio.post(
      options: Options(
        headers: {
          'x-api-key': apiKey,
        },
      ),
      "$host/sdk/initiate",
      data: {
        'user_name': userName,
        'user_unique_id': userId,
        "token_expiry_beta": 1,
        "rtm_token_expiry_beta": 2
      },
    );
    if (response.data['success'] && response.data['data'] != null) {
      return (
        response.data['data']['access_token'] as String,
        response.data['data']['refresh_token'] as String
      );
    }

    throw Exception("Failed to initiate user");
  } on DioException catch (e) {
    debugPrint("Error: ${e.message}");
    throw Exception("Failed to initiate user");
  } finally {
    dio.close();
  }
}



================================================
File: chatbot_example/lib/utils/network_handling.dart
================================================
import 'dart:async';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chatbot_flutter_sample/main.dart';

class NetworkConnectivity {
  NetworkConnectivity._();
  static final _instance = NetworkConnectivity._();
  static NetworkConnectivity get instance => _instance;
  final _networkConnectivity = Connectivity();
  final _controller = StreamController.broadcast();

  void initialise() async {
    _networkConnectivity.onConnectivityChanged.listen((result) {
      if (result.contains(ConnectivityResult.mobile) ||
          result.contains(ConnectivityResult.wifi)) {
        rootScaffoldMessengerKey.currentState?.clearSnackBars();
      } else {
        rootScaffoldMessengerKey.currentState?.showSnackBar(
          confirmationToast(
            content: "No internet\nCheck your connection and try again",
            backgroundColor: const Color.fromARGB(255, 108, 108, 108),
          ),
        );
      }
    });
  }

  void disposeStream() => _controller.close();
}

SnackBar confirmationToast(
    {required String content, required Color backgroundColor}) {
  return SnackBar(
    showCloseIcon: true,
    duration: const Duration(days: 1),
    backgroundColor: backgroundColor,
    elevation: 5,
    behavior: SnackBarBehavior.floating,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5.0)),
    content: Align(
      alignment: Alignment.center,
      child: Text(
        content,
        textAlign: TextAlign.left,
      ),
    ),
  );
}



================================================
File: chatbot_example/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.10)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "likeminds_chatbot_flutter_sample")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.likeminds.chatbot.flutter.sample")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Define the application target. To change its name, change BINARY_NAME above,
# not the value here, or `flutter run` will no longer work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
File: chatbot_example/linux/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
File: chatbot_example/linux/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "likeminds_chatbot_flutter_sample");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "likeminds_chatbot_flutter_sample");
  }

  gtk_window_set_default_size(window, 1280, 720);
  gtk_widget_show(GTK_WIDGET(window));

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}



================================================
File: chatbot_example/linux/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
File: chatbot_example/linux/.gitignore
================================================
flutter/ephemeral



================================================
File: chatbot_example/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
File: chatbot_example/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <emoji_picker_flutter/emoji_picker_flutter_plugin.h>
#include <file_selector_linux/file_selector_plugin.h>
#include <media_kit_libs_linux/media_kit_libs_linux_plugin.h>
#include <media_kit_video/media_kit_video_plugin.h>
#include <open_file_linux/open_file_linux_plugin.h>
#include <url_launcher_linux/url_launcher_plugin.h>

void fl_register_plugins(FlPluginRegistry* registry) {
  g_autoptr(FlPluginRegistrar) emoji_picker_flutter_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "EmojiPickerFlutterPlugin");
  emoji_picker_flutter_plugin_register_with_registrar(emoji_picker_flutter_registrar);
  g_autoptr(FlPluginRegistrar) file_selector_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "FileSelectorPlugin");
  file_selector_plugin_register_with_registrar(file_selector_linux_registrar);
  g_autoptr(FlPluginRegistrar) media_kit_libs_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "MediaKitLibsLinuxPlugin");
  media_kit_libs_linux_plugin_register_with_registrar(media_kit_libs_linux_registrar);
  g_autoptr(FlPluginRegistrar) media_kit_video_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "MediaKitVideoPlugin");
  media_kit_video_plugin_register_with_registrar(media_kit_video_registrar);
  g_autoptr(FlPluginRegistrar) open_file_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "OpenFileLinuxPlugin");
  open_file_linux_plugin_register_with_registrar(open_file_linux_registrar);
  g_autoptr(FlPluginRegistrar) url_launcher_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "UrlLauncherPlugin");
  url_launcher_plugin_register_with_registrar(url_launcher_linux_registrar);
}



================================================
File: chatbot_example/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
File: chatbot_example/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  emoji_picker_flutter
  file_selector_linux
  media_kit_libs_linux
  media_kit_video
  open_file_linux
  url_launcher_linux
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
  media_kit_native_event_loop
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
File: chatbot_example/macos/Podfile
================================================
platform :osx, '10.14'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'ephemeral', 'Flutter-Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure \"flutter pub get\" is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter-Generated.xcconfig, then run \"flutter pub get\""
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_macos_podfile_setup

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_macos_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_macos_build_settings(target)
  end
end



================================================
File: chatbot_example/macos/.gitignore
================================================
# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/



================================================
File: chatbot_example/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
File: chatbot_example/macos/Flutter/Flutter-Release.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
File: chatbot_example/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import connectivity_plus
import device_info_plus
import emoji_picker_flutter
import file_selector_macos
import firebase_core
import firebase_database
import firebase_messaging
import media_kit_libs_macos_video
import media_kit_video
import open_file_mac
import package_info_plus
import path_provider_foundation
import pdf_render
import screen_brightness_macos
import shared_preferences_foundation
import sqflite
import url_launcher_macos
import wakelock_plus

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  ConnectivityPlusPlugin.register(with: registry.registrar(forPlugin: "ConnectivityPlusPlugin"))
  DeviceInfoPlusMacosPlugin.register(with: registry.registrar(forPlugin: "DeviceInfoPlusMacosPlugin"))
  EmojiPickerFlutterPlugin.register(with: registry.registrar(forPlugin: "EmojiPickerFlutterPlugin"))
  FileSelectorPlugin.register(with: registry.registrar(forPlugin: "FileSelectorPlugin"))
  FLTFirebaseCorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseCorePlugin"))
  FLTFirebaseDatabasePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseDatabasePlugin"))
  FLTFirebaseMessagingPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseMessagingPlugin"))
  MediaKitLibsMacosVideoPlugin.register(with: registry.registrar(forPlugin: "MediaKitLibsMacosVideoPlugin"))
  MediaKitVideoPlugin.register(with: registry.registrar(forPlugin: "MediaKitVideoPlugin"))
  OpenFilePlugin.register(with: registry.registrar(forPlugin: "OpenFilePlugin"))
  FPPPackageInfoPlusPlugin.register(with: registry.registrar(forPlugin: "FPPPackageInfoPlusPlugin"))
  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
  SwiftPdfRenderPlugin.register(with: registry.registrar(forPlugin: "SwiftPdfRenderPlugin"))
  ScreenBrightnessMacosPlugin.register(with: registry.registrar(forPlugin: "ScreenBrightnessMacosPlugin"))
  SharedPreferencesPlugin.register(with: registry.registrar(forPlugin: "SharedPreferencesPlugin"))
  SqflitePlugin.register(with: registry.registrar(forPlugin: "SqflitePlugin"))
  UrlLauncherPlugin.register(with: registry.registrar(forPlugin: "UrlLauncherPlugin"))
  WakelockPlusMacosPlugin.register(with: registry.registrar(forPlugin: "WakelockPlusMacosPlugin"))
}



================================================
File: chatbot_example/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }
}



================================================
File: chatbot_example/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
File: chatbot_example/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
File: chatbot_example/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
File: chatbot_example/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
File: chatbot_example/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = likeminds_chatbot_flutter_sample

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2024 com.example. All rights reserved.



================================================
File: chatbot_example/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
File: chatbot_example/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
File: chatbot_example/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
File: chatbot_example/macos/Runner.xcodeproj/project.pbxproj
================================================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXAggregateTarget section */
		33CC111A2044C6BA0003C045 /* Flutter Assemble */ = {
			isa = PBXAggregateTarget;
			buildConfigurationList = 33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */;
			buildPhases = (
				33CC111E2044C6BF0003C045 /* ShellScript */,
			);
			dependencies = (
			);
			name = "Flutter Assemble";
			productName = FLX;
		};
/* End PBXAggregateTarget section */

/* Begin PBXBuildFile section */
		331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C80D7294CF71000263BE5 /* RunnerTests.swift */; };
		335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */ = {isa = PBXBuildFile; fileRef = 335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */; };
		33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC10F02044A3C60003C045 /* AppDelegate.swift */; };
		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C80D9294CF71000263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC10EC2044A3C60003C045;
			remoteInfo = Runner;
		};
		33CC111F2044C79F0003C045 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC111A2044C6BA0003C045;
			remoteInfo = FLX;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		33CC110E2044A8840003C045 /* Bundle Framework */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Bundle Framework";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
		33CC10ED2044A3C60003C045 /* likeminds_chatbot_flutter_sample.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "likeminds_chatbot_flutter_sample.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		33CC10F72044A3C60003C045 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = Info.plist; path = Runner/Info.plist; sourceTree = "<group>"; };
		33CC11122044BFA00003C045 /* MainFlutterWindow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainFlutterWindow.swift; sourceTree = "<group>"; };
		33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Debug.xcconfig"; sourceTree = "<group>"; };
		33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Release.xcconfig"; sourceTree = "<group>"; };
		33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = "Flutter-Generated.xcconfig"; path = "ephemeral/Flutter-Generated.xcconfig"; sourceTree = "<group>"; };
		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		331C80D2294CF70F00263BE5 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EA2044A3C60003C045 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C80D6294CF71000263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C80D7294CF71000263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		33BA886A226E78AF003329D5 /* Configs */ = {
			isa = PBXGroup;
			children = (
				33E5194F232828860026EE4D /* AppInfo.xcconfig */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				333000ED22D3DE5D00554162 /* Warnings.xcconfig */,
			);
			path = Configs;
			sourceTree = "<group>";
		};
		33CC10E42044A3C60003C045 = {
			isa = PBXGroup;
			children = (
				33FAB671232836740065AC1E /* Runner */,
				33CEB47122A05771004F2AC0 /* Flutter */,
				331C80D6294CF71000263BE5 /* RunnerTests */,
				33CC10EE2044A3C60003C045 /* Products */,
				D73912EC22F37F3D000D13A0 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		33CC10EE2044A3C60003C045 /* Products */ = {
			isa = PBXGroup;
			children = (
				33CC10ED2044A3C60003C045 /* likeminds_chatbot_flutter_sample.app */,
				331C80D5294CF71000263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		33CC11242044D66E0003C045 /* Resources */ = {
			isa = PBXGroup;
			children = (
				33CC10F22044A3C60003C045 /* Assets.xcassets */,
				33CC10F42044A3C60003C045 /* MainMenu.xib */,
				33CC10F72044A3C60003C045 /* Info.plist */,
			);
			name = Resources;
			path = ..;
			sourceTree = "<group>";
		};
		33CEB47122A05771004F2AC0 /* Flutter */ = {
			isa = PBXGroup;
			children = (
				335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */,
				33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */,
				33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */,
				33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */,
			);
			path = Flutter;
			sourceTree = "<group>";
		};
		33FAB671232836740065AC1E /* Runner */ = {
			isa = PBXGroup;
			children = (
				33CC10F02044A3C60003C045 /* AppDelegate.swift */,
				33CC11122044BFA00003C045 /* MainFlutterWindow.swift */,
				33E51913231747F40026EE4D /* DebugProfile.entitlements */,
				33E51914231749380026EE4D /* Release.entitlements */,
				33CC11242044D66E0003C045 /* Resources */,
				33BA886A226E78AF003329D5 /* Configs */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C80D4294CF70F00263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C80D1294CF70F00263BE5 /* Sources */,
				331C80D2294CF70F00263BE5 /* Frameworks */,
				331C80D3294CF70F00263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C80DA294CF71000263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C80D5294CF71000263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		33CC10EC2044A3C60003C045 /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				33CC10E92044A3C60003C045 /* Sources */,
				33CC10EA2044A3C60003C045 /* Frameworks */,
				33CC10EB2044A3C60003C045 /* Resources */,
				33CC110E2044A8840003C045 /* Bundle Framework */,
				3399D490228B24CF009A79C7 /* ShellScript */,
			);
			buildRules = (
			);
			dependencies = (
				33CC11202044C79F0003C045 /* PBXTargetDependency */,
			);
			name = Runner;
			productName = Runner;
			productReference = 33CC10ED2044A3C60003C045 /* likeminds_chatbot_flutter_sample.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		33CC10E52044A3C60003C045 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C80D4294CF70F00263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 33CC10EC2044A3C60003C045;
					};
					33CC10EC2044A3C60003C045 = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
						SystemCapabilities = {
							com.apple.Sandbox = {
								enabled = 1;
							};
						};
					};
					33CC111A2044C6BA0003C045 = {
						CreatedOnToolsVersion = 9.2;
						ProvisioningStyle = Manual;
					};
				};
			};
			buildConfigurationList = 33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 33CC10E42044A3C60003C045;
			productRefGroup = 33CC10EE2044A3C60003C045 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				33CC10EC2044A3C60003C045 /* Runner */,
				331C80D4294CF70F00263BE5 /* RunnerTests */,
				33CC111A2044C6BA0003C045 /* Flutter Assemble */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C80D3294CF70F00263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EB2044A3C60003C045 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */,
				33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3399D490228B24CF009A79C7 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "echo \"$PRODUCT_NAME.app\" > \"$PROJECT_DIR\"/Flutter/ephemeral/.app_filename && \"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh embed\n";
		};
		33CC111E2044C6BF0003C045 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				Flutter/ephemeral/FlutterInputs.xcfilelist,
			);
			inputPaths = (
				Flutter/ephemeral/tripwire,
			);
			outputFileListPaths = (
				Flutter/ephemeral/FlutterOutputs.xcfilelist,
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C80D1294CF70F00263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10E92044A3C60003C045 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */,
				33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */,
				335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C80DA294CF71000263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC10EC2044A3C60003C045 /* Runner */;
			targetProxy = 331C80D9294CF71000263BE5 /* PBXContainerItemProxy */;
		};
		33CC11202044C79F0003C045 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC111A2044C6BA0003C045 /* Flutter Assemble */;
			targetProxy = 33CC111F2044C79F0003C045 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		33CC10F42044A3C60003C045 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				33CC10F52044A3C60003C045 /* Base */,
			);
			name = MainMenu.xib;
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		331C80DB294CF71000263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/likeminds_chatbot_flutter_sample.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/likeminds_chatbot_flutter_sample";
			};
			name = Debug;
		};
		331C80DC294CF71000263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/likeminds_chatbot_flutter_sample.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/likeminds_chatbot_flutter_sample";
			};
			name = Release;
		};
		331C80DD294CF71000263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.likemindsChatbotFlutterSample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/likeminds_chatbot_flutter_sample.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/likeminds_chatbot_flutter_sample";
			};
			name = Profile;
		};
		338D0CE9231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Profile;
		};
		338D0CEA231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Profile;
		};
		338D0CEB231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Profile;
		};
		33CC10F92044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		33CC10FA2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		33CC10FC2044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		33CC10FD2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Release.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		33CC111C2044C6BA0003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Debug;
		};
		33CC111D2044C6BA0003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C80DB294CF71000263BE5 /* Debug */,
				331C80DC294CF71000263BE5 /* Release */,
				331C80DD294CF71000263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10F92044A3C60003C045 /* Debug */,
				33CC10FA2044A3C60003C045 /* Release */,
				338D0CE9231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10FC2044A3C60003C045 /* Debug */,
				33CC10FD2044A3C60003C045 /* Release */,
				338D0CEA231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC111C2044C6BA0003C045 /* Debug */,
				33CC111D2044C6BA0003C045 /* Release */,
				338D0CEB231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 33CC10E52044A3C60003C045 /* Project object */;
}



================================================
File: chatbot_example/macos/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/macos/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "33CC10EC2044A3C60003C045"
               BuildableName = "likeminds_chatbot_flutter_sample.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "likeminds_chatbot_flutter_sample.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C80D4294CF70F00263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "likeminds_chatbot_flutter_sample.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "likeminds_chatbot_flutter_sample.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
File: chatbot_example/macos/Runner.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>



================================================
File: chatbot_example/macos/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: chatbot_example/macos/RunnerTests/RunnerTests.swift
================================================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
File: chatbot_example/test/widget_test.dart
================================================
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:likeminds_chatbot_flutter_sample/app.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const LMChatbotApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}



================================================
File: chatbot_example/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="likeminds_chatbot_flutter_sample">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>likeminds_chatbot_flutter_sample</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>



================================================
File: chatbot_example/web/manifest.json
================================================
{
    "name": "likeminds_chatbot_flutter_sample",
    "short_name": "likeminds_chatbot_flutter_sample",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}




================================================
File: chatbot_example/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(likeminds_chatbot_flutter_sample LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "likeminds_chatbot_flutter_sample")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
File: chatbot_example/windows/.gitignore
================================================
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/



================================================
File: chatbot_example/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
File: chatbot_example/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <connectivity_plus/connectivity_plus_windows_plugin.h>
#include <emoji_picker_flutter/emoji_picker_flutter_plugin_c_api.h>
#include <file_selector_windows/file_selector_windows.h>
#include <firebase_core/firebase_core_plugin_c_api.h>
#include <media_kit_libs_windows_video/media_kit_libs_windows_video_plugin_c_api.h>
#include <media_kit_video/media_kit_video_plugin_c_api.h>
#include <permission_handler_windows/permission_handler_windows_plugin.h>
#include <screen_brightness_windows/screen_brightness_windows_plugin.h>
#include <url_launcher_windows/url_launcher_windows.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  ConnectivityPlusWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("ConnectivityPlusWindowsPlugin"));
  EmojiPickerFlutterPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("EmojiPickerFlutterPluginCApi"));
  FileSelectorWindowsRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FileSelectorWindows"));
  FirebaseCorePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseCorePluginCApi"));
  MediaKitLibsWindowsVideoPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("MediaKitLibsWindowsVideoPluginCApi"));
  MediaKitVideoPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("MediaKitVideoPluginCApi"));
  PermissionHandlerWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PermissionHandlerWindowsPlugin"));
  ScreenBrightnessWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("ScreenBrightnessWindowsPlugin"));
  UrlLauncherWindowsRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("UrlLauncherWindows"));
}



================================================
File: chatbot_example/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
File: chatbot_example/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  connectivity_plus
  emoji_picker_flutter
  file_selector_windows
  firebase_core
  media_kit_libs_windows_video
  media_kit_video
  permission_handler_windows
  screen_brightness_windows
  url_launcher_windows
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
  media_kit_native_event_loop
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
File: chatbot_example/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
File: chatbot_example/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "likeminds_chatbot_flutter_sample" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "likeminds_chatbot_flutter_sample" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2024 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "likeminds_chatbot_flutter_sample.exe" "\0"
            VALUE "ProductName", "likeminds_chatbot_flutter_sample" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
File: chatbot_example/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
File: chatbot_example/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
File: chatbot_example/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"likeminds_chatbot_flutter_sample", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
File: chatbot_example/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
File: chatbot_example/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>



================================================
File: chatbot_example/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
File: chatbot_example/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
File: chatbot_example/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
File: chatbot_example/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_




================================================
File: example/README.md
================================================
# LikeMinds Chat Flutter Sample

The quickest way to get a working app for trying out the Chat SDK



================================================
File: example/analysis_options.yaml
================================================
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    - public_member_api_docs
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options



================================================
File: example/devtools_options.yaml
================================================
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:



================================================
File: example/firebase.json
================================================
{"flutter":{"platforms":{"android":{"default":{"projectId":"likeminds-sdk-app","appId":"1:317419981427:android:383c84d581bad91bd2f806","fileOutput":"android/app/google-services.json"}},"ios":{"default":{"projectId":"likeminds-sdk-app","appId":"1:317419981427:ios:5c2e7053ed57f4b2d2f806","uploadDebugSymbols":false,"fileOutput":"ios/Runner/GoogleService-Info.plist"}},"macos":{"default":{"projectId":"likeminds-sdk-app","appId":"1:317419981427:ios:5c2e7053ed57f4b2d2f806","uploadDebugSymbols":false,"fileOutput":"macos/Runner/GoogleService-Info.plist"}},"dart":{"lib/firebase_options.dart":{"projectId":"likeminds-sdk-app","configurations":{"android":"1:317419981427:android:383c84d581bad91bd2f806","ios":"1:317419981427:ios:5c2e7053ed57f4b2d2f806","macos":"1:317419981427:ios:5c2e7053ed57f4b2d2f806","web":"1:317419981427:web:066d353b2223357cd2f806","windows":"1:317419981427:web:4437716c13e11f97d2f806"}}}}}}


================================================
File: example/pubspec.lock
================================================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: "0b2f2bd91ba804e53a61d757b986f89f1f9eaed5b11e4b2f5a2468d86d6c9fc7"
      url: "https://pub.dev"
    source: hosted
    version: "67.0.0"
  _flutterfire_internals:
    dependency: transitive
    description:
      name: _flutterfire_internals
      sha256: "5534e701a2c505fed1f0799e652dd6ae23bd4d2c4cf797220e5ced5764a7c1c2"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.44"
  amazon_cognito_identity_dart_2:
    dependency: transitive
    description:
      name: amazon_cognito_identity_dart_2
      sha256: "7dba58d7cba61a9d98861d5bfc777a69aa60127e78da3778095213a7e3b1539a"
      url: "https://pub.dev"
    source: hosted
    version: "3.6.5"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: "37577842a27e4338429a1cbc32679d508836510b056f1eedf0c8d20e39c1383d"
      url: "https://pub.dev"
    source: hosted
    version: "6.4.1"
  archive:
    dependency: transitive
    description:
      name: archive
      sha256: cb6a278ef2dbb298455e1a713bda08524a175630ec643a242c399c932a0a1f7d
      url: "https://pub.dev"
    source: hosted
    version: "3.6.1"
  args:
    dependency: transitive
    description:
      name: args
      sha256: "7cf60b9f0cc88203c5a190b4cd62a99feea42759a7fa695010eb5de1c0b2252a"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "947bfcf187f74dbc5e146c9eb9c0f10c9f8b30743e341481c1e2ed3ecc18c20c"
      url: "https://pub.dev"
    source: hosted
    version: "2.11.0"
  bloc:
    dependency: transitive
    description:
      name: bloc
      sha256: "106842ad6569f0b60297619e9e0b1885c2fb9bf84812935490e6c5275777804e"
      url: "https://pub.dev"
    source: hosted
    version: "8.1.4"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "6cfb5af12253eaf2b368f07bacc5a80d1301a071c73360d746b7f2e32d762c66"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "80184af8b6cb3e5c1c4ec6d8544d27711700bc3e6d2efad04238c7b5290889f0"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: bf80fcfb46a29945b423bd9aad884590fb1dc69b330a4d4700cac476af1708d1
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  cached_network_image:
    dependency: transitive
    description:
      name: cached_network_image
      sha256: "7c1183e361e5c8b0a0f21a28401eecdbde252441106a9816400dd4c2b2424916"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.1"
  cached_network_image_platform_interface:
    dependency: transitive
    description:
      name: cached_network_image_platform_interface
      sha256: "35814b016e37fbdc91f7ae18c8caf49ba5c88501813f73ce8a07027a395e2829"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  cached_network_image_web:
    dependency: transitive
    description:
      name: cached_network_image_web
      sha256: "980842f4e8e2535b8dbd3d5ca0b1f0ba66bf61d14cc3a17a9b4788a3685ba062"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.1"
  carousel_slider:
    dependency: transitive
    description:
      name: carousel_slider
      sha256: "7b006ec356205054af5beaef62e2221160ea36b90fb70a35e4deacd49d0349ae"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: "04a925763edad70e8443c99234dc3328f442e811f1d8fd1a72f1c8ad0f69a605"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: feb6bed21949061731a7a75fc5d2aa727cf160b91af9a3e464c5e3a32e28b5ff
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: cb6d7f03e1de671e34607e909a7213e31d7752be4fb66a86d29fe1eb14bfb5cf
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: ee67cb0715911d28db6bf4af1026078bd6f0128b07a5f66fb2ed94ec6783c09a
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
  connectivity_plus:
    dependency: "direct main"
    description:
      name: connectivity_plus
      sha256: "2056db5241f96cdc0126bd94459fc4cdc13876753768fc7a31c425e50a7177d0"
      url: "https://pub.dev"
    source: hosted
    version: "6.0.5"
  connectivity_plus_platform_interface:
    dependency: transitive
    description:
      name: connectivity_plus_platform_interface
      sha256: "42657c1715d48b167930d5f34d00222ac100475f73d10162ddf43e714932f204"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: "0f08b14755d163f6e2134cb58222dd25ea2a2ee8a195e53983d57c075324d592"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.1"
  cross_file:
    dependency: transitive
    description:
      name: cross_file
      sha256: "7caf6a750a0c04effbb52a676dce9a4a592e10ad35c34d6d2d0e4811160d5670"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.4+2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: ec30d999af904f33454ba22ed9a86162b35e52b44ac4807d1d93c288041d7d27
      url: "https://pub.dev"
    source: hosted
    version: "3.0.5"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  curl_logger_dio_interceptor:
    dependency: transitive
    description:
      name: curl_logger_dio_interceptor
      sha256: f20d89187a321d2150e1412bca30ebf4d89130bafc648ce21bd4f1ef4062b214
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  custom_pop_up_menu:
    dependency: transitive
    description:
      name: custom_pop_up_menu
      sha256: eeac484c6ddffffb25e803dc2a5cc9381e700a29f074e9fcc76fe36b62fde850
      url: "https://pub.dev"
    source: hosted
    version: "1.2.4"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "99e066ce75c89d6b29903d788a7bb9369cf754f7b24bf70bf4b6d6d6b26853b9"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.6"
  date_format:
    dependency: transitive
    description:
      name: date_format
      sha256: a48254e60bdb7f1d5a15cac7f86e37491808056c0a99dbdc850841def4754ddc
      url: "https://pub.dev"
    source: hosted
    version: "2.0.9"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: "365c771ac3b0e58845f39ec6deebc76e3276aa9922b0cc60840712094d9047ac"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.10"
  device_info_plus:
    dependency: "direct main"
    description:
      name: device_info_plus
      sha256: a7fd703482b391a87d60b6061d04dfdeab07826b96f9abd8f5ed98068acc0074
      url: "https://pub.dev"
    source: hosted
    version: "10.1.2"
  device_info_plus_platform_interface:
    dependency: transitive
    description:
      name: device_info_plus_platform_interface
      sha256: "282d3cf731045a2feb66abfe61bbc40870ae50a3ed10a4d3d217556c35c8c2ba"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  dio:
    dependency: transitive
    description:
      name: dio
      sha256: "5598aa796bbf4699afd5c67c0f5f6e2ed542afc956884b9cd58c306966efc260"
      url: "https://pub.dev"
    source: hosted
    version: "5.7.0"
  dio_web_adapter:
    dependency: transitive
    description:
      name: dio_web_adapter
      sha256: "33259a9276d6cea88774a0000cfae0d861003497755969c92faa223108620dc8"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  emoji_picker_flutter:
    dependency: transitive
    description:
      name: emoji_picker_flutter
      sha256: "3bf6d4cadc188215570a15c80fd7aeecec312b1cb3168ab08394e0faa4161fcb"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  envied:
    dependency: transitive
    description:
      name: envied
      sha256: bbff9c76120e4dc5e2e36a46690cf0a26feb65e7765633f4e8d916bcd173a450
      url: "https://pub.dev"
    source: hosted
    version: "0.5.4+1"
  equatable:
    dependency: transitive
    description:
      name: equatable
      sha256: c2b87cb7756efdf69892005af546c56c0b5037f54d2a88269b4f347a505e3ca2
      url: "https://pub.dev"
    source: hosted
    version: "2.0.5"
  extended_image:
    dependency: transitive
    description:
      name: extended_image
      sha256: "8ad4917eaae7271ce6d975d5c0040c7903010262908fbdb49ff2798fca754d3b"
      url: "https://pub.dev"
    source: hosted
    version: "8.3.0"
  extended_image_library:
    dependency: transitive
    description:
      name: extended_image_library
      sha256: "9a94ec9314aa206cfa35f16145c3cd6e2c924badcc670eaaca8a3a8063a68cd7"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.5"
  extended_text_field:
    dependency: "direct overridden"
    description:
      name: extended_text_field
      sha256: "3996195c117c6beb734026a7bc0ba80d7e4e84e4edd4728caa544d8209ab4d7d"
      url: "https://pub.dev"
    source: hosted
    version: "16.0.2"
  extended_text_library:
    dependency: transitive
    description:
      name: extended_text_library
      sha256: "55d09098ec56fab0d9a8a68950ca0bbf2efa1327937f7cec6af6dfa066234829"
      url: "https://pub.dev"
    source: hosted
    version: "12.0.0"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "511392330127add0b769b75a987850d136345d9227c6b94c96a04cf4a391bf78"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.1"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "16ed7b077ef01ad6170a3d0c57caa4a112a38d7a2ed5602e0aca9ca6f3d98da6"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  file:
    dependency: transitive
    description:
      name: file
      sha256: "5fc22d7c25582e38ad9a8515372cd9a93834027aacf1801cf01164dac0ffa08c"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  file_picker:
    dependency: transitive
    description:
      name: file_picker
      sha256: "167bb619cdddaa10ef2907609feb8a79c16dfa479d3afaf960f8e223f754bf12"
      url: "https://pub.dev"
    source: hosted
    version: "8.1.2"
  file_selector_linux:
    dependency: transitive
    description:
      name: file_selector_linux
      sha256: "045d372bf19b02aeb69cacf8b4009555fb5f6f0b7ad8016e5f46dd1387ddd492"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.2+1"
  file_selector_macos:
    dependency: transitive
    description:
      name: file_selector_macos
      sha256: cb284e267f8e2a45a904b5c094d2ba51d0aabfc20b1538ab786d9ef7dc2bf75c
      url: "https://pub.dev"
    source: hosted
    version: "0.9.4+1"
  file_selector_platform_interface:
    dependency: transitive
    description:
      name: file_selector_platform_interface
      sha256: a3994c26f10378a039faa11de174d7b78eb8f79e4dd0af2a451410c1a5c3f66b
      url: "https://pub.dev"
    source: hosted
    version: "2.6.2"
  file_selector_windows:
    dependency: transitive
    description:
      name: file_selector_windows
      sha256: "2ad726953f6e8affbc4df8dc78b77c3b4a060967a291e528ef72ae846c60fb69"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.3+2"
  firebase_core:
    dependency: "direct main"
    description:
      name: firebase_core
      sha256: "51dfe2fbf3a984787a2e7b8592f2f05c986bfedd6fdacea3f9e0a7beb334de96"
      url: "https://pub.dev"
    source: hosted
    version: "3.6.0"
  firebase_core_platform_interface:
    dependency: transitive
    description:
      name: firebase_core_platform_interface
      sha256: e30da58198a6d4b49d5bce4e852f985c32cb10db329ebef9473db2b9f09ce810
      url: "https://pub.dev"
    source: hosted
    version: "5.3.0"
  firebase_core_web:
    dependency: transitive
    description:
      name: firebase_core_web
      sha256: f967a7138f5d2ffb1ce15950e2a382924239eaa521150a8f144af34e68b3b3e5
      url: "https://pub.dev"
    source: hosted
    version: "2.18.1"
  firebase_database:
    dependency: transitive
    description:
      name: firebase_database
      sha256: "64f8076912139e83f3db3d853df5bffd4c6150a71ffef393584318efd4883f7c"
      url: "https://pub.dev"
    source: hosted
    version: "11.1.4"
  firebase_database_platform_interface:
    dependency: transitive
    description:
      name: firebase_database_platform_interface
      sha256: "750e9076a41bc78ce87b95f9d0548f224e5b0679009f6236bf5cf98884db60dd"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.5+44"
  firebase_database_web:
    dependency: transitive
    description:
      name: firebase_database_web
      sha256: daf3fbde892ff5f2ea7469eff1ab22b7988fe96b637919fdec6890141eb51023
      url: "https://pub.dev"
    source: hosted
    version: "0.2.6+2"
  firebase_messaging:
    dependency: "direct main"
    description:
      name: firebase_messaging
      sha256: eb6e28a3a35deda61fe8634967c84215efc19133ba58d8e0fc6c9a2af2cba05e
      url: "https://pub.dev"
    source: hosted
    version: "15.1.3"
  firebase_messaging_platform_interface:
    dependency: transitive
    description:
      name: firebase_messaging_platform_interface
      sha256: b316c4ee10d93d32c033644207afc282d9b2b4372f3cf9c6022f3558b3873d2d
      url: "https://pub.dev"
    source: hosted
    version: "4.5.46"
  firebase_messaging_web:
    dependency: transitive
    description:
      name: firebase_messaging_web
      sha256: d7f0147a1a9fe4313168e20154a01fd5cf332898de1527d3930ff77b8c7f5387
      url: "https://pub.dev"
    source: hosted
    version: "3.9.2"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: "25517a4deb0c03aa0f32fd12db525856438902d9c16536311e76cdc57b31d7d1"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_bloc:
    dependency: transitive
    description:
      name: flutter_bloc
      sha256: b594505eac31a0518bdcb4b5b79573b8d9117b193cc80cc12e17d639b10aa27a
      url: "https://pub.dev"
    source: hosted
    version: "8.1.6"
  flutter_cache_manager:
    dependency: transitive
    description:
      name: flutter_cache_manager
      sha256: "400b6592f16a4409a7f2bb929a9a7e38c72cceb8ffb99ee57bbf2cb2cecf8386"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.1"
  flutter_dotenv:
    dependency: "direct main"
    description:
      name: flutter_dotenv
      sha256: "9357883bdd153ab78cbf9ffa07656e336b8bbb2b5a3ca596b0b27e119f7c7d77"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "3f41d009ba7172d5ff9be5f6e6e6abb4300e263aab8866d2a0842ed2a70f8f0c"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  flutter_localizations:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_plugin_android_lifecycle:
    dependency: transitive
    description:
      name: flutter_plugin_android_lifecycle
      sha256: "9ee02950848f61c4129af3d6ec84a1cfc0e47931abc746b03e7a3bc3e8ff6eda"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.22"
  flutter_sound:
    dependency: transitive
    description:
      name: flutter_sound
      sha256: "31f9b2058a152520774f98147adb9f5df3b2e9ee0d5b6a7f4f07bec9feeca4e3"
      url: "https://pub.dev"
    source: hosted
    version: "9.16.3"
  flutter_sound_platform_interface:
    dependency: transitive
    description:
      name: flutter_sound_platform_interface
      sha256: "60ce97b065ca12161d501575dfcd49ec0764545a5e9ff9576dc96eb19f189e76"
      url: "https://pub.dev"
    source: hosted
    version: "9.16.3"
  flutter_sound_web:
    dependency: transitive
    description:
      name: flutter_sound_web
      sha256: c557aebe181ce1d2261a4cb9e3bb8eada18af30745791a7241e8d00152c5fa06
      url: "https://pub.dev"
    source: hosted
    version: "9.16.3"
  flutter_staggered_grid_view:
    dependency: transitive
    description:
      name: flutter_staggered_grid_view
      sha256: "19e7abb550c96fbfeb546b23f3ff356ee7c59a019a651f8f102a4ba9b7349395"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.0"
  flutter_svg:
    dependency: transitive
    description:
      name: flutter_svg
      sha256: "7b4ca6cf3304575fe9c8ec64813c8d02ee41d2afe60bcfe0678bcb5375d596a2"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.10+1"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  gif:
    dependency: transitive
    description:
      name: gif
      sha256: ade95694f1471da737922806818ffade2814d1d7f8d10af38ebcf36ace012bc0
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  giphy_get:
    dependency: transitive
    description:
      name: giphy_get
      sha256: "5a51c507bb52680da17d2f715d99f6beb638e69ac10e6cc1d53ae32d57b635b5"
      url: "https://pub.dev"
    source: hosted
    version: "3.5.6"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: "0e7014b3b7d4dac1ca4d6114f82bf1782ee86745b9b42a92c9289c23d8a0ab63"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  google_fonts:
    dependency: "direct main"
    description:
      name: google_fonts
      sha256: b1ac0fe2832c9cc95e5e88b57d627c5e68c223b9657f4b96e1487aa9098c7b82
      url: "https://pub.dev"
    source: hosted
    version: "6.2.1"
  hive:
    dependency: transitive
    description:
      name: hive
      sha256: "8dcf6db979d7933da8217edcec84e9df1bdb4e4edc7fc77dbd5aa74356d6d941"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.3"
  hive_flutter:
    dependency: transitive
    description:
      name: hive_flutter
      sha256: dca1da446b1d808a51689fb5d0c6c9510c0a2ba01e22805d492c73b68e33eecc
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  http:
    dependency: transitive
    description:
      name: http
      sha256: b9c29a161230ee03d3ccf545097fccd9b87a5264228c5d348202e0f0c28f9010
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  http_client_helper:
    dependency: transitive
    description:
      name: http_client_helper
      sha256: "8a9127650734da86b5c73760de2b404494c968a3fd55602045ffec789dac3cb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "2aa08ce0341cc9b354a498388e30986515406668dbcc4f7c950c3e715496693b"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.2"
  image:
    dependency: transitive
    description:
      name: image
      sha256: "2237616a36c0d69aef7549ab439b833fb7f9fb9fc861af2cc9ac3eedddd69ca8"
      url: "https://pub.dev"
    source: hosted
    version: "4.2.0"
  image_picker:
    dependency: transitive
    description:
      name: image_picker
      sha256: "021834d9c0c3de46bf0fe40341fa07168407f694d9b2bb18d532dc1261867f7a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  image_picker_android:
    dependency: transitive
    description:
      name: image_picker_android
      sha256: "8c5abf0dcc24fe6e8e0b4a5c0b51a5cf30cefdf6407a3213dae61edc75a70f56"
      url: "https://pub.dev"
    source: hosted
    version: "0.8.12+12"
  image_picker_for_web:
    dependency: transitive
    description:
      name: image_picker_for_web
      sha256: "65d94623e15372c5c51bebbcb820848d7bcb323836e12dfdba60b5d3a8b39e50"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.5"
  image_picker_ios:
    dependency: transitive
    description:
      name: image_picker_ios
      sha256: "6703696ad49f5c3c8356d576d7ace84d1faf459afb07accbb0fae780753ff447"
      url: "https://pub.dev"
    source: hosted
    version: "0.8.12"
  image_picker_linux:
    dependency: transitive
    description:
      name: image_picker_linux
      sha256: "4ed1d9bb36f7cd60aa6e6cd479779cc56a4cb4e4de8f49d487b1aaad831300fa"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1+1"
  image_picker_macos:
    dependency: transitive
    description:
      name: image_picker_macos
      sha256: "3f5ad1e8112a9a6111c46d0b57a7be2286a9a07fc6e1976fdf5be2bd31d4ff62"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1+1"
  image_picker_platform_interface:
    dependency: transitive
    description:
      name: image_picker_platform_interface
      sha256: "9ec26d410ff46f483c5519c29c02ef0e02e13a543f882b152d4bfd2f06802f80"
      url: "https://pub.dev"
    source: hosted
    version: "2.10.0"
  image_picker_windows:
    dependency: transitive
    description:
      name: image_picker_windows
      sha256: "6ad07afc4eb1bc25f3a01084d28520496c4a3bb0cb13685435838167c9dcedeb"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1+1"
  infinite_scroll_pagination:
    dependency: transitive
    description:
      name: infinite_scroll_pagination
      sha256: b68bce20752fcf36c7739e60de4175494f74e99e9a69b4dd2fe3a1dd07a7f16a
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  intl:
    dependency: transitive
    description:
      name: intl
      sha256: d6f56758b7d3014a48af9701c085700aac781a92a87a62b1333b46d8879661cf
      url: "https://pub.dev"
    source: hosted
    version: "0.19.0"
  js:
    dependency: "direct overridden"
    description:
      name: js
      sha256: c1b2e9b5ea78c45e1a0788d29606ba27dc5f71f019f32ca5140f61ef071838cf
      url: "https://pub.dev"
    source: hosted
    version: "0.7.1"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  json_serializable:
    dependency: transitive
    description:
      name: json_serializable
      sha256: ea1432d167339ea9b5bb153f0571d0039607a873d6e04e0117af043f14a1fd4b
      url: "https://pub.dev"
    source: hosted
    version: "6.8.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "3f87a60e8c63aecc975dda1ceedbc8f24de75f09e4856ea27daf8958f2f0ce05"
      url: "https://pub.dev"
    source: hosted
    version: "10.0.5"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "932549fb305594d82d7183ecd9fa93463e9914e1b67cacc34bc40906594a1806"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.5"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "6ba465d5d76e67ddf503e1161d1f4a6bc42306f9d66ca1e8f079a47290fb06d3"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  likeminds_chat_fl:
    dependency: "direct overridden"
    description:
      path: "../../LikeMinds-Flutter-GroupChat-SDK"
      relative: true
    source: path
    version: "1.12.0"
  likeminds_chat_flutter_core:
    dependency: "direct main"
    description:
      path: "../lib/packages/core"
      relative: true
    source: path
    version: "0.14.0"
  likeminds_chat_flutter_ui:
    dependency: "direct overridden"
    description:
      path: "../lib/packages/ui"
      relative: true
    source: path
    version: "0.14.0"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: "976c774dd944a42e83e2467f4cc670daef7eed6295b10b36ae8c85bcbf828235"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  logger:
    dependency: transitive
    description:
      name: logger
      sha256: "697d067c60c20999686a0add96cf6aba723b3aa1f83ecf806a8097231529ec32"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.0"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: "623a88c9594aa774443aa3eb2d41807a48486b5613e67599fb4c41c0ad47c340"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  lottie:
    dependency: transitive
    description:
      name: lottie
      sha256: "7afc60865a2429d994144f7d66ced2ae4305fe35d82890b8766e3359872d872c"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: d2323aa2060500f906aa31a895b4030b6da3ebdcc5619d14ce1aada65cd161cb
      url: "https://pub.dev"
    source: hosted
    version: "0.12.16+1"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  media_kit:
    dependency: transitive
    description:
      name: media_kit
      sha256: "1f1deee148533d75129a6f38251ff8388e33ee05fc2d20a6a80e57d6051b7b62"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.11"
  media_kit_libs_android_video:
    dependency: transitive
    description:
      name: media_kit_libs_android_video
      sha256: "9dd8012572e4aff47516e55f2597998f0a378e3d588d0fad0ca1f11a53ae090c"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.6"
  media_kit_libs_ios_video:
    dependency: transitive
    description:
      name: media_kit_libs_ios_video
      sha256: b5382994eb37a4564c368386c154ad70ba0cc78dacdd3fb0cd9f30db6d837991
      url: "https://pub.dev"
    source: hosted
    version: "1.1.4"
  media_kit_libs_linux:
    dependency: transitive
    description:
      name: media_kit_libs_linux
      sha256: e186891c31daa6bedab4d74dcdb4e8adfccc7d786bfed6ad81fe24a3b3010310
      url: "https://pub.dev"
    source: hosted
    version: "1.1.3"
  media_kit_libs_macos_video:
    dependency: transitive
    description:
      name: media_kit_libs_macos_video
      sha256: f26aa1452b665df288e360393758f84b911f70ffb3878032e1aabba23aa1032d
      url: "https://pub.dev"
    source: hosted
    version: "1.1.4"
  media_kit_libs_video:
    dependency: transitive
    description:
      name: media_kit_libs_video
      sha256: "20bb4aefa8fece282b59580e1cd8528117297083a6640c98c2e98cfc96b93288"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  media_kit_libs_windows_video:
    dependency: transitive
    description:
      name: media_kit_libs_windows_video
      sha256: "32654572167825c42c55466f5d08eee23ea11061c84aa91b09d0e0f69bdd0887"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.10"
  media_kit_native_event_loop:
    dependency: transitive
    description:
      name: media_kit_native_event_loop
      sha256: "7d82e3b3e9ded5c35c3146c5ba1da3118d1dd8ac3435bac7f29f458181471b40"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.9"
  media_kit_video:
    dependency: transitive
    description:
      name: media_kit_video
      sha256: "2cc3b966679963ba25a4ce5b771e532a521ebde7c6aa20e9802bec95d9916c8f"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.5"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: bdb68674043280c3428e9ec998512fb681678676b3c54e773629ffe74419f8c7
      url: "https://pub.dev"
    source: hosted
    version: "1.15.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "801fd0b26f14a4a58ccb09d5892c3fbdeff209594300a542492cf13fba9d247a"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.6"
  nested:
    dependency: transitive
    description:
      name: nested
      sha256: "03bac4c528c64c95c722ec99280375a6f2fc708eec17c7b3f07253b626cd2a20"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  nm:
    dependency: transitive
    description:
      name: nm
      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  octo_image:
    dependency: transitive
    description:
      name: octo_image
      sha256: "34faa6639a78c7e3cbe79be6f9f96535867e879748ade7d17c9b1ae7536293bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  open_file:
    dependency: transitive
    description:
      name: open_file
      sha256: d17e2bddf5b278cb2ae18393d0496aa4f162142ba97d1a9e0c30d476adf99c0e
      url: "https://pub.dev"
    source: hosted
    version: "3.5.10"
  open_file_android:
    dependency: transitive
    description:
      name: open_file_android
      sha256: "58141fcaece2f453a9684509a7275f231ac0e3d6ceb9a5e6de310a7dff9084aa"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.6"
  open_file_ios:
    dependency: transitive
    description:
      name: open_file_ios
      sha256: "02996f01e5f6863832068e97f8f3a5ef9b613516db6897f373b43b79849e4d07"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.3"
  open_file_linux:
    dependency: transitive
    description:
      name: open_file_linux
      sha256: d189f799eecbb139c97f8bc7d303f9e720954fa4e0fa1b0b7294767e5f2d7550
      url: "https://pub.dev"
    source: hosted
    version: "0.0.5"
  open_file_mac:
    dependency: transitive
    description:
      name: open_file_mac
      sha256: "1440b1e37ceb0642208cfeb2c659c6cda27b25187a90635c9d1acb7d0584d324"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.3"
  open_file_platform_interface:
    dependency: transitive
    description:
      name: open_file_platform_interface
      sha256: "101b424ca359632699a7e1213e83d025722ab668b9fd1412338221bf9b0e5757"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.3"
  open_file_web:
    dependency: transitive
    description:
      name: open_file_web
      sha256: e3dbc9584856283dcb30aef5720558b90f88036360bd078e494ab80a80130c4f
      url: "https://pub.dev"
    source: hosted
    version: "0.0.4"
  open_file_windows:
    dependency: transitive
    description:
      name: open_file_windows
      sha256: d26c31ddf935a94a1a3aa43a23f4fff8a5ff4eea395fe7a8cb819cf55431c875
      url: "https://pub.dev"
    source: hosted
    version: "0.0.3"
  overlay_support:
    dependency: transitive
    description:
      name: overlay_support
      sha256: fc39389bfd94e6985e1e13b2a88a125fc4027608485d2d4e2847afe1b2bb339c
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: "1c5b77ccc91e4823a5af61ee74e6b972db1ef98c2ff5a18d3161c982a55448bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  package_info_plus:
    dependency: transitive
    description:
      name: package_info_plus
      sha256: a75164ade98cb7d24cfd0a13c6408927c6b217fa60dee5a7ff5c116a58f28918
      url: "https://pub.dev"
    source: hosted
    version: "8.0.2"
  package_info_plus_platform_interface:
    dependency: transitive
    description:
      name: package_info_plus_platform_interface
      sha256: ac1f4a4847f1ade8e6a87d1f39f5d7c67490738642e2542f559ec38c37489a66
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "087ce49c3f0dc39180befefc60fdb4acd8f8620e5682fe2476afd0b3688bb4af"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.0"
  path_parsing:
    dependency: transitive
    description:
      name: path_parsing
      sha256: e3e67b1629e6f7e8100b367d3db6ba6af4b1f0bb80f64db18ef1fbabd2fa9ccf
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  path_provider:
    dependency: transitive
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: "6f01f8e37ec30b07bc424b4deabac37cacb1bc7e2e515ad74486039918a37eb7"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.10"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: f234384a3fdd67f989b4d54a5d73ca2a6c422fa55ae694381ae0f4375cd1ea16
      url: "https://pub.dev"
    source: hosted
    version: "2.4.0"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  pdf_render:
    dependency: transitive
    description:
      name: pdf_render
      sha256: bacd2ad8f4f4c9821827003065f5c2f9ca474dd418ff29c68272aab4c0e1e88b
      url: "https://pub.dev"
    source: hosted
    version: "1.4.12"
  permission_handler:
    dependency: transitive
    description:
      name: permission_handler
      sha256: "18bf33f7fefbd812f37e72091a15575e72d5318854877e0e4035a24ac1113ecb"
      url: "https://pub.dev"
    source: hosted
    version: "11.3.1"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: "76e4ab092c1b240d31177bb64d2b0bea43f43d0e23541ec866151b9f7b2490fa"
      url: "https://pub.dev"
    source: hosted
    version: "12.0.12"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: e6f6d73b12438ef13e648c4ae56bd106ec60d17e90a59c4545db6781229082a0
      url: "https://pub.dev"
    source: hosted
    version: "9.4.5"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: af26edbbb1f2674af65a8f4b56e1a6f526156bc273d0e65dd8075fab51c78851
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+2"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: e9c8eadee926c4532d0305dff94b85bf961f16759c3af791486613152af4b4f9
      url: "https://pub.dev"
    source: hosted
    version: "4.2.3"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: c15605cd28af66339f8eb6fbe0e541bfe2d1b72d5825efc6598f3e0a31b9ad27
      url: "https://pub.dev"
    source: hosted
    version: "6.0.2"
  photo_view:
    dependency: transitive
    description:
      name: photo_view
      sha256: "1fc3d970a91295fbd1364296575f854c9863f225505c28c46e0a03e48960c75e"
      url: "https://pub.dev"
    source: hosted
    version: "0.15.0"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "9b71283fc13df574056616011fb138fd3b793ea47cc509c189a6c3fa5f8a1a65"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.5"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  provider:
    dependency: transitive
    description:
      name: provider
      sha256: c8a055ee5ce3fd98d6fc872478b03823ffdb448699c6ebdbbc71d59b596fd48c
      url: "https://pub.dev"
    source: hosted
    version: "6.1.2"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "40d3ab1bbd474c4c2328c91e3a7df8c6dd629b79ece4c4bd04bee496a224fb0c"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: c799b721d79eb6ee6fa56f00c04b472dcd44a30d258fac2174a6ec57302678f8
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  recase:
    dependency: transitive
    description:
      name: recase
      sha256: e4eb4ec2dcdee52dcf99cb4ceabaffc631d7424ee55e56f280bc039737f89213
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  rxdart:
    dependency: transitive
    description:
      name: rxdart
      sha256: "5c3004a4a8dbb94bd4bf5412a4def4acdaa12e12f269737a5751369e12d1a962"
      url: "https://pub.dev"
    source: hosted
    version: "0.28.0"
  safe_local_storage:
    dependency: transitive
    description:
      name: safe_local_storage
      sha256: ede4eb6cb7d88a116b3d3bf1df70790b9e2038bc37cb19112e381217c74d9440
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  screen_brightness:
    dependency: transitive
    description:
      name: screen_brightness
      sha256: ed8da4a4511e79422fc1aa88138e920e4008cd312b72cdaa15ccb426c0faaedd
      url: "https://pub.dev"
    source: hosted
    version: "0.2.2+1"
  screen_brightness_android:
    dependency: transitive
    description:
      name: screen_brightness_android
      sha256: "3df10961e3a9e968a5e076fe27e7f4741fa8a1d3950bdeb48cf121ed529d0caf"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0+2"
  screen_brightness_ios:
    dependency: transitive
    description:
      name: screen_brightness_ios
      sha256: "99adc3ca5490b8294284aad5fcc87f061ad685050e03cf45d3d018fe398fd9a2"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0"
  screen_brightness_macos:
    dependency: transitive
    description:
      name: screen_brightness_macos
      sha256: "64b34e7e3f4900d7687c8e8fb514246845a73ecec05ab53483ed025bd4a899fd"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0+1"
  screen_brightness_platform_interface:
    dependency: transitive
    description:
      name: screen_brightness_platform_interface
      sha256: b211d07f0c96637a15fb06f6168617e18030d5d74ad03795dd8547a52717c171
      url: "https://pub.dev"
    source: hosted
    version: "0.1.0"
  screen_brightness_windows:
    dependency: transitive
    description:
      name: screen_brightness_windows
      sha256: "9261bf33d0fc2707d8cf16339ce25768100a65e70af0fcabaf032fc12408ba86"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3"
  shared_preferences:
    dependency: transitive
    description:
      name: shared_preferences
      sha256: "746e5369a43170c25816cc472ee016d3a66bc13fcf430c0bc41ad7b4b2922051"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: "480ba4345773f56acda9abf5f50bd966f581dac5d514e5fc4a18c62976bbba7e"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: c4b35f6cb8f63c147312c054ce7c2254c8066745125264f0c88739c417fc9d9f
      url: "https://pub.dev"
    source: hosted
    version: "2.5.2"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: d2ca4132d3946fec2184261726b355836a82c33d7d5b67af32692aff18a4684e
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shimmer:
    dependency: transitive
    description:
      name: shimmer
      sha256: "5f88c883a22e9f9f299e5ba0e4f7e6054857224976a5d9f839d4ebdc94a14ac9"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.99"
  sliver_tools:
    dependency: transitive
    description:
      name: sliver_tools
      sha256: eae28220badfb9d0559207badcbbc9ad5331aac829a88cb0964d330d2a4636a6
      url: "https://pub.dev"
    source: hosted
    version: "0.2.12"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "14658ba5f669685cd3d63701d01b31ea748310f7ab854e471962670abcf57832"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  source_helper:
    dependency: transitive
    description:
      name: source_helper
      sha256: "6adebc0006c37dd63fe05bca0a929b99f06402fc95aa35bf36d67f5c06de01fd"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.4"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "53e943d4206a5e30df338fd4c6e7a077e02254531b138a15aec3bd143c1a8b3c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.0"
  sprintf:
    dependency: transitive
    description:
      name: sprintf
      sha256: "1fc9ffe69d4df602376b52949af107d8f5703b77cda567c4d7d86a0693120f23"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.0"
  sqflite:
    dependency: transitive
    description:
      name: sqflite
      sha256: a43e5a27235518c03ca238e7b4732cf35eabe863a369ceba6cbefa537a66f16d
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3+1"
  sqflite_common:
    dependency: transitive
    description:
      name: sqflite_common
      sha256: "3da423ce7baf868be70e2c0976c28a1bb2f73644268b7ffa7d2e08eab71f16a4"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.4"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "73713990125a6d93122541237550ee3352a2d84baad52d375a4cad2eb9b7ce0b"
      url: "https://pub.dev"
    source: hosted
    version: "1.11.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: ba2aa5d8cc609d96bbb2899c28934f9e1af5cddbd60a827822ea467161eb54e7
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "556692adab6cfa87322a115640c11f13cb77b3f076ddcc5d6ae3c20242bedcde"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  super_sliver_list:
    dependency: transitive
    description:
      name: super_sliver_list
      sha256: b1e1e64d08ce40e459b9bb5d9f8e361617c26b8c9f3bb967760b0f436b6e3f56
      url: "https://pub.dev"
    source: hosted
    version: "0.4.1"
  swipe_to_action:
    dependency: transitive
    description:
      name: swipe_to_action
      sha256: "0914f78df07a15b5fd97e800036fd63a2bcd4dbe67a4a514a597303806a361ea"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0"
  synchronized:
    dependency: transitive
    description:
      name: synchronized
      sha256: "539ef412b170d65ecdafd780f924e5be3f60032a1128df156adad6c5b373d558"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0+1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: a29248a84fbb7c79282b40b8c72a1209db169a2e0542bce341da992fe1bc7e84
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "5b8a98dafc4d5c4c9c72d8b31ab2b23fc13422348d2997120294d3bac86b4ddb"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.2"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: facc8d6582f16042dd49f2463ff1bd6e2c9ef9f3d5da3d9b087e244a7b564b3c
      url: "https://pub.dev"
    source: hosted
    version: "1.3.2"
  universal_platform:
    dependency: transitive
    description:
      name: universal_platform
      sha256: "64e16458a0ea9b99260ceb5467a214c1f298d647c659af1bff6d3bf82536b1ec"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  uri_parser:
    dependency: transitive
    description:
      name: uri_parser
      sha256: "6543c9fd86d2862fac55d800a43e67c0dcd1a41677cb69c2f8edfe73bbcf1835"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.2"
  url_launcher:
    dependency: transitive
    description:
      name: url_launcher
      sha256: "21b704ce5fa560ea9f3b525b43601c678728ba46725bab9b01187b4831377ed3"
      url: "https://pub.dev"
    source: hosted
    version: "6.3.0"
  url_launcher_android:
    dependency: transitive
    description:
      name: url_launcher_android
      sha256: f0c73347dfcfa5b3db8bc06e1502668265d39c08f310c29bff4e28eea9699f79
      url: "https://pub.dev"
    source: hosted
    version: "6.3.9"
  url_launcher_ios:
    dependency: transitive
    description:
      name: url_launcher_ios
      sha256: e43b677296fadce447e987a2f519dcf5f6d1e527dc35d01ffab4fff5b8a7063e
      url: "https://pub.dev"
    source: hosted
    version: "6.3.1"
  url_launcher_linux:
    dependency: transitive
    description:
      name: url_launcher_linux
      sha256: e2b9622b4007f97f504cd64c0128309dfb978ae66adbe944125ed9e1750f06af
      url: "https://pub.dev"
    source: hosted
    version: "3.2.0"
  url_launcher_macos:
    dependency: transitive
    description:
      name: url_launcher_macos
      sha256: "769549c999acdb42b8bcfa7c43d72bf79a382ca7441ab18a808e101149daf672"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.1"
  url_launcher_platform_interface:
    dependency: transitive
    description:
      name: url_launcher_platform_interface
      sha256: "552f8a1e663569be95a8190206a38187b531910283c3e982193e4f2733f01029"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  url_launcher_web:
    dependency: transitive
    description:
      name: url_launcher_web
      sha256: "772638d3b34c779ede05ba3d38af34657a05ac55b06279ea6edd409e323dca8e"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.3"
  url_launcher_windows:
    dependency: transitive
    description:
      name: url_launcher_windows
      sha256: "49c10f879746271804767cb45551ec5592cdab00ee105c06dddde1a98f73b185"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  uuid:
    dependency: transitive
    description:
      name: uuid
      sha256: f33d6bb662f0e4f79dcd7ada2e6170f3b3a2530c28fc41f49a411ddedd576a77
      url: "https://pub.dev"
    source: hosted
    version: "4.5.0"
  vector_graphics:
    dependency: transitive
    description:
      name: vector_graphics
      sha256: "32c3c684e02f9bc0afb0ae0aa653337a2fe022e8ab064bcd7ffda27a74e288e3"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.11+1"
  vector_graphics_codec:
    dependency: transitive
    description:
      name: vector_graphics_codec
      sha256: c86987475f162fadff579e7320c7ddda04cd2fdeffbe1129227a85d9ac9e03da
      url: "https://pub.dev"
    source: hosted
    version: "1.1.11+1"
  vector_graphics_compiler:
    dependency: transitive
    description:
      name: vector_graphics_compiler
      sha256: "12faff3f73b1741a36ca7e31b292ddeb629af819ca9efe9953b70bd63fc8cd81"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.11+1"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: "80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  video_thumbnail:
    dependency: transitive
    description:
      name: video_thumbnail
      sha256: "3455c189d3f0bb4e3fc2236475aa84fe598b9b2d0e08f43b9761f5bc44210016"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.3"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "5c5f338a667b4c644744b661f309fb8080bb94b18a7e91ef1dbd343bed00ed6d"
      url: "https://pub.dev"
    source: hosted
    version: "14.2.5"
  volume_controller:
    dependency: transitive
    description:
      name: volume_controller
      sha256: c71d4c62631305df63b72da79089e078af2659649301807fa746088f365cb48e
      url: "https://pub.dev"
    source: hosted
    version: "2.0.8"
  wakelock_plus:
    dependency: transitive
    description:
      name: wakelock_plus
      sha256: bf4ee6f17a2fa373ed3753ad0e602b7603f8c75af006d5b9bdade263928c0484
      url: "https://pub.dev"
    source: hosted
    version: "1.2.8"
  wakelock_plus_platform_interface:
    dependency: transitive
    description:
      name: wakelock_plus_platform_interface
      sha256: "422d1cdbb448079a8a62a5a770b69baa489f8f7ca21aef47800c726d404f9d16"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "3d2ad6751b3c16cf07c7fca317a1413b3f26530319181b37e3b9039b84fc01d8"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  web:
    dependency: transitive
    description:
      name: web
      sha256: cd3543bd5798f6ad290ea73d210f423502e71900302dde696f8bff84bf89a1cb
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: "68d1e89a91ed61ad9c370f9f8b6effed9ae5e0ede22a270bdfa6daf79fc2290a"
      url: "https://pub.dev"
    source: hosted
    version: "5.5.4"
  win32_registry:
    dependency: transitive
    description:
      name: win32_registry
      sha256: "21ec76dfc731550fd3e2ce7a33a9ea90b828fdf19a5c3bcf556fa992cfa99852"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.5"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: faea9dee56b520b55a566385b84f2e8de55e7496104adada9962e0bd11bcff1d
      url: "https://pub.dev"
    source: hosted
    version: "1.0.4"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: b015a8ad1c488f66851d762d3090a21c600e479dc75e68328c52774040cf9226
      url: "https://pub.dev"
    source: hosted
    version: "6.5.0"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: "75769501ea3489fca56601ff33454fe45507ea3bfb014161abc3b43ae25989d5"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
sdks:
  dart: ">=3.4.0 <4.0.0"
  flutter: ">=3.22.0"



================================================
File: example/pubspec.yaml
================================================
name: likeminds_chat_flutter_sample
description: Master sample app for LikeMinds Chat SDK, showcasing the latest features available.
publish_to: "none"
version: 0.15.0

environment:
  sdk: ">=3.1.0 <4.0.0"
  flutter: ">=3.10.2"

dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^1.0.2
  firebase_core:

  likeminds_chat_flutter_core: ^0.15.0
  google_fonts: ^6.2.0
  flutter_dotenv: ^5.1.0
  firebase_messaging: ^15.0.3
  device_info_plus: ^10.1.0
  connectivity_plus: ^6.0.3

dependency_overrides:
  js: ^0.7.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0

flutter:
  uses-material-design: true



================================================
File: example/pubspec_overrides.yaml
================================================
# melos_managed_dependency_overrides: js

dependency_overrides:
  likeminds_chat_flutter_core:
    path: ../lib/packages/core
  likeminds_chat_flutter_ui:
    path: ../lib/packages/ui
  likeminds_chat_fl:
    path: ../../LikeMinds-Flutter-GroupChat-SDK/
  extended_text_field: ^16.0.0
  js: ^0.7.1



================================================
File: example/.fvmrc
================================================
{
  "flutter": "3.22.0"
}


================================================
File: example/.gitignore
================================================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# FVM Version Cache
.fvm/


================================================
File: example/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819
      base_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819
    - platform: ios
      create_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819
      base_revision: 80c2e84975bbd28ecf5f8d4bd4ca5a2490bfc819

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
File: example/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx1536M
android.useAndroidX=true
android.enableJetifier=true



================================================
File: example/android/.gitignore
================================================
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java

# Remember to never publicly share your keystore.
# See https://flutter.dev/docs/deployment/android#reference-the-keystore-from-the-app
key.properties
**/*.keystore
**/*.jks



================================================
File: example/android/app/google-services.json
================================================
{
  "project_info": {
    "project_number": "317419981427",
    "project_id": "likeminds-sdk-app",
    "storage_bucket": "likeminds-sdk-app.appspot.com"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:d40f25139f5b51a1d2f806",
        "android_client_info": {
          "package_name": "com.example.likeminds_feed_ss_sample"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:383c84d581bad91bd2f806",
        "android_client_info": {
          "package_name": "com.likeminds.chat.flutter.sample"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:3d43f34bdf73d2f5d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.chat.sx"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:164a8ccb63a70ab9d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.chatsample"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:1121d9f691545267d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.chatsampleapp"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:7cad89b10e73d0b0d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.chatsampleapp.debug"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:f2deeede970a20f0d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.feedexample"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:39193e779135e11cd2f806",
        "android_client_info": {
          "package_name": "com.likeminds.feedsample"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:363c6b0cb7755690d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.feedsampleapp"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:a87c7d61abe7aaaed2f806",
        "android_client_info": {
          "package_name": "com.likeminds.feedsampleapp.social"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:36bc6190f8093740d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.feedsampleapp.social.debug"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:fd0b5e08083d3cc5d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.flutter.sample"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:41d628b711423e93d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.likemindschat"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:0b431a9399e249c4d2f806",
        "android_client_info": {
          "package_name": "com.likeminds.myapplication"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:59687b07fa4ad6eed2f806",
        "android_client_info": {
          "package_name": "com.rnsampleapp"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    },
    {
      "client_info": {
        "mobilesdk_app_id": "1:317419981427:android:dbc1ef90f35b42d5d2f806",
        "android_client_info": {
          "package_name": "com.sampleapp"
        }
      },
      "oauth_client": [
        {
          "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "317419981427-2ephdi4q8i78sn2envf4aacob8o8d24a.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "317419981427-7qihmbvns7n6094rcsddhdthov77bhkf.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.likeminds.suraasa.dev"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}


================================================
File: example/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO"/>
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
</manifest>



================================================
File: example/android/app/src/main/AndroidManifest.xml
================================================
<manifest 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO"/>
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <application
        android:label="chat.flutter.sample"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher"
        tools:replace="android:icon, android:label">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
</manifest>



================================================
File: example/android/app/src/main/kotlin/com/example/likeminds_chat_flutter_sample/MainActivity.kt
================================================
package com.likeminds.chat.flutter.sample

import io.flutter.embedding.android.FlutterActivity

class MainActivity: FlutterActivity() {
}



================================================
File: example/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
File: example/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>








================================================
File: example/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
File: example/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
File: example/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES"/>
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO"/>
</manifest>



================================================
File: example/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5-all.zip



================================================
File: example/ios/Podfile
================================================
# Uncomment this line to define a global platform for your project
platform :ios, '13.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
    target.build_configurations.each do |config|
      config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '13.0'
      config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'
    end
    target.build_configurations.each do |config|
      # You can remove unused permissions here
      # for more information: https://github.com/Baseflow/flutter-permission-handler/blob/main/permission_handler_apple/ios/Classes/PermissionHandlerEnums.h
      # e.g. when you don't need camera permission, just add 'PERMISSION_CAMERA=0'
      config.build_settings['GCC_PREPROCESSOR_DEFINITIONS'] ||= [
        '$(inherited)',

        ## dart: PermissionGroup.camera
        'PERMISSION_CAMERA=1',

        ## dart: PermissionGroup.microphone
        'PERMISSION_MICROPHONE=1',

        ## dart: PermissionGroup.photos
        'PERMISSION_PHOTOS=1',

        ## dart: PermissionGroup.notification
        'PERMISSION_NOTIFICATIONS=1',

        ## dart: PermissionGroup.mediaLibrary
        'PERMISSION_MEDIA_LIBRARY=1',
      ]

    end
  end
end



================================================
File: example/ios/Podfile.lock
================================================
PODS:
  - connectivity_plus (0.0.1):
    - Flutter
    - FlutterMacOS
  - device_info_plus (0.0.1):
    - Flutter
  - DKImagePickerController/Core (4.3.9):
    - DKImagePickerController/ImageDataManager
    - DKImagePickerController/Resource
  - DKImagePickerController/ImageDataManager (4.3.9)
  - DKImagePickerController/PhotoGallery (4.3.9):
    - DKImagePickerController/Core
    - DKPhotoGallery
  - DKImagePickerController/Resource (4.3.9)
  - DKPhotoGallery (0.0.19):
    - DKPhotoGallery/Core (= 0.0.19)
    - DKPhotoGallery/Model (= 0.0.19)
    - DKPhotoGallery/Preview (= 0.0.19)
    - DKPhotoGallery/Resource (= 0.0.19)
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Core (0.0.19):
    - DKPhotoGallery/Model
    - DKPhotoGallery/Preview
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Model (0.0.19):
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Preview (0.0.19):
    - DKPhotoGallery/Model
    - DKPhotoGallery/Resource
    - SDWebImage
    - SwiftyGif
  - DKPhotoGallery/Resource (0.0.19):
    - SDWebImage
    - SwiftyGif
  - emoji_picker_flutter (0.0.1):
    - Flutter
  - file_picker (0.0.1):
    - DKImagePickerController/PhotoGallery
    - Flutter
  - Firebase/CoreOnly (11.2.0):
    - FirebaseCore (= 11.2.0)
  - Firebase/Database (11.2.0):
    - Firebase/CoreOnly
    - FirebaseDatabase (~> 11.2.0)
  - Firebase/Messaging (11.2.0):
    - Firebase/CoreOnly
    - FirebaseMessaging (~> 11.2.0)
  - firebase_core (3.6.0):
    - Firebase/CoreOnly (= 11.2.0)
    - Flutter
  - firebase_database (11.1.4):
    - Firebase/Database (= 11.2.0)
    - firebase_core
    - Flutter
  - firebase_messaging (15.1.3):
    - Firebase/Messaging (= 11.2.0)
    - firebase_core
    - Flutter
  - FirebaseAppCheckInterop (11.6.0)
  - FirebaseCore (11.2.0):
    - FirebaseCoreInternal (~> 11.0)
    - GoogleUtilities/Environment (~> 8.0)
    - GoogleUtilities/Logger (~> 8.0)
  - FirebaseCoreInternal (11.6.0):
    - "GoogleUtilities/NSData+zlib (~> 8.0)"
  - FirebaseDatabase (11.2.0):
    - FirebaseAppCheckInterop (~> 11.0)
    - FirebaseCore (~> 11.0)
    - FirebaseSharedSwift (~> 11.0)
    - GoogleUtilities/UserDefaults (~> 8.0)
    - leveldb-library (~> 1.22)
  - FirebaseInstallations (11.4.0):
    - FirebaseCore (~> 11.0)
    - GoogleUtilities/Environment (~> 8.0)
    - GoogleUtilities/UserDefaults (~> 8.0)
    - PromisesObjC (~> 2.4)
  - FirebaseMessaging (11.2.0):
    - FirebaseCore (~> 11.0)
    - FirebaseInstallations (~> 11.0)
    - GoogleDataTransport (~> 10.0)
    - GoogleUtilities/AppDelegateSwizzler (~> 8.0)
    - GoogleUtilities/Environment (~> 8.0)
    - GoogleUtilities/Reachability (~> 8.0)
    - GoogleUtilities/UserDefaults (~> 8.0)
    - nanopb (~> 3.30910.0)
  - FirebaseSharedSwift (11.6.0)
  - Flutter (1.0.0)
  - flutter_sound (9.16.3):
    - Flutter
    - flutter_sound_core (= 9.16.3)
  - flutter_sound_core (9.16.3)
  - GoogleDataTransport (10.1.0):
    - nanopb (~> 3.30910.0)
    - PromisesObjC (~> 2.4)
  - GoogleUtilities/AppDelegateSwizzler (8.0.2):
    - GoogleUtilities/Environment
    - GoogleUtilities/Logger
    - GoogleUtilities/Network
    - GoogleUtilities/Privacy
  - GoogleUtilities/Environment (8.0.2):
    - GoogleUtilities/Privacy
  - GoogleUtilities/Logger (8.0.2):
    - GoogleUtilities/Environment
    - GoogleUtilities/Privacy
  - GoogleUtilities/Network (8.0.2):
    - GoogleUtilities/Logger
    - "GoogleUtilities/NSData+zlib"
    - GoogleUtilities/Privacy
    - GoogleUtilities/Reachability
  - "GoogleUtilities/NSData+zlib (8.0.2)":
    - GoogleUtilities/Privacy
  - GoogleUtilities/Privacy (8.0.2)
  - GoogleUtilities/Reachability (8.0.2):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - GoogleUtilities/UserDefaults (8.0.2):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - image_picker_ios (0.0.1):
    - Flutter
  - leveldb-library (1.22.6)
  - libwebp (1.3.2):
    - libwebp/demux (= 1.3.2)
    - libwebp/mux (= 1.3.2)
    - libwebp/sharpyuv (= 1.3.2)
    - libwebp/webp (= 1.3.2)
  - libwebp/demux (1.3.2):
    - libwebp/webp
  - libwebp/mux (1.3.2):
    - libwebp/demux
  - libwebp/sharpyuv (1.3.2)
  - libwebp/webp (1.3.2):
    - libwebp/sharpyuv
  - media_kit_libs_ios_video (1.0.4):
    - Flutter
  - media_kit_native_event_loop (1.0.0):
    - Flutter
  - media_kit_video (0.0.1):
    - Flutter
  - nanopb (3.30910.0):
    - nanopb/decode (= 3.30910.0)
    - nanopb/encode (= 3.30910.0)
  - nanopb/decode (3.30910.0)
  - nanopb/encode (3.30910.0)
  - open_file_ios (0.0.1):
    - Flutter
  - package_info_plus (0.4.5):
    - Flutter
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - pdf_render (0.0.1):
    - Flutter
  - permission_handler_apple (9.3.0):
    - Flutter
  - PromisesObjC (2.4.0)
  - screen_brightness_ios (0.1.0):
    - Flutter
  - SDWebImage (5.20.0):
    - SDWebImage/Core (= 5.20.0)
  - SDWebImage/Core (5.20.0)
  - shared_preferences_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - sqflite (0.0.3):
    - Flutter
    - FlutterMacOS
  - SwiftyGif (5.4.5)
  - url_launcher_ios (0.0.1):
    - Flutter
  - video_thumbnail (0.0.1):
    - Flutter
    - libwebp
  - volume_controller (0.0.1):
    - Flutter
  - wakelock_plus (0.0.1):
    - Flutter

DEPENDENCIES:
  - connectivity_plus (from `.symlinks/plugins/connectivity_plus/darwin`)
  - device_info_plus (from `.symlinks/plugins/device_info_plus/ios`)
  - emoji_picker_flutter (from `.symlinks/plugins/emoji_picker_flutter/ios`)
  - file_picker (from `.symlinks/plugins/file_picker/ios`)
  - firebase_core (from `.symlinks/plugins/firebase_core/ios`)
  - firebase_database (from `.symlinks/plugins/firebase_database/ios`)
  - firebase_messaging (from `.symlinks/plugins/firebase_messaging/ios`)
  - Flutter (from `Flutter`)
  - flutter_sound (from `.symlinks/plugins/flutter_sound/ios`)
  - image_picker_ios (from `.symlinks/plugins/image_picker_ios/ios`)
  - media_kit_libs_ios_video (from `.symlinks/plugins/media_kit_libs_ios_video/ios`)
  - media_kit_native_event_loop (from `.symlinks/plugins/media_kit_native_event_loop/ios`)
  - media_kit_video (from `.symlinks/plugins/media_kit_video/ios`)
  - open_file_ios (from `.symlinks/plugins/open_file_ios/ios`)
  - package_info_plus (from `.symlinks/plugins/package_info_plus/ios`)
  - path_provider_foundation (from `.symlinks/plugins/path_provider_foundation/darwin`)
  - pdf_render (from `.symlinks/plugins/pdf_render/ios`)
  - permission_handler_apple (from `.symlinks/plugins/permission_handler_apple/ios`)
  - screen_brightness_ios (from `.symlinks/plugins/screen_brightness_ios/ios`)
  - shared_preferences_foundation (from `.symlinks/plugins/shared_preferences_foundation/darwin`)
  - sqflite (from `.symlinks/plugins/sqflite/darwin`)
  - url_launcher_ios (from `.symlinks/plugins/url_launcher_ios/ios`)
  - video_thumbnail (from `.symlinks/plugins/video_thumbnail/ios`)
  - volume_controller (from `.symlinks/plugins/volume_controller/ios`)
  - wakelock_plus (from `.symlinks/plugins/wakelock_plus/ios`)

SPEC REPOS:
  trunk:
    - DKImagePickerController
    - DKPhotoGallery
    - Firebase
    - FirebaseAppCheckInterop
    - FirebaseCore
    - FirebaseCoreInternal
    - FirebaseDatabase
    - FirebaseInstallations
    - FirebaseMessaging
    - FirebaseSharedSwift
    - flutter_sound_core
    - GoogleDataTransport
    - GoogleUtilities
    - leveldb-library
    - libwebp
    - nanopb
    - PromisesObjC
    - SDWebImage
    - SwiftyGif

EXTERNAL SOURCES:
  connectivity_plus:
    :path: ".symlinks/plugins/connectivity_plus/darwin"
  device_info_plus:
    :path: ".symlinks/plugins/device_info_plus/ios"
  emoji_picker_flutter:
    :path: ".symlinks/plugins/emoji_picker_flutter/ios"
  file_picker:
    :path: ".symlinks/plugins/file_picker/ios"
  firebase_core:
    :path: ".symlinks/plugins/firebase_core/ios"
  firebase_database:
    :path: ".symlinks/plugins/firebase_database/ios"
  firebase_messaging:
    :path: ".symlinks/plugins/firebase_messaging/ios"
  Flutter:
    :path: Flutter
  flutter_sound:
    :path: ".symlinks/plugins/flutter_sound/ios"
  image_picker_ios:
    :path: ".symlinks/plugins/image_picker_ios/ios"
  media_kit_libs_ios_video:
    :path: ".symlinks/plugins/media_kit_libs_ios_video/ios"
  media_kit_native_event_loop:
    :path: ".symlinks/plugins/media_kit_native_event_loop/ios"
  media_kit_video:
    :path: ".symlinks/plugins/media_kit_video/ios"
  open_file_ios:
    :path: ".symlinks/plugins/open_file_ios/ios"
  package_info_plus:
    :path: ".symlinks/plugins/package_info_plus/ios"
  path_provider_foundation:
    :path: ".symlinks/plugins/path_provider_foundation/darwin"
  pdf_render:
    :path: ".symlinks/plugins/pdf_render/ios"
  permission_handler_apple:
    :path: ".symlinks/plugins/permission_handler_apple/ios"
  screen_brightness_ios:
    :path: ".symlinks/plugins/screen_brightness_ios/ios"
  shared_preferences_foundation:
    :path: ".symlinks/plugins/shared_preferences_foundation/darwin"
  sqflite:
    :path: ".symlinks/plugins/sqflite/darwin"
  url_launcher_ios:
    :path: ".symlinks/plugins/url_launcher_ios/ios"
  video_thumbnail:
    :path: ".symlinks/plugins/video_thumbnail/ios"
  volume_controller:
    :path: ".symlinks/plugins/volume_controller/ios"
  wakelock_plus:
    :path: ".symlinks/plugins/wakelock_plus/ios"

SPEC CHECKSUMS:
  connectivity_plus: ddd7f30999e1faaef5967c23d5b6d503d10434db
  device_info_plus: 97af1d7e84681a90d0693e63169a5d50e0839a0d
  DKImagePickerController: 946cec48c7873164274ecc4624d19e3da4c1ef3c
  DKPhotoGallery: b3834fecb755ee09a593d7c9e389d8b5d6deed60
  emoji_picker_flutter: fe2e6151c5b548e975d546e6eeb567daf0962a58
  file_picker: 09aa5ec1ab24135ccd7a1621c46c84134bfd6655
  Firebase: 98e6bf5278170668a7983e12971a66b2cd57fc8c
  firebase_core: 2bedc3136ec7c7b8561c6123ed0239387b53f2af
  firebase_database: d52bf1a2e0542f565925feed43fa5c4350576ed7
  firebase_messaging: 15d114e1a41fc31e4fbabcd48d765a19eec94a38
  FirebaseAppCheckInterop: 347aa09a805219a31249b58fc956888e9fcb314b
  FirebaseCore: a282032ae9295c795714ded2ec9c522fc237f8da
  FirebaseCoreInternal: d98ab91e2d80a56d7b246856a8885443b302c0c2
  FirebaseDatabase: 7f0bcea9a7c0554284019a6bac1d80e7288ee831
  FirebaseInstallations: 6ef4a1c7eb2a61ee1f74727d7f6ce2e72acf1414
  FirebaseMessaging: c9ec7b90c399c7a6100297e9d16f8a27fc7f7152
  FirebaseSharedSwift: a4e5dfca3e210633bb3a3dfb94176c019211948b
  Flutter: e0871f40cf51350855a761d2e70bf5af5b9b5de7
  flutter_sound: d9c7b35b2f19366439a74695d190d9a504a6b4fe
  flutter_sound_core: 2c5d7e93183845b53a776d99c4d6ebc2933ec495
  GoogleDataTransport: aae35b7ea0c09004c3797d53c8c41f66f219d6a7
  GoogleUtilities: 26a3abef001b6533cf678d3eb38fd3f614b7872d
  image_picker_ios: c560581cceedb403a6ff17f2f816d7fea1421fc1
  leveldb-library: cc8b8f8e013647a295ad3f8cd2ddf49a6f19be19
  libwebp: 1786c9f4ff8a279e4dac1e8f385004d5fc253009
  media_kit_libs_ios_video: a5fe24bc7875ccd6378a0978c13185e1344651c1
  media_kit_native_event_loop: e6b2ab20cf0746eb1c33be961fcf79667304fa2a
  media_kit_video: 5da63f157170e5bf303bf85453b7ef6971218a2e
  nanopb: fad817b59e0457d11a5dfbde799381cd727c1275
  open_file_ios: 461db5853723763573e140de3193656f91990d9e
  package_info_plus: 58f0028419748fad15bf008b270aaa8e54380b1c
  path_provider_foundation: 2b6b4c569c0fb62ec74538f866245ac84301af46
  pdf_render: 0b4e1a615aab83ce88b26c57753049424908a755
  permission_handler_apple: 9878588469a2b0d0fc1e048d9f43605f92e6cec2
  PromisesObjC: f5707f49cb48b9636751c5b2e7d227e43fba9f47
  screen_brightness_ios: 715ca807df953bf676d339f11464e438143ee625
  SDWebImage: 73c6079366fea25fa4bb9640d5fb58f0893facd8
  shared_preferences_foundation: fcdcbc04712aee1108ac7fda236f363274528f78
  sqflite: 673a0e54cc04b7d6dba8d24fb8095b31c3a99eec
  SwiftyGif: 706c60cf65fa2bc5ee0313beece843c8eb8194d4
  url_launcher_ios: 5334b05cef931de560670eeae103fd3e431ac3fe
  video_thumbnail: c4e2a3c539e247d4de13cd545344fd2d26ffafd1
  volume_controller: 531ddf792994285c9b17f9d8a7e4dcdd29b3eae9
  wakelock_plus: 78ec7c5b202cab7761af8e2b2b3d0671be6c4ae1

PODFILE CHECKSUM: 8c43c61cb6731d05142f58993481d3c29edf778d

COCOAPODS: 1.16.2



================================================
File: example/ios/.gitignore
================================================
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3



================================================
File: example/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>



================================================
File: example/ios/Flutter/Debug.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "Generated.xcconfig"



================================================
File: example/ios/Flutter/Release.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "Generated.xcconfig"



================================================
File: example/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}



================================================
File: example/ios/Runner/GoogleService-Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>API_KEY</key>
	<string>AIzaSyAVmbe-8jgnO2MUnFotMdp2tmDVnwTZqfE</string>
	<key>GCM_SENDER_ID</key>
	<string>317419981427</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.likeminds.chat.flutter.sample</string>
	<key>PROJECT_ID</key>
	<string>likeminds-sdk-app</string>
	<key>STORAGE_BUCKET</key>
	<string>likeminds-sdk-app.appspot.com</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:317419981427:ios:5c2e7053ed57f4b2d2f806</string>
</dict>
</plist>


================================================
File: example/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>LM Chat Sample</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>chat.flutter.sample</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
		<key>NSAllowsArbitraryLoadsForMedia</key>
		<true/>
		<key>NSAllowsLocalNetworking</key>
		<true/>
		<key>NSExceptionAllowsInsecureHTTPLoads</key>
		<true/>
	</dict>
	<key>NSCameraUsageDescription</key>
	<string>We require camera access to take pictures for uploading</string>
	<key>NSMicrophoneUsageDescription</key>
	<string>This app needs access to microphone for voice messages</string>
	<key>NSPhotoLibraryUsageDescription</key>
	<string>We require access to your photo library to upload files</string>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	<key>UIBackgroundModes</key>
	<array>
		<string>fetch</string>
		<string>remote-notification</string>
		<string>processing</string>
		<string>audio</string>
	</array>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>NSDocumentsFolderUsageDescription</key>
	<string>This app needs access to documents for saving voice messages</string>
</dict>
</plist>



================================================
File: example/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
File: example/ios/Runner/Runner.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>aps-environment</key>
	<string>development</string>
</dict>
</plist>



================================================
File: example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
File: example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
File: example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
File: example/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
File: example/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
File: example/ios/Runner.xcodeproj/project.pbxproj
================================================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		0313D7206C3F0A6876FF6CE4 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D33703E871BBA32F70572A0B /* Pods_Runner.framework */; };
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		861B1E310E3A0835D100F3CA /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 64E0FA2E96E66DD82F9AEDEC /* Pods_RunnerTests.framework */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		1FBB9C906CE773B5A7950C83 /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
		2FC15ADA2CB53EE300769480 /* Runner.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = Runner.entitlements; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		5A87D13B5A971AC704F7DD82 /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		62440458D27A45A0E5A7E265 /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
		64E0FA2E96E66DD82F9AEDEC /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		98702AB99F1D6B926E2AC9D6 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
		AA2CE819CAB0CBAFC2AF6F43 /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		D33703E871BBA32F70572A0B /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		DA31BCE5BC4F47045F7D8DCC /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		627A3C360DEF74EA8F45C14D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				861B1E310E3A0835D100F3CA /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				0313D7206C3F0A6876FF6CE4 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		50B1A9F096EEC9D9B8409D93 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				D33703E871BBA32F70572A0B /* Pods_Runner.framework */,
				64E0FA2E96E66DD82F9AEDEC /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
				F61BB9A18A046264D84889AD /* Pods */,
				50B1A9F096EEC9D9B8409D93 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				2FC15ADA2CB53EE300769480 /* Runner.entitlements */,
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		F61BB9A18A046264D84889AD /* Pods */ = {
			isa = PBXGroup;
			children = (
				98702AB99F1D6B926E2AC9D6 /* Pods-Runner.debug.xcconfig */,
				62440458D27A45A0E5A7E265 /* Pods-Runner.release.xcconfig */,
				1FBB9C906CE773B5A7950C83 /* Pods-Runner.profile.xcconfig */,
				AA2CE819CAB0CBAFC2AF6F43 /* Pods-RunnerTests.debug.xcconfig */,
				5A87D13B5A971AC704F7DD82 /* Pods-RunnerTests.release.xcconfig */,
				DA31BCE5BC4F47045F7D8DCC /* Pods-RunnerTests.profile.xcconfig */,
			);
			path = Pods;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				D74F4137A0E11627772732EA /* [CP] Check Pods Manifest.lock */,
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
				627A3C360DEF74EA8F45C14D /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				323D8D09726C685B4E878F31 /* [CP] Check Pods Manifest.lock */,
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
				3D6398ABF7227710EACD90E2 /* [CP] Embed Pods Frameworks */,
				F0ECD5C6B443E4126E7C7DF2 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		323D8D09726C685B4E878F31 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		3D6398ABF7227710EACD90E2 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Embed Pods Frameworks";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
		D74F4137A0E11627772732EA /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		F0ECD5C6B443E4126E7C7DF2 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES = YES;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Runner.entitlements;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = HPC929F5X6;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = AA2CE819CAB0CBAFC2AF6F43 /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 5A87D13B5A971AC704F7DD82 /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = DA31BCE5BC4F47045F7D8DCC /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES = YES;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Runner.entitlements;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = HPC929F5X6;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES = YES;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Runner.entitlements;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = HPC929F5X6;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}



================================================
File: example/ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>



================================================
File: example/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: example/ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>



================================================
File: example/ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
File: example/ios/Runner.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>



================================================
File: example/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
File: example/lib/app.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_sample/onboarding/cred_screen.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:likeminds_chat_flutter_sample/main.dart';

class LMChatSampleApp extends StatelessWidget {
  const LMChatSampleApp({super.key});

  @override
  Widget build(BuildContext context) {
    return OverlaySupport.global(
      toastTheme: ToastThemeData(
        background: Colors.black.withOpacity(0.6),
        textColor: Colors.white,
      ),
      child: MaterialApp(
        navigatorKey: rootNavigatorKey,
        title: 'Chat App for UI + SDK package',
        debugShowCheckedModeBanner: isDebug,
        scaffoldMessengerKey: rootScaffoldMessengerKey,
        theme: ThemeData.from(
          colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        ),
        home: const CredScreen(),
      ),
    );
  }
}



================================================
File: example/lib/main.dart
================================================
import 'dart:io';

import 'package:device_info_plus/device_info_plus.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_sample/app.dart';
import 'package:likeminds_chat_flutter_sample/utils/firebase_options.dart';

/// Flutter flavour/environment manager v0.0.1
const isDebug = bool.fromEnvironment('LM_DEBUG_ENV');

/// A global key that provides access to the ScaffoldMessengerState.
///
/// This key can be used to show SnackBars or other material banners
/// from anywhere in the app. It is typically used in conjunction with
/// the `ScaffoldMessenger` widget to display messages to the user.
///
/// Example usage:
///
/// ```dart
/// rootScaffoldMessenger.currentState?.showSnackBar(
///   SnackBar(content: Text('Hello, world!')),
/// );
/// ```
///
/// Ensure that the `ScaffoldMessenger` widget is properly initialized
/// in your widget tree, typically at the root of your app.
final GlobalKey<ScaffoldMessengerState> rootScaffoldMessengerKey =
    GlobalKey<ScaffoldMessengerState>();

/// A global key used to access the root navigator of the application.
///
/// This key can be used to perform navigation operations such as pushing
/// new routes or popping the current route from anywhere in the app.
///
/// Example usage:
///
/// ```dart
/// // Push a new route
/// rootNavigatorKey.currentState?.push(MaterialPageRoute(builder: (context) => NewPage()));
///
/// // Pop the current route
/// rootNavigatorKey.currentState?.pop();
/// ```
///
/// Ensure that this key is assigned to the `navigatorKey` property of the
/// `MaterialApp` or `CupertinoApp` widget.
final GlobalKey<NavigatorState> rootNavigatorKey = GlobalKey<NavigatorState>();

/// First level notification handler
/// Essential to declare it outside of any class or function as per Firebase docs
/// Call [LMChatNotificationHandler.instance.handleNotification] in this function
/// to handle notifications at the second level (inside the app)
/// Make sure to call [setupNotifications] before this function
@pragma('vm:entry-point')
Future<void> _handleNotification(RemoteMessage message) async {
  debugPrint("--- Notification received in LEVEL 1 ---");
  await LMChatNotificationHandler.instance
      .handleBackgroundNotification(message);
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  setupNotifications();
  await LMChatCore.instance.initialize(
    excludedConversationStates: [
      ConversationState.memberJoinedOpenChatroom,
      ConversationState.memberLeftOpenChatroom,
      ConversationState.memberLeftSecretChatroom,
      ConversationState.memberAddedToChatroom,
    ],
  );
  runApp(const LMChatSampleApp());
}

/// Setup notifications
/// 1. Initialize Firebase
/// 2. Get device id - [deviceId]
/// 3. Get FCM token - [setupMessaging]
/// 4. Register device with LM - [LMChatNotificationHandler]
/// 5. Listen for FG and BG notifications
/// 6. Handle notifications - [_handleNotification]
void setupNotifications() async {
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  final devId = await deviceId();
  final fcmToken = await setupMessaging();
  if (fcmToken == null) {
    debugPrint("FCM token is null or permission declined");
    return;
  }
  // Register device with LM, and listen for notifications
  LMChatNotificationHandler.instance.init(deviceId: devId, fcmToken: fcmToken);
  FirebaseMessaging.onBackgroundMessage(_handleNotification);
  FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) async {
    debugPrint("---The app is opened from a notification---");
    await LMChatNotificationHandler.instance
        .handleNotification(message, false, rootNavigatorKey);
  });
  FirebaseMessaging.instance.getInitialMessage().then(
    (RemoteMessage? message) async {
      if (message != null) {
        debugPrint("---The terminated app is opened from a notification---");
        await LMChatNotificationHandler.instance
            .handleNotification(message, false, rootNavigatorKey);
      }
    },
  );
}

/// Get device id
/// 1. Get device info
/// 2. Get device id
/// 3. Return device id
Future<String> deviceId() async {
  final deviceInfo = await DeviceInfoPlugin().deviceInfo;
  final deviceId =
      deviceInfo.data["identifierForVendor"] ?? deviceInfo.data["id"];
  debugPrint("Device id - $deviceId");
  return deviceId.toString();
}

/// Setup Firebase messaging on your app
/// The UI package needs your Firebase instance to be initialized
/// 1. Get messaging instance
/// 2. Get FCM token
/// 3. Request permission
/// 4. Return FCM token
Future<String?> setupMessaging() async {
  final messaging = FirebaseMessaging.instance;
  messaging.setForegroundNotificationPresentationOptions(
    // alert: true,
    badge: true,
    sound: true,
  );
  await messaging.requestPermission(
    alert: true,
    announcement: false,
    badge: true,
    carPlay: false,
    criticalAlert: true,
    provisional: false,
    sound: true,
  );
  if (Platform.isIOS) {
    messaging.getAPNSToken();
  }
  final token = await messaging.getToken();
  debugPrint("Token - $token");
  return token.toString();
}



================================================
File: example/lib/onboarding/cred_screen.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_sample/utils/network_handling.dart';

/// The credentials screen for the app.
class CredScreen extends StatefulWidget {
  /// Constructor for the CredScreen
  const CredScreen({super.key});

  @override
  State<CredScreen> createState() => _CredScreenState();
}

class _CredScreenState extends State<CredScreen> {
  final TextEditingController _usernameController = TextEditingController();
  final TextEditingController _userIdController = TextEditingController();
  final TextEditingController _apiKeyController = TextEditingController();
  bool isDarkMode = false;

  ButtonStyle get buttonStyle => ElevatedButton.styleFrom(
        backgroundColor: isDarkMode ? Colors.grey[800] : Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        fixedSize: const Size(
          200,
          42,
        ),
      );

  TextStyle get buttonTextStyle => TextStyle(
        color: isDarkMode ? Colors.white : Theme.of(context).primaryColor,
        fontSize: 18,
        fontWeight: FontWeight.bold,
      );

  Color get backgroundColor =>
      isDarkMode ? Colors.grey[900]! : Theme.of(context).primaryColor;

  Color get textColor => isDarkMode ? Colors.white : Colors.white;

  Color get textFieldBorderColor =>
      isDarkMode ? Colors.grey[700]! : Colors.white;

  @override
  void initState() {
    super.initState();
    NetworkConnectivity networkConnectivity = NetworkConnectivity.instance;
    networkConnectivity.initialise();
    _setTextFieldData();
  }

  @override
  void dispose() {
    _usernameController.dispose();
    _userIdController.dispose();
    _apiKeyController.dispose();
    super.dispose();
  }

  void _setTextFieldData() {
    User? user = LMChatCore.instance.lmChatClient.getLoggedInUser().data;
    String? apiKey = LMChatLocalPreference.instance
        .fetchCache(LMChatStringConstants.apiKey)
        ?.value as String?;
    if (user != null) {
      _usernameController.text = user.name;
      _userIdController.text = user.sdkClientInfo?.uuid ?? "";
    }
    if (apiKey != null) {
      _apiKeyController.text = apiKey;
    }
  }

  void _clearTextFieldData() {
    _usernameController.clear();
    _userIdController.clear();
    _apiKeyController.clear();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      resizeToAvoidBottomInset: true,
      backgroundColor: backgroundColor,
      appBar: AppBar(
        backgroundColor: backgroundColor,
        elevation: 0,
        centerTitle: false,
        title: Text(
          "LMChat Flutter Showcase",
          textAlign: TextAlign.center,
          style: TextStyle(
            color: textColor,
            fontSize: 18,
            fontWeight: FontWeight.bold,
          ),
        ),
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: Row(
              children: [
                Icon(
                  isDarkMode ? Icons.dark_mode : Icons.light_mode,
                  color: textColor,
                ),
                const SizedBox(width: 8),
                Switch(
                  value: isDarkMode,
                  onChanged: (value) {
                    setState(() {
                      isDarkMode = value;
                    });
                    LMChatTheme.setTheme(
                      isDarkMode
                          ? LMChatThemeData.dark()
                          : LMChatThemeData.light(),
                    );
                  },
                  activeColor: Colors.grey[800],
                  activeTrackColor: Colors.grey[600],
                ),
              ],
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 18.0),
        child: SingleChildScrollView(
          child: Column(
            children: [
              const SizedBox(height: 48),
              Text(
                "Enter your credentials",
                style: TextStyle(
                  color: textColor,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 18),
              TextField(
                cursorColor: textColor,
                controller: _apiKeyController,
                style: TextStyle(color: textColor),
                decoration: InputDecoration(
                  fillColor: textColor,
                  focusColor: textColor,
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: textFieldBorderColor),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: textFieldBorderColor),
                  ),
                  labelText: 'API Key',
                  labelStyle: TextStyle(
                    color: textColor,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              TextField(
                cursorColor: textColor,
                style: TextStyle(color: textColor),
                controller: _usernameController,
                decoration: InputDecoration(
                  fillColor: textColor,
                  focusColor: textColor,
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: textFieldBorderColor),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: textFieldBorderColor),
                  ),
                  labelText: 'Username',
                  labelStyle: TextStyle(
                    color: textColor,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              TextField(
                cursorColor: textColor,
                controller: _userIdController,
                style: TextStyle(color: textColor),
                decoration: InputDecoration(
                  fillColor: textColor,
                  focusColor: textColor,
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: textFieldBorderColor),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: textFieldBorderColor),
                  ),
                  labelText: 'User ID',
                  labelStyle: TextStyle(
                    color: textColor,
                  ),
                ),
              ),
              const SizedBox(height: 48),
              Text(
                "If no credentials are provided, the app will run with the default credentials.",
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: textColor,
                  fontSize: 16,
                ),
              ),
              const SizedBox(height: 72),
              ElevatedButton(
                style: buttonStyle,
                onPressed: _onSubmit,
                child: Text(
                  "Submit",
                  style: buttonTextStyle,
                ),
              ),
              const SizedBox(height: 20),
              ElevatedButton(
                style: buttonStyle,
                onPressed: () async {
                  await LMChatLocalPreference.instance.clearLocalData();
                  _clearTextFieldData();
                  setState(() {});
                },
                child: Text(
                  "Clear Data",
                  style: buttonTextStyle,
                ),
              ),
              const SizedBox(height: 18),
              LMChatAIButton(
                style: LMChatAIButtonStyle.basic().copyWith(
                  backgroundColor: isDarkMode ? Colors.grey[800] : Colors.white,
                  textColor: isDarkMode ? Colors.white : backgroundColor,
                  borderRadius: 12,
                ),
                props: LMChatAIButtonProps(
                  uuid: _userIdController.text,
                  userName: _usernameController.text,
                  apiKey: _apiKeyController.text,
                ),
              ),
              const SizedBox(height: 80),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _onSubmit() async {
    String apiKey = _apiKeyController.text;
    String username = _usernameController.text;
    String userId = _userIdController.text;
    if (apiKey.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Please enter the API Key"),
        ),
      );
      return;
    }
    if (userId.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("Please enter the User ID"),
        ),
      );
    } else {
      final response = await LMChatCore.instance.showChatWithApiKey(
        apiKey: apiKey,
        uuid: userId,
        userName: username,
      );
      if (response.success) {
        MaterialPageRoute route = MaterialPageRoute(
          builder: (context) => const LMChatHomeScreen(
              // chatroomType: LMChatroomType.dm,
              ),
        );
        Navigator.push(context, route);
      } else {
        toast(response.errorMessage ?? "An error occurred");
      }
    }
  }
}



================================================
File: example/lib/storybook/storybook.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

class StoryBookApp extends StatefulWidget {
  const StoryBookApp({super.key});

  @override
  State<StoryBookApp> createState() => _StoryBookAppState();
}

class _StoryBookAppState extends State<StoryBookApp> {
  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: StoryBookPage(),
    );
  }
}

class StoryBookPage extends StatefulWidget {
  const StoryBookPage({super.key});

  @override
  State<StoryBookPage> createState() => _StoryBookPageState();
}

class _StoryBookPageState extends State<StoryBookPage> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: iconStory(),
      ),
    );
  }
}

LMChatText textStory() {
  return const LMChatText(
    'Hello, World!',
    style: LMChatTextStyle(
      textStyle: TextStyle(
        fontSize: 18,
        fontWeight: FontWeight.bold,
      ),
    ),
  );
}

LMChatIcon iconStory() {
  return const LMChatIcon(
    type: LMChatIconType.icon,
    icon: Icons.access_alarm,
    style: LMChatIconStyle(
      size: 48,
      boxSize: 48,
      color: Colors.red,
      backgroundColor: Colors.green,
    ),
  );
}



================================================
File: example/lib/utils/example_callback.dart
================================================
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';

/// ExampleCallback represents the callback to be implemented
/// on the customer's end to extend [LMChatSDKCallback]
class ExampleCallback extends LMChatSDKCallback {
  @override
  // A function that handles the event fired callback with the specified event key and properties map.
  void eventFiredCallback(String eventKey, Map<String, dynamic> propertiesMap) {
    debugPrint("EXAMPLE: eventFiredCallback: $eventKey, $propertiesMap");
  }

  @override
  // A function that indicates a login is required.
  void loginRequiredCallback() {
    debugPrint("EXAMPLE: loginRequiredCallback");
  }

  @override
  // A function that handles the logout callback.
  void logoutCallback() {
    debugPrint("EXAMPLE: logoutCallback");
  }

  @override
  // A function that handles the routing of profile callback.
  void profileRouteCallback({required String lmUserId}) {
    debugPrint("LM User ID caught in callback : $lmUserId");
  }

  @override
  // A function that handles access token expired and refreshed callback.
  void onAccessTokenExpiredAndRefreshed(
      String accessToken, String refreshToken) {
    debugPrint(
      "New access token: $accessToken, New refresh token: $refreshToken",
    );
  }

  @override
  // A function that handles expiry of refresh token callback.
  Future<LMAuthToken> onRefreshTokenExpired() {
    // TODO: implement onRefreshTokenExpired
    throw UnimplementedError();
  }
}



================================================
File: example/lib/utils/firebase_options.dart
================================================
// File generated by FlutterFire CLI.
// ignore_for_file: lines_longer_than_80_chars, avoid_classes_with_only_static_members
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyBoKIOckkZHY6MmBrEE59LtKpzeSglt53Y',
    appId: '1:317419981427:web:066d353b2223357cd2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    authDomain: 'likeminds-sdk-app.firebaseapp.com',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    measurementId: 'G-VDC4M3W7W5',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCp2HimWufInSMnLc7ndFBEpeSDTj7Fxsw',
    appId: '1:317419981427:android:383c84d581bad91bd2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    storageBucket: 'likeminds-sdk-app.appspot.com',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyAVmbe-8jgnO2MUnFotMdp2tmDVnwTZqfE',
    appId: '1:317419981427:ios:5c2e7053ed57f4b2d2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    iosBundleId: 'com.likeminds.chat.flutter.sample',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyAVmbe-8jgnO2MUnFotMdp2tmDVnwTZqfE',
    appId: '1:317419981427:ios:5c2e7053ed57f4b2d2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    iosBundleId: 'com.likeminds.chat.flutter.sample',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyBoKIOckkZHY6MmBrEE59LtKpzeSglt53Y',
    appId: '1:317419981427:web:4437716c13e11f97d2f806',
    messagingSenderId: '317419981427',
    projectId: 'likeminds-sdk-app',
    authDomain: 'likeminds-sdk-app.firebaseapp.com',
    storageBucket: 'likeminds-sdk-app.appspot.com',
    measurementId: 'G-597NEX8YCE',
  );

}


================================================
File: example/lib/utils/mock_intiate_user.dart
================================================
import 'package:dio/dio.dart';
import 'package:flutter/material.dart';

/// Mock function to initiate user
Future<(String, String)> mockInitiateUser({
  required String apiKey,
  required String userName,
  required String userId,
}) async {
  String host = "https://betaauth.likeminds.community";
  final dio = Dio();
  try {
    final Response response = await dio.post(
      options: Options(
        headers: {
          'x-api-key': apiKey,
        },
      ),
      "$host/sdk/initiate",
      data: {
        'user_name': userName,
        'user_unique_id': userId,
        "token_expiry_beta": 1,
        "rtm_token_expiry_beta": 2
      },
    );
    if (response.data['success'] && response.data['data'] != null) {
      return (
        response.data['data']['access_token'] as String,
        response.data['data']['refresh_token'] as String
      );
    }

    throw Exception("Failed to initiate user");
  } on DioException catch (e) {
    debugPrint("Error: ${e.message}");
    throw Exception("Failed to initiate user");
  } finally {
    dio.close();
  }
}



================================================
File: example/lib/utils/network_handling.dart
================================================
import 'dart:async';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_sample/main.dart';

class NetworkConnectivity {
  NetworkConnectivity._();
  static final _instance = NetworkConnectivity._();
  static NetworkConnectivity get instance => _instance;
  final _networkConnectivity = Connectivity();
  final _controller = StreamController.broadcast();

  void initialise() async {
    _networkConnectivity.onConnectivityChanged.listen((result) {
      if (result.contains(ConnectivityResult.mobile) ||
          result.contains(ConnectivityResult.wifi)) {
        rootScaffoldMessengerKey.currentState?.clearSnackBars();
      } else {
        rootScaffoldMessengerKey.currentState?.showSnackBar(
          confirmationToast(
            content: "No internet\nCheck your connection and try again",
            backgroundColor: const Color.fromARGB(255, 108, 108, 108),
          ),
        );
      }
    });
  }

  void disposeStream() => _controller.close();
}

SnackBar confirmationToast(
    {required String content, required Color backgroundColor}) {
  return SnackBar(
    showCloseIcon: true,
    duration: const Duration(days: 1),
    backgroundColor: backgroundColor,
    elevation: 5,
    behavior: SnackBarBehavior.floating,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(5.0)),
    content: Align(
      alignment: Alignment.center,
      child: Text(
        content,
        textAlign: TextAlign.left,
      ),
    ),
  );
}



================================================
File: example/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.10)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "likeminds_chat_flutter_sample")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.likeminds.chat.flutter.sample")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Define the application target. To change its name, change BINARY_NAME above,
# not the value here, or `flutter run` will no longer work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
File: example/linux/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
File: example/linux/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "likeminds_chat_flutter_sample");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "likeminds_chat_flutter_sample");
  }

  gtk_window_set_default_size(window, 1280, 720);
  gtk_widget_show(GTK_WIDGET(window));

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}



================================================
File: example/linux/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
File: example/linux/.gitignore
================================================
flutter/ephemeral



================================================
File: example/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
File: example/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <emoji_picker_flutter/emoji_picker_flutter_plugin.h>
#include <file_selector_linux/file_selector_plugin.h>
#include <media_kit_libs_linux/media_kit_libs_linux_plugin.h>
#include <media_kit_video/media_kit_video_plugin.h>
#include <open_file_linux/open_file_linux_plugin.h>
#include <url_launcher_linux/url_launcher_plugin.h>

void fl_register_plugins(FlPluginRegistry* registry) {
  g_autoptr(FlPluginRegistrar) emoji_picker_flutter_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "EmojiPickerFlutterPlugin");
  emoji_picker_flutter_plugin_register_with_registrar(emoji_picker_flutter_registrar);
  g_autoptr(FlPluginRegistrar) file_selector_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "FileSelectorPlugin");
  file_selector_plugin_register_with_registrar(file_selector_linux_registrar);
  g_autoptr(FlPluginRegistrar) media_kit_libs_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "MediaKitLibsLinuxPlugin");
  media_kit_libs_linux_plugin_register_with_registrar(media_kit_libs_linux_registrar);
  g_autoptr(FlPluginRegistrar) media_kit_video_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "MediaKitVideoPlugin");
  media_kit_video_plugin_register_with_registrar(media_kit_video_registrar);
  g_autoptr(FlPluginRegistrar) open_file_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "OpenFileLinuxPlugin");
  open_file_linux_plugin_register_with_registrar(open_file_linux_registrar);
  g_autoptr(FlPluginRegistrar) url_launcher_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "UrlLauncherPlugin");
  url_launcher_plugin_register_with_registrar(url_launcher_linux_registrar);
}



================================================
File: example/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
File: example/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  emoji_picker_flutter
  file_selector_linux
  media_kit_libs_linux
  media_kit_video
  open_file_linux
  url_launcher_linux
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
  media_kit_native_event_loop
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
File: example/macos/Podfile
================================================
platform :osx, '10.14'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'ephemeral', 'Flutter-Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure \"flutter pub get\" is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter-Generated.xcconfig, then run \"flutter pub get\""
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_macos_podfile_setup

target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_macos_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_macos_build_settings(target)
  end
end



================================================
File: example/macos/Podfile.lock
================================================
PODS:
  - connectivity_plus (0.0.1):
    - Flutter
    - FlutterMacOS
  - device_info_plus (0.0.1):
    - FlutterMacOS
  - file_selector_macos (0.0.1):
    - FlutterMacOS
  - Firebase/CoreOnly (10.25.0):
    - FirebaseCore (= 10.25.0)
  - Firebase/Database (10.25.0):
    - Firebase/CoreOnly
    - FirebaseDatabase (~> 10.25.0)
  - Firebase/Messaging (10.25.0):
    - Firebase/CoreOnly
    - FirebaseMessaging (~> 10.25.0)
  - firebase_core (2.31.0):
    - Firebase/CoreOnly (~> 10.25.0)
    - FlutterMacOS
  - firebase_database (10.5.5):
    - Firebase/CoreOnly (~> 10.25.0)
    - Firebase/Database (~> 10.25.0)
    - firebase_core
    - FlutterMacOS
  - firebase_messaging (14.9.2):
    - Firebase/CoreOnly (~> 10.25.0)
    - Firebase/Messaging (~> 10.25.0)
    - firebase_core
    - FlutterMacOS
  - FirebaseAppCheckInterop (10.25.0)
  - FirebaseCore (10.25.0):
    - FirebaseCoreInternal (~> 10.0)
    - GoogleUtilities/Environment (~> 7.12)
    - GoogleUtilities/Logger (~> 7.12)
  - FirebaseCoreInternal (10.25.0):
    - "GoogleUtilities/NSData+zlib (~> 7.8)"
  - FirebaseDatabase (10.25.0):
    - FirebaseAppCheckInterop (~> 10.17)
    - FirebaseCore (~> 10.0)
    - FirebaseSharedSwift (~> 10.0)
    - GoogleUtilities/UserDefaults (~> 7.13)
    - leveldb-library (~> 1.22)
  - FirebaseInstallations (10.25.0):
    - FirebaseCore (~> 10.0)
    - GoogleUtilities/Environment (~> 7.8)
    - GoogleUtilities/UserDefaults (~> 7.8)
    - PromisesObjC (~> 2.1)
  - FirebaseMessaging (10.25.0):
    - FirebaseCore (~> 10.0)
    - FirebaseInstallations (~> 10.0)
    - GoogleDataTransport (~> 9.3)
    - GoogleUtilities/AppDelegateSwizzler (~> 7.8)
    - GoogleUtilities/Environment (~> 7.8)
    - GoogleUtilities/Reachability (~> 7.8)
    - GoogleUtilities/UserDefaults (~> 7.8)
    - nanopb (< 2.30911.0, >= 2.30908.0)
  - FirebaseSharedSwift (10.25.0)
  - FlutterMacOS (1.0.0)
  - GoogleDataTransport (9.4.1):
    - GoogleUtilities/Environment (~> 7.7)
    - nanopb (< 2.30911.0, >= 2.30908.0)
    - PromisesObjC (< 3.0, >= 1.2)
  - GoogleUtilities/AppDelegateSwizzler (7.13.3):
    - GoogleUtilities/Environment
    - GoogleUtilities/Logger
    - GoogleUtilities/Network
    - GoogleUtilities/Privacy
  - GoogleUtilities/Environment (7.13.3):
    - GoogleUtilities/Privacy
    - PromisesObjC (< 3.0, >= 1.2)
  - GoogleUtilities/Logger (7.13.3):
    - GoogleUtilities/Environment
    - GoogleUtilities/Privacy
  - GoogleUtilities/Network (7.13.3):
    - GoogleUtilities/Logger
    - "GoogleUtilities/NSData+zlib"
    - GoogleUtilities/Privacy
    - GoogleUtilities/Reachability
  - "GoogleUtilities/NSData+zlib (7.13.3)":
    - GoogleUtilities/Privacy
  - GoogleUtilities/Privacy (7.13.3)
  - GoogleUtilities/Reachability (7.13.3):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - GoogleUtilities/UserDefaults (7.13.3):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - leveldb-library (1.22.5)
  - media_kit_video (0.0.1):
    - FlutterMacOS
  - nanopb (2.30910.0):
    - nanopb/decode (= 2.30910.0)
    - nanopb/encode (= 2.30910.0)
  - nanopb/decode (2.30910.0)
  - nanopb/encode (2.30910.0)
  - package_info_plus (0.0.1):
    - FlutterMacOS
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - pdf_render (0.0.1):
    - FlutterMacOS
  - PromisesObjC (2.4.0)
  - realm (2.2.1):
    - FlutterMacOS
  - screen_brightness_macos (0.1.0):
    - FlutterMacOS
  - shared_preferences_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - sqflite (0.0.3):
    - Flutter
    - FlutterMacOS
  - url_launcher_macos (0.0.1):
    - FlutterMacOS
  - wakelock_plus (0.0.1):
    - FlutterMacOS

DEPENDENCIES:
  - connectivity_plus (from `Flutter/ephemeral/.symlinks/plugins/connectivity_plus/darwin`)
  - device_info_plus (from `Flutter/ephemeral/.symlinks/plugins/device_info_plus/macos`)
  - file_selector_macos (from `Flutter/ephemeral/.symlinks/plugins/file_selector_macos/macos`)
  - firebase_core (from `Flutter/ephemeral/.symlinks/plugins/firebase_core/macos`)
  - firebase_database (from `Flutter/ephemeral/.symlinks/plugins/firebase_database/macos`)
  - firebase_messaging (from `Flutter/ephemeral/.symlinks/plugins/firebase_messaging/macos`)
  - FlutterMacOS (from `Flutter/ephemeral`)
  - media_kit_video (from `Flutter/ephemeral/.symlinks/plugins/media_kit_video/macos`)
  - package_info_plus (from `Flutter/ephemeral/.symlinks/plugins/package_info_plus/macos`)
  - path_provider_foundation (from `Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin`)
  - pdf_render (from `Flutter/ephemeral/.symlinks/plugins/pdf_render/macos`)
  - realm (from `Flutter/ephemeral/.symlinks/plugins/realm/macos`)
  - screen_brightness_macos (from `Flutter/ephemeral/.symlinks/plugins/screen_brightness_macos/macos`)
  - shared_preferences_foundation (from `Flutter/ephemeral/.symlinks/plugins/shared_preferences_foundation/darwin`)
  - sqflite (from `Flutter/ephemeral/.symlinks/plugins/sqflite/darwin`)
  - url_launcher_macos (from `Flutter/ephemeral/.symlinks/plugins/url_launcher_macos/macos`)
  - wakelock_plus (from `Flutter/ephemeral/.symlinks/plugins/wakelock_plus/macos`)

SPEC REPOS:
  trunk:
    - Firebase
    - FirebaseAppCheckInterop
    - FirebaseCore
    - FirebaseCoreInternal
    - FirebaseDatabase
    - FirebaseInstallations
    - FirebaseMessaging
    - FirebaseSharedSwift
    - GoogleDataTransport
    - GoogleUtilities
    - leveldb-library
    - nanopb
    - PromisesObjC

EXTERNAL SOURCES:
  connectivity_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/connectivity_plus/darwin
  device_info_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/device_info_plus/macos
  file_selector_macos:
    :path: Flutter/ephemeral/.symlinks/plugins/file_selector_macos/macos
  firebase_core:
    :path: Flutter/ephemeral/.symlinks/plugins/firebase_core/macos
  firebase_database:
    :path: Flutter/ephemeral/.symlinks/plugins/firebase_database/macos
  firebase_messaging:
    :path: Flutter/ephemeral/.symlinks/plugins/firebase_messaging/macos
  FlutterMacOS:
    :path: Flutter/ephemeral
  media_kit_video:
    :path: Flutter/ephemeral/.symlinks/plugins/media_kit_video/macos
  package_info_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/package_info_plus/macos
  path_provider_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin
  pdf_render:
    :path: Flutter/ephemeral/.symlinks/plugins/pdf_render/macos
  realm:
    :path: Flutter/ephemeral/.symlinks/plugins/realm/macos
  screen_brightness_macos:
    :path: Flutter/ephemeral/.symlinks/plugins/screen_brightness_macos/macos
  shared_preferences_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/shared_preferences_foundation/darwin
  sqflite:
    :path: Flutter/ephemeral/.symlinks/plugins/sqflite/darwin
  url_launcher_macos:
    :path: Flutter/ephemeral/.symlinks/plugins/url_launcher_macos/macos
  wakelock_plus:
    :path: Flutter/ephemeral/.symlinks/plugins/wakelock_plus/macos

SPEC CHECKSUMS:
  connectivity_plus: ddd7f30999e1faaef5967c23d5b6d503d10434db
  device_info_plus: ce1b7762849d3ec103d0e0517299f2db7ad60720
  file_selector_macos: 54fdab7caa3ac3fc43c9fac4d7d8d231277f8cf2
  Firebase: 0312a2352584f782ea56f66d91606891d4607f06
  firebase_core: fdf12e0c4349815c2e832d9dcad59fbff0ff394b
  firebase_database: 5303a5efff6320ac6b2d1db4b3af93af2f3cac83
  firebase_messaging: d846ba0c4f69424dd537681b466fff6d40d34723
  FirebaseAppCheckInterop: 5da5ce93e8797a215e3f677fb0654b74e736c8b8
  FirebaseCore: 7ec4d0484817f12c3373955bc87762d96842d483
  FirebaseCoreInternal: 910a81992c33715fec9263ca7381d59ab3a750b7
  FirebaseDatabase: faa489a42f5f868d23a55dd442d6e2099348458e
  FirebaseInstallations: 91950fe859846fff0fbd296180909dd273103b09
  FirebaseMessaging: 88950ba9485052891ebe26f6c43a52bb62248952
  FirebaseSharedSwift: 0274086954b1b2d5fd7e829eccc587044d72a4ba
  FlutterMacOS: 8f6f14fa908a6fb3fba0cd85dbd81ec4b251fb24
  GoogleDataTransport: 6c09b596d841063d76d4288cc2d2f42cc36e1e2a
  GoogleUtilities: ea963c370a38a8069cc5f7ba4ca849a60b6d7d15
  leveldb-library: e8eadf9008a61f9e1dde3978c086d2b6d9b9dc28
  media_kit_video: f5bdcbfaef003c02251e50d44bb741aa96fb8a1e
  nanopb: 438bc412db1928dac798aa6fd75726007be04262
  package_info_plus: fa739dd842b393193c5ca93c26798dff6e3d0e0c
  path_provider_foundation: 2b6b4c569c0fb62ec74538f866245ac84301af46
  pdf_render: c2c4dfbd5cdb621c4f734018e52ab4546f08f3a1
  PromisesObjC: f5707f49cb48b9636751c5b2e7d227e43fba9f47
  realm: 2899b57e431e6b6fb9871e9e286961baab09bad9
  screen_brightness_macos: 2d6d3af2165592d9a55ffcd95b7550970e41ebda
  shared_preferences_foundation: fcdcbc04712aee1108ac7fda236f363274528f78
  sqflite: 673a0e54cc04b7d6dba8d24fb8095b31c3a99eec
  url_launcher_macos: 5f437abeda8c85500ceb03f5c1938a8c5a705399
  wakelock_plus: 4783562c9a43d209c458cb9b30692134af456269

PODFILE CHECKSUM: 236401fc2c932af29a9fcf0e97baeeb2d750d367

COCOAPODS: 1.15.2



================================================
File: example/macos/.gitignore
================================================
# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/



================================================
File: example/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
File: example/macos/Flutter/Flutter-Release.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
File: example/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import connectivity_plus
import device_info_plus
import emoji_picker_flutter
import file_selector_macos
import firebase_core
import firebase_database
import firebase_messaging
import media_kit_libs_macos_video
import media_kit_video
import open_file_mac
import package_info_plus
import path_provider_foundation
import pdf_render
import screen_brightness_macos
import shared_preferences_foundation
import sqflite
import url_launcher_macos
import wakelock_plus

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  ConnectivityPlusPlugin.register(with: registry.registrar(forPlugin: "ConnectivityPlusPlugin"))
  DeviceInfoPlusMacosPlugin.register(with: registry.registrar(forPlugin: "DeviceInfoPlusMacosPlugin"))
  EmojiPickerFlutterPlugin.register(with: registry.registrar(forPlugin: "EmojiPickerFlutterPlugin"))
  FileSelectorPlugin.register(with: registry.registrar(forPlugin: "FileSelectorPlugin"))
  FLTFirebaseCorePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseCorePlugin"))
  FLTFirebaseDatabasePlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseDatabasePlugin"))
  FLTFirebaseMessagingPlugin.register(with: registry.registrar(forPlugin: "FLTFirebaseMessagingPlugin"))
  MediaKitLibsMacosVideoPlugin.register(with: registry.registrar(forPlugin: "MediaKitLibsMacosVideoPlugin"))
  MediaKitVideoPlugin.register(with: registry.registrar(forPlugin: "MediaKitVideoPlugin"))
  OpenFilePlugin.register(with: registry.registrar(forPlugin: "OpenFilePlugin"))
  FPPPackageInfoPlusPlugin.register(with: registry.registrar(forPlugin: "FPPPackageInfoPlusPlugin"))
  PathProviderPlugin.register(with: registry.registrar(forPlugin: "PathProviderPlugin"))
  SwiftPdfRenderPlugin.register(with: registry.registrar(forPlugin: "SwiftPdfRenderPlugin"))
  ScreenBrightnessMacosPlugin.register(with: registry.registrar(forPlugin: "ScreenBrightnessMacosPlugin"))
  SharedPreferencesPlugin.register(with: registry.registrar(forPlugin: "SharedPreferencesPlugin"))
  SqflitePlugin.register(with: registry.registrar(forPlugin: "SqflitePlugin"))
  UrlLauncherPlugin.register(with: registry.registrar(forPlugin: "UrlLauncherPlugin"))
  WakelockPlusMacosPlugin.register(with: registry.registrar(forPlugin: "WakelockPlusMacosPlugin"))
}



================================================
File: example/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }
}



================================================
File: example/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
File: example/macos/Runner/GoogleService-Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>API_KEY</key>
	<string>AIzaSyAVmbe-8jgnO2MUnFotMdp2tmDVnwTZqfE</string>
	<key>GCM_SENDER_ID</key>
	<string>317419981427</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.likeminds.chat.flutter.sample</string>
	<key>PROJECT_ID</key>
	<string>likeminds-sdk-app</string>
	<key>STORAGE_BUCKET</key>
	<string>likeminds-sdk-app.appspot.com</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:317419981427:ios:5c2e7053ed57f4b2d2f806</string>
</dict>
</plist>


================================================
File: example/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
File: example/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
File: example/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
File: example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
File: example/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
File: example/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = LM Chat Flutter Sample

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2024 com.example. All rights reserved.



================================================
File: example/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
File: example/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
File: example/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
File: example/macos/Runner.xcodeproj/project.pbxproj
================================================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXAggregateTarget section */
		33CC111A2044C6BA0003C045 /* Flutter Assemble */ = {
			isa = PBXAggregateTarget;
			buildConfigurationList = 33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */;
			buildPhases = (
				33CC111E2044C6BF0003C045 /* ShellScript */,
			);
			dependencies = (
			);
			name = "Flutter Assemble";
			productName = FLX;
		};
/* End PBXAggregateTarget section */

/* Begin PBXBuildFile section */
		1867E22911A1391D2593D23A /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 9C374263BCAF2750D1190FA3 /* Pods_RunnerTests.framework */; };
		193009D645DB92A4AADBEB91 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = F80944DE9966191502C5BECC /* Pods_Runner.framework */; };
		331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C80D7294CF71000263BE5 /* RunnerTests.swift */; };
		335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */ = {isa = PBXBuildFile; fileRef = 335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */; };
		33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC10F02044A3C60003C045 /* AppDelegate.swift */; };
		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
		92BE665E819D4449BC0C9E45 /* GoogleService-Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 38111D956C9E7D739A4B6A1D /* GoogleService-Info.plist */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C80D9294CF71000263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC10EC2044A3C60003C045;
			remoteInfo = Runner;
		};
		33CC111F2044C79F0003C045 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC111A2044C6BA0003C045;
			remoteInfo = FLX;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		33CC110E2044A8840003C045 /* Bundle Framework */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Bundle Framework";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		2E21F00127D6E0D13988BCB6 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
		33CC10ED2044A3C60003C045 /* likeminds_chat_flutter_sample.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = likeminds_chat_flutter_sample.app; sourceTree = BUILT_PRODUCTS_DIR; };
		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		33CC10F72044A3C60003C045 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = Info.plist; path = Runner/Info.plist; sourceTree = "<group>"; };
		33CC11122044BFA00003C045 /* MainFlutterWindow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainFlutterWindow.swift; sourceTree = "<group>"; };
		33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Debug.xcconfig"; sourceTree = "<group>"; };
		33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Release.xcconfig"; sourceTree = "<group>"; };
		33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = "Flutter-Generated.xcconfig"; path = "ephemeral/Flutter-Generated.xcconfig"; sourceTree = "<group>"; };
		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
		38111D956C9E7D739A4B6A1D /* GoogleService-Info.plist */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.plist.xml; name = "GoogleService-Info.plist"; path = "Runner/GoogleService-Info.plist"; sourceTree = "<group>"; };
		50885E60DA167E7CED650AAD /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		5C8A3B16232FD259B4FE440E /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		6752C9D50594486655375F5D /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
		770E689FE3858FBD336788D4 /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
		9C374263BCAF2750D1190FA3 /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		AC5147F04941808B94401FB8 /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
		F80944DE9966191502C5BECC /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		331C80D2294CF70F00263BE5 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				1867E22911A1391D2593D23A /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EA2044A3C60003C045 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				193009D645DB92A4AADBEB91 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		009372B8E9EABB82FAF318F8 /* Pods */ = {
			isa = PBXGroup;
			children = (
				2E21F00127D6E0D13988BCB6 /* Pods-Runner.debug.xcconfig */,
				6752C9D50594486655375F5D /* Pods-Runner.release.xcconfig */,
				AC5147F04941808B94401FB8 /* Pods-Runner.profile.xcconfig */,
				5C8A3B16232FD259B4FE440E /* Pods-RunnerTests.debug.xcconfig */,
				50885E60DA167E7CED650AAD /* Pods-RunnerTests.release.xcconfig */,
				770E689FE3858FBD336788D4 /* Pods-RunnerTests.profile.xcconfig */,
			);
			name = Pods;
			path = Pods;
			sourceTree = "<group>";
		};
		331C80D6294CF71000263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C80D7294CF71000263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		33BA886A226E78AF003329D5 /* Configs */ = {
			isa = PBXGroup;
			children = (
				33E5194F232828860026EE4D /* AppInfo.xcconfig */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				333000ED22D3DE5D00554162 /* Warnings.xcconfig */,
			);
			path = Configs;
			sourceTree = "<group>";
		};
		33CC10E42044A3C60003C045 = {
			isa = PBXGroup;
			children = (
				33FAB671232836740065AC1E /* Runner */,
				33CEB47122A05771004F2AC0 /* Flutter */,
				331C80D6294CF71000263BE5 /* RunnerTests */,
				33CC10EE2044A3C60003C045 /* Products */,
				D73912EC22F37F3D000D13A0 /* Frameworks */,
				009372B8E9EABB82FAF318F8 /* Pods */,
				38111D956C9E7D739A4B6A1D /* GoogleService-Info.plist */,
			);
			sourceTree = "<group>";
		};
		33CC10EE2044A3C60003C045 /* Products */ = {
			isa = PBXGroup;
			children = (
				33CC10ED2044A3C60003C045 /* likeminds_chat_flutter_sample.app */,
				331C80D5294CF71000263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		33CC11242044D66E0003C045 /* Resources */ = {
			isa = PBXGroup;
			children = (
				33CC10F22044A3C60003C045 /* Assets.xcassets */,
				33CC10F42044A3C60003C045 /* MainMenu.xib */,
				33CC10F72044A3C60003C045 /* Info.plist */,
			);
			name = Resources;
			path = ..;
			sourceTree = "<group>";
		};
		33CEB47122A05771004F2AC0 /* Flutter */ = {
			isa = PBXGroup;
			children = (
				335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */,
				33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */,
				33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */,
				33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */,
			);
			path = Flutter;
			sourceTree = "<group>";
		};
		33FAB671232836740065AC1E /* Runner */ = {
			isa = PBXGroup;
			children = (
				33CC10F02044A3C60003C045 /* AppDelegate.swift */,
				33CC11122044BFA00003C045 /* MainFlutterWindow.swift */,
				33E51913231747F40026EE4D /* DebugProfile.entitlements */,
				33E51914231749380026EE4D /* Release.entitlements */,
				33CC11242044D66E0003C045 /* Resources */,
				33BA886A226E78AF003329D5 /* Configs */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				F80944DE9966191502C5BECC /* Pods_Runner.framework */,
				9C374263BCAF2750D1190FA3 /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C80D4294CF70F00263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				ADFA2357067CCDE323A1A248 /* [CP] Check Pods Manifest.lock */,
				331C80D1294CF70F00263BE5 /* Sources */,
				331C80D2294CF70F00263BE5 /* Frameworks */,
				331C80D3294CF70F00263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C80DA294CF71000263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C80D5294CF71000263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		33CC10EC2044A3C60003C045 /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				58FCCA332B03A6536C9269E8 /* [CP] Check Pods Manifest.lock */,
				33CC10E92044A3C60003C045 /* Sources */,
				33CC10EA2044A3C60003C045 /* Frameworks */,
				33CC10EB2044A3C60003C045 /* Resources */,
				33CC110E2044A8840003C045 /* Bundle Framework */,
				3399D490228B24CF009A79C7 /* ShellScript */,
				EBC6DC0E29CF2D2936CCA243 /* [CP] Embed Pods Frameworks */,
				86ABDCD5386121376E592C00 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
				33CC11202044C79F0003C045 /* PBXTargetDependency */,
			);
			name = Runner;
			productName = Runner;
			productReference = 33CC10ED2044A3C60003C045 /* likeminds_chat_flutter_sample.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		33CC10E52044A3C60003C045 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C80D4294CF70F00263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 33CC10EC2044A3C60003C045;
					};
					33CC10EC2044A3C60003C045 = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
						SystemCapabilities = {
							com.apple.Sandbox = {
								enabled = 1;
							};
						};
					};
					33CC111A2044C6BA0003C045 = {
						CreatedOnToolsVersion = 9.2;
						ProvisioningStyle = Manual;
					};
				};
			};
			buildConfigurationList = 33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 33CC10E42044A3C60003C045;
			productRefGroup = 33CC10EE2044A3C60003C045 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				33CC10EC2044A3C60003C045 /* Runner */,
				331C80D4294CF70F00263BE5 /* RunnerTests */,
				33CC111A2044C6BA0003C045 /* Flutter Assemble */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C80D3294CF70F00263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EB2044A3C60003C045 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */,
				33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */,
				92BE665E819D4449BC0C9E45 /* GoogleService-Info.plist in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3399D490228B24CF009A79C7 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "echo \"$PRODUCT_NAME.app\" > \"$PROJECT_DIR\"/Flutter/ephemeral/.app_filename && \"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh embed\n";
		};
		33CC111E2044C6BF0003C045 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				Flutter/ephemeral/FlutterInputs.xcfilelist,
			);
			inputPaths = (
				Flutter/ephemeral/tripwire,
			);
			outputFileListPaths = (
				Flutter/ephemeral/FlutterOutputs.xcfilelist,
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
		};
		58FCCA332B03A6536C9269E8 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		86ABDCD5386121376E592C00 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
		ADFA2357067CCDE323A1A248 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		EBC6DC0E29CF2D2936CCA243 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Embed Pods Frameworks";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C80D1294CF70F00263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10E92044A3C60003C045 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */,
				33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */,
				335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C80DA294CF71000263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC10EC2044A3C60003C045 /* Runner */;
			targetProxy = 331C80D9294CF71000263BE5 /* PBXContainerItemProxy */;
		};
		33CC11202044C79F0003C045 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC111A2044C6BA0003C045 /* Flutter Assemble */;
			targetProxy = 33CC111F2044C79F0003C045 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		33CC10F42044A3C60003C045 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				33CC10F52044A3C60003C045 /* Base */,
			);
			name = MainMenu.xib;
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		331C80DB294CF71000263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 5C8A3B16232FD259B4FE440E /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/likeminds_chat_flutter_sample.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/likeminds_chat_flutter_sample";
			};
			name = Debug;
		};
		331C80DC294CF71000263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 50885E60DA167E7CED650AAD /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/likeminds_chat_flutter_sample.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/likeminds_chat_flutter_sample";
			};
			name = Release;
		};
		331C80DD294CF71000263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 770E689FE3858FBD336788D4 /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.likeminds.chat.flutter.sample.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/likeminds_chat_flutter_sample.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/likeminds_chat_flutter_sample";
			};
			name = Profile;
		};
		338D0CE9231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Profile;
		};
		338D0CEA231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Profile;
		};
		338D0CEB231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Profile;
		};
		33CC10F92044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		33CC10FA2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.14;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		33CC10FC2044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		33CC10FD2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Release.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		33CC111C2044C6BA0003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Debug;
		};
		33CC111D2044C6BA0003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C80DB294CF71000263BE5 /* Debug */,
				331C80DC294CF71000263BE5 /* Release */,
				331C80DD294CF71000263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10F92044A3C60003C045 /* Debug */,
				33CC10FA2044A3C60003C045 /* Release */,
				338D0CE9231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10FC2044A3C60003C045 /* Debug */,
				33CC10FD2044A3C60003C045 /* Release */,
				338D0CEA231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC111C2044C6BA0003C045 /* Debug */,
				33CC111D2044C6BA0003C045 /* Release */,
				338D0CEB231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 33CC10E52044A3C60003C045 /* Project object */;
}



================================================
File: example/macos/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: example/macos/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "33CC10EC2044A3C60003C045"
               BuildableName = "likeminds_chat_flutter_sample.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "likeminds_chat_flutter_sample.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C80D4294CF70F00263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "likeminds_chat_flutter_sample.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "likeminds_chat_flutter_sample.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>



================================================
File: example/macos/Runner.xcworkspace/contents.xcworkspacedata
================================================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>



================================================
File: example/macos/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>



================================================
File: example/macos/RunnerTests/RunnerTests.swift
================================================
import FlutterMacOS
import Cocoa
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
File: example/test/widget_test.dart
================================================
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

// import 'package:flutter/material.dart';
// import 'package:flutter_test/flutter_test.dart';

// import 'package:likeminds_chat_flutter_sample/main.dart';

// void main() {
//   testWidgets('Counter increments smoke test', (WidgetTester tester) async {
//     // Build our app and trigger a frame.
//     await tester.pumpWidget(const MyApp());

//     // Verify that our counter starts at 0.
//     expect(find.text('0'), findsOneWidget);
//     expect(find.text('1'), findsNothing);

//     // Tap the '+' icon and trigger a frame.
//     await tester.tap(find.byIcon(Icons.add));
//     await tester.pump();

//     // Verify that our counter has incremented.
//     expect(find.text('0'), findsNothing);
//     expect(find.text('1'), findsOneWidget);
//   });
// }



================================================
File: example/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="likeminds_chat_flutter_sample">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>likeminds_chat_flutter_sample</title>
  <link rel="manifest" href="manifest.json">

  <script>
    // The value below is injected by flutter build, do not touch.
    const serviceWorkerVersion = null;
  </script>
  <!-- This script adds the flutter initialization JS code -->
  <script src="flutter.js" defer></script>
</head>
<body>
  <script>
    window.addEventListener('load', function(ev) {
      // Download main.dart.js
      _flutter.loader.loadEntrypoint({
        serviceWorker: {
          serviceWorkerVersion: serviceWorkerVersion,
        },
        onEntrypointLoaded: function(engineInitializer) {
          engineInitializer.initializeEngine().then(function(appRunner) {
            appRunner.runApp();
          });
        }
      });
    });
  </script>
</body>
</html>



================================================
File: example/web/manifest.json
================================================
{
    "name": "likeminds_chat_flutter_sample",
    "short_name": "likeminds_chat_flutter_sample",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}




================================================
File: example/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(likeminds_chat_flutter_sample LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "likeminds_chat_flutter_sample")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
File: example/windows/.gitignore
================================================
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/



================================================
File: example/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      windows-x64 $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
File: example/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <connectivity_plus/connectivity_plus_windows_plugin.h>
#include <emoji_picker_flutter/emoji_picker_flutter_plugin_c_api.h>
#include <file_selector_windows/file_selector_windows.h>
#include <firebase_core/firebase_core_plugin_c_api.h>
#include <media_kit_libs_windows_video/media_kit_libs_windows_video_plugin_c_api.h>
#include <media_kit_video/media_kit_video_plugin_c_api.h>
#include <permission_handler_windows/permission_handler_windows_plugin.h>
#include <screen_brightness_windows/screen_brightness_windows_plugin.h>
#include <url_launcher_windows/url_launcher_windows.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  ConnectivityPlusWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("ConnectivityPlusWindowsPlugin"));
  EmojiPickerFlutterPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("EmojiPickerFlutterPluginCApi"));
  FileSelectorWindowsRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FileSelectorWindows"));
  FirebaseCorePluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("FirebaseCorePluginCApi"));
  MediaKitLibsWindowsVideoPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("MediaKitLibsWindowsVideoPluginCApi"));
  MediaKitVideoPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("MediaKitVideoPluginCApi"));
  PermissionHandlerWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("PermissionHandlerWindowsPlugin"));
  ScreenBrightnessWindowsPluginRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("ScreenBrightnessWindowsPlugin"));
  UrlLauncherWindowsRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("UrlLauncherWindows"));
}



================================================
File: example/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
File: example/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  connectivity_plus
  emoji_picker_flutter
  file_selector_windows
  firebase_core
  media_kit_libs_windows_video
  media_kit_video
  permission_handler_windows
  screen_brightness_windows
  url_launcher_windows
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
  media_kit_native_event_loop
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
File: example/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
File: example/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "likeminds_chat_flutter_sample" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "likeminds_chat_flutter_sample" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2024 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "likeminds_chat_flutter_sample.exe" "\0"
            VALUE "ProductName", "likeminds_chat_flutter_sample" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
File: example/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
File: example/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
File: example/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"likeminds_chat_flutter_sample", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
File: example/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
File: example/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
    </application>
  </compatibility>
</assembly>



================================================
File: example/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length <= 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
File: example/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
File: example/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
File: example/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_




================================================
File: lib/likeminds_chat_flutter.dart
================================================
library likeminds_chat_flutter;



================================================
File: lib/packages/core/README.md
================================================
# LikeMinds Chat Flutter Core

LikeMinds Chat Flutter core is the layer of SDK that allows you to get started in the fastest way possible in building a chat experience within your app.



================================================
File: lib/packages/core/CHANGELOG.md
================================================
## 0.5.0

- Initial release for Chat, DM MVP.

## 0.5.1

- Fixed a bug in `LMChatroomMenu` widget

## 0.6.0

- Added Support for chatroom
- Added conversation lists and actions
- enhancements and minor feature additions

## 0.6.1

- Added Support for block member
- Support for targetSDK v34 out of the box
- Updating dependencies to support Flutter `v3.22.0`

## 0.7.0

- Added multimedia support
- Added multimedia utils and handler functions

## 0.7.5

- Added support for Link Preview

## 0.8.0

- Added support for Tagging
- Added support for Reactions
- Added retry mechanism
- Added Analytics support

### 0.9.0

- Added support for poll
- Fixed Deleted text and link preview ui

### 0.10.0

- Added support for voice notes

### 0.11.0

- Added support for chatbot
- Added support for custom user roles

### 0.12.0

- Added support for poll configuration
- Added support for dark theme
- Added loads of UI/UX improvements

### 0.12.1

- Replaced `open_filex` with `open_file` plugin
- Removed `flutter_keyboard_visibility` plugin

### 0.13.0

- Added Custom Widget support in Chatroom

### 0.14.0

- Fixed Customization misses across the SDK
- Added support for .svg `fileUrl` in `LMChatImage`

## 0.14.1

- Patch update for `likeminds_chat_fl: ^1.12.1`

## 0.15.0

- Fixed attachment menubar hanging issue
- Fixed link preview bug


================================================
File: lib/packages/core/LICENSE
================================================
Copyright [2024] [Collabmates Private Limited]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



================================================
File: lib/packages/core/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
linter:
  rules:
    - public_member_api_docs


================================================
File: lib/packages/core/devtools_options.yaml
================================================
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:



================================================
File: lib/packages/core/pubspec.yaml
================================================
name: likeminds_chat_flutter_core
description: The core package of LikeMinds Flutter Chat SDK
version: 0.15.0
homepage: https://likeminds.community

environment:
  sdk: ">=3.1.0 <4.0.0"
  flutter: ">=3.10.2"

dependencies:
  flutter:
    sdk: flutter

  # Other LM packages
  likeminds_chat_fl: 1.12.1
  likeminds_chat_flutter_ui: 0.15.0
  envied: ^0.5.4+1
  flutter_bloc: ^8.1.5
  equatable: ^2.0.5
  infinite_scroll_pagination: ^4.0.0
  url_launcher: ^6.3.0
  firebase_core: ^3.6.0
  firebase_database: ^11.1.4
  extended_text_field: ^15.0.0
  path: ^1.9.0
  firebase_messaging: ^15.1.3
  overlay_support: ^2.1.0
  shared_preferences: ^2.2.3
  video_thumbnail: ^0.5.3
  file_picker: ^8.0.6
  cached_network_image: ^3.3.1
  shimmer: ^3.0.0
  date_format: ^2.0.7
  intl: ^0.19.0
  permission_handler: ^11.3.1
  device_info_plus: ^10.1.0
  custom_pop_up_menu: ^1.2.4
  bloc: ^8.1.4
  meta: ^1.11.0
  http: ^1.2.2
  amazon_cognito_identity_dart_2: ^3.6.5
  giphy_get: ^3.5.6
  image_picker: ^1.1.2
  media_kit: ^1.1.11
  flutter_sound: ^9.16.3
  path_provider: ^2.1.4
  carousel_slider: ^5.0.0
  lottie: ^3.1.3
  super_sliver_list: ^0.4.1
  photo_view: ^0.15.0

dev_dependencies:
  flutter_lints: ^4.0.0
  flutter_test:
    sdk: flutter

flutter:
  assets:
    - assets/
    - assets/images/
    - assets/icons/



================================================
File: lib/packages/core/pubspec_overrides.yaml
================================================
# melos_managed_dependency_overrides: likeminds_chat_flutter_ui
dependency_overrides:
  likeminds_chat_fl:
    path: ../../../../LikeMinds-Flutter-GroupChat-SDK/
  js: ^0.7.1
  likeminds_chat_flutter_ui:
    path: ../ui



================================================
File: lib/packages/core/.flutter-plugins
================================================
# This is a generated file; do not edit or check into version control.
device_info_plus=/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/
emoji_picker_flutter=/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/
file_picker=/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/
file_selector_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/file_selector_linux-0.9.2+1/
file_selector_macos=/Users/anujkumar/.pub-cache/hosted/pub.dev/file_selector_macos-0.9.4/
file_selector_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/file_selector_windows-0.9.3+2/
firebase_core=/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/
firebase_core_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core_web-2.18.1/
firebase_database=/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_database-11.1.4/
firebase_database_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_database_web-0.2.6+2/
firebase_messaging=/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_messaging-15.1.3/
firebase_messaging_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_messaging_web-3.9.2/
flutter_plugin_android_lifecycle=/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_plugin_android_lifecycle-2.0.19/
flutter_sound=/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound-9.17.0/
flutter_sound_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound_web-9.17.0/
image_picker=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker-1.1.2/
image_picker_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_android-0.8.12+12/
image_picker_for_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_for_web-3.0.5/
image_picker_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_ios-0.8.12/
image_picker_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_linux-0.2.1+1/
image_picker_macos=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_macos-0.2.1+1/
image_picker_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_windows-0.2.1+1/
media_kit_libs_android_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_android_video-1.3.6/
media_kit_libs_ios_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_ios_video-1.1.4/
media_kit_libs_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_linux-1.1.3/
media_kit_libs_macos_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_macos_video-1.1.4/
media_kit_libs_windows_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_windows_video-1.0.10/
media_kit_native_event_loop=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/
media_kit_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/
open_file=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file-3.5.10/
open_file_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_android-1.0.6/
open_file_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_ios-1.0.3/
open_file_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_linux-0.0.5/
open_file_mac=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_mac-1.0.3/
open_file_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_web-0.0.4/
open_file_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_windows-0.0.3/
package_info_plus=/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/
path_provider=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider-2.1.5/
path_provider_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_android-2.2.12/
path_provider_foundation=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/
path_provider_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_linux-2.2.1/
path_provider_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_windows-2.2.1/
pdf_render=/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/
permission_handler=/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler-11.3.1/
permission_handler_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_android-12.0.6/
permission_handler_apple=/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_apple-9.4.4/
permission_handler_html=/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_html-0.1.1/
permission_handler_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_windows-0.2.1/
screen_brightness=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness-0.2.2+1/
screen_brightness_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_android-0.1.0+2/
screen_brightness_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_ios-0.1.0/
screen_brightness_macos=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_macos-0.1.0+1/
screen_brightness_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_windows-0.1.3/
shared_preferences=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences-2.3.2/
shared_preferences_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_android-2.3.3/
shared_preferences_foundation=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/
shared_preferences_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_linux-2.4.1/
shared_preferences_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_web-2.4.2/
shared_preferences_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_windows-2.4.1/
sqflite=/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/
url_launcher=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher-6.3.1/
url_launcher_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_android-6.3.2/
url_launcher_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_ios-6.3.0/
url_launcher_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_linux-3.1.1/
url_launcher_macos=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_macos-3.2.0/
url_launcher_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_web-2.3.3/
url_launcher_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_windows-3.1.1/
video_thumbnail=/Users/anujkumar/.pub-cache/hosted/pub.dev/video_thumbnail-0.5.3/
volume_controller=/Users/anujkumar/.pub-cache/hosted/pub.dev/volume_controller-2.0.7/
wakelock_plus=/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/



================================================
File: lib/packages/core/.flutter-plugins-dependencies
================================================
{"info":"This is a generated file; do not edit or check into version control.","plugins":{"ios":[{"name":"device_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/","native_build":true,"dependencies":[]},{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"file_picker","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/","native_build":true,"dependencies":[]},{"name":"firebase_core","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"firebase_database","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_database-11.1.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_messaging","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_messaging-15.1.3/","native_build":true,"dependencies":["firebase_core"]},{"name":"flutter_sound","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound-9.17.0/","native_build":true,"dependencies":[]},{"name":"image_picker_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_ios-0.8.12/","native_build":true,"dependencies":[]},{"name":"media_kit_libs_ios_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_ios_video-1.1.4/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus","volume_controller"]},{"name":"open_file_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_ios-1.0.3/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":true,"dependencies":[]},{"name":"path_provider_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","native_build":true,"dependencies":[]},{"name":"permission_handler_apple","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_apple-9.4.4/","native_build":true,"dependencies":[]},{"name":"screen_brightness_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_ios-0.1.0/","native_build":true,"dependencies":[]},{"name":"shared_preferences_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"sqflite","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"url_launcher_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_ios-6.3.0/","native_build":true,"dependencies":[]},{"name":"video_thumbnail","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/video_thumbnail-0.5.3/","native_build":true,"dependencies":[]},{"name":"volume_controller","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/volume_controller-2.0.7/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":true,"dependencies":["package_info_plus"]}],"android":[{"name":"device_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/","native_build":true,"dependencies":[]},{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"file_picker","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/","native_build":true,"dependencies":["flutter_plugin_android_lifecycle"]},{"name":"firebase_core","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"firebase_database","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_database-11.1.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_messaging","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_messaging-15.1.3/","native_build":true,"dependencies":["firebase_core"]},{"name":"flutter_plugin_android_lifecycle","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_plugin_android_lifecycle-2.0.19/","native_build":true,"dependencies":[]},{"name":"flutter_sound","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound-9.17.0/","native_build":true,"dependencies":[]},{"name":"image_picker_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_android-0.8.12+12/","native_build":true,"dependencies":["flutter_plugin_android_lifecycle"]},{"name":"media_kit_libs_android_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_android_video-1.3.6/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus","volume_controller"]},{"name":"open_file_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_android-1.0.6/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":true,"dependencies":[]},{"name":"path_provider_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_android-2.2.12/","native_build":true,"dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","native_build":true,"dependencies":[]},{"name":"permission_handler_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_android-12.0.6/","native_build":true,"dependencies":[]},{"name":"screen_brightness_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_android-0.1.0+2/","native_build":true,"dependencies":[]},{"name":"shared_preferences_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_android-2.3.3/","native_build":true,"dependencies":[]},{"name":"sqflite","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/","native_build":true,"dependencies":[]},{"name":"url_launcher_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_android-6.3.2/","native_build":true,"dependencies":[]},{"name":"video_thumbnail","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/video_thumbnail-0.5.3/","native_build":true,"dependencies":[]},{"name":"volume_controller","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/volume_controller-2.0.7/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":true,"dependencies":["package_info_plus"]}],"macos":[{"name":"device_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/","native_build":true,"dependencies":[]},{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"file_picker","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/","native_build":false,"dependencies":[]},{"name":"file_selector_macos","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_selector_macos-0.9.4/","native_build":true,"dependencies":[]},{"name":"firebase_core","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"firebase_database","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_database-11.1.4/","native_build":true,"dependencies":["firebase_core"]},{"name":"firebase_messaging","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_messaging-15.1.3/","native_build":true,"dependencies":["firebase_core"]},{"name":"image_picker_macos","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_macos-0.2.1+1/","native_build":false,"dependencies":["file_selector_macos"]},{"name":"media_kit_libs_macos_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_macos_video-1.1.4/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus"]},{"name":"open_file_mac","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_mac-1.0.3/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":true,"dependencies":[]},{"name":"path_provider_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","native_build":true,"dependencies":[]},{"name":"screen_brightness_macos","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_macos-0.1.0+1/","native_build":true,"dependencies":[]},{"name":"shared_preferences_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"sqflite","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"url_launcher_macos","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_macos-3.2.0/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":true,"dependencies":["package_info_plus"]}],"linux":[{"name":"device_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/","native_build":false,"dependencies":[]},{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"file_picker","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/","native_build":false,"dependencies":[]},{"name":"file_selector_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_selector_linux-0.9.2+1/","native_build":true,"dependencies":[]},{"name":"image_picker_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_linux-0.2.1+1/","native_build":false,"dependencies":["file_selector_linux"]},{"name":"media_kit_libs_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_linux-1.1.3/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus"]},{"name":"open_file_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_linux-0.0.5/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":false,"dependencies":[]},{"name":"path_provider_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_linux-2.2.1/","native_build":false,"dependencies":[]},{"name":"shared_preferences_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_linux-2.4.1/","native_build":false,"dependencies":["path_provider_linux"]},{"name":"url_launcher_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_linux-3.1.1/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":false,"dependencies":["package_info_plus"]}],"windows":[{"name":"device_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/","native_build":false,"dependencies":[]},{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"file_picker","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/","native_build":false,"dependencies":[]},{"name":"file_selector_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_selector_windows-0.9.3+2/","native_build":true,"dependencies":[]},{"name":"firebase_core","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core-3.6.0/","native_build":true,"dependencies":[]},{"name":"image_picker_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_windows-0.2.1+1/","native_build":false,"dependencies":["file_selector_windows"]},{"name":"media_kit_libs_windows_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_windows_video-1.0.10/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus"]},{"name":"open_file_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_windows-0.0.3/","native_build":false,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":false,"dependencies":[]},{"name":"path_provider_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_windows-2.2.1/","native_build":false,"dependencies":[]},{"name":"permission_handler_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_windows-0.2.1/","native_build":true,"dependencies":[]},{"name":"screen_brightness_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_windows-0.1.3/","native_build":true,"dependencies":[]},{"name":"shared_preferences_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_windows-2.4.1/","native_build":false,"dependencies":["path_provider_windows"]},{"name":"url_launcher_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_windows-3.1.1/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":false,"dependencies":["package_info_plus"]}],"web":[{"name":"device_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/device_info_plus-10.1.2/","dependencies":[]},{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","dependencies":[]},{"name":"file_picker","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/file_picker-8.1.2/","dependencies":[]},{"name":"firebase_core_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_core_web-2.18.1/","dependencies":[]},{"name":"firebase_database_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_database_web-0.2.6+2/","dependencies":["firebase_core_web"]},{"name":"firebase_messaging_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/firebase_messaging_web-3.9.2/","dependencies":["firebase_core_web"]},{"name":"flutter_sound_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound_web-9.17.0/","dependencies":[]},{"name":"image_picker_for_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/image_picker_for_web-3.0.5/","dependencies":[]},{"name":"open_file_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_web-0.0.4/","dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","dependencies":[]},{"name":"permission_handler_html","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/permission_handler_html-0.1.1/","dependencies":[]},{"name":"shared_preferences_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_web-2.4.2/","dependencies":[]},{"name":"url_launcher_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_web-2.3.3/","dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","dependencies":["package_info_plus"]}]},"dependencyGraph":[{"name":"device_info_plus","dependencies":[]},{"name":"emoji_picker_flutter","dependencies":["shared_preferences"]},{"name":"file_picker","dependencies":["flutter_plugin_android_lifecycle"]},{"name":"file_selector_linux","dependencies":[]},{"name":"file_selector_macos","dependencies":[]},{"name":"file_selector_windows","dependencies":[]},{"name":"firebase_core","dependencies":["firebase_core_web"]},{"name":"firebase_core_web","dependencies":[]},{"name":"firebase_database","dependencies":["firebase_core","firebase_database_web"]},{"name":"firebase_database_web","dependencies":["firebase_core","firebase_core_web"]},{"name":"firebase_messaging","dependencies":["firebase_core","firebase_messaging_web"]},{"name":"firebase_messaging_web","dependencies":["firebase_core","firebase_core_web"]},{"name":"flutter_plugin_android_lifecycle","dependencies":[]},{"name":"flutter_sound","dependencies":["path_provider","flutter_sound_web"]},{"name":"flutter_sound_web","dependencies":[]},{"name":"image_picker","dependencies":["image_picker_android","image_picker_for_web","image_picker_ios","image_picker_linux","image_picker_macos","image_picker_windows"]},{"name":"image_picker_android","dependencies":["flutter_plugin_android_lifecycle"]},{"name":"image_picker_for_web","dependencies":[]},{"name":"image_picker_ios","dependencies":[]},{"name":"image_picker_linux","dependencies":["file_selector_linux"]},{"name":"image_picker_macos","dependencies":["file_selector_macos"]},{"name":"image_picker_windows","dependencies":["file_selector_windows"]},{"name":"media_kit_libs_android_video","dependencies":[]},{"name":"media_kit_libs_ios_video","dependencies":[]},{"name":"media_kit_libs_linux","dependencies":[]},{"name":"media_kit_libs_macos_video","dependencies":[]},{"name":"media_kit_libs_windows_video","dependencies":[]},{"name":"media_kit_native_event_loop","dependencies":[]},{"name":"media_kit_video","dependencies":["wakelock_plus","screen_brightness","volume_controller"]},{"name":"open_file","dependencies":["open_file_android","open_file_web","open_file_ios","open_file_mac","open_file_windows","open_file_linux"]},{"name":"open_file_android","dependencies":[]},{"name":"open_file_ios","dependencies":[]},{"name":"open_file_linux","dependencies":[]},{"name":"open_file_mac","dependencies":[]},{"name":"open_file_web","dependencies":[]},{"name":"open_file_windows","dependencies":[]},{"name":"package_info_plus","dependencies":[]},{"name":"path_provider","dependencies":["path_provider_android","path_provider_foundation","path_provider_linux","path_provider_windows"]},{"name":"path_provider_android","dependencies":[]},{"name":"path_provider_foundation","dependencies":[]},{"name":"path_provider_linux","dependencies":[]},{"name":"path_provider_windows","dependencies":[]},{"name":"pdf_render","dependencies":[]},{"name":"permission_handler","dependencies":["permission_handler_android","permission_handler_apple","permission_handler_html","permission_handler_windows"]},{"name":"permission_handler_android","dependencies":[]},{"name":"permission_handler_apple","dependencies":[]},{"name":"permission_handler_html","dependencies":[]},{"name":"permission_handler_windows","dependencies":[]},{"name":"screen_brightness","dependencies":["screen_brightness_android","screen_brightness_ios","screen_brightness_macos","screen_brightness_windows"]},{"name":"screen_brightness_android","dependencies":[]},{"name":"screen_brightness_ios","dependencies":[]},{"name":"screen_brightness_macos","dependencies":[]},{"name":"screen_brightness_windows","dependencies":[]},{"name":"shared_preferences","dependencies":["shared_preferences_android","shared_preferences_foundation","shared_preferences_linux","shared_preferences_web","shared_preferences_windows"]},{"name":"shared_preferences_android","dependencies":[]},{"name":"shared_preferences_foundation","dependencies":[]},{"name":"shared_preferences_linux","dependencies":["path_provider_linux"]},{"name":"shared_preferences_web","dependencies":[]},{"name":"shared_preferences_windows","dependencies":["path_provider_windows"]},{"name":"sqflite","dependencies":[]},{"name":"url_launcher","dependencies":["url_launcher_android","url_launcher_ios","url_launcher_linux","url_launcher_macos","url_launcher_web","url_launcher_windows"]},{"name":"url_launcher_android","dependencies":[]},{"name":"url_launcher_ios","dependencies":[]},{"name":"url_launcher_linux","dependencies":[]},{"name":"url_launcher_macos","dependencies":[]},{"name":"url_launcher_web","dependencies":[]},{"name":"url_launcher_windows","dependencies":[]},{"name":"video_thumbnail","dependencies":[]},{"name":"volume_controller","dependencies":[]},{"name":"wakelock_plus","dependencies":["package_info_plus"]}],"date_created":"2025-03-07 19:51:14.515065","version":"3.24.5","swift_package_manager_enabled":false}


================================================
File: lib/packages/core/.gitignore
================================================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
# Libraries should not include pubspec.lock, per https://dart.dev/guides/libraries/private-files#pubspeclock.
/pubspec.lock
**/doc/api/
.dart_tool/
.packages
build/



================================================
File: lib/packages/core/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e1e47221e86272429674bec4f1bd36acc4fc7b77"
  channel: "stable"

project_type: package



================================================
File: lib/packages/core/.pubignore
================================================
pubspec_overrides.yaml




================================================
File: lib/packages/core/lib/likeminds_chat_flutter_core.dart
================================================
library likeminds_chat_flutter_core;

export 'src/views/views.dart';
export 'src/blocs/blocs.dart';
export 'src/core/core.dart';
export 'src/core/configurations/chat_config.dart';
export 'src/core/configurations/chat_builder.dart';
export 'src/core/configurations/widget_source.dart';
export 'src/utils/utils.dart';
export 'src/widgets/widgets.dart';

const bool isDebug = bool.fromEnvironment('LM_DEBUG_ENV');



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/README.md
================================================
<meta name='keywords' content='flutter, typeahead, autocomplete, customizable, floating'>

[![Pub](https://img.shields.io/pub/v/flutter_typeahead)](https://pub.dev/packages/flutter_typeahead)

# Flutter TypeAhead
A TypeAhead (autocomplete) widget for Flutter, where you can show suggestions to
users as they type

<img src="https://raw.githubusercontent.com/AbdulRahmanAlHamali/flutter_typeahead/master/flutter_typeahead.gif">

## Features
* Shows suggestions in an overlay that floats on top of other widgets
* Allows you to specify what the suggestions will look like through a
builder function
* Allows you to specify what happens when the user taps a suggestion
* Accepts all the parameters that traditional TextFields accept, like
decoration, custom TextEditingController, text styling, etc.
* Provides two versions, a normal version and a [FormField](https://docs.flutter.io/flutter/widgets/FormField-class.html)
version that accepts validation, submitting, etc.
* Provides high customizable; you can customize the suggestion box decoration,
the loading bar, the animation, the debounce duration, etc.

## Installation
See the [installation instructions on pub](https://pub.dartlang.org/packages/flutter_typeahead#-installing-tab-).

Note: As for Typeahead 3.X this package is based on Dart 2.12 (null-safety). You may also want to explore the new built in Flutter 2 widgets that have similar behavior. 

## Usage examples
You can import the package with:
```dart
import 'package:flutter_typeahead/flutter_typeahead.dart';
```

For Cupertino users import:
```dart
import 'package:flutter_typeahead/cupertino_flutter_typeahead.dart';
```

Use it as follows:

### Material Example 1:
```dart
TypeAheadField(
  textFieldConfiguration: TextFieldConfiguration(
    autofocus: true,
    style: DefaultTextStyle.of(context).style.copyWith(
      fontStyle: FontStyle.italic
    ),
    decoration: InputDecoration(
      border: OutlineInputBorder()
    )
  ),
  suggestionsCallback: (pattern) async {
    return await BackendService.getSuggestions(pattern);
  },
  itemBuilder: (context, suggestion) {
    return ListTile(
      leading: Icon(Icons.shopping_cart),
      title: Text(suggestion['name']),
      subtitle: Text('\$${suggestion['price']}'),
    );
  },
  onSuggestionSelected: (suggestion) {
    Navigator.of(context).push(MaterialPageRoute(
      builder: (context) => ProductPage(product: suggestion)
    ));
  },
)
```
In the code above, the `textFieldConfiguration` property allows us to
configure the displayed `TextField` as we want. In this example, we are
configuring the `autofocus`, `style` and `decoration` properties.

The `suggestionsCallback` is called with the search string that the user
types, and is expected to return a `List` of data either synchronously or
asynchronously. In this example, we are calling an asynchronous function
called `BackendService.getSuggestions` which fetches the list of
suggestions.

The `itemBuilder` is called to build a widget for each suggestion.
In this example, we build a simple `ListTile` that shows the name and the
price of the item. Please note that you shouldn't provide an `onTap`
callback here. The TypeAhead widget takes care of that.

The `onSuggestionSelected` is a callback called when the user taps a
suggestion. In this example, when the user taps a
suggestion, we navigate to a page that shows us the information of the
tapped product.

### Material Example 2:
Here's another example, where we use the TypeAheadFormField inside a `Form`:
```dart
final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
final TextEditingController _typeAheadController = TextEditingController();
String _selectedCity;
...
Form(
  key: this._formKey,
  child: Padding(
    padding: EdgeInsets.all(32.0),
    child: Column(
      children: <Widget>[
        Text(
          'What is your favorite city?'
        ),
        TypeAheadFormField(
          textFieldConfiguration: TextFieldConfiguration(
            controller: this._typeAheadController,
            decoration: InputDecoration(
              labelText: 'City'
            )
          ),          
          suggestionsCallback: (pattern) {
            return CitiesService.getSuggestions(pattern);
          },
          itemBuilder: (context, suggestion) {
            return ListTile(
              title: Text(suggestion),
            );
          },
          transitionBuilder: (context, suggestionsBox, controller) {
            return suggestionsBox;
          },
          onSuggestionSelected: (suggestion) {
            this._typeAheadController.text = suggestion;
          },
          validator: (value) {
            if (value.isEmpty) {
              return 'Please select a city';
            }
          },
          onSaved: (value) => this._selectedCity = value,
        ),
        SizedBox(height: 10.0,),
        RaisedButton(
          child: Text('Submit'),
          onPressed: () {
            if (this._formKey.currentState.validate()) {
              this._formKey.currentState.save();
              Scaffold.of(context).showSnackBar(SnackBar(
                content: Text('Your Favorite City is ${this._selectedCity}')
              ));
            }
          },
        )
      ],
    ),
  ),
)
```
Here, we assign to the `controller` property of the `textFieldConfiguration`
a `TextEditingController` that we call `_typeAheadController`.
We use this controller in the `onSuggestionSelected` callback to set the
value of the `TextField` to the selected suggestion.

The `validator` callback can be used like any `FormField.validator`
function. In our example, it checks whether a value has been entered,
and displays an error message if not. The `onSaved` callback is used to
save the value of the field to the `_selectedCity` member variable.

The `transitionBuilder` allows us to customize the animation of the
suggestion box. In this example, we are returning the suggestionsBox
immediately, meaning that we don't want any animation.

### Cupertino Example:
Please see the Cupertino code in the example project.

## Known Issues

### Animations
Placing TypeAheadField in widgets with animations may cause the suggestions box 
to resize incorrectly. Since animation times are variable, this has to be 
corrected manually at the end of the animation. You will need to add a 
SuggestionsBoxController described below and the following code for the 
AnimationController.
```dart
void Function(AnimationStatus) _statusListener;

@override
void initState() {
  super.initState();
  _statusListener = (AnimationStatus status) {
    if (status == AnimationStatus.completed ||
        status == AnimationStatus.dismissed) {
      _suggestionsBoxController.resize();
    }
  };

  _animationController.addStatusListener(_statusListener);
}

@override
  void dispose() {
    _animationController.removeStatusListener(_statusListener);
    _animationController.dispose();
    super.dispose();
}
```

#### Dialogs
There is a known issue with opening dialogs where the suggestions box will sometimes appear too small. This is a timing issue caused by the animations described above. Currently, `showDialog` has a duration of 150 ms for the animations. TypeAheadField has a delay of 170 ms to compensate for this. Until the end of the animation can be properly detected and fixed using the solution above, this temporary fix will work most of the time. If the suggestions box is too small, closing and reopening the keyboard will usually fix the issue.

### Cupertino
The Cupertino classes in TypeAhead are still new. There are also differences in the Cupertino widgets vs the Material ones. Some behavior will not translate when moving between the two.

## Customizations
TypeAhead widgets consist of a TextField and a suggestion box that shows
as the user types. Both are highly customizable

### Customizing the TextField
You can customize the text field using the `textFieldConfiguration` property.
You provide this property with an instance of `TextFieldConfiguration`,
which allows you to configure all the usual properties of `TextField`, like
`decoration`, `style`, `controller`, `focusNode`, `autofocus`, `enabled`,
etc.

### Customizing the suggestions box
TypeAhead provides default configurations for the suggestions box. You can,
however, override most of them. This is done by passing a `SuggestionsBoxDecoration` 
to the `suggestionsBoxDecoration` property.

Use the `offsetX` property in `SuggestionsBoxDecoration` to shift the suggestions box along the x-axis. 
You may also pass BoxConstraints to `constraints` in `SuggestionsBoxDecoration` to adjust the width 
and height of the suggestions box. Using the two together will allow the suggestions box to be placed 
almost anywhere.

#### Customizing the loader, the error and the "no items found" message
You can use the `loadingBuilder`, `errorBuilder` and `noItemsFoundBuilder` to
customize their corresponding widgets. For example, to show a custom error
widget:
```dart
errorBuilder: (BuildContext context, Object error) =>
  Text(
    '$error',
    style: TextStyle(
      color: Theme.of(context).errorColor
    )
  )
```

By default, the suggestions box will maintain the old suggestions while new 
suggestions are being retrieved. To show a circular progress indicator 
during retrieval instead, set `keepSuggestionsOnLoading` to false.

#### Hiding the suggestions box
There are three scenarios when you can hide the suggestions box.

Set `hideOnLoading` to true to hide the box while suggestions are being 
retrieved. This will also ignore the `loadingBuilder`. Set `hideOnEmpty` 
to true to hide the box when there are no suggestions. This will also ignore 
the `noItemsFoundBuilder`. Set `hideOnError` to true to hide the box when there 
is an error retrieving suggestions. This will also ignore the `errorBuilder`.

By default, the suggestions box will automatically hide when the keyboard is hidden. 
To change this behavior, set `hideSuggestionsOnKeyboardHide` to false.

#### Customizing the animation
You can customize the suggestion box animation through 3 parameters: the
`animationDuration`, the `animationStart`, and the `transitionBuilder`.

The `animationDuration` specifies how long the animation should take, while the
`animationStart` specified what point (between 0.0 and 1.0) the animation
should start from. The `transitionBuilder` accepts the `suggestionsBox` and
`animationController` as parameters, and should return a widget that uses
the `animationController` to animate the display of the `suggestionsBox`.
For example:
```dart
transitionBuilder: (context, suggestionsBox, animationController) =>
  FadeTransition(
    child: suggestionsBox,
    opacity: CurvedAnimation(
      parent: animationController,
      curve: Curves.fastOutSlowIn
    ),
  )
```
This uses [FadeTransition](https://docs.flutter.io/flutter/widgets/FadeTransition-class.html)
to fade the `suggestionsBox` into the view. Note how the
`animationController` was provided as the parent of the animation.

In order to fully remove the animation, `transitionBuilder` should simply
return the `suggestionsBox`. This callback could also be used to wrap the
`suggestionsBox` with any desired widgets, not necessarily for animation.

#### Customizing the debounce duration
The suggestions box does not fire for each character the user types. Instead,
we wait until the user is idle for a duration of time, and then call the
`suggestionsCallback`. The duration defaults to 300 milliseconds, but can be
configured using the `debounceDuration` parameter.

#### Customizing the offset of the suggestions box
By default, the suggestions box is displayed 5 pixels below the `TextField`.
You can change this by changing the `suggestionsBoxVerticalOffset` property.

#### Customizing the decoration of the suggestions box
You can also customize the decoration of the suggestions box using the
`suggestionsBoxDecoration` property. For example, to remove the elevation
of the suggestions box, you can write:
```dart
suggestionsBoxDecoration: SuggestionsBoxDecoration(
  elevation: 0.0
)
```

#### Customizing the growth direction of the suggestions list
By default, the list grows towards the bottom. However, you can use the `direction` property to customize the growth direction to be one of `AxisDirection.down` or `AxisDirection.up`, the latter of which will cause the list to grow up, where the first suggestion is at the bottom of the list, and the last suggestion is at the top.

Set `autoFlipDirection` to true to allow the suggestions list to automatically flip direction whenever it detects that there is not enough space for the current direction. This is useful for scenarios where the TypeAheadField is in a scrollable widget or when the developer wants to ensure the list is always viewable despite different user screen sizes.

#### Controlling the suggestions box
Manual control of the suggestions box can be achieved by creating an instance of `SuggestionsBoxController` and 
passing it to the `suggestionsBoxController` property. This will allow you to manually open, close, toggle, or 
resize the suggestions box.

## For more information
Visit the [API Documentation](https://pub.dartlang.org/documentation/flutter_typeahead/latest/)

## Team:
| [<img src="https://avatars.githubusercontent.com/u/16646600?v=3" width="100px;"/>](https://github.com/AbdulRahmanAlHamali)|[<img src="https://avatars.githubusercontent.com/u/2034925?v=3" width="100px;"/>](https://github.com/sjmcdowall)|[<img src="https://avatars.githubusercontent.com/u/5499214?v=3" width="100px;"/>](https://github.com/KaYBlitZ)|
|---|---|---|
|AbdulRahman AlHamali|S McDowall|Kenneth Liang|

## Shout out to the contributors!
This project is the result of the collective effort of contributors who participated effectively by submitting pull requests, reporting issues, and answering questions. Thank you for your proactiveness, and we hope flutter_typeahead made your lifes at least a little easier!

## How you can help
[Contribution Guidelines](https://github.com/AbdulRahmanAlHamali/flutter_typeahead/blob/master/CONTRIBUTING.md)



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/LICENSE
================================================
BSD 2-Clause License

Copyright (c) 2018, AbdulRahmanAlHamali
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/flutter_typeahead.dart
================================================
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/field/typeahead_field.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/field/text_field_configuration.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/field/typeahead_form_field.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_controller.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_decoration.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_list.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_typeahead_field.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_text_field_configuration.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_typeahead_form_field.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_list.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_controller.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_decoration.dart';
export 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box.dart';



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/keyboard_suggestion_selection_notifier.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class KeyboardSuggestionSelectionNotifier
    extends ValueNotifier<LogicalKeyboardKey?> {
  KeyboardSuggestionSelectionNotifier() : super(null);

  void onKeyboardEvent(RawKeyEvent event) {
    // * we only handle key down event
    if (event.runtimeType == RawKeyUpEvent) return;

    if (event.logicalKey == LogicalKeyboardKey.arrowDown ||
        event.logicalKey == LogicalKeyboardKey.arrowUp) {
      if (value == event.logicalKey) {
        notifyListeners();
      } else {
        value = event.logicalKey;
      }
    }
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/should_refresh_suggestion_focus_index_notifier.dart
================================================
import 'package:flutter/material.dart';

class ShouldRefreshSuggestionFocusIndexNotifier extends ValueNotifier<void> {
  ShouldRefreshSuggestionFocusIndexNotifier(
      {required FocusNode? textFieldFocusNode})
      : super(null) {
    textFieldFocusNode?.addListener(() {
      if (textFieldFocusNode.hasFocus) {
        notifyListeners();
      }
    });
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/typedef.dart
================================================
import 'dart:async';

import 'package:flutter/widgets.dart';

typedef FutureOr<Iterable<T>> SuggestionsCallback<T>(String pattern);
typedef Widget ItemBuilder<T>(BuildContext context, T itemData);
typedef void SuggestionSelectionCallback<T>(T suggestion);
typedef Widget ErrorBuilder(BuildContext context, Object? error);

typedef Widget AnimationTransitionBuilder(
    BuildContext context, Widget child, AnimationController? controller);



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/utils.dart
================================================
import 'dart:io';

import 'package:flutter/foundation.dart';

final supportedPlatform = (kIsWeb || Platform.isAndroid || Platform.isIOS);



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_text_field_configuration.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:flutter/services.dart';

// Cupertino BoxDecoration taken from flutter/lib/src/cupertino/text_field.dart
const BorderSide _kDefaultRoundedBorderSide = BorderSide(
  color: CupertinoDynamicColor.withBrightness(
    color: Color(0x33000000),
    darkColor: Color(0x33FFFFFF),
  ),
  style: BorderStyle.solid,
  width: 0.0,
);

const Border _kDefaultRoundedBorder = Border(
  top: _kDefaultRoundedBorderSide,
  bottom: _kDefaultRoundedBorderSide,
  left: _kDefaultRoundedBorderSide,
  right: _kDefaultRoundedBorderSide,
);

const BoxDecoration _kDefaultRoundedBorderDecoration = BoxDecoration(
  color: CupertinoDynamicColor.withBrightness(
    color: CupertinoColors.white,
    darkColor: CupertinoColors.black,
  ),
  border: _kDefaultRoundedBorder,
  borderRadius: BorderRadius.all(Radius.circular(5.0)),
);

/// Supply an instance of this class to the [TypeAhead.textFieldConfiguration]
/// property to configure the displayed text field. See [documentation](https://docs.flutter.io/flutter/cupertino/CupertinoTextField-class.html)
/// for more information on properties.
class CupertinoTextFieldConfiguration {
  final TextEditingController? controller;
  final FocusNode? focusNode;
  final BoxDecoration decoration;
  final EdgeInsetsGeometry padding;
  final String? placeholder;
  final Widget? prefix;
  final OverlayVisibilityMode prefixMode;
  final Widget? suffix;
  final OverlayVisibilityMode suffixMode;
  final OverlayVisibilityMode clearButtonMode;
  final TextInputType? keyboardType;
  final TextInputAction? textInputAction;
  final TextCapitalization textCapitalization;
  final TextStyle? style;
  final TextAlign textAlign;
  final bool autofocus;
  final bool obscureText;
  final bool autocorrect;
  final int maxLines;
  final int? minLines;
  final int? maxLength;
  final MaxLengthEnforcement? maxLengthEnforcement;
  final ValueChanged<String>? onChanged;
  final VoidCallback? onEditingComplete;
  final GestureTapCallback? onTap;
  final ValueChanged<String>? onSubmitted;
  final List<TextInputFormatter>? inputFormatters;
  final bool enabled;
  final bool enableSuggestions;
  final double cursorWidth;
  final Radius cursorRadius;
  final Color? cursorColor;
  final Brightness? keyboardAppearance;
  final EdgeInsets scrollPadding;
  final bool enableInteractiveSelection;

  /// Creates a CupertinoTextFieldConfiguration
  const CupertinoTextFieldConfiguration({
    this.controller,
    this.focusNode,
    this.decoration = _kDefaultRoundedBorderDecoration,
    this.padding = const EdgeInsets.all(6.0),
    this.placeholder,
    this.prefix,
    this.prefixMode = OverlayVisibilityMode.always,
    this.suffix,
    this.suffixMode = OverlayVisibilityMode.always,
    this.clearButtonMode = OverlayVisibilityMode.never,
    this.keyboardType,
    this.textInputAction,
    this.textCapitalization = TextCapitalization.none,
    this.style,
    this.textAlign = TextAlign.start,
    this.autofocus = false,
    this.obscureText = false,
    this.autocorrect = true,
    this.maxLines = 1,
    this.minLines,
    this.maxLength,
    this.maxLengthEnforcement,
    this.onChanged,
    this.onEditingComplete,
    this.onTap,
    this.onSubmitted,
    this.inputFormatters,
    this.enabled = true,
    this.enableSuggestions = true,
    this.cursorWidth = 2.0,
    this.cursorRadius = const Radius.circular(2.0),
    this.cursorColor,
    this.keyboardAppearance,
    this.scrollPadding = const EdgeInsets.all(20.0),
    this.enableInteractiveSelection = true,
  });

  /// Copies the [CupertinoTextFieldConfiguration] and only changes the specified properties
  CupertinoTextFieldConfiguration copyWith({
    TextEditingController? controller,
    FocusNode? focusNode,
    BoxDecoration? decoration,
    EdgeInsetsGeometry? padding,
    String? placeholder,
    Widget? prefix,
    OverlayVisibilityMode? prefixMode,
    Widget? suffix,
    OverlayVisibilityMode? suffixMode,
    OverlayVisibilityMode? clearButtonMode,
    TextInputType? keyboardType,
    TextInputAction? textInputAction,
    TextCapitalization? textCapitalization,
    TextStyle? style,
    TextAlign? textAlign,
    bool? autofocus,
    bool? obscureText,
    bool? autocorrect,
    int? maxLines,
    int? minLines,
    int? maxLength,
    MaxLengthEnforcement? maxLengthEnforcement,
    ValueChanged<String>? onChanged,
    VoidCallback? onEditingComplete,
    GestureTapCallback? onTap,
    ValueChanged<String>? onSubmitted,
    List<TextInputFormatter>? inputFormatters,
    bool? enabled,
    bool? enableSuggestions,
    double? cursorWidth,
    Radius? cursorRadius,
    Color? cursorColor,
    Brightness? keyboardAppearance,
    EdgeInsets? scrollPadding,
    bool? enableInteractiveSelection,
  }) {
    return CupertinoTextFieldConfiguration(
      controller: controller ?? this.controller,
      focusNode: focusNode ?? this.focusNode,
      decoration: decoration ?? this.decoration,
      padding: padding ?? this.padding,
      placeholder: placeholder ?? this.placeholder,
      prefix: prefix ?? this.prefix,
      prefixMode: prefixMode ?? this.prefixMode,
      suffix: suffix ?? this.suffix,
      suffixMode: suffixMode ?? this.suffixMode,
      clearButtonMode: clearButtonMode ?? this.clearButtonMode,
      keyboardType: keyboardType ?? this.keyboardType,
      textInputAction: textInputAction ?? this.textInputAction,
      textCapitalization: textCapitalization ?? this.textCapitalization,
      style: style ?? this.style,
      textAlign: textAlign ?? this.textAlign,
      autofocus: autofocus ?? this.autofocus,
      obscureText: obscureText ?? this.obscureText,
      autocorrect: autocorrect ?? this.autocorrect,
      maxLines: maxLines ?? this.maxLines,
      minLines: minLines ?? this.minLines,
      maxLength: maxLength ?? this.maxLength,
      maxLengthEnforcement: maxLengthEnforcement ?? this.maxLengthEnforcement,
      onChanged: onChanged ?? this.onChanged,
      onEditingComplete: onEditingComplete ?? this.onEditingComplete,
      onTap: onTap ?? this.onTap,
      onSubmitted: onSubmitted ?? this.onSubmitted,
      inputFormatters: inputFormatters ?? this.inputFormatters,
      enabled: enabled ?? this.enabled,
      enableSuggestions: enableSuggestions ?? this.enableSuggestions,
      cursorWidth: cursorWidth ?? this.cursorWidth,
      cursorRadius: cursorRadius ?? this.cursorRadius,
      cursorColor: cursorColor ?? this.cursorColor,
      keyboardAppearance: keyboardAppearance ?? this.keyboardAppearance,
      scrollPadding: scrollPadding ?? this.scrollPadding,
      enableInteractiveSelection:
          enableInteractiveSelection ?? this.enableInteractiveSelection,
    );
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_typeahead_field.dart
================================================
import 'dart:async';
import 'dart:core';

import 'package:flutter/cupertino.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_text_field_configuration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_controller.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_decoration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_list.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';

/// A [CupertinoTextField](https://docs.flutter.io/flutter/cupertino/CupertinoTextField-class.html)
/// that displays a list of suggestions as the user types
///
/// See also:
///
/// * [TypeAheadFormField], a [FormField](https://docs.flutter.io/flutter/widgets/FormField-class.html)
/// implementation of [TypeAheadField] that allows the value to be saved,
/// validated, etc.
class CupertinoTypeAheadField<T> extends StatefulWidget {
  /// Called with the search pattern to get the search suggestions.
  ///
  /// This callback must not be null. It is be called by the TypeAhead widget
  /// and provided with the search pattern. It should return a [List](https://api.dartlang.org/stable/2.0.0/dart-core/List-class.html)
  /// of suggestions either synchronously, or asynchronously (as the result of a
  /// [Future](https://api.dartlang.org/stable/dart-async/Future-class.html)).
  /// Typically, the list of suggestions should not contain more than 4 or 5
  /// entries. These entries will then be provided to [itemBuilder] to display
  /// the suggestions.
  ///
  /// Example:
  /// ```dart
  /// suggestionsCallback: (pattern) async {
  ///   return await _getSuggestions(pattern);
  /// }
  /// ```
  final SuggestionsCallback<T> suggestionsCallback;

  /// Called when a suggestion is tapped.
  ///
  /// This callback must not be null. It is called by the TypeAhead widget and
  /// provided with the value of the tapped suggestion.
  ///
  /// For example, you might want to navigate to a specific view when the user
  /// tabs a suggestion:
  /// ```dart
  /// onSuggestionSelected: (suggestion) {
  ///   Navigator.of(context).push(MaterialPageRoute(
  ///     builder: (context) => SearchResult(
  ///       searchItem: suggestion
  ///     )
  ///   ));
  /// }
  /// ```
  ///
  /// Or to set the value of the text field:
  /// ```dart
  /// onSuggestionSelected: (suggestion) {
  ///   _controller.text = suggestion['name'];
  /// }
  /// ```
  final SuggestionSelectionCallback<T> onSuggestionSelected;

  /// Called for each suggestion returned by [suggestionsCallback] to build the
  /// corresponding widget.
  ///
  /// This callback must not be null. It is called by the TypeAhead widget for
  /// each suggestion, and expected to build a widget to display this
  /// suggestion's info. For example:
  ///
  /// ```dart
  /// itemBuilder: (context, suggestion) {
  ///   return Padding(
  ///     padding: const EdgeInsets.all(4.0),
  ///     child: Text(
  ///       suggestion,
  ///     ),
  ///   );
  /// }
  /// ```
  final ItemBuilder<T> itemBuilder;

  /// The decoration of the material sheet that contains the suggestions.
  final CupertinoSuggestionsBoxDecoration suggestionsBoxDecoration;

  /// Used to control the `_SuggestionsBox`. Allows manual control to
  /// open, close, toggle, or resize the `_SuggestionsBox`.
  final CupertinoSuggestionsBoxController? suggestionsBoxController;

  /// The duration to wait after the user stops typing before calling
  /// [suggestionsCallback]
  ///
  /// This is useful, because, if not set, a request for suggestions will be
  /// sent for every character that the user types.
  ///
  /// This duration is set by default to 300 milliseconds
  final Duration debounceDuration;

  /// Called when waiting for [suggestionsCallback] to return.
  ///
  /// It is expected to return a widget to display while waiting.
  /// For example:
  /// ```dart
  /// (BuildContext context) {
  ///   return Text('Loading...');
  /// }
  /// ```
  ///
  /// If not specified, a [CupertinoActivityIndicator](https://docs.flutter.io/flutter/cupertino/CupertinoActivityIndicator-class.html) is shown
  final WidgetBuilder? loadingBuilder;

  /// Called when [suggestionsCallback] returns an empty array.
  ///
  /// It is expected to return a widget to display when no suggestions are
  /// avaiable.
  /// For example:
  /// ```dart
  /// (BuildContext context) {
  ///   return Text('No Items Found!');
  /// }
  /// ```
  ///
  /// If not specified, a simple text is shown
  final WidgetBuilder? noItemsFoundBuilder;

  /// Called when [suggestionsCallback] throws an exception.
  ///
  /// It is called with the error object, and expected to return a widget to
  /// display when an exception is thrown
  /// For example:
  /// ```dart
  /// (BuildContext context, error) {
  ///   return Text('$error');
  /// }
  /// ```
  final ErrorBuilder? errorBuilder;

  /// Called to display animations when [suggestionsCallback] returns suggestions
  ///
  /// It is provided with the suggestions box instance and the animation
  /// controller, and expected to return some animation that uses the controller
  /// to display the suggestion box.
  ///
  /// For example:
  /// ```dart
  /// transitionBuilder: (context, suggestionsBox, animationController) {
  ///   return FadeTransition(
  ///     child: suggestionsBox,
  ///     opacity: CurvedAnimation(
  ///       parent: animationController,
  ///       curve: Curves.fastOutSlowIn
  ///     ),
  ///   );
  /// }
  /// ```
  /// This argument is best used with [animationDuration] and [animationStart]
  /// to fully control the animation.
  ///
  /// To fully remove the animation, just return `suggestionsBox`
  ///
  /// If not specified, a [SizeTransition](https://docs.flutter.io/flutter/widgets/SizeTransition-class.html) is shown.
  final AnimationTransitionBuilder? transitionBuilder;

  /// The duration that [transitionBuilder] animation takes.
  ///
  /// This argument is best used with [transitionBuilder] and [animationStart]
  /// to fully control the animation.
  ///
  /// Defaults to 500 milliseconds.
  final Duration animationDuration;

  /// Determine the [SuggestionBox]'s direction.
  ///
  /// If [AxisDirection.down], the [SuggestionBox] will be below the [TextField]
  /// and the [_SuggestionsList] will grow **down**.
  ///
  /// If [AxisDirection.up], the [SuggestionBox] will be above the [TextField]
  /// and the [_SuggestionsList] will grow **up**.
  ///
  /// [AxisDirection.left] and [AxisDirection.right] are not allowed.
  final AxisDirection direction;

  /// The value at which the [transitionBuilder] animation starts.
  ///
  /// This argument is best used with [transitionBuilder] and [animationDuration]
  /// to fully control the animation.
  ///
  /// Defaults to 0.25.
  final double animationStart;

  /// The configuration of the [CupertinoTextField](https://docs.flutter.io/flutter/cupertino/CupertinoTextField-class.html)
  /// that the TypeAhead widget displays
  final CupertinoTextFieldConfiguration textFieldConfiguration;

  /// How far below the text field should the suggestions box be
  ///
  /// Defaults to 5.0
  final double suggestionsBoxVerticalOffset;

  /// If set to true, suggestions will be fetched immediately when the field is
  /// added to the view.
  ///
  /// But the suggestions box will only be shown when the field receives focus.
  /// To make the field receive focus immediately, you can set the `autofocus`
  /// property in the [textFieldConfiguration] to true
  ///
  /// Defaults to false
  final bool getImmediateSuggestions;

  /// If set to true, no loading box will be shown while suggestions are
  /// being fetched. [loadingBuilder] will also be ignored.
  ///
  /// Defaults to false.
  final bool hideOnLoading;

  /// If set to true, nothing will be shown if there are no results.
  /// [noItemsFoundBuilder] will also be ignored.
  ///
  /// Defaults to false.
  final bool hideOnEmpty;

  /// If set to true, nothing will be shown if there is an error.
  /// [errorBuilder] will also be ignored.
  ///
  /// Defaults to false.
  final bool hideOnError;

  /// If set to false, the suggestions box will stay opened after
  /// the keyboard is closed.
  ///
  /// Defaults to true.
  final bool hideSuggestionsOnKeyboardHide;

  /// If set to false, the suggestions box will show a circular
  /// progress indicator when retrieving suggestions.
  ///
  /// Defaults to true.
  final bool keepSuggestionsOnLoading;

  /// If set to true, the suggestions box will remain opened even after
  /// selecting a suggestion.
  ///
  /// Note that if this is enabled, the only way
  /// to close the suggestions box is either manually via the
  /// `SuggestionsBoxController` or when the user closes the software
  /// keyboard if `hideSuggestionsOnKeyboardHide` is set to true. Users
  /// with a physical keyboard will be unable to close the
  /// box without a manual way via `SuggestionsBoxController`.
  ///
  /// Defaults to false.
  final bool keepSuggestionsOnSuggestionSelected;

  /// If set to true, in the case where the suggestions box has less than
  /// _SuggestionsBoxController.minOverlaySpace to grow in the desired [direction], the direction axis
  /// will be temporarily flipped if there's more room available in the opposite
  /// direction.
  ///
  /// Defaults to false
  final bool autoFlipDirection;

  /// If set to false, suggestion list will not be reversed according to the
  /// [autoFlipDirection] property.
  ///
  /// Defaults to true.
  final bool autoFlipListDirection;

  /// The minimum number of characters which must be entered before
  /// [suggestionsCallback] is triggered.
  ///
  /// Defaults to 0.
  final int minCharsForSuggestions;

  /// If set to true and if the user scrolls through the suggestion list, hide the keyboard automatically.
  /// If set to false, the keyboard remains visible.
  /// Throws an exception, if hideKeyboardOnDrag and hideSuggestionsOnKeyboardHide are both set to true as
  /// they are mutual exclusive.
  ///
  /// Defaults to false
  final bool hideKeyboardOnDrag;

  /// A callback function that notifies the consumer about changes in the visibility of the keyboard.
  ///
  /// This function is invoked whenever there is a change in the keyboard's visibility state:
  /// - If the keyboard becomes visible, the callback is triggered with `true`.
  /// - If the keyboard is hidden, the callback is triggered with `false`.
  ///
  /// This can be used to perform actions based on the keyboard's visibility, such as adjusting the UI,
  /// scrolling the view, or updating the state of related widgets.
  ///
  /// Note: This callback does not directly control the keyboard's visibility but serves as an observer
  /// for visibility changes. It is optional and defaults to null if no action is required on visibility changes.
  final void Function(bool)? onKeyboardFocusChange;

  /// Creates a [CupertinoTypeAheadField]
  const CupertinoTypeAheadField({
    Key? key,
    required this.suggestionsCallback,
    required this.itemBuilder,
    required this.onSuggestionSelected,
    this.textFieldConfiguration = const CupertinoTextFieldConfiguration(),
    this.suggestionsBoxDecoration = const CupertinoSuggestionsBoxDecoration(),
    this.debounceDuration = const Duration(milliseconds: 300),
    this.suggestionsBoxController,
    this.loadingBuilder,
    this.noItemsFoundBuilder,
    this.errorBuilder,
    this.transitionBuilder,
    this.animationStart = 0.25,
    this.animationDuration = const Duration(milliseconds: 500),
    this.getImmediateSuggestions = false,
    this.suggestionsBoxVerticalOffset = 5.0,
    this.direction = AxisDirection.down,
    this.hideOnLoading = false,
    this.hideOnEmpty = false,
    this.hideOnError = false,
    this.hideSuggestionsOnKeyboardHide = true,
    this.keepSuggestionsOnLoading = true,
    this.keepSuggestionsOnSuggestionSelected = false,
    this.autoFlipDirection = false,
    this.autoFlipListDirection = true,
    this.minCharsForSuggestions = 0,
    this.hideKeyboardOnDrag = true,
    this.onKeyboardFocusChange,
  })  : assert(animationStart >= 0.0 && animationStart <= 1.0),
        assert(
            direction == AxisDirection.down || direction == AxisDirection.up),
        assert(minCharsForSuggestions >= 0),
        assert(!hideKeyboardOnDrag ||
            hideKeyboardOnDrag && !hideSuggestionsOnKeyboardHide),
        super(key: key);

  @override
  _CupertinoTypeAheadFieldState<T> createState() =>
      _CupertinoTypeAheadFieldState<T>();
}

class _CupertinoTypeAheadFieldState<T> extends State<CupertinoTypeAheadField<T>>
    with WidgetsBindingObserver {
  FocusNode? _focusNode;
  TextEditingController? _textEditingController;
  CupertinoSuggestionsBox? _suggestionsBox;

  TextEditingController? get _effectiveController =>
      widget.textFieldConfiguration.controller ?? _textEditingController;

  FocusNode? get _effectiveFocusNode =>
      widget.textFieldConfiguration.focusNode ?? _focusNode;
  late VoidCallback _focusNodeListener;

  final LayerLink _layerLink = LayerLink();

  // Timer that resizes the suggestion box on each tick. Only active when the user is scrolling.
  Timer? _resizeOnScrollTimer;

  // The rate at which the suggestion box will resize when the user is scrolling
  final Duration _resizeOnScrollRefreshRate = const Duration(milliseconds: 500);

  // Will have a value if the typeahead is inside a scrollable widget
  ScrollPosition? _scrollPosition;
  // state of the keyboard
  bool _isKeyboardVisible = false;
  // create a stream of bool to check if the keyboard is open
  StreamController<bool> _keyboardVisibilityController =
      StreamController<bool>.broadcast();

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();

    // The 'viewInsets' describe parts of the display that are overlaid, typically by the system UI (e.g. keyboard).
    final bottomInset = WidgetsBinding.instance.window.viewInsets.bottom;

    // If bottomInset > 0, we assume keyboard is open.
    bool newValue = bottomInset > 0.0;
    if (newValue != _isKeyboardVisible) {
      _isKeyboardVisible = newValue;
      _keyboardVisibilityController.add(_isKeyboardVisible);
      widget.onKeyboardFocusChange?.call(_isKeyboardVisible);
    }
    // Catch keyboard event and orientation change; resize suggestions list
    this._suggestionsBox!.onChangeMetrics();
  }

  @override
  void dispose() {
    this._suggestionsBox!.close();
    this._suggestionsBox!.widgetMounted = false;
    WidgetsBinding.instance.removeObserver(this);
    _effectiveFocusNode!.removeListener(_focusNodeListener);
    _focusNode?.dispose();
    _resizeOnScrollTimer?.cancel();
    _scrollPosition?.removeListener(_scrollResizeListener);
    _textEditingController?.dispose();
    _keyboardVisibilityController.close();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    if (widget.textFieldConfiguration.controller == null) {
      this._textEditingController = TextEditingController();
    }

    if (widget.textFieldConfiguration.focusNode == null) {
      this._focusNode = FocusNode();
    }

    this._suggestionsBox = CupertinoSuggestionsBox(
      context,
      widget.direction,
      widget.autoFlipDirection,
      widget.autoFlipListDirection,
    );

    widget.suggestionsBoxController?.suggestionsBox = this._suggestionsBox;
    widget.suggestionsBoxController?.effectiveFocusNode =
        this._effectiveFocusNode;

    this._focusNodeListener = () {
      if (_effectiveFocusNode!.hasFocus) {
        this._suggestionsBox!.open();
      } else {
        this._suggestionsBox!.close();
      }
    };

    this._effectiveFocusNode!.addListener(_focusNodeListener);
    // listen for the keyboard visibility
    // close the suggestion box when the keyboard is hidden
    _keyboardVisibilityController.stream.listen((bool isVisible) {
      if (!isVisible && widget.hideSuggestionsOnKeyboardHide) {
        _effectiveFocusNode!.unfocus();
      }
    });
    WidgetsBinding.instance.addPostFrameCallback((duration) {
      if (mounted) {
        this._initOverlayEntry();
        // calculate initial suggestions list size
        this._suggestionsBox!.resize();

        // in case we already missed the focus event
        if (this._effectiveFocusNode!.hasFocus) {
          this._suggestionsBox!.open();
        }
      }
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final scrollableState = Scrollable.maybeOf(context);
    if (scrollableState != null) {
      // The TypeAheadField is inside a scrollable widget
      _scrollPosition = scrollableState.position;

      _scrollPosition!.removeListener(_scrollResizeListener);
      _scrollPosition!.isScrollingNotifier.addListener(_scrollResizeListener);
    }
  }

  void _scrollResizeListener() {
    bool isScrolling = _scrollPosition!.isScrollingNotifier.value;
    _resizeOnScrollTimer?.cancel();
    if (isScrolling) {
      // Scroll started
      _resizeOnScrollTimer =
          Timer.periodic(_resizeOnScrollRefreshRate, (timer) {
        _suggestionsBox!.resize();
      });
    } else {
      // Scroll finished
      _suggestionsBox!.resize();
    }
  }

  void _initOverlayEntry() {
    this._suggestionsBox!.overlayEntry = OverlayEntry(builder: (context) {
      final suggestionsList = CupertinoSuggestionsList<T>(
        suggestionsBox: _suggestionsBox,
        decoration: widget.suggestionsBoxDecoration,
        debounceDuration: widget.debounceDuration,
        controller: this._effectiveController,
        loadingBuilder: widget.loadingBuilder,
        noItemsFoundBuilder: widget.noItemsFoundBuilder,
        errorBuilder: widget.errorBuilder,
        transitionBuilder: widget.transitionBuilder,
        suggestionsCallback: widget.suggestionsCallback,
        animationDuration: widget.animationDuration,
        animationStart: widget.animationStart,
        getImmediateSuggestions: widget.getImmediateSuggestions,
        onSuggestionSelected: (T selection) {
          if (!widget.keepSuggestionsOnSuggestionSelected) {
            this._effectiveFocusNode!.unfocus();
            this._suggestionsBox!.close();
          }
          widget.onSuggestionSelected(selection);
        },
        itemBuilder: widget.itemBuilder,
        direction: _suggestionsBox!.direction,
        hideOnLoading: widget.hideOnLoading,
        hideOnEmpty: widget.hideOnEmpty,
        hideOnError: widget.hideOnError,
        keepSuggestionsOnLoading: widget.keepSuggestionsOnLoading,
        minCharsForSuggestions: widget.minCharsForSuggestions,
        hideKeyboardOnDrag: widget.hideKeyboardOnDrag,
      );

      double w = _suggestionsBox!.textBoxWidth;
      if (widget.suggestionsBoxDecoration.constraints != null) {
        if (widget.suggestionsBoxDecoration.constraints!.minWidth != 0.0 &&
            widget.suggestionsBoxDecoration.constraints!.maxWidth !=
                double.infinity) {
          w = (widget.suggestionsBoxDecoration.constraints!.minWidth +
                  widget.suggestionsBoxDecoration.constraints!.maxWidth) /
              2;
        } else if (widget.suggestionsBoxDecoration.constraints!.minWidth !=
                0.0 &&
            widget.suggestionsBoxDecoration.constraints!.minWidth > w) {
          w = widget.suggestionsBoxDecoration.constraints!.minWidth;
        } else if (widget.suggestionsBoxDecoration.constraints!.maxWidth !=
                double.infinity &&
            widget.suggestionsBoxDecoration.constraints!.maxWidth < w) {
          w = widget.suggestionsBoxDecoration.constraints!.maxWidth;
        }
      }

      return Positioned(
        width: w,
        child: CompositedTransformFollower(
          link: this._layerLink,
          showWhenUnlinked: false,
          offset: Offset(
              widget.suggestionsBoxDecoration.offsetX,
              _suggestionsBox!.direction == AxisDirection.down
                  ? _suggestionsBox!.textBoxHeight +
                      widget.suggestionsBoxVerticalOffset
                  : _suggestionsBox!.directionUpOffset),
          child: _suggestionsBox!.direction == AxisDirection.down
              ? suggestionsList
              : FractionalTranslation(
                  translation:
                      const Offset(0.0, -1.0), // visually flips list to go up
                  child: suggestionsList,
                ),
        ),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: this._layerLink,
      child: CupertinoTextField(
        controller: this._effectiveController,
        focusNode: this._effectiveFocusNode,
        decoration: widget.textFieldConfiguration.decoration,
        padding: widget.textFieldConfiguration.padding,
        placeholder: widget.textFieldConfiguration.placeholder,
        prefix: widget.textFieldConfiguration.prefix,
        prefixMode: widget.textFieldConfiguration.prefixMode,
        suffix: widget.textFieldConfiguration.suffix,
        suffixMode: widget.textFieldConfiguration.suffixMode,
        clearButtonMode: widget.textFieldConfiguration.clearButtonMode,
        keyboardType: widget.textFieldConfiguration.keyboardType,
        textInputAction: widget.textFieldConfiguration.textInputAction,
        textCapitalization: widget.textFieldConfiguration.textCapitalization,
        style: widget.textFieldConfiguration.style,
        textAlign: widget.textFieldConfiguration.textAlign,
        autofocus: widget.textFieldConfiguration.autofocus,
        obscureText: widget.textFieldConfiguration.obscureText,
        autocorrect: widget.textFieldConfiguration.autocorrect,
        maxLines: widget.textFieldConfiguration.maxLines,
        minLines: widget.textFieldConfiguration.minLines,
        maxLength: widget.textFieldConfiguration.maxLength,
        maxLengthEnforcement:
            widget.textFieldConfiguration.maxLengthEnforcement,
        onChanged: widget.textFieldConfiguration.onChanged,
        onEditingComplete: widget.textFieldConfiguration.onEditingComplete,
        onTap: widget.textFieldConfiguration.onTap,
//         onTapOutside: (_){},
        onSubmitted: widget.textFieldConfiguration.onSubmitted,
        inputFormatters: widget.textFieldConfiguration.inputFormatters,
        enabled: widget.textFieldConfiguration.enabled,
        cursorWidth: widget.textFieldConfiguration.cursorWidth,
        cursorRadius: widget.textFieldConfiguration.cursorRadius,
        cursorColor: widget.textFieldConfiguration.cursorColor,
        keyboardAppearance: widget.textFieldConfiguration.keyboardAppearance,
        scrollPadding: widget.textFieldConfiguration.scrollPadding,
        enableInteractiveSelection:
            widget.textFieldConfiguration.enableInteractiveSelection,
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_typeahead_form_field.dart
================================================
import 'dart:core';

import 'package:flutter/cupertino.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_text_field_configuration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_typeahead_field.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_controller.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_decoration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';

/// A [FormField](https://docs.flutter.io/flutter/widgets/FormField-class.html)
/// implementation of [TypeAheadField], that allows the value to be saved,
/// validated, etc.
///
/// See also:
///
/// * [TypeAheadField], A [CupertinoTextField](https://docs.flutter.io/flutter/cupertino/CupertinoTextField-class.html)
/// that displays a list of suggestions as the user types
class CupertinoTypeAheadFormField<T> extends FormField<String> {
  /// The configuration of the [CupertinoTextField](https://docs.flutter.io/flutter/cupertino/CupertinoTextField-class.html)
  /// that the TypeAhead widget displays
  final CupertinoTextFieldConfiguration textFieldConfiguration;

  /// Creates a [CupertinoTypeAheadFormField]
  CupertinoTypeAheadFormField(
      {Key? key,
      String? initialValue,
      bool getImmediateSuggestions = false,
      @Deprecated('Use autoValidateMode parameter which provides more specific '
          'behavior related to auto validation. '
          'This feature was deprecated after Flutter v1.19.0.')
      bool autovalidate = false,
      bool enabled = true,
      AutovalidateMode? autovalidateMode,
      FormFieldSetter<String>? onSaved,
      FormFieldValidator<String>? validator,
      ErrorBuilder? errorBuilder,
      WidgetBuilder? noItemsFoundBuilder,
      WidgetBuilder? loadingBuilder,
      Duration debounceDuration = const Duration(milliseconds: 300),
      CupertinoSuggestionsBoxDecoration suggestionsBoxDecoration =
          const CupertinoSuggestionsBoxDecoration(),
      CupertinoSuggestionsBoxController? suggestionsBoxController,
      required SuggestionSelectionCallback<T> onSuggestionSelected,
      required ItemBuilder<T> itemBuilder,
      required SuggestionsCallback<T> suggestionsCallback,
      double suggestionsBoxVerticalOffset = 5.0,
      this.textFieldConfiguration = const CupertinoTextFieldConfiguration(),
      AnimationTransitionBuilder? transitionBuilder,
      Duration animationDuration = const Duration(milliseconds: 500),
      double animationStart = 0.25,
      AxisDirection direction = AxisDirection.down,
      bool hideOnLoading = false,
      bool hideOnEmpty = false,
      bool hideOnError = false,
      bool hideSuggestionsOnKeyboardHide = true,
      bool keepSuggestionsOnLoading = true,
      bool keepSuggestionsOnSuggestionSelected = false,
      bool autoFlipDirection = false,
      bool autoFlipListDirection = true,
      int minCharsForSuggestions = 0,
      bool hideKeyboardOnDrag = false})
      : assert(
            initialValue == null || textFieldConfiguration.controller == null),
        assert(minCharsForSuggestions >= 0),
        super(
            key: key,
            onSaved: onSaved,
            validator: validator,
            initialValue: textFieldConfiguration.controller != null
                ? textFieldConfiguration.controller!.text
                : (initialValue ?? ''),
            enabled: enabled,
            autovalidateMode: autovalidateMode,
            builder: (FormFieldState<String> field) {
              final CupertinoTypeAheadFormFieldState state =
                  field as CupertinoTypeAheadFormFieldState<dynamic>;

              return CupertinoTypeAheadField(
                getImmediateSuggestions: getImmediateSuggestions,
                transitionBuilder: transitionBuilder,
                errorBuilder: errorBuilder,
                noItemsFoundBuilder: noItemsFoundBuilder,
                loadingBuilder: loadingBuilder,
                debounceDuration: debounceDuration,
                suggestionsBoxDecoration: suggestionsBoxDecoration,
                suggestionsBoxController: suggestionsBoxController,
                textFieldConfiguration: textFieldConfiguration.copyWith(
                  onChanged: (text) {
                    state.didChange(text);
                    textFieldConfiguration.onChanged?.call(text);
                  },
                  controller: state._effectiveController,
                ),
                suggestionsBoxVerticalOffset: suggestionsBoxVerticalOffset,
                onSuggestionSelected: onSuggestionSelected,
                itemBuilder: itemBuilder,
                suggestionsCallback: suggestionsCallback,
                animationStart: animationStart,
                animationDuration: animationDuration,
                direction: direction,
                hideOnLoading: hideOnLoading,
                hideOnEmpty: hideOnEmpty,
                hideOnError: hideOnError,
                hideSuggestionsOnKeyboardHide: hideSuggestionsOnKeyboardHide,
                keepSuggestionsOnLoading: keepSuggestionsOnLoading,
                keepSuggestionsOnSuggestionSelected:
                    keepSuggestionsOnSuggestionSelected,
                autoFlipDirection: autoFlipDirection,
                autoFlipListDirection: autoFlipListDirection,
                minCharsForSuggestions: minCharsForSuggestions,
                hideKeyboardOnDrag: hideKeyboardOnDrag,
              );
            });

  @override
  CupertinoTypeAheadFormFieldState<T> createState() =>
      CupertinoTypeAheadFormFieldState<T>();
}

class CupertinoTypeAheadFormFieldState<T> extends FormFieldState<String> {
  TextEditingController? _controller;

  TextEditingController? get _effectiveController =>
      widget.textFieldConfiguration.controller ?? _controller;

  @override
  CupertinoTypeAheadFormField get widget =>
      super.widget as CupertinoTypeAheadFormField<dynamic>;

  @override
  void initState() {
    super.initState();
    if (widget.textFieldConfiguration.controller == null) {
      _controller = TextEditingController(text: widget.initialValue);
    } else {
      widget.textFieldConfiguration.controller!
          .addListener(_handleControllerChanged);
    }
  }

  @override
  void didUpdateWidget(CupertinoTypeAheadFormField oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.textFieldConfiguration.controller !=
        oldWidget.textFieldConfiguration.controller) {
      oldWidget.textFieldConfiguration.controller
          ?.removeListener(_handleControllerChanged);
      widget.textFieldConfiguration.controller
          ?.addListener(_handleControllerChanged);

      if (oldWidget.textFieldConfiguration.controller != null &&
          widget.textFieldConfiguration.controller == null) {
        _controller = TextEditingController.fromValue(
            oldWidget.textFieldConfiguration.controller!.value);
      }
      if (widget.textFieldConfiguration.controller != null) {
        setValue(widget.textFieldConfiguration.controller!.text);
        if (oldWidget.textFieldConfiguration.controller == null) {
          _controller = null;
        }
      }
    }
  }

  @override
  void dispose() {
    widget.textFieldConfiguration.controller
        ?.removeListener(_handleControllerChanged);
    super.dispose();
  }

  @override
  void reset() {
    super.reset();
    setState(() {
      _effectiveController!.text = widget.initialValue!;
    });
  }

  void _handleControllerChanged() {
    // Suppress changes that originated from within this class.
    //
    // In the case where a controller has been passed in to this widget, we
    // register this change listener. In these cases, we'll also receive change
    // notifications for changes originating from within this class -- for
    // example, the reset() method. In such cases, the FormField value will
    // already have been set.
    if (_effectiveController!.text != value) {
      didChange(_effectiveController!.text);
    }
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/field/cupertino_typeahead_field.dart';

class CupertinoSuggestionsBox {
  static const int waitMetricsTimeoutMillis = 1000;
  static const double minOverlaySpace = 64.0;

  final BuildContext context;
  final AxisDirection desiredDirection;
  final bool autoFlipDirection;
  final bool autoFlipListDirection;

  OverlayEntry? overlayEntry;
  AxisDirection direction;

  bool isOpened = false;
  bool widgetMounted = true;
  double maxHeight = 300.0;
  double textBoxWidth = 100.0;
  double textBoxHeight = 100.0;
  late double directionUpOffset;

  CupertinoSuggestionsBox(
    this.context,
    this.direction,
    this.autoFlipDirection,
    this.autoFlipListDirection,
  ) : desiredDirection = direction;

  void open() {
    if (isOpened) return;
    assert(overlayEntry != null);
    resize();
    Overlay.of(context).insert(overlayEntry!);
    isOpened = true;
  }

  void close() {
    if (!isOpened) return;
    assert(overlayEntry != null);
    overlayEntry!.remove();
    isOpened = false;
  }

  void toggle() {
    if (isOpened) {
      close();
    } else {
      open();
    }
  }

  MediaQuery? _findRootMediaQuery() {
    MediaQuery? rootMediaQuery;
    context.visitAncestorElements((element) {
      if (element.widget is MediaQuery) {
        rootMediaQuery = element.widget as MediaQuery;
      }
      return true;
    });

    return rootMediaQuery;
  }

  /// Delays until the keyboard has toggled or the orientation has fully changed
  Future<bool> _waitChangeMetrics() async {
    if (widgetMounted) {
      // initial viewInsets which are before the keyboard is toggled
      EdgeInsets initial = MediaQuery.of(context).viewInsets;
      // initial MediaQuery for orientation change
      MediaQuery? initialRootMediaQuery = _findRootMediaQuery();

      int timer = 0;
      // viewInsets or MediaQuery have changed once keyboard has toggled or orientation has changed
      while (widgetMounted && timer < waitMetricsTimeoutMillis) {
        await Future<void>.delayed(const Duration(milliseconds: 170));
        timer += 170;

        if (widgetMounted &&
            (MediaQuery.of(context).viewInsets != initial ||
                _findRootMediaQuery() != initialRootMediaQuery)) {
          return true;
        }
      }
    }

    return false;
  }

  void resize() {
    // check to see if widget is still mounted
    // user may have closed the widget with the keyboard still open
    if (widgetMounted) {
      _adjustMaxHeightAndOrientation();
      overlayEntry!.markNeedsBuild();
    }
  }

  // See if there's enough room in the desired direction for the overlay to display
  // correctly. If not, try the opposite direction if things look more roomy there
  void _adjustMaxHeightAndOrientation() {
    CupertinoTypeAheadField widget = context.widget as CupertinoTypeAheadField;

    RenderBox box = context.findRenderObject() as RenderBox;
    textBoxWidth = box.size.width;
    textBoxHeight = box.size.height;

    // top of text box
    double textBoxAbsY = box.localToGlobal(Offset.zero).dy;

    // height of window
    double windowHeight = MediaQuery.of(context).size.height;

    // we need to find the root MediaQuery for the unsafe area height
    // we cannot use BuildContext.ancestorWidgetOfExactType because
    // widgets like SafeArea creates a new MediaQuery with the padding removed
    MediaQuery rootMediaQuery = _findRootMediaQuery()!;

    // height of keyboard
    double keyboardHeight = rootMediaQuery.data.viewInsets.bottom;

    double maxHDesired = _calculateMaxHeight(desiredDirection, box, widget,
        windowHeight, rootMediaQuery, keyboardHeight, textBoxAbsY);

    // if there's enough room in the desired direction, update the direction and the max height
    if (maxHDesired >= minOverlaySpace || !autoFlipDirection) {
      direction = desiredDirection;
      maxHeight = maxHDesired;
    } else {
      // There's not enough room in the desired direction so see how much room is in the opposite direction
      AxisDirection flipped = flipAxisDirection(desiredDirection);
      double maxHFlipped = _calculateMaxHeight(flipped, box, widget,
          windowHeight, rootMediaQuery, keyboardHeight, textBoxAbsY);

      // if there's more room in this opposite direction, update the direction and maxHeight
      if (maxHFlipped > maxHDesired) {
        direction = flipped;
        maxHeight = maxHFlipped;
      }
    }

    if (maxHeight < 0) maxHeight = 0;
  }

  double _calculateMaxHeight(
      AxisDirection direction,
      RenderBox box,
      CupertinoTypeAheadField widget,
      double windowHeight,
      MediaQuery rootMediaQuery,
      double keyboardHeight,
      double textBoxAbsY) {
    return direction == AxisDirection.down
        ? _calculateMaxHeightDown(box, widget, windowHeight, rootMediaQuery,
            keyboardHeight, textBoxAbsY)
        : _calculateMaxHeightUp(box, widget, windowHeight, rootMediaQuery,
            keyboardHeight, textBoxAbsY);
  }

  double _calculateMaxHeightDown(
      RenderBox box,
      CupertinoTypeAheadField widget,
      double windowHeight,
      MediaQuery rootMediaQuery,
      double keyboardHeight,
      double textBoxAbsY) {
    // unsafe area, ie: iPhone X 'home button'
    // keyboardHeight includes unsafeAreaHeight, if keyboard is showing, set to 0
    double unsafeAreaHeight =
        keyboardHeight == 0 ? rootMediaQuery.data.padding.bottom : 0;

    return windowHeight -
        keyboardHeight -
        unsafeAreaHeight -
        textBoxHeight -
        textBoxAbsY -
        2 * widget.suggestionsBoxVerticalOffset;
  }

  double _calculateMaxHeightUp(
      RenderBox box,
      CupertinoTypeAheadField widget,
      double windowHeight,
      MediaQuery rootMediaQuery,
      double keyboardHeight,
      double textBoxAbsY) {
    // recalculate keyboard absolute y value
    double keyboardAbsY = windowHeight - keyboardHeight;

    directionUpOffset = textBoxAbsY > keyboardAbsY
        ? keyboardAbsY - textBoxAbsY - widget.suggestionsBoxVerticalOffset
        : -widget.suggestionsBoxVerticalOffset;

    // unsafe area, ie: iPhone X notch
    double unsafeAreaHeight = rootMediaQuery.data.padding.top;

    return textBoxAbsY > keyboardAbsY
        ? keyboardAbsY -
            unsafeAreaHeight -
            2 * widget.suggestionsBoxVerticalOffset
        : textBoxAbsY -
            unsafeAreaHeight -
            2 * widget.suggestionsBoxVerticalOffset;
  }

  Future<void> onChangeMetrics() async {
    if (await _waitChangeMetrics()) {
      resize();
    }
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_controller.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/flutter_typeahead.dart';

/// Supply an instance of this class to the [TypeAhead.suggestionsBoxController]
/// property to manually control the suggestions box
class CupertinoSuggestionsBoxController {
  CupertinoSuggestionsBox? suggestionsBox;
  FocusNode? effectiveFocusNode;

  /// Opens the suggestions box
  void open() {
    effectiveFocusNode!.requestFocus();
  }

  /// Closes the suggestions box
  void close() {
    effectiveFocusNode!.unfocus();
  }

  /// Opens the suggestions box if closed and vice-versa
  void toggle() {
    if (suggestionsBox!.isOpened) {
      close();
    } else {
      open();
    }
  }

  /// Recalculates the height of the suggestions box
  void resize() {
    suggestionsBox!.resize();
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_decoration.dart
================================================
import 'package:flutter/cupertino.dart';

/// Supply an instance of this class to the [TypeAhead.suggestionsBoxDecoration]
/// property to configure the suggestions box decoration
class CupertinoSuggestionsBoxDecoration {
  /// Defines if a scrollbar will be displayed or not.
  final bool hasScrollbar;

  /// The constraints to be applied to the suggestions box
  final BoxConstraints? constraints;
  final Color? color;
  final BoxBorder? border;
  final BorderRadiusGeometry? borderRadius;

  /// Adds an offset to the suggestions box
  final double offsetX;

  /// Creates a [CupertinoSuggestionsBoxDecoration]
  const CupertinoSuggestionsBoxDecoration(
      {this.hasScrollbar = true,
      this.constraints,
      this.color,
      this.border,
      this.borderRadius,
      this.offsetX = 0.0});
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_list.dart
================================================
import 'dart:async';
import 'dart:math';

import 'package:flutter/cupertino.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/cupertino/suggestions_box/cupertino_suggestions_box_decoration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';

class CupertinoSuggestionsList<T> extends StatefulWidget {
  final CupertinoSuggestionsBox? suggestionsBox;
  final TextEditingController? controller;
  final bool getImmediateSuggestions;
  final SuggestionSelectionCallback<T>? onSuggestionSelected;
  final SuggestionsCallback<T>? suggestionsCallback;
  final ItemBuilder<T>? itemBuilder;
  final CupertinoSuggestionsBoxDecoration? decoration;
  final Duration? debounceDuration;
  final WidgetBuilder? loadingBuilder;
  final WidgetBuilder? noItemsFoundBuilder;
  final ErrorBuilder? errorBuilder;
  final AnimationTransitionBuilder? transitionBuilder;
  final Duration? animationDuration;
  final double? animationStart;
  final AxisDirection? direction;
  final bool? hideOnLoading;
  final bool? hideOnEmpty;
  final bool? hideOnError;
  final bool? keepSuggestionsOnLoading;
  final int? minCharsForSuggestions;
  final bool hideKeyboardOnDrag;

  const CupertinoSuggestionsList({
    super.key,
    required this.suggestionsBox,
    this.controller,
    this.getImmediateSuggestions = false,
    this.onSuggestionSelected,
    this.suggestionsCallback,
    this.itemBuilder,
    this.decoration,
    this.debounceDuration,
    this.loadingBuilder,
    this.noItemsFoundBuilder,
    this.errorBuilder,
    this.transitionBuilder,
    this.animationDuration,
    this.animationStart,
    this.direction,
    this.hideOnLoading,
    this.hideOnEmpty,
    this.hideOnError,
    this.keepSuggestionsOnLoading,
    this.minCharsForSuggestions,
    this.hideKeyboardOnDrag = false,
  });

  @override
  _CupertinoSuggestionsListState<T> createState() =>
      _CupertinoSuggestionsListState<T>();
}

class _CupertinoSuggestionsListState<T>
    extends State<CupertinoSuggestionsList<T>>
    with SingleTickerProviderStateMixin {
  Iterable<T>? _suggestions;
  late bool _suggestionsValid;
  late VoidCallback _controllerListener;
  Timer? _debounceTimer;
  bool? _isLoading, _isQueued;
  Object? _error;
  AnimationController? _animationController;
  String? _lastTextValue;

  @override
  void didUpdateWidget(CupertinoSuggestionsList<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    _getSuggestions();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _getSuggestions();
  }

  @override
  void initState() {
    super.initState();

    this._animationController = AnimationController(
      vsync: this,
      duration: widget.animationDuration,
    );

    this._suggestionsValid = widget.minCharsForSuggestions! > 0 ? true : false;
    this._isLoading = false;
    this._isQueued = false;
    this._lastTextValue = widget.controller!.text;

    if (widget.getImmediateSuggestions) {
      this._getSuggestions();
    }

    this._controllerListener = () {
      // If we came here because of a change in selected text, not because of
      // actual change in text
      if (widget.controller!.text == this._lastTextValue) return;

      this._lastTextValue = widget.controller!.text;

      this._debounceTimer?.cancel();
      if (widget.controller!.text.length < widget.minCharsForSuggestions!) {
        if (mounted) {
          setState(() {
            _isLoading = false;
            _suggestions = null;
            _suggestionsValid = true;
          });
        }
        return;
      } else {
        this._debounceTimer = Timer(widget.debounceDuration!, () async {
          if (this._debounceTimer!.isActive) return;
          if (_isLoading!) {
            _isQueued = true;
            return;
          }

          await this.invalidateSuggestions();
          while (_isQueued!) {
            _isQueued = false;
            await this.invalidateSuggestions();
          }
        });
      }
    };

    widget.controller!.addListener(this._controllerListener);
  }

  Future<void> invalidateSuggestions() async {
    _suggestionsValid = false;
    _getSuggestions();
  }

  Future<void> _getSuggestions() async {
    if (_suggestionsValid) return;
    _suggestionsValid = true;

    if (mounted) {
      setState(() {
        this._animationController!.forward(from: 1.0);

        this._isLoading = true;
        this._error = null;
      });

      Iterable<T>? suggestions;
      Object? error;

      try {
        suggestions =
            await widget.suggestionsCallback!(widget.controller!.text);
      } catch (e) {
        error = e;
      }

      if (mounted) {
        // if it wasn't removed in the meantime
        setState(() {
          double? animationStart = widget.animationStart;
          // allow suggestionsCallback to return null and not throw error here
          if (error != null || suggestions?.isEmpty == true) {
            animationStart = 1.0;
          }
          this._animationController!.forward(from: animationStart);

          this._error = error;
          this._isLoading = false;
          this._suggestions = suggestions;
        });
      }
    }
  }

  @override
  void dispose() {
    _animationController!.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    bool isEmpty = this._suggestions != null
        ? this._suggestions!.isEmpty && widget.controller!.text == ""
        : true;
    if ((this._suggestions == null || isEmpty) && this._isLoading == false) {
      return Container();
    }

    Widget child;
    if (this._isLoading!) {
      if (widget.hideOnLoading!) {
        child = Container(height: 0);
      } else {
        child = createLoadingWidget();
      }
    } else if (this._error != null) {
      if (widget.hideOnError!) {
        child = Container(height: 0);
      } else {
        child = createErrorWidget();
      }
    } else if (this._suggestions!.isEmpty) {
      if (widget.hideOnEmpty!) {
        child = Container(height: 0);
      } else {
        child = createNoItemsFoundWidget();
      }
    } else {
      child = createSuggestionsWidget();
    }

    var animationChild = widget.transitionBuilder != null
        ? widget.transitionBuilder!(context, child, this._animationController)
        : SizeTransition(
            axisAlignment: -1.0,
            sizeFactor: CurvedAnimation(
                parent: this._animationController!,
                curve: Curves.fastOutSlowIn),
            child: child,
          );

    BoxConstraints constraints;
    if (widget.decoration!.constraints == null) {
      constraints = BoxConstraints(
        maxHeight: widget.suggestionsBox!.maxHeight,
      );
    } else {
      double maxHeight = min(widget.decoration!.constraints!.maxHeight,
          widget.suggestionsBox!.maxHeight);
      constraints = widget.decoration!.constraints!.copyWith(
        minHeight: min(widget.decoration!.constraints!.minHeight, maxHeight),
        maxHeight: maxHeight,
      );
    }

    return ConstrainedBox(
      constraints: constraints,
      child: animationChild,
    );
  }

  Widget createLoadingWidget() {
    Widget child;

    if (widget.keepSuggestionsOnLoading! && this._suggestions != null) {
      if (this._suggestions!.isEmpty) {
        child = createNoItemsFoundWidget();
      } else {
        child = createSuggestionsWidget();
      }
    } else {
      child = widget.loadingBuilder != null
          ? widget.loadingBuilder!(context)
          : Container(
              decoration: BoxDecoration(
                color: CupertinoColors.white,
                border: Border.all(
                  color: CupertinoColors.extraLightBackgroundGray,
                  width: 1.0,
                ),
              ),
              child: const Align(
                alignment: Alignment.center,
                child: Padding(
                  padding: EdgeInsets.symmetric(vertical: 8.0),
                  child: CupertinoActivityIndicator(),
                ),
              ),
            );
    }

    return child;
  }

  Widget createErrorWidget() {
    return widget.errorBuilder != null
        ? widget.errorBuilder!(context, this._error)
        : Container(
            decoration: BoxDecoration(
              color: CupertinoColors.white,
              border: Border.all(
                color: CupertinoColors.extraLightBackgroundGray,
                width: 1.0,
              ),
            ),
            child: Padding(
              padding: const EdgeInsets.all(4.0),
              child: Text(
                'Error: ${this._error}',
                textAlign: TextAlign.start,
                style: const TextStyle(
                  color: CupertinoColors.destructiveRed,
                  fontSize: 18.0,
                ),
              ),
            ),
          );
  }

  Widget createNoItemsFoundWidget() {
    return widget.noItemsFoundBuilder != null
        ? widget.noItemsFoundBuilder!(context)
        : Container(
            decoration: BoxDecoration(
              color: CupertinoColors.white,
              border: Border.all(
                color: CupertinoColors.extraLightBackgroundGray,
                width: 1.0,
              ),
            ),
            child: const Padding(
              padding: EdgeInsets.all(4.0),
              child: Text(
                'No Items Found!',
                textAlign: TextAlign.start,
                style: TextStyle(
                  color: CupertinoColors.inactiveGray,
                  fontSize: 18.0,
                ),
              ),
            ),
          );
  }

  Widget createSuggestionsWidget() {
    Widget child = Container(
      decoration: BoxDecoration(
        color: widget.decoration!.color ?? CupertinoColors.white,
        border: widget.decoration!.border ??
            Border.all(
              color: CupertinoColors.extraLightBackgroundGray,
              width: 1.0,
            ),
        borderRadius: widget.decoration!.borderRadius,
      ),
      child: ListView(
        padding: EdgeInsets.zero,
        primary: false,
        shrinkWrap: true,
        keyboardDismissBehavior: widget.hideKeyboardOnDrag
            ? ScrollViewKeyboardDismissBehavior.onDrag
            : ScrollViewKeyboardDismissBehavior.manual,
        reverse: widget.suggestionsBox!.direction == AxisDirection.down
            ? false
            : widget.suggestionsBox!.autoFlipListDirection,
        children: this._suggestions!.map((T suggestion) {
          return GestureDetector(
            behavior: HitTestBehavior.translucent,
            child: widget.itemBuilder!(context, suggestion),
            onTap: () {
              widget.onSuggestionSelected!(suggestion);
            },
          );
        }).toList(),
      ),
    );

    if (widget.decoration!.hasScrollbar) {
      child = CupertinoScrollbar(child: child);
    }

    return child;
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/field/text_field_configuration.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// Supply an instance of this class to the [TypeAhead.textFieldConfiguration]
/// property to configure the displayed text field
class TextFieldConfiguration {
  /// The decoration to show around the text field.
  ///
  /// Same as [TextField.decoration](https://docs.flutter.io/flutter/material/TextField/decoration.html)
  final InputDecoration decoration;

  /// Controls the text being edited.
  ///
  /// If null, this widget will create its own [TextEditingController](https://docs.flutter.io/flutter/widgets/TextEditingController-class.html).
  /// A typical use case for this field in the TypeAhead widget is to set the
  /// text of the widget when a suggestion is selected. For example:
  ///
  /// ```dart
  /// final _controller = TextEditingController();
  /// ...
  /// ...
  /// TypeAheadField(
  ///   controller: _controller,
  ///   ...
  ///   ...
  ///   onSuggestionSelected: (suggestion) {
  ///     _controller.text = suggestion['city_name'];
  ///   }
  /// )
  /// ```
  final TextEditingController? controller;

  /// Controls whether this widget has keyboard focus.
  ///
  /// Same as [TextField.focusNode](https://docs.flutter.io/flutter/material/TextField/focusNode.html)
  final FocusNode? focusNode;

  /// The style to use for the text being edited.
  ///
  /// Same as [TextField.style](https://docs.flutter.io/flutter/material/TextField/style.html)
  final TextStyle? style;

  /// How the text being edited should be aligned horizontally.
  ///
  /// Same as [TextField.textAlign](https://docs.flutter.io/flutter/material/TextField/textAlign.html)
  final TextAlign textAlign;

  /// Same as [TextField.textDirection](https://docs.flutter.io/flutter/material/TextField/textDirection.html)
  ///
  /// Defaults to null
  final TextDirection? textDirection;

  /// Same as [TextField.textAlignVertical](https://api.flutter.dev/flutter/material/TextField/textAlignVertical.html)
  final TextAlignVertical? textAlignVertical;

  /// If false the textfield is "disabled": it ignores taps and its
  /// [decoration] is rendered in grey.
  ///
  /// Same as [TextField.enabled](https://docs.flutter.io/flutter/material/TextField/enabled.html)
  final bool enabled;

  /// Whether to show input suggestions as the user types.
  ///
  /// Same as [TextField.enableSuggestions](https://api.flutter.dev/flutter/material/TextField/enableSuggestions.html)
  final bool enableSuggestions;

  /// The type of keyboard to use for editing the text.
  ///
  /// Same as [TextField.keyboardType](https://docs.flutter.io/flutter/material/TextField/keyboardType.html)
  final TextInputType keyboardType;

  /// Whether this text field should focus itself if nothing else is already
  /// focused.
  ///
  /// Same as [TextField.autofocus](https://docs.flutter.io/flutter/material/TextField/autofocus.html)
  final bool autofocus;

  /// Optional input validation and formatting overrides.
  ///
  /// Same as [TextField.inputFormatters](https://docs.flutter.io/flutter/material/TextField/inputFormatters.html)
  final List<TextInputFormatter>? inputFormatters;

  /// Whether to enable autocorrection.
  ///
  /// Same as [TextField.autocorrect](https://docs.flutter.io/flutter/material/TextField/autocorrect.html)
  final bool autocorrect;

  /// The maximum number of lines for the text to span, wrapping if necessary.
  ///
  /// Same as [TextField.maxLines](https://docs.flutter.io/flutter/material/TextField/maxLines.html)
  final int? maxLines;

  /// The minimum number of lines to occupy when the content spans fewer lines.
  ///
  /// Same as [TextField.minLines](https://docs.flutter.io/flutter/material/TextField/minLines.html)
  final int? minLines;

  /// The maximum number of characters (Unicode scalar values) to allow in the
  /// text field.
  ///
  /// Same as [TextField.maxLength](https://docs.flutter.io/flutter/material/TextField/maxLength.html)
  final int? maxLength;

  /// If true, prevents the field from allowing more than [maxLength]
  /// characters.
  ///
  /// Same as [TextField.maxLengthEnforcement](https://api.flutter.dev/flutter/material/TextField/maxLengthEnforcement.html)
  final MaxLengthEnforcement? maxLengthEnforcement;

  /// Whether to hide the text being edited (e.g., for passwords).
  ///
  /// Same as [TextField.obscureText](https://docs.flutter.io/flutter/material/TextField/obscureText.html)
  final bool obscureText;

  /// Called when the text being edited changes.
  ///
  /// Same as [TextField.onChanged](https://docs.flutter.io/flutter/material/TextField/onChanged.html)
  final ValueChanged<String>? onChanged;

  /// Called when the user indicates that they are done editing the text in the
  /// field.
  ///
  /// Same as [TextField.onSubmitted](https://docs.flutter.io/flutter/material/TextField/onSubmitted.html)
  final ValueChanged<String>? onSubmitted;

  /// The color to use when painting the cursor.
  ///
  /// Same as [TextField.cursorColor](https://docs.flutter.io/flutter/material/TextField/cursorColor.html)
  final Color? cursorColor;

  /// How rounded the corners of the cursor should be. By default, the cursor has a null Radius
  ///
  /// Same as [TextField.cursorRadius](https://docs.flutter.io/flutter/material/TextField/cursorRadius.html)
  final Radius? cursorRadius;

  /// How thick the cursor will be.
  ///
  /// Same as [TextField.cursorWidth](https://docs.flutter.io/flutter/material/TextField/cursorWidth.html)
  final double cursorWidth;

  /// The appearance of the keyboard.
  ///
  /// Same as [TextField.keyboardAppearance](https://docs.flutter.io/flutter/material/TextField/keyboardAppearance.html)
  final Brightness? keyboardAppearance;

  /// Called when the user submits editable content (e.g., user presses the "done" button on the keyboard).
  ///
  /// Same as [TextField.onEditingComplete](https://docs.flutter.io/flutter/material/TextField/onEditingComplete.html)
  final VoidCallback? onEditingComplete;

  /// Called for each distinct tap except for every second tap of a double tap.
  ///
  /// Same as [TextField.onTap](https://docs.flutter.io/flutter/material/TextField/onTap.html)
  final GestureTapCallback? onTap;

  /// Configures padding to edges surrounding a Scrollable when the Textfield scrolls into view.
  ///
  /// Same as [TextField.scrollPadding](https://docs.flutter.io/flutter/material/TextField/scrollPadding.html)
  final EdgeInsets scrollPadding;

  /// Configures how the platform keyboard will select an uppercase or lowercase keyboard.
  ///
  /// Same as [TextField.TextCapitalization](https://docs.flutter.io/flutter/material/TextField/textCapitalization.html)
  final TextCapitalization textCapitalization;

  /// The type of action button to use for the keyboard.
  ///
  /// Same as [TextField.textInputAction](https://docs.flutter.io/flutter/material/TextField/textInputAction.html)
  final TextInputAction? textInputAction;

  final bool enableInteractiveSelection;

  /// Creates a TextFieldConfiguration
  const TextFieldConfiguration({
    this.decoration = const InputDecoration(),
    this.style,
    this.controller,
    this.onChanged,
    this.onSubmitted,
    this.obscureText = false,
    this.maxLengthEnforcement,
    this.maxLength,
    this.maxLines = 1,
    this.minLines,
    this.textAlignVertical,
    this.autocorrect = true,
    this.inputFormatters,
    this.autofocus = false,
    this.keyboardType = TextInputType.text,
    this.enabled = true,
    this.enableSuggestions = true,
    this.textAlign = TextAlign.start,
    this.focusNode,
    this.cursorColor,
    this.cursorRadius,
    this.textInputAction,
    this.textCapitalization = TextCapitalization.none,
    this.cursorWidth = 2.0,
    this.keyboardAppearance,
    this.onEditingComplete,
    this.onTap,
    this.textDirection,
    this.scrollPadding = const EdgeInsets.all(20.0),
    this.enableInteractiveSelection = true,
  });

  /// Copies the [TextFieldConfiguration] and only changes the specified
  /// properties
  TextFieldConfiguration copyWith(
      {InputDecoration? decoration,
      TextStyle? style,
      TextEditingController? controller,
      ValueChanged<String>? onChanged,
      ValueChanged<String>? onSubmitted,
      bool? obscureText,
      MaxLengthEnforcement? maxLengthEnforcement,
      int? maxLength,
      int? maxLines,
      int? minLines,
      bool? autocorrect,
      List<TextInputFormatter>? inputFormatters,
      bool? autofocus,
      TextInputType? keyboardType,
      bool? enabled,
      bool? enableSuggestions,
      TextAlign? textAlign,
      FocusNode? focusNode,
      Color? cursorColor,
      TextAlignVertical? textAlignVertical,
      Radius? cursorRadius,
      double? cursorWidth,
      Brightness? keyboardAppearance,
      VoidCallback? onEditingComplete,
      GestureTapCallback? onTap,
      EdgeInsets? scrollPadding,
      TextCapitalization? textCapitalization,
      TextDirection? textDirection,
      TextInputAction? textInputAction,
      bool? enableInteractiveSelection}) {
    return TextFieldConfiguration(
      decoration: decoration ?? this.decoration,
      style: style ?? this.style,
      controller: controller ?? this.controller,
      onChanged: onChanged ?? this.onChanged,
      onSubmitted: onSubmitted ?? this.onSubmitted,
      obscureText: obscureText ?? this.obscureText,
      maxLengthEnforcement: maxLengthEnforcement ?? this.maxLengthEnforcement,
      maxLength: maxLength ?? this.maxLength,
      maxLines: maxLines ?? this.maxLines,
      minLines: minLines ?? this.minLines,
      autocorrect: autocorrect ?? this.autocorrect,
      inputFormatters: inputFormatters ?? this.inputFormatters,
      autofocus: autofocus ?? this.autofocus,
      keyboardType: keyboardType ?? this.keyboardType,
      enabled: enabled ?? this.enabled,
      enableSuggestions: enableSuggestions ?? this.enableSuggestions,
      textAlign: textAlign ?? this.textAlign,
      textAlignVertical: textAlignVertical ?? this.textAlignVertical,
      focusNode: focusNode ?? this.focusNode,
      cursorColor: cursorColor ?? this.cursorColor,
      cursorRadius: cursorRadius ?? this.cursorRadius,
      cursorWidth: cursorWidth ?? this.cursorWidth,
      keyboardAppearance: keyboardAppearance ?? this.keyboardAppearance,
      onEditingComplete: onEditingComplete ?? this.onEditingComplete,
      onTap: onTap ?? this.onTap,
      scrollPadding: scrollPadding ?? this.scrollPadding,
      textCapitalization: textCapitalization ?? this.textCapitalization,
      textInputAction: textInputAction ?? this.textInputAction,
      textDirection: textDirection ?? this.textDirection,
      enableInteractiveSelection:
          enableInteractiveSelection ?? this.enableInteractiveSelection,
    );
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/field/typeahead_field.dart
================================================
// ignore_for_file: deprecated_member_use

import 'dart:async';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/field/text_field_configuration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/keyboard_suggestion_selection_notifier.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/should_refresh_suggestion_focus_index_notifier.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_controller.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_decoration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_list.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';
import 'package:extended_text_field/extended_text_field.dart';

/// # Flutter TypeAhead
/// A TypeAhead widget for Flutter, where you can show suggestions to
/// users as they type
///
/// ## Features
/// * Shows suggestions in an overlay that floats on top of other widgets
/// * Allows you to specify what the suggestions will look like through a
/// builder function
/// * Allows you to specify what happens when the user taps a suggestion
/// * Accepts all the parameters that traditional TextFields accept, like
/// decoration, custom TextEditingController, text styling, etc.
/// * Provides two versions, a normal version and a [FormField](https://docs.flutter.io/flutter/widgets/FormField-class.html)
/// version that accepts validation, submitting, etc.
/// * Provides high customizability; you can customize the suggestion box decoration,
/// the loading bar, the animation, the debounce duration, etc.
///
/// ## Installation
/// See the [installation instructions on pub](https://pub.dartlang.org/packages/flutter_typeahead#-installing-tab-).
///
/// ## Usage examples
/// You can import the package with:
/// ```dart
/// import 'package:flutter_typeahead/flutter_typeahead.dart';
/// ```
///
/// and then use it as follows:
///
/// ### Example 1:
/// ```dart
/// TypeAheadField(
///   textFieldConfiguration: TextFieldConfiguration(
///     autofocus: true,
///     style: DefaultTextStyle.of(context).style.copyWith(
///       fontStyle: FontStyle.italic
///     ),
///     decoration: InputDecoration(
///       border: OutlineInputBorder()
///     )
///   ),
///   suggestionsCallback: (pattern) async {
///     return await BackendService.getSuggestions(pattern);
///   },
///   itemBuilder: (context, suggestion) {
///     return ListTile(
///       leading: Icon(Icons.shopping_cart),
///       title: Text(suggestion['name']),
///       subtitle: Text('\$${suggestion['price']}'),
///     );
///   },
///   onSuggestionSelected: (suggestion) {
///     Navigator.of(context).push(MaterialPageRoute(
///       builder: (context) => ProductPage(product: suggestion)
///     ));
///   },
/// )
/// ```
/// In the code above, the `textFieldConfiguration` property allows us to
/// configure the displayed `TextField` as we want. In this example, we are
/// configuring the `autofocus`, `style` and `decoration` properties.
///
/// The `suggestionsCallback` is called with the search string that the user
/// types, and is expected to return a `List` of data either synchronously or
/// asynchronously. In this example, we are calling an asynchronous function
/// called `BackendService.getSuggestions` which fetches the list of
/// suggestions.
///
/// The `itemBuilder` is called to build a widget for each suggestion.
/// In this example, we build a simple `ListTile` that shows the name and the
/// price of the item. Please note that you shouldn't provide an `onTap`
/// callback here. The TypeAhead widget takes care of that.
///
/// The `onSuggestionSelected` is a callback called when the user taps a
/// suggestion. In this example, when the user taps a
/// suggestion, we navigate to a page that shows us the information of the
/// tapped product.
///
/// ### Example 2:
/// Here's another example, where we use the TypeAheadFormField inside a `Form`:
/// ```dart
/// final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
/// final TextEditingController _typeAheadController = TextEditingController();
/// String _selectedCity;
/// ...
/// Form(
///   key: this._formKey,
///   child: Padding(
///     padding: EdgeInsets.all(32.0),
///     child: Column(
///       children: <Widget>[
///         Text(
///           'What is your favorite city?'
///         ),
///         TypeAheadFormField(
///           textFieldConfiguration: TextFieldConfiguration(
///             controller: this._typeAheadController,
///             decoration: InputDecoration(
///               labelText: 'City'
///             )
///           ),
///           suggestionsCallback: (pattern) {
///             return CitiesService.getSuggestions(pattern);
///           },
///           itemBuilder: (context, suggestion) {
///             return ListTile(
///               title: Text(suggestion),
///             );
///           },
///           transitionBuilder: (context, suggestionsBox, controller) {
///             return suggestionsBox;
///           },
///           onSuggestionSelected: (suggestion) {
///             this._typeAheadController.text = suggestion;
///           },
///           validator: (value) {
///             if (value.isEmpty) {
///               return 'Please select a city';
///             }
///           },
///           onSaved: (value) => this._selectedCity = value,
///         ),
///         SizedBox(height: 10.0,),
///         RaisedButton(
///           child: Text('Submit'),
///           onPressed: () {
///             if (this._formKey.currentState.validate()) {
///               this._formKey.currentState.save();
///               Scaffold.of(context).showSnackBar(LMChatSnackBar(
///                 content: Text('Your Favorite City is ${this._selectedCity}')
///               ));
///             }
///           },
///         )
///       ],
///     ),
///   ),
/// )
/// ```
/// Here, we assign to the `controller` property of the `textFieldConfiguration`
/// a `TextEditingController` that we call `_typeAheadController`.
/// We use this controller in the `onSuggestionSelected` callback to set the
/// value of the `TextField` to the selected suggestion.
///
/// The `validator` callback can be used like any `FormField.validator`
/// function. In our example, it checks whether a value has been entered,
/// and displays an error message if not. The `onSaved` callback is used to
/// save the value of the field to the `_selectedCity` member variable.
///
/// The `transitionBuilder` allows us to customize the animation of the
/// suggestion box. In this example, we are returning the suggestionsBox
/// immediately, meaning that we don't want any animation.
///
/// ## Customizations
/// TypeAhead widgets consist of a TextField and a suggestion box that shows
/// as the user types. Both are highly customizable
///
/// ### Customizing the TextField
/// You can customize the text field using the `textFieldConfiguration` property.
/// You provide this property with an instance of `TextFieldConfiguration`,
/// which allows you to configure all the usual properties of `TextField`, like
/// `decoration`, `style`, `controller`, `focusNode`, `autofocus`, `enabled`,
/// etc.
///
/// ### Customizing the Suggestions Box
/// TypeAhead provides default configurations for the suggestions box. You can,
/// however, override most of them.
///
/// #### Customizing the loader, the error and the "no items found" message
/// You can use the [loadingBuilder], [errorBuilder] and [noItemsFoundBuilder] to
/// customize their corresponding widgets. For example, to show a custom error
/// widget:
/// ```dart
/// errorBuilder: (BuildContext context, Object error) =>
///   Text(
///     '$error',
///     style: TextStyle(
///       color: Theme.of(context).errorColor
///     )
///   )
/// ```
/// #### Customizing the animation
/// You can customize the suggestion box animation through 3 parameters: the
/// `animationDuration`, the `animationStart`, and the `transitionBuilder`.
///
/// The `animationDuration` specifies how long the animation should take, while the
/// `animationStart` specified what point (between 0.0 and 1.0) the animation
/// should start from. The `transitionBuilder` accepts the `suggestionsBox` and
/// `animationController` as parameters, and should return a widget that uses
/// the `animationController` to animate the display of the `suggestionsBox`.
/// For example:
/// ```dart
/// transitionBuilder: (context, suggestionsBox, animationController) =>
///   FadeTransition(
///     child: suggestionsBox,
///     opacity: CurvedAnimation(
///       parent: animationController,
///       curve: Curves.fastOutSlowIn
///     ),
///   )
/// ```
/// This uses [FadeTransition](https://docs.flutter.io/flutter/widgets/FadeTransition-class.html)
/// to fade the `suggestionsBox` into the view. Note how the
/// `animationController` was provided as the parent of the animation.
///
/// In order to fully remove the animation, `transitionBuilder` should simply
/// return the `suggestionsBox`. This callback could also be used to wrap the
/// `suggestionsBox` with any desired widgets, not necessarily for animation.
///
/// #### Customizing the debounce duration
/// The suggestions box does not fire for each character the user types. Instead,
/// we wait until the user is idle for a duration of time, and then call the
/// `suggestionsCallback`. The duration defaults to 300 milliseconds, but can be
/// configured using the `debounceDuration` parameter.
///
/// #### Customizing the offset of the suggestions box
/// By default, the suggestions box is displayed 5 pixels below the `TextField`.
/// You can change this by changing the `suggestionsBoxVerticalOffset` property.
///
/// #### Customizing the decoration of the suggestions box
/// You can also customize the decoration of the suggestions box using the
/// `suggestionsBoxDecoration` property. For example, to remove the elevation
/// of the suggestions box, you can write:
/// ```dart
/// suggestionsBoxDecoration: SuggestionsBoxDecoration(
///   elevation: 0.0
/// )
/// ```
/// A [FormField](https://docs.flutter.io/flutter/widgets/FormField-class.html)
/// implementation of [TypeAheadField], that allows the value to be saved,
/// validated, etc.
///
/// See also:
///
/// * [TypeAheadField], A [TextField](https://docs.flutter.io/flutter/material/TextField-class.html)
/// that displays a list of suggestions as the user types
class TypeAheadField<T> extends StatefulWidget {
  /// Called with the search pattern to get the search suggestions.
  ///
  /// This callback must not be null. It is be called by the TypeAhead widget
  /// and provided with the search pattern. It should return a [List](https://api.dartlang.org/stable/2.0.0/dart-core/List-class.html)
  /// of suggestions either synchronously, or asynchronously (as the result of a
  /// [Future](https://api.dartlang.org/stable/dart-async/Future-class.html)).
  /// Typically, the list of suggestions should not contain more than 4 or 5
  /// entries. These entries will then be provided to [itemBuilder] to display
  /// the suggestions.
  ///
  /// Example:
  /// ```dart
  /// suggestionsCallback: (pattern) async {
  ///   return await _getSuggestions(pattern);
  /// }
  /// ```
  final SuggestionsCallback<T> suggestionsCallback;

  /// Called when a suggestion is tapped.
  ///
  /// This callback must not be null. It is called by the TypeAhead widget and
  /// provided with the value of the tapped suggestion.
  ///
  /// For example, you might want to navigate to a specific view when the user
  /// tabs a suggestion:
  /// ```dart
  /// onSuggestionSelected: (suggestion) {
  ///   Navigator.of(context).push(MaterialPageRoute(
  ///     builder: (context) => SearchResult(
  ///       searchItem: suggestion
  ///     )
  ///   ));
  /// }
  /// ```
  ///
  /// Or to set the value of the text field:
  /// ```dart
  /// onSuggestionSelected: (suggestion) {
  ///   _controller.text = suggestion['name'];
  /// }
  /// ```
  final SuggestionSelectionCallback<T> onSuggestionSelected;

  /// Called for each suggestion returned by [suggestionsCallback] to build the
  /// corresponding widget.
  ///
  /// This callback must not be null. It is called by the TypeAhead widget for
  /// each suggestion, and expected to build a widget to display this
  /// suggestion's info. For example:
  ///
  /// ```dart
  /// itemBuilder: (context, suggestion) {
  ///   return ListTile(
  ///     title: Text(suggestion['name']),
  ///     subtitle: Text('USD' + suggestion['price'].toString())
  ///   );
  /// }
  /// ```
  final ItemBuilder<T> itemBuilder;

  /// used to control the scroll behavior of item-builder list
  final ScrollController? scrollController;

  /// The decoration of the material sheet that contains the suggestions.
  ///
  /// If null, default decoration with an elevation of 4.0 is used
  ///

  final SuggestionsBoxDecoration suggestionsBoxDecoration;

  /// Used to control the `_SuggestionsBox`. Allows manual control to
  /// open, close, toggle, or resize the `_SuggestionsBox`.
  final SuggestionsBoxController? suggestionsBoxController;

  /// The duration to wait after the user stops typing before calling
  /// [suggestionsCallback]
  ///
  /// This is useful, because, if not set, a request for suggestions will be
  /// sent for every character that the user types.
  ///
  /// This duration is set by default to 300 milliseconds
  final Duration debounceDuration;

  /// Called when waiting for [suggestionsCallback] to return.
  ///
  /// It is expected to return a widget to display while waiting.
  /// For example:
  /// ```dart
  /// (BuildContext context) {
  ///   return Text('Loading...');
  /// }
  /// ```
  ///
  /// If not specified, a [CircularProgressIndicator](https://docs.flutter.io/flutter/material/CircularProgressIndicator-class.html) is shown
  final WidgetBuilder? loadingBuilder;

  /// Called when [suggestionsCallback] returns an empty array.
  ///
  /// It is expected to return a widget to display when no suggestions are
  /// avaiable.
  /// For example:
  /// ```dart
  /// (BuildContext context) {
  ///   return Text('No Items Found!');
  /// }
  /// ```
  ///
  /// If not specified, a simple text is shown
  final WidgetBuilder? noItemsFoundBuilder;

  /// Called when [suggestionsCallback] throws an exception.
  ///
  /// It is called with the error object, and expected to return a widget to
  /// display when an exception is thrown
  /// For example:
  /// ```dart
  /// (BuildContext context, error) {
  ///   return Text('$error');
  /// }
  /// ```
  ///
  /// If not specified, the error is shown in [ThemeData.errorColor](https://docs.flutter.io/flutter/material/ThemeData/errorColor.html)
  final ErrorBuilder? errorBuilder;

  /// Called to display animations when [suggestionsCallback] returns suggestions
  ///
  /// It is provided with the suggestions box instance and the animation
  /// controller, and expected to return some animation that uses the controller
  /// to display the suggestion box.
  ///
  /// For example:
  /// ```dart
  /// transitionBuilder: (context, suggestionsBox, animationController) {
  ///   return FadeTransition(
  ///     child: suggestionsBox,
  ///     opacity: CurvedAnimation(
  ///       parent: animationController,
  ///       curve: Curves.fastOutSlowIn
  ///     ),
  ///   );
  /// }
  /// ```
  /// This argument is best used with [animationDuration] and [animationStart]
  /// to fully control the animation.
  ///
  /// To fully remove the animation, just return `suggestionsBox`
  ///
  /// If not specified, a [SizeTransition](https://docs.flutter.io/flutter/widgets/SizeTransition-class.html) is shown.
  final AnimationTransitionBuilder? transitionBuilder;

  /// The duration that [transitionBuilder] animation takes.
  ///
  /// This argument is best used with [transitionBuilder] and [animationStart]
  /// to fully control the animation.
  ///
  /// Defaults to 500 milliseconds.
  final Duration animationDuration;

  /// Determine the [SuggestionBox]'s direction.
  ///
  /// If [AxisDirection.down], the [SuggestionBox] will be below the [TextField]
  /// and the [_SuggestionsList] will grow **down**.
  ///
  /// If [AxisDirection.up], the [SuggestionBox] will be above the [TextField]
  /// and the [_SuggestionsList] will grow **up**.
  ///
  /// [AxisDirection.left] and [AxisDirection.right] are not allowed.
  final AxisDirection direction;

  /// The value at which the [transitionBuilder] animation starts.
  ///
  /// This argument is best used with [transitionBuilder] and [animationDuration]
  /// to fully control the animation.
  ///
  /// Defaults to 0.25.
  final double animationStart;

  /// The configuration of the [TextField](https://docs.flutter.io/flutter/material/TextField-class.html)
  /// that the TypeAhead widget displays
  final TextFieldConfiguration textFieldConfiguration;

  final ScrollPhysics scrollPhysics;

  /// How far below the text field should the suggestions box be
  ///
  /// Defaults to 5.0
  final double suggestionsBoxVerticalOffset;

  /// If set to true, suggestions will be fetched immediately when the field is
  /// added to the view.
  ///
  /// But the suggestions box will only be shown when the field receives focus.
  /// To make the field receive focus immediately, you can set the `autofocus`
  /// property in the [textFieldConfiguration] to true
  ///
  /// Defaults to false
  final bool getImmediateSuggestions;

  /// If set to true, no loading box will be shown while suggestions are
  /// being fetched. [loadingBuilder] will also be ignored.
  ///
  /// Defaults to false.
  final bool hideOnLoading;

  /// If set to true, nothing will be shown if there are no results.
  /// [noItemsFoundBuilder] will also be ignored.
  ///
  /// Defaults to false.
  final bool hideOnEmpty;

  /// If set to true, nothing will be shown if there is an error.
  /// [errorBuilder] will also be ignored.
  ///
  /// Defaults to false.
  final bool hideOnError;

  /// If set to false, the suggestions box will stay opened after
  /// the keyboard is closed.
  ///
  /// Defaults to true.
  final bool hideSuggestionsOnKeyboardHide;

  /// If set to false, the suggestions box will show a circular
  /// progress indicator when retrieving suggestions.
  ///
  /// Defaults to true.
  final bool keepSuggestionsOnLoading;

  /// If set to true, the suggestions box will remain opened even after
  /// selecting a suggestion.
  ///
  /// Note that if this is enabled, the only way
  /// to close the suggestions box is either manually via the
  /// `SuggestionsBoxController` or when the user closes the software
  /// keyboard if `hideSuggestionsOnKeyboardHide` is set to true. Users
  /// with a physical keyboard will be unable to close the
  /// box without a manual way via `SuggestionsBoxController`.
  ///
  /// Defaults to false.
  final bool keepSuggestionsOnSuggestionSelected;

  /// If set to true, in the case where the suggestions box has less than
  /// _SuggestionsBoxController.minOverlaySpace to grow in the desired [direction], the direction axis
  /// will be temporarily flipped if there's more room available in the opposite
  /// direction.
  ///
  /// Defaults to false
  final bool autoFlipDirection;

  /// If set to false, suggestion list will not be reversed according to the
  /// [autoFlipDirection] property.
  ///
  /// Defaults to true.
  final bool autoFlipListDirection;

  final bool hideKeyboard;

  /// The minimum number of characters which must be entered before
  /// [suggestionsCallback] is triggered.
  ///
  /// Defaults to 0.
  final int minCharsForSuggestions;

  /// If set to true and if the user scrolls through the suggestion list, hide the keyboard automatically.
  /// If set to false, the keyboard remains visible.
  /// Throws an exception, if hideKeyboardOnDrag and hideSuggestionsOnKeyboardHide are both set to true as
  /// they are mutual exclusive.
  ///
  /// Defaults to false
  final bool hideKeyboardOnDrag;

  final Color? tagColor;

  /// A callback function that notifies the consumer about changes in the visibility of the keyboard.
  ///
  /// This function is invoked whenever there is a change in the keyboard's visibility state:
  /// - If the keyboard becomes visible, the callback is triggered with `true`.
  /// - If the keyboard is hidden, the callback is triggered with `false`.
  ///
  /// This can be used to perform actions based on the keyboard's visibility, such as adjusting the UI,
  /// scrolling the view, or updating the state of related widgets.
  ///
  /// Note: This callback does not directly control the keyboard's visibility but serves as an observer
  /// for visibility changes. It is optional and defaults to null if no action is required on visibility changes.
  final void Function(bool)? onKeyboardFocusChange;

  // Adds a callback for the suggestion box opening or closing
  final void Function(bool)? onSuggestionsBoxToggle;

  final void Function(dynamic)? onTagTap;

  /// Creates a [TypeAheadField]
  const TypeAheadField({
    required this.suggestionsCallback,
    required this.itemBuilder,
    required this.onSuggestionSelected,
    this.scrollPhysics = const NeverScrollableScrollPhysics(),
    this.onTagTap,
    this.tagColor,
    this.textFieldConfiguration = const TextFieldConfiguration(),
    this.suggestionsBoxDecoration = const SuggestionsBoxDecoration(),
    this.debounceDuration = const Duration(milliseconds: 300),
    this.suggestionsBoxController,
    this.scrollController,
    this.loadingBuilder,
    this.noItemsFoundBuilder,
    this.errorBuilder,
    this.transitionBuilder,
    this.animationStart = 0.25,
    this.animationDuration = const Duration(milliseconds: 500),
    this.getImmediateSuggestions = false,
    this.suggestionsBoxVerticalOffset = 5.0,
    this.direction = AxisDirection.down,
    this.hideOnLoading = false,
    this.hideOnEmpty = false,
    this.hideOnError = false,
    this.hideSuggestionsOnKeyboardHide = true,
    this.keepSuggestionsOnLoading = true,
    this.keepSuggestionsOnSuggestionSelected = false,
    this.autoFlipDirection = false,
    this.autoFlipListDirection = true,
    this.hideKeyboard = false,
    this.minCharsForSuggestions = 0,
    this.onSuggestionsBoxToggle,
    this.hideKeyboardOnDrag = false,
    this.onKeyboardFocusChange,
    super.key,
  })  : assert(animationStart >= 0.0 && animationStart <= 1.0),
        assert(
            direction == AxisDirection.down || direction == AxisDirection.up),
        assert(minCharsForSuggestions >= 0),
        assert(!hideKeyboardOnDrag ||
            hideKeyboardOnDrag && !hideSuggestionsOnKeyboardHide);

  @override
  _TypeAheadFieldState<T> createState() => _TypeAheadFieldState<T>();
}

class _TypeAheadFieldState<T> extends State<TypeAheadField<T>>
    with WidgetsBindingObserver {
  FocusNode? _focusNode;
  final KeyboardSuggestionSelectionNotifier
      _keyboardSuggestionSelectionNotifier =
      KeyboardSuggestionSelectionNotifier();
  TextEditingController? _textEditingController;
  SuggestionsBox? _suggestionsBox;

  TextEditingController? get _effectiveController =>
      widget.textFieldConfiguration.controller ?? _textEditingController;

  FocusNode? get _effectiveFocusNode =>
      widget.textFieldConfiguration.focusNode ?? _focusNode;
  late VoidCallback _focusNodeListener;

  final LayerLink _layerLink = LayerLink();

  // Timer that resizes the suggestion box on each tick. Only active when the user is scrolling.
  Timer? _resizeOnScrollTimer;

  // The rate at which the suggestion box will resize when the user is scrolling
  final Duration _resizeOnScrollRefreshRate = const Duration(milliseconds: 500);

  // Will have a value if the typeahead is inside a scrollable widget
  ScrollPosition? _scrollPosition;

  // state of the keyboard
  bool _isKeyboardVisible = false;
  // stream to trigger the keyboard visibility
  StreamController<bool> _keyboardVisibilityController =
      StreamController<bool>.broadcast();

  bool _areSuggestionsFocused = false;
  late final _shouldRefreshSuggestionsFocusIndex =
      ShouldRefreshSuggestionFocusIndexNotifier(
          textFieldFocusNode: _effectiveFocusNode);

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();

    // The 'viewInsets' describe parts of the display that are overlaid, typically by the system UI (e.g. keyboard).
    final bottomInset = WidgetsBinding.instance.window.viewInsets.bottom;

    // If bottomInset > 0, we assume keyboard is open.
    bool newValue = bottomInset > 0.0;
    if (newValue != _isKeyboardVisible) {
      _isKeyboardVisible = newValue;
      _keyboardVisibilityController.add(_isKeyboardVisible);
      widget.onKeyboardFocusChange?.call(_isKeyboardVisible);
    }
    // Catch keyboard event and orientation change; resize suggestions list
    this._suggestionsBox!.onChangeMetrics();
  }

  @override
  void dispose() {
    this._suggestionsBox!.close();
    this._suggestionsBox!.widgetMounted = false;
    WidgetsBinding.instance.removeObserver(this);
    _effectiveFocusNode!.removeListener(_focusNodeListener);
    _focusNode?.dispose();
    _resizeOnScrollTimer?.cancel();
    _scrollPosition?.removeListener(_scrollResizeListener);
    _textEditingController?.dispose();
    _keyboardVisibilityController.close();
    super.dispose();
  }

  KeyEventResult _onKeyEvent(FocusNode _, RawKeyEvent event) {
    if (event.isKeyPressed(LogicalKeyboardKey.arrowUp) ||
        event.isKeyPressed(LogicalKeyboardKey.arrowDown)) {
      // do nothing to avoid puzzling users until keyboard arrow nav is implemented
    } else {
      _keyboardSuggestionSelectionNotifier.onKeyboardEvent(event);
    }
    return KeyEventResult.ignored;
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    if (widget.textFieldConfiguration.controller == null) {
      this._textEditingController = TextEditingController();
    }

    final textFieldConfigurationFocusNode =
        widget.textFieldConfiguration.focusNode;
    if (textFieldConfigurationFocusNode == null) {
      this._focusNode = FocusNode(onKey: _onKeyEvent);
    } else if (textFieldConfigurationFocusNode.onKey == null) {
      // * we add the _onKeyEvent callback to the textFieldConfiguration focusNode
      textFieldConfigurationFocusNode.onKey = ((node, event) {
        final keyEventResult = _onKeyEvent(node, event);
        return keyEventResult;
      });
    } else {
      final onKeyCopy = textFieldConfigurationFocusNode.onKey!;
      textFieldConfigurationFocusNode.onKey = ((node, event) {
        _onKeyEvent(node, event);
        return onKeyCopy(node, event);
      });
    }

    this._suggestionsBox = SuggestionsBox(
      context,
      widget.direction,
      widget.autoFlipDirection,
      widget.autoFlipListDirection,
    );

    widget.suggestionsBoxController?.suggestionsBox = this._suggestionsBox;
    widget.suggestionsBoxController?.effectiveFocusNode =
        this._effectiveFocusNode;

    this._focusNodeListener = () {
      if (_effectiveFocusNode!.hasFocus) {
        this._suggestionsBox!.open();
      } else if (!_areSuggestionsFocused) {
        if (widget.hideSuggestionsOnKeyboardHide) {
          this._suggestionsBox!.close();
        }
      }

      widget.onSuggestionsBoxToggle?.call(this._suggestionsBox!.isOpened);
    };

    this._effectiveFocusNode!.addListener(_focusNodeListener);

    // listen for the keyboard visibility
    // close the suggestion box when the keyboard is hidden
    _keyboardVisibilityController.stream.listen((bool isVisible) {
      if (!isVisible && widget.hideSuggestionsOnKeyboardHide) {
        _effectiveFocusNode!.unfocus();
      }
    });

    WidgetsBinding.instance.addPostFrameCallback((duration) {
      if (mounted) {
        this._initOverlayEntry();
        // calculate initial suggestions list size
        this._suggestionsBox!.resize();

        // in case we already missed the focus event
        if (this._effectiveFocusNode!.hasFocus) {
          this._suggestionsBox!.open();
        }
      }
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final scrollableState = Scrollable.maybeOf(context);
    if (scrollableState != null) {
      // The TypeAheadField is inside a scrollable widget
      _scrollPosition = scrollableState.position;

      _scrollPosition!.removeListener(_scrollResizeListener);
      _scrollPosition!.isScrollingNotifier.addListener(_scrollResizeListener);
    }
  }

  void _scrollResizeListener() {
    bool isScrolling = _scrollPosition!.isScrollingNotifier.value;
    _resizeOnScrollTimer?.cancel();
    if (isScrolling) {
      // Scroll started
      _resizeOnScrollTimer =
          Timer.periodic(_resizeOnScrollRefreshRate, (timer) {
        _suggestionsBox!.resize();
      });
    } else {
      // Scroll finished
      _suggestionsBox!.resize();
    }
  }

  void _initOverlayEntry() {
    this._suggestionsBox!.overlayEntry = OverlayEntry(builder: (context) {
      void giveTextFieldFocus() {
        _effectiveFocusNode?.requestFocus();
        _areSuggestionsFocused = false;
      }

      void onSuggestionFocus() {
        if (!_areSuggestionsFocused) {
          _areSuggestionsFocused = true;
        }
      }

      final suggestionsList = SuggestionsList<T>(
          suggestionsBox: _suggestionsBox,
          decoration: widget.suggestionsBoxDecoration,
          debounceDuration: widget.debounceDuration,
          controller: this._effectiveController,
          loadingBuilder: widget.loadingBuilder,
          scrollController: widget.scrollController,
          noItemsFoundBuilder: widget.noItemsFoundBuilder,
          errorBuilder: widget.errorBuilder,
          transitionBuilder: widget.transitionBuilder,
          suggestionsCallback: widget.suggestionsCallback,
          animationDuration: widget.animationDuration,
          animationStart: widget.animationStart,
          getImmediateSuggestions: widget.getImmediateSuggestions,
          onSuggestionSelected: (T selection) {
            if (!widget.keepSuggestionsOnSuggestionSelected) {
              // this._effectiveFocusNode!.unfocus();
              this._suggestionsBox!.close();
            }
            widget.onSuggestionSelected(selection);
          },
          itemBuilder: widget.itemBuilder,
          direction: _suggestionsBox!.direction,
          hideOnLoading: widget.hideOnLoading,
          hideOnEmpty: widget.hideOnEmpty,
          hideOnError: widget.hideOnError,
          keepSuggestionsOnLoading: widget.keepSuggestionsOnLoading,
          minCharsForSuggestions: widget.minCharsForSuggestions,
          keyboardSuggestionSelectionNotifier:
              _keyboardSuggestionSelectionNotifier,
          shouldRefreshSuggestionFocusIndexNotifier:
              _shouldRefreshSuggestionsFocusIndex,
          giveTextFieldFocus: giveTextFieldFocus,
          onSuggestionFocus: onSuggestionFocus,
          onKeyEvent: _onKeyEvent,
          hideKeyboardOnDrag: widget.hideKeyboardOnDrag);

      double w = _suggestionsBox!.textBoxWidth;
      if (widget.suggestionsBoxDecoration.constraints != null) {
        if (widget.suggestionsBoxDecoration.constraints!.minWidth != 0.0 &&
            widget.suggestionsBoxDecoration.constraints!.maxWidth !=
                double.infinity) {
          w = (widget.suggestionsBoxDecoration.constraints!.minWidth +
                  widget.suggestionsBoxDecoration.constraints!.maxWidth) /
              2;
        } else if (widget.suggestionsBoxDecoration.constraints!.minWidth !=
                0.0 &&
            widget.suggestionsBoxDecoration.constraints!.minWidth > w) {
          w = widget.suggestionsBoxDecoration.constraints!.minWidth;
        } else if (widget.suggestionsBoxDecoration.constraints!.maxWidth !=
                double.infinity &&
            widget.suggestionsBoxDecoration.constraints!.maxWidth < w) {
          w = widget.suggestionsBoxDecoration.constraints!.maxWidth;
        }
      }

      final Widget compositedFollower = CompositedTransformFollower(
        link: this._layerLink,
        showWhenUnlinked: false,
        offset: Offset(
            widget.suggestionsBoxDecoration.offsetX,
            _suggestionsBox!.direction == AxisDirection.down
                ? _suggestionsBox!.textBoxHeight +
                    widget.suggestionsBoxVerticalOffset
                : _suggestionsBox!.directionUpOffset),
        child: _suggestionsBox!.direction == AxisDirection.down
            ? suggestionsList
            : FractionalTranslation(
                translation:
                    const Offset(0.0, -1.0), // visually flips list to go up
                child: suggestionsList,
              ),
      );

      // When wrapped in the Positioned widget, the suggestions box widget
      // is placed before the Scaffold semantically. In order to have the
      // suggestions box navigable from the search input or keyboard,
      // Semantics > Align > ConstrainedBox are needed. This does not change
      // the style visually. However, when VO/TB are not enabled it is
      // necessary to use the Positioned widget to allow the elements to be
      // properly tappable.
      return MediaQuery.of(context).accessibleNavigation
          ? Semantics(
              container: true,
              child: Align(
                alignment: Alignment.topLeft,
                child: ConstrainedBox(
                  constraints: BoxConstraints(maxWidth: w),
                  child: compositedFollower,
                ),
              ),
            )
          : Positioned(
              width: w,
              child: compositedFollower,
            );
    });
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: this._layerLink,
      child: ExtendedTextField(
        specialTextSpanBuilder: MySpecialTextSpanBuilder(
          onTagTap: widget.onTagTap,
          tagColor: widget.tagColor,
        ),
        scrollPhysics: widget.scrollPhysics,
        focusNode: this._effectiveFocusNode,
        controller: this._effectiveController,
        decoration: widget.textFieldConfiguration.decoration,
        style: widget.textFieldConfiguration.style,
        textAlign: widget.textFieldConfiguration.textAlign,
        enabled: widget.textFieldConfiguration.enabled,
        keyboardType: widget.textFieldConfiguration.keyboardType,
        autofocus: widget.textFieldConfiguration.autofocus,
        inputFormatters: widget.textFieldConfiguration.inputFormatters,
        autocorrect: widget.textFieldConfiguration.autocorrect,
        maxLines: widget.textFieldConfiguration.maxLines,
        textAlignVertical: widget.textFieldConfiguration.textAlignVertical,
        minLines: widget.textFieldConfiguration.minLines,
        maxLength: widget.textFieldConfiguration.maxLength,
        maxLengthEnforcement:
            widget.textFieldConfiguration.maxLengthEnforcement,
        obscureText: widget.textFieldConfiguration.obscureText,
        onChanged: widget.textFieldConfiguration.onChanged,
        onSubmitted: widget.textFieldConfiguration.onSubmitted,
        onEditingComplete: widget.textFieldConfiguration.onEditingComplete,
        onTap: widget.textFieldConfiguration.onTap,
//         onTapOutside: (_) {},
        scrollPadding: widget.textFieldConfiguration.scrollPadding,
        textInputAction: widget.textFieldConfiguration.textInputAction,
        textCapitalization: widget.textFieldConfiguration.textCapitalization,
        keyboardAppearance: widget.textFieldConfiguration.keyboardAppearance,
        cursorWidth: widget.textFieldConfiguration.cursorWidth,
        cursorRadius: widget.textFieldConfiguration.cursorRadius,
        cursorColor: widget.textFieldConfiguration.cursorColor,
        textDirection: widget.textFieldConfiguration.textDirection,
        enableInteractiveSelection:
            widget.textFieldConfiguration.enableInteractiveSelection,
        readOnly: widget.hideKeyboard,
      ),
    );
  }
}

class AtText extends SpecialText {
  static const String flag = "@";
  @override
  final SpecialTextGestureTapCallback? onTap;
  final int start;
  final Color? tagColor;

  /// whether show background for @somebody
  final bool showAtBackground;

  AtText(
    TextStyle textStyle, {
    this.showAtBackground = false,
    this.tagColor,
    required this.start,
    this.onTap,
  }) : super(
          flag,
          "~",
          textStyle,
        );

  @override
  InlineSpan finishText() {
    TextStyle textStyle = this.textStyle!.copyWith(
          color: tagColor ?? Colors.blue,
        );

    final String atText = toString();
    final String atTextWithoutFlag = atText.replaceAll('~', '');

    return showAtBackground
        ? BackgroundTextSpan(
            background: Paint()..color = Colors.white,
            text: atTextWithoutFlag,
            actualText: atText,
            start: start,

            ///caret can move into special text
            deleteAll: true,
            style: textStyle,
            recognizer: (TapGestureRecognizer()
              ..onTap = () {
                if (onTap != null) onTap!(atText);
              }),
          )
        : SpecialTextSpan(
            text: atTextWithoutFlag,
            actualText: atText,
            start: start,
            style: textStyle,
            recognizer: (TapGestureRecognizer()
              ..onTap = () {
                if (onTap != null) onTap!(atText);
              }),
          );
  }
}

class MySpecialTextSpanBuilder extends SpecialTextSpanBuilder {
  MySpecialTextSpanBuilder({
    this.showAtBackground = false,
    this.onTagTap,
    this.tagColor,
  });

  /// whether show background for @somebody
  final bool showAtBackground;
  final Color? tagColor;
  final void Function(dynamic)? onTagTap;

  @override
  SpecialText? createSpecialText(String flag,
      {TextStyle? textStyle,
      SpecialTextGestureTapCallback? onTap,
      int? index}) {
    if (flag == '') {
      return null;
    }

    ///index is end index of start flag, so text start index should be index-(flag.length-1)
    if (isStart(flag, AtText.flag)) {
      return AtText(
        textStyle ?? const TextStyle(),
        onTap: onTap ?? onTagTap,
        start: index! - (AtText.flag.length),
        showAtBackground: showAtBackground,
        tagColor: tagColor,
      );
    }
    return null;
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/field/typeahead_form_field.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/field/text_field_configuration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/field/typeahead_field.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_controller.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_decoration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';

/// A [FormField](https://docs.flutter.io/flutter/widgets/FormField-class.html)
/// implementation of [TypeAheadField], that allows the value to be saved,
/// validated, etc.
///
/// See also:
///
/// * [TypeAheadField], A [TextField](https://docs.flutter.io/flutter/material/TextField-class.html)
/// that displays a list of suggestions as the user types
class TypeAheadFormField<T> extends FormField<String> {
  /// The configuration of the [TextField](https://docs.flutter.io/flutter/material/TextField-class.html)
  /// that the TypeAhead widget displays
  final TextFieldConfiguration textFieldConfiguration;

  // Adds a callback for resetting the form field
  final void Function()? onReset;

  /// Creates a [TypeAheadFormField]
  TypeAheadFormField({
    Key? key,
    String? initialValue,
    bool getImmediateSuggestions = false,
    @Deprecated('Use autovalidateMode parameter which provides more specific '
        'behavior related to auto validation. '
        'This feature was deprecated after Flutter v1.19.0.')
    bool autovalidate = false,
    bool enabled = true,
    AutovalidateMode autovalidateMode = AutovalidateMode.disabled,
    FormFieldSetter<String>? onSaved,
    this.onReset,
    FormFieldValidator<String>? validator,
    ErrorBuilder? errorBuilder,
    WidgetBuilder? noItemsFoundBuilder,
    WidgetBuilder? loadingBuilder,
    void Function(bool)? onSuggestionsBoxToggle,
    Duration debounceDuration = const Duration(milliseconds: 300),
    SuggestionsBoxDecoration suggestionsBoxDecoration =
        const SuggestionsBoxDecoration(),
    SuggestionsBoxController? suggestionsBoxController,
    required SuggestionSelectionCallback<T> onSuggestionSelected,
    required ItemBuilder<T> itemBuilder,
    required SuggestionsCallback<T> suggestionsCallback,
    double suggestionsBoxVerticalOffset = 5.0,
    this.textFieldConfiguration = const TextFieldConfiguration(),
    AnimationTransitionBuilder? transitionBuilder,
    Duration animationDuration = const Duration(milliseconds: 500),
    double animationStart = 0.25,
    AxisDirection direction = AxisDirection.down,
    bool hideOnLoading = false,
    bool hideOnEmpty = false,
    bool hideOnError = false,
    bool hideSuggestionsOnKeyboardHide = true,
    bool keepSuggestionsOnLoading = true,
    bool keepSuggestionsOnSuggestionSelected = false,
    bool autoFlipDirection = false,
    bool autoFlipListDirection = true,
    bool hideKeyboard = false,
    int minCharsForSuggestions = 0,
    bool hideKeyboardOnDrag = false,
  })  : assert(
            initialValue == null || textFieldConfiguration.controller == null),
        assert(minCharsForSuggestions >= 0),
        super(
            key: key,
            onSaved: onSaved,
            validator: validator,
            initialValue: textFieldConfiguration.controller != null
                ? textFieldConfiguration.controller!.text
                : (initialValue ?? ''),
            enabled: enabled,
            autovalidateMode: autovalidateMode,
            builder: (FormFieldState<String> field) {
              final _TypeAheadFormFieldState state =
                  field as _TypeAheadFormFieldState<dynamic>;

              return TypeAheadField(
                onTagTap: (dynamic d) {},
                getImmediateSuggestions: getImmediateSuggestions,
                transitionBuilder: transitionBuilder,
                errorBuilder: errorBuilder,
                noItemsFoundBuilder: noItemsFoundBuilder,
                loadingBuilder: loadingBuilder,
                debounceDuration: debounceDuration,
                suggestionsBoxDecoration: suggestionsBoxDecoration,
                suggestionsBoxController: suggestionsBoxController,
                textFieldConfiguration: textFieldConfiguration.copyWith(
                  decoration: textFieldConfiguration.decoration
                      .copyWith(errorText: state.errorText),
                  onChanged: (text) {
                    state.didChange(text);
                    textFieldConfiguration.onChanged?.call(text);
                  },
                  controller: state._effectiveController,
                ),
                suggestionsBoxVerticalOffset: suggestionsBoxVerticalOffset,
                onSuggestionSelected: onSuggestionSelected,
                onSuggestionsBoxToggle: onSuggestionsBoxToggle,
                itemBuilder: itemBuilder,
                suggestionsCallback: suggestionsCallback,
                animationStart: animationStart,
                animationDuration: animationDuration,
                direction: direction,
                hideOnLoading: hideOnLoading,
                hideOnEmpty: hideOnEmpty,
                hideOnError: hideOnError,
                hideSuggestionsOnKeyboardHide: hideSuggestionsOnKeyboardHide,
                keepSuggestionsOnLoading: keepSuggestionsOnLoading,
                keepSuggestionsOnSuggestionSelected:
                    keepSuggestionsOnSuggestionSelected,
                autoFlipDirection: autoFlipDirection,
                autoFlipListDirection: autoFlipListDirection,
                hideKeyboard: hideKeyboard,
                minCharsForSuggestions: minCharsForSuggestions,
                hideKeyboardOnDrag: hideKeyboardOnDrag,
              );
            });

  @override
  _TypeAheadFormFieldState<T> createState() => _TypeAheadFormFieldState<T>();
}

class _TypeAheadFormFieldState<T> extends FormFieldState<String> {
  TextEditingController? _controller;

  TextEditingController? get _effectiveController =>
      widget.textFieldConfiguration.controller ?? _controller;

  @override
  TypeAheadFormField get widget => super.widget as TypeAheadFormField<dynamic>;

  @override
  void initState() {
    super.initState();
    if (widget.textFieldConfiguration.controller == null) {
      _controller = TextEditingController(text: widget.initialValue);
    } else {
      widget.textFieldConfiguration.controller!
          .addListener(_handleControllerChanged);
    }
  }

  @override
  void didUpdateWidget(TypeAheadFormField oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.textFieldConfiguration.controller !=
        oldWidget.textFieldConfiguration.controller) {
      oldWidget.textFieldConfiguration.controller
          ?.removeListener(_handleControllerChanged);
      widget.textFieldConfiguration.controller
          ?.addListener(_handleControllerChanged);

      if (oldWidget.textFieldConfiguration.controller != null &&
          widget.textFieldConfiguration.controller == null) {
        _controller = TextEditingController.fromValue(
            oldWidget.textFieldConfiguration.controller!.value);
      }
      if (widget.textFieldConfiguration.controller != null) {
        setValue(widget.textFieldConfiguration.controller!.text);
        if (oldWidget.textFieldConfiguration.controller == null) {
          _controller = null;
        }
      }
    }
  }

  @override
  void dispose() {
    widget.textFieldConfiguration.controller
        ?.removeListener(_handleControllerChanged);
    super.dispose();
  }

  @override
  void reset() {
    super.reset();
    setState(() {
      _effectiveController!.text = widget.initialValue!;
      if (widget.onReset != null) {
        widget.onReset!();
      }
    });
  }

  void _handleControllerChanged() {
    // Suppress changes that originated from within this class.
    //
    // In the case where a controller has been passed in to this widget, we
    // register this change listener. In these cases, we'll also receive change
    // notifications for changes originating from within this class -- for
    // example, the reset() method. In such cases, the FormField value will
    // already have been set.
    if (_effectiveController!.text != value) {
      didChange(_effectiveController!.text);
    }
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/flutter_typeahead.dart';

class SuggestionsBox {
  static const int waitMetricsTimeoutMillis = 1000;
  static const double minOverlaySpace = 64.0;

  final BuildContext context;
  final AxisDirection desiredDirection;
  final bool autoFlipDirection;
  final bool autoFlipListDirection;

  OverlayEntry? overlayEntry;
  AxisDirection direction;

  bool isOpened = false;
  bool widgetMounted = true;
  double maxHeight = 300.0;
  double textBoxWidth = 100.0;
  double textBoxHeight = 100.0;
  late double directionUpOffset;

  SuggestionsBox(
    this.context,
    this.direction,
    this.autoFlipDirection,
    this.autoFlipListDirection,
  ) : desiredDirection = direction;

  void open() {
    if (isOpened) return;
    assert(overlayEntry != null);
    resize();
    Overlay.of(context).insert(overlayEntry!);
    isOpened = true;
  }

  void close() {
    if (!isOpened) return;
    assert(overlayEntry != null);
    overlayEntry!.remove();
    isOpened = false;
  }

  void toggle() {
    if (isOpened) {
      close();
    } else {
      open();
    }
  }

  MediaQuery? _findRootMediaQuery() {
    MediaQuery? rootMediaQuery;
    context.visitAncestorElements((element) {
      if (element.widget is MediaQuery) {
        rootMediaQuery = element.widget as MediaQuery;
      }
      return true;
    });

    return rootMediaQuery;
  }

  /// Delays until the keyboard has toggled or the orientation has fully changed
  Future<bool> _waitChangeMetrics() async {
    if (widgetMounted) {
      // initial viewInsets which are before the keyboard is toggled
      EdgeInsets initial = MediaQuery.of(context).viewInsets;
      // initial MediaQuery for orientation change
      MediaQuery? initialRootMediaQuery = _findRootMediaQuery();

      int timer = 0;
      // viewInsets or MediaQuery have changed once keyboard has toggled or orientation has changed
      while (widgetMounted && timer < waitMetricsTimeoutMillis) {
        // TODO: reduce delay if showDialog ever exposes detection of animation end
        await Future<void>.delayed(const Duration(milliseconds: 170));
        timer += 170;

        if (widgetMounted &&
            (MediaQuery.of(context).viewInsets != initial ||
                _findRootMediaQuery() != initialRootMediaQuery)) {
          return true;
        }
      }
    }

    return false;
  }

  void resize() {
    // check to see if widget is still mounted
    // user may have closed the widget with the keyboard still open
    if (widgetMounted) {
      _adjustMaxHeightAndOrientation();
      overlayEntry!.markNeedsBuild();
    }
  }

  // See if there's enough room in the desired direction for the overlay to display
  // correctly. If not, try the opposite direction if things look more roomy there
  void _adjustMaxHeightAndOrientation() {
    TypeAheadField widget = context.widget as TypeAheadField;

    RenderBox? box = context.findRenderObject() as RenderBox?;
    if (box == null || box.hasSize == false) {
      return;
    }

    textBoxWidth = box.size.width;
    textBoxHeight = box.size.height;

    // top of text box
    double textBoxAbsY = box.localToGlobal(Offset.zero).dy;

    // height of window
    double windowHeight = MediaQuery.of(context).size.height;

    // we need to find the root MediaQuery for the unsafe area height
    // we cannot use BuildContext.ancestorWidgetOfExactType because
    // widgets like SafeArea creates a new MediaQuery with the padding removed
    MediaQuery rootMediaQuery = _findRootMediaQuery()!;

    // height of keyboard
    double keyboardHeight = rootMediaQuery.data.viewInsets.bottom;

    double maxHDesired = _calculateMaxHeight(desiredDirection, box, widget,
        windowHeight, rootMediaQuery, keyboardHeight, textBoxAbsY);

    // if there's enough room in the desired direction, update the direction and the max height
    if (maxHDesired >= minOverlaySpace || !autoFlipDirection) {
      direction = desiredDirection;
      // Sometimes textBoxAbsY is NaN, so we need to check for that
      if (!maxHDesired.isNaN) {
        maxHeight = maxHDesired;
      }
    } else {
      // There's not enough room in the desired direction so see how much room is in the opposite direction
      AxisDirection flipped = flipAxisDirection(desiredDirection);
      double maxHFlipped = _calculateMaxHeight(flipped, box, widget,
          windowHeight, rootMediaQuery, keyboardHeight, textBoxAbsY);

      // if there's more room in this opposite direction, update the direction and maxHeight
      if (maxHFlipped > maxHDesired) {
        direction = flipped;

        // Not sure if this is needed, but it's here just in case
        if (!maxHFlipped.isNaN) {
          maxHeight = maxHFlipped;
        }
      }
    }

    if (maxHeight < 0) maxHeight = 0;
  }

  double _calculateMaxHeight(
      AxisDirection direction,
      RenderBox box,
      TypeAheadField widget,
      double windowHeight,
      MediaQuery rootMediaQuery,
      double keyboardHeight,
      double textBoxAbsY) {
    return direction == AxisDirection.down
        ? _calculateMaxHeightDown(box, widget, windowHeight, rootMediaQuery,
            keyboardHeight, textBoxAbsY)
        : _calculateMaxHeightUp(box, widget, windowHeight, rootMediaQuery,
            keyboardHeight, textBoxAbsY);
  }

  double _calculateMaxHeightDown(
      RenderBox box,
      TypeAheadField widget,
      double windowHeight,
      MediaQuery rootMediaQuery,
      double keyboardHeight,
      double textBoxAbsY) {
    // unsafe area, ie: iPhone X 'home button'
    // keyboardHeight includes unsafeAreaHeight, if keyboard is showing, set to 0
    double unsafeAreaHeight =
        keyboardHeight == 0 ? rootMediaQuery.data.padding.bottom : 0;

    return windowHeight -
        keyboardHeight -
        unsafeAreaHeight -
        textBoxHeight -
        textBoxAbsY -
        2 * widget.suggestionsBoxVerticalOffset;
  }

  double _calculateMaxHeightUp(
      RenderBox box,
      TypeAheadField widget,
      double windowHeight,
      MediaQuery rootMediaQuery,
      double keyboardHeight,
      double textBoxAbsY) {
    // recalculate keyboard absolute y value
    double keyboardAbsY = windowHeight - keyboardHeight;

    directionUpOffset = textBoxAbsY > keyboardAbsY
        ? keyboardAbsY - textBoxAbsY - widget.suggestionsBoxVerticalOffset
        : -widget.suggestionsBoxVerticalOffset;

    // unsafe area, ie: iPhone X notch
    double unsafeAreaHeight = rootMediaQuery.data.padding.top;

    return textBoxAbsY > keyboardAbsY
        ? keyboardAbsY -
            unsafeAreaHeight -
            2 * widget.suggestionsBoxVerticalOffset
        : textBoxAbsY -
            unsafeAreaHeight -
            2 * widget.suggestionsBoxVerticalOffset;
  }

  Future<void> onChangeMetrics() async {
    if (await _waitChangeMetrics()) {
      resize();
    }
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_controller.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/flutter_typeahead.dart';

/// Supply an instance of this class to the [TypeAhead.suggestionsBoxController]
/// property to manually control the suggestions box
class SuggestionsBoxController {
  SuggestionsBox? suggestionsBox;
  FocusNode? effectiveFocusNode;

  /// Opens the suggestions box
  void open() {
    effectiveFocusNode?.requestFocus();
  }

  bool isOpened() {
    return suggestionsBox?.isOpened ?? false;
  }

  /// Closes the suggestions box
  void close() {
    effectiveFocusNode?.unfocus();
  }

  /// Opens the suggestions box if closed and vice-versa
  void toggle() {
    if (suggestionsBox?.isOpened ?? false) {
      close();
    } else {
      open();
    }
  }

  /// Recalculates the height of the suggestions box
  void resize() {
    suggestionsBox!.resize();
  }
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_decoration.dart
================================================
import 'package:flutter/material.dart';

/// Supply an instance of this class to the [TypeAhead.suggestionsBoxDecoration]
/// property to configure the suggestions box decoration
class SuggestionsBoxDecoration {
  /// The z-coordinate at which to place the suggestions box. This controls the size
  /// of the shadow below the box.
  ///
  /// Same as [Material.elevation](https://docs.flutter.io/flutter/material/Material/elevation.html)
  final double elevation;

  /// The color to paint the suggestions box.
  ///
  /// Same as [Material.color](https://docs.flutter.io/flutter/material/Material/color.html)
  final Color? color;

  /// Defines the material's shape as well its shadow.
  ///
  /// Same as [Material.shape](https://docs.flutter.io/flutter/material/Material/shape.html)
  final ShapeBorder? shape;

  /// Defines if a scrollbar will be displayed or not.
  final bool hasScrollbar;

  /// If non-null, the corners of this box are rounded by this [BorderRadius](https://docs.flutter.io/flutter/painting/BorderRadius-class.html).
  ///
  /// Same as [Material.borderRadius](https://docs.flutter.io/flutter/material/Material/borderRadius.html)
  final BorderRadius? borderRadius;

  /// The color to paint the shadow below the material.
  ///
  /// Same as [Material.shadowColor](https://docs.flutter.io/flutter/material/Material/shadowColor.html)
  final Color shadowColor;

  /// The constraints to be applied to the suggestions box
  final BoxConstraints? constraints;

  /// Adds an offset to the suggestions box
  final double offsetX;

  /// The content will be clipped (or not) according to this option.
  ///
  /// Same as [Material.clipBehavior](https://api.flutter.dev/flutter/material/Material/clipBehavior.html)
  final Clip clipBehavior;

  /// Creates a SuggestionsBoxDecoration
  const SuggestionsBoxDecoration(
      {this.elevation = 4.0,
      this.color,
      this.shape,
      this.hasScrollbar = true,
      this.borderRadius,
      this.shadowColor = const Color(0xFF000000),
      this.constraints,
      this.clipBehavior = Clip.none,
      this.offsetX = 0.0});
}



================================================
File: lib/packages/core/lib/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_list.dart
================================================
// ignore_for_file: deprecated_member_use

import 'dart:async';
import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/keyboard_suggestion_selection_notifier.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/should_refresh_suggestion_focus_index_notifier.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/material/suggestions_box/suggestions_box_decoration.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/src/typedef.dart';

class SuggestionsList<T> extends StatefulWidget {
  final SuggestionsBox? suggestionsBox;
  final TextEditingController? controller;
  final bool getImmediateSuggestions;
  final SuggestionSelectionCallback<T>? onSuggestionSelected;
  final SuggestionsCallback<T>? suggestionsCallback;
  final ItemBuilder<T>? itemBuilder;
  final ScrollController? scrollController;
  final SuggestionsBoxDecoration? decoration;
  final Duration? debounceDuration;
  final WidgetBuilder? loadingBuilder;
  final WidgetBuilder? noItemsFoundBuilder;
  final ErrorBuilder? errorBuilder;
  final AnimationTransitionBuilder? transitionBuilder;
  final Duration? animationDuration;
  final double? animationStart;
  final AxisDirection? direction;
  final bool? hideOnLoading;
  final bool? hideOnEmpty;
  final bool? hideOnError;
  final bool? keepSuggestionsOnLoading;
  final int? minCharsForSuggestions;
  final KeyboardSuggestionSelectionNotifier keyboardSuggestionSelectionNotifier;
  final ShouldRefreshSuggestionFocusIndexNotifier
      shouldRefreshSuggestionFocusIndexNotifier;
  final VoidCallback giveTextFieldFocus;
  final VoidCallback onSuggestionFocus;
  final KeyEventResult Function(FocusNode _, RawKeyEvent event) onKeyEvent;
  final bool hideKeyboardOnDrag;

  const SuggestionsList({
    super.key,
    required this.suggestionsBox,
    this.controller,
    this.getImmediateSuggestions = false,
    this.onSuggestionSelected,
    this.suggestionsCallback,
    this.itemBuilder,
    this.scrollController,
    this.decoration,
    this.debounceDuration,
    this.loadingBuilder,
    this.noItemsFoundBuilder,
    this.errorBuilder,
    this.transitionBuilder,
    this.animationDuration,
    this.animationStart,
    this.direction,
    this.hideOnLoading,
    this.hideOnEmpty,
    this.hideOnError,
    this.keepSuggestionsOnLoading,
    this.minCharsForSuggestions,
    required this.keyboardSuggestionSelectionNotifier,
    required this.shouldRefreshSuggestionFocusIndexNotifier,
    required this.giveTextFieldFocus,
    required this.onSuggestionFocus,
    required this.onKeyEvent,
    required this.hideKeyboardOnDrag,
  });

  @override
  _SuggestionsListState<T> createState() => _SuggestionsListState<T>();
}

class _SuggestionsListState<T> extends State<SuggestionsList<T>>
    with SingleTickerProviderStateMixin {
  Iterable<T>? _suggestions;
  late bool _suggestionsValid;
  late VoidCallback _controllerListener;
  Timer? _debounceTimer;
  bool? _isLoading, _isQueued;
  Object? _error;
  AnimationController? _animationController;
  String? _lastTextValue;
  late final ScrollController _scrollController =
      widget.scrollController ?? ScrollController();
  List<FocusNode> _focusNodes = [];
  int _suggestionIndex = -1;

  _SuggestionsListState() {
    this._controllerListener = () {
      // If we came here because of a change in selected text, not because of
      // actual change in text
      if (widget.controller!.text == this._lastTextValue) return;

      this._lastTextValue = widget.controller!.text;

      this._debounceTimer?.cancel();
      if (widget.controller!.text.length < widget.minCharsForSuggestions!) {
        if (mounted) {
          setState(() {
            _isLoading = false;
            _suggestions = null;
            _suggestionsValid = true;
          });
        }
        return;
      } else {
        this._debounceTimer = Timer(widget.debounceDuration!, () async {
          if (this._debounceTimer!.isActive) return;
          if (_isLoading!) {
            _isQueued = true;
            return;
          }

          await this.invalidateSuggestions();
          while (_isQueued!) {
            _isQueued = false;
            await this.invalidateSuggestions();
          }
        });
      }
    };
  }

  @override
  void didUpdateWidget(SuggestionsList<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    widget.controller!.addListener(this._controllerListener);
    _getSuggestions();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _getSuggestions();
  }

  @override
  void initState() {
    super.initState();

    this._animationController = AnimationController(
      vsync: this,
      duration: widget.animationDuration,
    );

    this._suggestionsValid = widget.minCharsForSuggestions! > 0 ? true : false;
    this._isLoading = false;
    this._isQueued = false;
    this._lastTextValue = widget.controller!.text;

    if (widget.getImmediateSuggestions) {
      this._getSuggestions();
    }

    widget.controller!.addListener(this._controllerListener);

    widget.keyboardSuggestionSelectionNotifier.addListener(() {
      final suggestionsLength = _suggestions?.length;
      final event = widget.keyboardSuggestionSelectionNotifier.value;
      if (event == null || suggestionsLength == null) return;

      if (event == LogicalKeyboardKey.arrowDown &&
          _suggestionIndex < suggestionsLength - 1) {
        _suggestionIndex++;
      } else if (event == LogicalKeyboardKey.arrowUp && _suggestionIndex > -1) {
        _suggestionIndex--;
      }

      if (_suggestionIndex > -1 && _suggestionIndex < _focusNodes.length) {
        final focusNode = _focusNodes[_suggestionIndex];
        focusNode.requestFocus();
        widget.onSuggestionFocus();
      } else {
        widget.giveTextFieldFocus();
      }
    });

    widget.shouldRefreshSuggestionFocusIndexNotifier.addListener(() {
      if (_suggestionIndex != -1) {
        _suggestionIndex = -1;
      }
    });
  }

  Future<void> invalidateSuggestions() async {
    _suggestionsValid = false;
    await _getSuggestions();
  }

  Future<void> _getSuggestions() async {
    if (_suggestionsValid) return;
    _suggestionsValid = true;

    if (mounted) {
      setState(() {
        this._animationController!.forward(from: 1.0);

        this._isLoading = true;
        this._error = null;
      });

      Iterable<T>? suggestions;
      Object? error;

      try {
        suggestions =
            await widget.suggestionsCallback!(widget.controller!.text);
      } catch (e) {
        error = e;
      }

      if (mounted) {
        // if it wasn't removed in the meantime
        setState(() {
          double? animationStart = widget.animationStart;
          // allow suggestionsCallback to return null and not throw error here
          if (error != null || suggestions?.isEmpty == true) {
            animationStart = 1.0;
          }
          this._animationController!.forward(from: animationStart);

          this._error = error;
          this._isLoading = false;
          this._suggestions = suggestions;
          _focusNodes = List.generate(
            _suggestions?.length ?? 0,
            (index) => FocusNode(onKey: (_, event) {
              return widget.onKeyEvent(_, event);
            }),
          );
        });
      }
    }
  }

  @override
  void dispose() {
    _animationController!.dispose();
    _debounceTimer?.cancel();
    for (final focusNode in _focusNodes) {
      focusNode.dispose();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    bool isEmpty = this._suggestions != null
        ? this._suggestions!.isEmpty && widget.controller!.text == ""
        : true;
    if ((this._suggestions == null || isEmpty) &&
        this._isLoading == false &&
        this._error == null) return Container();

    Widget child;
    if (this._isLoading!) {
      if (widget.hideOnLoading!) {
        child = Container(height: 0);
      } else {
        child = createLoadingWidget();
      }
    } else if (this._error != null) {
      if (widget.hideOnError!) {
        child = Container(height: 0);
      } else {
        child = createErrorWidget();
      }
    } else if (this._suggestions!.isEmpty) {
      if (widget.hideOnEmpty!) {
        child = Container(height: 0);
      } else {
        child = createNoItemsFoundWidget();
      }
    } else {
      child = createSuggestionsWidget();
    }

    final animationChild = widget.transitionBuilder != null
        ? widget.transitionBuilder!(context, child, this._animationController)
        : SizeTransition(
            axisAlignment: -1.0,
            sizeFactor: CurvedAnimation(
                parent: this._animationController!,
                curve: Curves.fastOutSlowIn),
            child: child,
          );

    BoxConstraints constraints;
    if (widget.decoration!.constraints == null) {
      constraints = BoxConstraints(
        maxHeight: widget.suggestionsBox!.maxHeight,
      );
    } else {
      double maxHeight = min(widget.decoration!.constraints!.maxHeight,
          widget.suggestionsBox!.maxHeight);
      constraints = widget.decoration!.constraints!.copyWith(
        minHeight: min(widget.decoration!.constraints!.minHeight, maxHeight),
        maxHeight: maxHeight,
      );
    }

    var container = Material(
      elevation: widget.decoration!.elevation,
      color: widget.decoration!.color,
      shape: widget.decoration!.shape,
      borderRadius: widget.decoration!.borderRadius,
      shadowColor: widget.decoration!.shadowColor,
      clipBehavior: widget.decoration!.clipBehavior,
      child: ConstrainedBox(
        constraints: constraints,
        child: animationChild,
      ),
    );

    return container;
  }

  Widget createLoadingWidget() {
    Widget child;

    if (widget.keepSuggestionsOnLoading! && this._suggestions != null) {
      if (this._suggestions!.isEmpty) {
        child = createNoItemsFoundWidget();
      } else {
        child = createSuggestionsWidget();
      }
    } else {
      child = widget.loadingBuilder != null
          ? widget.loadingBuilder!(context)
          : const Align(
              alignment: Alignment.center,
              child: Padding(
                padding: EdgeInsets.symmetric(vertical: 8.0),
                child: CircularProgressIndicator(),
              ),
            );
    }

    return child;
  }

  Widget createErrorWidget() {
    return widget.errorBuilder != null
        ? widget.errorBuilder!(context, this._error)
        : Padding(
            padding: const EdgeInsets.all(8.0),
            child: Text(
              'Error: ${this._error}',
              style: TextStyle(color: Theme.of(context).colorScheme.error),
            ),
          );
  }

  Widget createNoItemsFoundWidget() {
    return widget.noItemsFoundBuilder != null
        ? widget.noItemsFoundBuilder!(context)
        : Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: Text(
              'No Items Found!',
              textAlign: TextAlign.center,
              style: TextStyle(
                  color: Theme.of(context).disabledColor, fontSize: 18.0),
            ),
          );
  }

  Widget createSuggestionsWidget() {
    Widget child = ListView(
      padding: EdgeInsets.zero,
      primary: false,
      shrinkWrap: true,
      keyboardDismissBehavior: widget.hideKeyboardOnDrag
          ? ScrollViewKeyboardDismissBehavior.onDrag
          : ScrollViewKeyboardDismissBehavior.manual,
      controller: _scrollController,
      reverse: widget.suggestionsBox!.direction == AxisDirection.down
          ? false
          : widget.suggestionsBox!.autoFlipListDirection,
      children: List.generate(this._suggestions!.length, (index) {
        final suggestion = _suggestions!.elementAt(index);
        final focusNode = _focusNodes[index];

        return TextFieldTapRegion(
          child: InkWell(
            focusColor: Theme.of(context).hoverColor,
            focusNode: focusNode,
            child: widget.itemBuilder!(context, suggestion),
            onTap: () {
              // * we give the focus back to the text field
              widget.giveTextFieldFocus();

              widget.onSuggestionSelected!(suggestion);
            },
          ),
        );
      }),
    );

    if (widget.decoration!.hasScrollbar) {
      child = Scrollbar(
        controller: _scrollController,
        child: child,
      );
    }

    return child;
  }
}



================================================
File: lib/packages/core/lib/packages/pluralize/pluralize.dart
================================================
import 'package:likeminds_chat_flutter_core/packages/pluralize/mixins/data/pluralize_irregular_data.dart';
import 'package:likeminds_chat_flutter_core/packages/pluralize/mixins/data/pluralize_plural_data.dart';
import 'package:likeminds_chat_flutter_core/packages/pluralize/mixins/data/pluralize_singular_data.dart';
import 'package:likeminds_chat_flutter_core/packages/pluralize/mixins/data/pluralize_uncountable_data.dart';
import 'package:likeminds_chat_flutter_core/packages/pluralize/mixins/pluralize_utils.dart';

/// {@template pluralize_word_action}
/// Enum to define the action to perform on a word.
/// {@endtemplate}
enum LMChatPluralizeWordAction {
  firstLetterCapitalSingular,
  allCapitalSingular,
  allSmallSingular,
  firstLetterCapitalPlural,
  allCapitalPlural,
  allSmallPlural,
}

/// {@template pluralize}
/// A class to pluralize or singularize a word.
/// {@endtemplate}
class LMChatPluralize {
  static LMChatPluralize? _instance;
  static LMChatPluralize get instance =>
      _instance ??= LMChatPluralize._internal();

  LMChatPluralize._internal() {
    init();
  }

  final _pluralRules = <List<dynamic>>[];
  final _singularRules = <List<dynamic>>[];
  final _uncountables = <String, bool>{};
  final _irregularPlurals = <String, String>{};
  final _irregularSingles = <String, String>{};

  /// Pluralize or singularize a word based on the passed in action.
  /// [word]     The word to pluralize or singularize.
  /// [action]   The action to perform on the word.
  String pluralizeOrCapitalize(String word, LMChatPluralizeWordAction action) {
    switch (action) {
      case LMChatPluralizeWordAction.firstLetterCapitalSingular:
        return capitalizeFirstLetter(singular(word));
      case LMChatPluralizeWordAction.allCapitalSingular:
        return singular(word).toUpperCase();
      case LMChatPluralizeWordAction.allSmallSingular:
        return singular(word).toLowerCase();
      case LMChatPluralizeWordAction.firstLetterCapitalPlural:
        return capitalizeFirstLetter(plural(word));
      case LMChatPluralizeWordAction.allCapitalPlural:
        return plural(word).toUpperCase();
      case LMChatPluralizeWordAction.allSmallPlural:
        return plural(word).toLowerCase();
    }
  }

  String capitalizeFirstLetter(String word) {
    return '${word[0].toUpperCase()}${word.substring(1).toLowerCase()}';
  }

  /// Sanitize a word by passing in the word and sanitization rules.
  String sanitizeWord(String token, String word, List<List<dynamic>> rules) {
    // Empty string or doesn't need fixing.
    if (token.isEmpty || _uncountables.containsKey(token)) {
      return word;
    }

    var len = rules.length;

    // Iterate over the sanitization rules and use the first one to match.
    while (len-- > 0) {
      final rule = rules[len];

      final regexp = rule[0] as RegExp;
      if (regexp.hasMatch(word)) {
        return LMChatPluralizeUtils.replace(word, rule);
      }
    }

    return word;
  }

  /// Replace a word with the updated word.
  ///
  /// [replaceMap]  map of words to be replaced
  /// [keepMap]     map of words to keep intact
  /// [rules]       List of rules to use for sanitization
  ///
  /// Returns a function that accepts a word and returns the updated word
  String replaceWord(Map<String, String> replaceMap,
      Map<String, String> keepMap, List<List<dynamic>> rules, String word) {
    // Get the correct token and case restoration functions.
    final token = word.toLowerCase();

    // Check against the keep object map.
    if (keepMap.containsKey(token)) {
      return LMChatPluralizeUtils.restoreCase(word, token);
    }

    // Check against the replacement map for a direct word replacement.
    if (replaceMap.containsKey(token)) {
      return LMChatPluralizeUtils.restoreCase(word, replaceMap[token]!);
    }

    // Run all the rules against the word.
    return sanitizeWord(token, word, rules);
  }

  /// Check if a word is part of the map.
  bool checkWord(
    Map<String, String> replaceMap,
    Map<String, String> keepMap,
    List<List<dynamic>> rules,
    String word,
  ) {
    final token = word.toLowerCase();

    if (keepMap.containsKey(token)) {
      return true;
    }
    if (replaceMap.containsKey(token)) {
      return false;
    }

    return sanitizeWord(token, token, rules) == token;
  }

  /// Pluralize or singularize a word based on the passed in count.
  String pluralize(String word, int count, bool inclusive) {
    final String pluralized = count == 1 ? singular(word) : plural(word);

    return (inclusive ? '$count ' : '') + pluralized;
  }

  /// Pluralize a word.
  String plural(String word) =>
      replaceWord(_irregularSingles, _irregularPlurals, _pluralRules, word);

  /// Check if a word is plural.
  bool isPlural(String word) =>
      checkWord(_irregularSingles, _irregularPlurals, _pluralRules, word);

  ///Singularize a word.
  String singular(String word) =>
      replaceWord(_irregularPlurals, _irregularSingles, _singularRules, word);

  ///Check if a word is singular.
  bool isSingular(String word) =>
      checkWord(_irregularPlurals, _irregularSingles, _singularRules, word);

  /// Add a pluralization rule to the collection.
  void addPluralRule(dynamic rule, String replacement) {
    _pluralRules.add([rule, replacement]);
  }

  /// Add a singularization rule to the collection.
  void addSingularRule(dynamic rule, String replacement) {
    _singularRules.add([rule, replacement]);
  }

  ///Add an irregular word definition.
  void addIrregularRule(String singleParam, String pluralParam) {
    final plural = pluralParam.toLowerCase();
    final single = singleParam.toLowerCase();

    _irregularSingles[single] = plural;
    _irregularPlurals[plural] = single;
  }

  /// Add an uncountable word rule.
  void addUncountableRule(dynamic word) {
    if (word is String) {
      _uncountables[word.toLowerCase()] = true;
      return;
    }

    // Set singular and plural references for the word.
    addPluralRule(word, r'$0');
    addSingularRule(word, r'$0');
  }

  /// Initialize the collection of pluralization and singularization rules.
  void init() {
    initIrregularRules();
    initPluralRules();
    initSingularRules();
    initUncountableRules();
  }

  void initIrregularRules() {
    for (final rule in LMChatPluralizeIrregularData.irregularRulesData) {
      addIrregularRule(rule[0], rule[1]);
    }
  }

  void initPluralRules() {
    for (final regex in LMChatPluralizePluralData.pluralRulesData.keys) {
      addPluralRule(regex, LMChatPluralizePluralData.pluralRulesData[regex]!);
    }
  }

  void initSingularRules() {
    for (final rule in LMChatPluralizeSingularData.singularRulesData.keys) {
      final String replacement =
          LMChatPluralizeSingularData.singularRulesData[rule]!;
      addSingularRule(rule, replacement);
    }
  }

  void initUncountableRules() {
    for (final rule in LMChatPluralizeUncountableData.uncountableRulesData) {
      addUncountableRule(rule);
    }
  }
}



================================================
File: lib/packages/core/lib/packages/pluralize/mixins/pluralize_utils.dart
================================================
mixin LMChatPluralizeUtils {
  /// Pass in a word token to produce a function that can replicate the case on
  /// another word.
  static String restoreCase(String word, String token) {
    if (word == token) {
      return token;
    }

    if (word == word.toLowerCase()) {
      return token.toLowerCase();
    }

    if (word == word.toUpperCase()) {
      return token.toUpperCase();
    }

    if (word[0] == word[0].toUpperCase()) {
      return '${token[0].toUpperCase()}${token.substring(1).toLowerCase()}';
    }

    return token.toLowerCase();
  }

  /// Interpolate a regexp string.
  static String interpolate(String str, List<String> args) {
    final RegExp exp = RegExp(r'\$(\d{1,2})');
    return str.replaceAllMapped(exp, (match) {
      final matchedText = match.group(1);
      final int index = int.parse(matchedText!);
      return args.length > index ? args[index] : '';
    });
  }

  // Replace a word using a rule.
  static String replace(String word, List<dynamic> rule) {
    final regex = rule[0] as RegExp;
    //print('regex: $regex');

    // Use the first element of the rule as a RegExp to match in the word.
    // The second element of the rule is used as a string to replace the match.
    return word.replaceFirstMapped(regex, (match) {
      // Interpolate the replacement string using arguments from the match.

      final groups = match.groups([match.groupCount]);

      final args = groups.map((e) => e!).toList();
      final group = match.group(0);
      final String result = interpolate(rule[1] as String, args);

      // If the match is an empty string, use the previous character of the word.
      if (group!.isEmpty) {
        return restoreCase(word[match.start - 1], result);
      }
      // Otherwise, use the match as the source to restore the case.
      return restoreCase(match.group(0)!, result);
    });
  }
}



================================================
File: lib/packages/core/lib/packages/pluralize/mixins/data/pluralize_irregular_data.dart
================================================
class LMChatPluralizeIrregularData {
  /// Irregular rules.
  static List<List<String>> irregularRulesData = [
    // Pronouns.
    ['I', 'we'],
    ['me', 'us'],
    ['he', 'they'],
    ['she', 'they'],
    ['them', 'them'],
    ['myself', 'ourselves'],
    ['yourself', 'yourselves'],
    ['itself', 'themselves'],
    ['herself', 'themselves'],
    ['himself', 'themselves'],
    ['themself', 'themselves'],
    ['is', 'are'],
    ['was', 'were'],
    ['has', 'have'],
    ['this', 'these'],
    ['that', 'those'],
    // Words ending in with a consonant and `o`.
    ['echo', 'echoes'],
    ['dingo', 'dingoes'],
    ['volcano', 'volcanoes'],
    ['tornado', 'tornadoes'],
    ['torpedo', 'torpedoes'],
    // Ends with `us`.
    ['genus', 'genera'],
    ['viscus', 'viscera'],
    // Ends with `ma`.
    ['stigma', 'stigmata'],
    ['stoma', 'stomata'],
    ['dogma', 'dogmata'],
    ['lemma', 'lemmata'],
    ['schema', 'schemata'],
    ['anathema', 'anathemata'],
    // Other irregular rules.
    ['ox', 'oxen'],
    ['axe', 'axes'],
    ['die', 'dice'],
    ['yes', 'yeses'],
    ['foot', 'feet'],
    ['eave', 'eaves'],
    ['goose', 'geese'],
    ['tooth', 'teeth'],
    ['quiz', 'quizzes'],
    ['human', 'humans'],
    ['proof', 'proofs'],
    ['carve', 'carves'],
    ['valve', 'valves'],
    ['looey', 'looies'],
    ['thief', 'thieves'],
    ['groove', 'grooves'],
    ['pickaxe', 'pickaxes'],
    ['passerby', 'passersby'],
    ['person', 'people']
  ];
}



================================================
File: lib/packages/core/lib/packages/pluralize/mixins/data/pluralize_plural_data.dart
================================================
class LMChatPluralizePluralData {
  static Map<RegExp, String> pluralRulesData = {
    RegExp(r's?$', caseSensitive: false): 's',
    RegExp('[^\u0000-\u007F]\$', caseSensitive: false): r'$0',
    RegExp(r'([^aeiou]ese)$', caseSensitive: false): r'$0',
    RegExp(r'(ax|test)is$', caseSensitive: false): r'$0es',
    RegExp(r'(alias|[^aou]us|t[lm]as|gas|ris)$', caseSensitive: false): r'$0es',
    RegExp(r'(e[mn]u)s?$', caseSensitive: false): r'$0s',
    RegExp(r'([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$', caseSensitive: false):
        r'$0',
    RegExp(
        r'(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$',
        caseSensitive: false): r'$0i',
    RegExp(r'(alumn|alg|vertebr)(?:a|ae)$', caseSensitive: false): r'$0ae',
    RegExp(r'(seraph|cherub)(?:im)?$', caseSensitive: false): r'$0im',
    RegExp(r'(her|at|gr)o$', caseSensitive: false): r'$0oes',
    RegExp(
        r'(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$',
        caseSensitive: false): r'$0a',
    RegExp(
        r'(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$',
        caseSensitive: false): r'$0a',
    RegExp(r'sis$', caseSensitive: false): 'ses',
    RegExp(r'((kni|wi|li)fe)$', caseSensitive: false): r'$0ves',
    RegExp(r'(ar|l|ea|eo|oa|hoo)f$', caseSensitive: false): r'$0ves',
    RegExp(r'([^aeiouy]|qu)y$', caseSensitive: false): r'$0ies',
    RegExp(r'([^ch][ieo][ln])ey$', caseSensitive: false): r'$0ies',
    RegExp(r'(x|ch|ss|sh|zz)$', caseSensitive: false): r'$0es',
    RegExp(r'(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$',
        caseSensitive: false): r'$0ices',
    RegExp(r'\b((?:tit)?m|l)(?:ice|ouse)$', caseSensitive: false): r'$0ice',
    RegExp(r'(child)(?:ren)?$', caseSensitive: false): r'$0ren',
    RegExp(r'eaux$', caseSensitive: false): r'$0',
    RegExp(r'm[ae]n$', caseSensitive: false): 'men',
    RegExp(r'^thou$'): 'you'
  };
}



================================================
File: lib/packages/core/lib/packages/pluralize/mixins/data/pluralize_singular_data.dart
================================================
class LMChatPluralizeSingularData {
  static Map<RegExp, String> singularRulesData = {
    RegExp(r's$', caseSensitive: false): '',
    RegExp(r'(ss)$', caseSensitive: false): r'$0',
    RegExp(r'(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$',
        caseSensitive: false): r'$0fe',
    RegExp(r'(ar|(?:wo|[ae])l|[eo][ao])ves$', caseSensitive: false): r'$0f',
    RegExp(r'ies$', caseSensitive: false): 'y',
    RegExp(
        r'\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$',
        caseSensitive: false): r'$0ie',
    RegExp(r'\b(mon|smil)ies$', caseSensitive: false): r'$0ey',
    RegExp(r'\b((?:tit)?m|l)ice$', caseSensitive: false): r'$0ouse',
    RegExp(r'(seraph|cherub)im$', caseSensitive: false): r'$0',
    RegExp(
        r'(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$',
        caseSensitive: false): r'$0',
    RegExp(r'(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$',
        caseSensitive: false): r'$0sis',
    RegExp(r'(movie|twelve|abuse|e[mn]u)s$', caseSensitive: false): r'$0',
    RegExp(r'(test)(?:is|es)$', caseSensitive: false): r'$0is',
    RegExp(
        r'(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$',
        caseSensitive: false): r'$0us',
    RegExp(
        r'(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$',
        caseSensitive: false): r'$0um',
    RegExp(
        r'(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$',
        caseSensitive: false): r'$0on',
    RegExp(r'(alumn|alg|vertebr)ae$', caseSensitive: false): r'$0a',
    RegExp(r'(cod|mur|sil|vert|ind)ices$', caseSensitive: false): r'$0ex',
    RegExp(r'(matr|append)ices$', caseSensitive: false): r'$0ix',
    RegExp(r'(pe)(rson|ople)$', caseSensitive: false): r'$0rson',
    RegExp(r'(child)ren$', caseSensitive: false): r'$0',
    RegExp(r'(eau)x?$', caseSensitive: false): r'$0',
    RegExp(r'men$', caseSensitive: false): 'man',
  };
}



================================================
File: lib/packages/core/lib/packages/pluralize/mixins/data/pluralize_uncountable_data.dart
================================================
class LMChatPluralizeUncountableData {
// Uncountable rules
  static List<dynamic> uncountableRulesData = [
    'adulthood',
    'advice',
    'agenda',
    'aid',
    'aircraft',
    'alcohol',
    'ammo',
    'analytics',
    'anime',
    'athletics',
    'audio',
    'bison',
    'blood',
    'bream',
    'buffalo',
    'butter',
    'carp',
    'cash',
    'chassis',
    'chess',
    'clothing',
    'cod',
    'commerce',
    'cooperation',
    'corps',
    'debris',
    'diabetes',
    'digestion',
    'elk',
    'energy',
    'equipment',
    'excretion',
    'expertise',
    'firmware',
    'flounder',
    'fun',
    'gallows',
    'garbage',
    'graffiti',
    'hardware',
    'headquarters',
    'health',
    'herpes',
    'highjinks',
    'homework',
    'housework',
    'information',
    'jeans',
    'justice',
    'kudos',
    'labour',
    'literature',
    'machinery',
    'mackerel',
    'mail',
    'media',
    'mews',
    'moose',
    'music',
    'mud',
    'manga',
    'news',
    'only',
    'personnel',
    'pike',
    'plankton',
    'pliers',
    'police',
    'pollution',
    'premises',
    'rain',
    'research',
    'rice',
    'salmon',
    'scissors',
    'series',
    'sewage',
    'shambles',
    'shrimp',
    'software',
    'species',
    'staff',
    'swine',
    'tennis',
    'traffic',
    'transportation',
    'trout',
    'tuna',
    'wealth',
    'welfare',
    'whiting',
    'wildebeest',
    'wildlife',
    'you',
    RegExp(r'pok[eé]mon$', caseSensitive: false),
    RegExp(r'[^aeiou]ese$', caseSensitive: false),
    RegExp(r'deer$', caseSensitive: false),
    RegExp(r'fish$', caseSensitive: false),
    RegExp(r'measles$', caseSensitive: false),
    RegExp(r'o[iu]s$', caseSensitive: false),
    RegExp(r'pox$', caseSensitive: false),
    RegExp(r'sheep$', caseSensitive: false)
  ];
}



================================================
File: lib/packages/core/lib/src/blocs/blocs.dart
================================================
export 'home/home_bloc.dart';
export 'chatroom/chatroom_bloc.dart';
export 'chatroom_action/chatroom_action_bloc.dart';
export 'conversation/conversation_bloc.dart';
export 'conversation_action/conversation_action_bloc.dart';
export 'participants/participants_bloc.dart';
export 'dm/dm_bloc.dart';
export 'profile/profile_bloc.dart';
export 'analytics/analytics_bloc.dart';



================================================
File: lib/packages/core/lib/src/blocs/observer.dart
================================================
import 'package:flutter/foundation.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

class LMChatBlocObserver extends BlocObserver {
  @override
  void onEvent(Bloc bloc, Object? event) {
    super.onEvent(bloc, event);
    debugPrint(event.toString());
  }

  @override
  void onChange(BlocBase bloc, Change change) {
    super.onChange(bloc, change);
    // print(change);
  }

  @override
  void onCreate(BlocBase bloc) {
    super.onCreate(bloc);
    // print(bloc);
  }

  @override
  void onTransition(Bloc bloc, Transition transition) {
    super.onTransition(bloc, transition);
    // print(transition);
  }

  @override
  void onError(BlocBase bloc, Object error, StackTrace stackTrace) {
    debugPrint(error.toString());
    super.onError(bloc, error, stackTrace);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/analytics/analytics_bloc.dart
================================================
import 'package:equatable/equatable.dart';
import 'package:bloc/bloc.dart';

part 'analytics_event.dart';
part 'analytics_state.dart';
part 'handler/fire_analytics_event_handler.dart';

/// {@template lm_analytics_bloc}
/// LMChatAnalyticsBloc handle all the analytics related actions
/// like fire analytics event.
/// LMChatAnalyticsEvent defines the events which are handled by this bloc.
/// LMChatAnalyticsState defines the states which are emitted by this bloc
/// {@endtemplate}
class LMChatAnalyticsBloc
    extends Bloc<LMChatAnalyticsEvent, LMChatAnalyticsState> {
  /// {@macro lm_analytics_bloc}
  static LMChatAnalyticsBloc? _lmAnalyticsBloc;

  /// {@macro lm_analytics_bloc}
  static LMChatAnalyticsBloc get instance =>
      _lmAnalyticsBloc ??= LMChatAnalyticsBloc._();

  LMChatAnalyticsBloc._() : super(LMChatAnalyticsInitiated()) {
    on<LMChatFireAnalyticsEvent>(fireAnalyticsEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/analytics/analytics_event.dart
================================================
part of 'analytics_bloc.dart';

/// {@template lm_analytics_event}
/// LMChatAnalyticsEvent defines the events which are handled by LMChatAnalyticsBloc.
/// {@endtemplate}
abstract class LMChatAnalyticsEvent extends Equatable {
  /// {@macro lm_analytics_event}
  const LMChatAnalyticsEvent();

  @override
  List<Object> get props => [];
}

/// {@template lm_init_analytic_event}
/// LMChatInitAnalyticsEvent defines the event to initiate LMChatAnalyticsBloc.
/// {@endtemplate}
class LMChatInitAnalyticsEvent extends LMChatAnalyticsEvent {}

/// {@template lm_fire_analytic_event}
/// LMChatFireAnalyticsEvent defines the event to fire an analytics event.
/// [eventName] of type String defines the name of the event to be fired.
/// [eventProperties] of type Map<String, dynamic> defines the properties
/// of the event to be fired.
/// {@endtemplate}
class LMChatFireAnalyticsEvent extends LMChatAnalyticsEvent {
  // Name of the event to be fired
  // i.e. post_liked, etc.
  final String eventName;
  // Properties of the event to be fired
  // i.e. likes count, post id, etc.
  final Map<String, dynamic> eventProperties;

  /// {@macro lm_feed_widget_source}
  // final LMChatWidgetSource? widgetSource;

  /// {@macro lm_fire_analytic_event}
  const LMChatFireAnalyticsEvent({
    required this.eventName,
    required this.eventProperties,
    // this.widgetSource,
  });

  @override
  List<Object> get props => [
        eventName,
        eventProperties,
        identityHashCode(this),
      ];
}



================================================
File: lib/packages/core/lib/src/blocs/analytics/analytics_state.dart
================================================
part of 'analytics_bloc.dart';

/// {@template lm_fire_analytic_state}
/// LMChatAnalyticsState defines the states which are emitted by LMChatAnalyticsBloc.
/// {@endtemplate}
abstract class LMChatAnalyticsState extends Equatable {
  /// {@macro lm_fire_analytic_state}
  const LMChatAnalyticsState();

  @override
  List<Object> get props => [];
}

/// {@template lm_analytics_initiated_state}
/// LMChatAnalyticsInitiated defines the state when LMChatAnalyticsBloc is initiated.
/// {@endtemplate}
class LMChatAnalyticsInitiated extends LMChatAnalyticsState {}

/// {@template lm_analytics_event_fired_state}
/// LMChatAnalyticsEventFired defines the state when an analytics event is fired.
/// [eventName] of type String defines the name of the event fired.
/// [eventProperties] of type Map<String, dynamic> defines the properties
/// of the event fired.
/// {@endtemplate}
class LMChatAnalyticsEventFired extends LMChatAnalyticsState {
  /// Name of the event fired
  final String eventName;
  /// Properties of the event fired
  /// i.e. likes count, post id, etc.
  final Map<String, dynamic> eventProperties;

  /// {@macro lm_feed_widget_source}
  // final LMChatWidgetSource? widgetSource;

  const LMChatAnalyticsEventFired({
    required this.eventName,
    required this.eventProperties,
    // this.widgetSource,
  });

  @override
  List<Object> get props => [
        eventName,
        eventProperties,
        identityHashCode(this),
      ];
}



================================================
File: lib/packages/core/lib/src/blocs/analytics/handler/fire_analytics_event_handler.dart
================================================
// ignore_for_file: deprecated_member_use_from_same_package

part of '../analytics_bloc.dart';

/// {@template fire_analytics_event_handler}
/// [fireAnalyticsEventHandler] handles the event to fire an analytics event.
/// [eventName] of type String defines the name of the event to be fired.
/// [eventProperties] of type Map<String, dynamic> defines the properties
/// of the event to be fired.
/// {@endtemplate}
fireAnalyticsEventHandler(
    LMChatFireAnalyticsEvent event, Emitter<LMChatAnalyticsState> emit) async {
  emit(LMChatAnalyticsEventFired(
    eventName: event.eventName,
    eventProperties: event.eventProperties,
    // widgetSource: event.widgetSource,
  ));
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom/chatroom_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';

part 'chatroom_event.dart';
part 'chatroom_state.dart';

part 'handler/fetch_chatroom_handler.dart';

/// BLoC responsible for handling the Chatroom,
/// Allows for users to fetch and display a chatroom,
class LMChatroomBloc extends Bloc<LMChatroomEvent, LMChatroomState> {
  static LMChatroomBloc? _instance;

  // Creating a singleton instance of the LMChatHomeFeedBloc
  static LMChatroomBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatroomBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatroomBloc._() : super(LMChatroomLoadingState()) {
    // Event handler for fetching chatroom
    on<LMChatFetchChatroomEvent>(fetchChatroomEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom/chatroom_event.dart
================================================
part of 'chatroom_bloc.dart';

@immutable
abstract class LMChatroomEvent extends Equatable {}

class LMChatFetchChatroomEvent extends LMChatroomEvent {
  final int chatroomId;

  LMChatFetchChatroomEvent({required this.chatroomId});

  @override
  List<Object> get props => [
        chatroomId,
      ];
}

class LMChatroomDetailsEvent extends LMChatroomEvent {
  @override
  List<Object> get props => [];
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom/chatroom_state.dart
================================================
part of 'chatroom_bloc.dart';

@immutable
abstract class LMChatroomState extends Equatable {}

class LMChatroomLoadingState extends LMChatroomState {
  @override
  List<Object> get props => [];
}

class LMChatroomLoadedState extends LMChatroomState {
  final ChatRoom chatroom;
  final List<ChatroomAction> actions;
  final int lastConversationId;
  final int participantCount;

  LMChatroomLoadedState({
    required this.chatroom,
    required this.actions,
    required this.lastConversationId,
    required this.participantCount,
  });

  @override
  List<Object> get props => [
        chatroom,
        actions,
        lastConversationId,
        participantCount,
      ];
}

class LMChatroomErrorState extends LMChatroomState {
  final String message;

  LMChatroomErrorState(this.message);

  @override
  List<Object> get props => [message];
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom/handler/fetch_chatroom_handler.dart
================================================
part of '../chatroom_bloc.dart';

/// Function to handle fetch Home Feed events,
/// emits appropriate state based on response,
/// and converts models to view data models
void fetchChatroomEventHandler(
  LMChatFetchChatroomEvent event,
  Emitter<LMChatroomState> emit,
) async {
  emit(LMChatroomLoadingState());

  // Fetching the chatroom using LMChatClient
  LMResponse<GetChatroomResponse> response =
      await LMChatCore.client.getChatroom(
    (GetChatroomRequestBuilder()..chatroomId(event.chatroomId)).build(),
  );

  //Emit error state and fail gracefully
  if (!response.success) {
    emit(LMChatroomErrorState(
      response.errorMessage ?? LMChatStringConstants.errorFallback,
    ));
  }

  //Success, now continue with parsing the response
  final ChatRoom chatroom = response.data!.chatroom!;

  //Finally, emit the loaded success state with the chatroom response
  emit(
    LMChatroomLoadedState(
      chatroom: chatroom,
      actions: response.data!.chatroomActions!,
      participantCount: response.data!.participantCount ?? 0,
      lastConversationId: response.data!.lastConversationId ?? 0,
    ),
  );
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/chatroom_action_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:meta/meta.dart';

part 'chatroom_action_event.dart';
part 'chatroom_action_state.dart';

part 'handler/show_emoji_keyboard_handler.dart';
part 'handler/hide_emoji_keyboard_handler.dart';
part 'handler/mark_read_chatroom_handler.dart';
part 'handler/set_chatroom_topic_handler.dart';

class LMChatroomActionBloc
    extends Bloc<LMChatroomActionEvent, LMChatroomActionState> {
  static LMChatroomActionBloc? _instance;
  // Creating a singleton instance of the LMChatHomeFeedBloc
  static LMChatroomActionBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatroomActionBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatroomActionBloc._() : super(LMChatChatroomActionInitial()) {
    on<LMChatroomActionEvent>(_handleEvent);
  }

  void _handleEvent(
      LMChatroomActionEvent event, Emitter<LMChatroomActionState> emit) async {
    if (event is LMChatShowEmojiKeyboardEvent) {
      _handleShowEmojiKeyboard(event, emit);
    } else if (event is LMChatHideEmojiKeyboardEvent) {
      _handleHideEmojiKeyboard(emit);
    } else if (event is LMChatMarkReadChatroomEvent) {
      await _handleMarkReadChatroom(event);
    } else if (event is LMChatSetChatroomTopicEvent) {
      await _handleSetChatroomTopic(event, emit);
    }
  }
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/chatroom_action_event.dart
================================================
part of 'chatroom_action_bloc.dart';

@immutable
abstract class LMChatroomActionEvent extends Equatable {}

class LMChatMarkReadChatroomEvent extends LMChatroomActionEvent {
  final int chatroomId;

  LMChatMarkReadChatroomEvent({required this.chatroomId});

  @override
  List<Object> get props => [chatroomId];
}

class LMChatFollowChatroomEvent extends LMChatroomActionEvent {
  final int chatroomId;
  final bool follow;

  LMChatFollowChatroomEvent({
    required this.chatroomId,
    required this.follow,
  });

  @override
  List<Object> get props => [chatroomId];
}

class LMChatLeaveChatroomEvent extends LMChatroomActionEvent {
  final int chatroomId;

  LMChatLeaveChatroomEvent({required this.chatroomId});

  @override
  List<Object> get props => [chatroomId];
}

class LMChatMuteChatroomEvent extends LMChatroomActionEvent {
  final int chatroomId;
  final bool mute;

  LMChatMuteChatroomEvent({
    required this.chatroomId,
    required this.mute,
  });

  @override
  List<Object> get props => [chatroomId];
}

class LMChatSetChatroomTopicEvent extends LMChatroomActionEvent {
  final int chatroomId;
  final int conversationId;
  final Conversation topic;

  LMChatSetChatroomTopicEvent({
    required this.chatroomId,
    required this.conversationId,
    required this.topic,
  });

  @override
  List<Object> get props => [chatroomId, conversationId, topic];
}

class LMChatShareChatroomUrlEvent extends LMChatroomActionEvent {
  final int chatroomId;
  final String domain;

  LMChatShareChatroomUrlEvent({
    required this.chatroomId,
    required this.domain,
  });

  @override
  List<Object> get props => [chatroomId];
}

class LMChatShowEmojiKeyboardEvent extends LMChatroomActionEvent {
  final int conversationId;

  LMChatShowEmojiKeyboardEvent({required this.conversationId});

  @override
  List<Object?> get props => [conversationId];
}

class LMChatHideEmojiKeyboardEvent extends LMChatroomActionEvent {
  LMChatHideEmojiKeyboardEvent();

  @override
  List<Object?> get props => [];
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/chatroom_action_state.dart
================================================
part of 'chatroom_action_bloc.dart';

@immutable
abstract class LMChatroomActionState extends Equatable {}

class LMChatChatroomActionInitial extends LMChatroomActionState {
  @override
  List<Object?> get props => [];
}

class LMChatChatroomActionLoading extends LMChatroomActionState {
  @override
  List<Object?> get props => [];
}

class LMChatChatroomTopicSet extends LMChatroomActionState {
  final Conversation topic;
  LMChatChatroomTopicSet(this.topic);
  @override
  List<Object?> get props => [topic];
}

class LMChatChatroomTopicError extends LMChatroomActionState {
  final String errorMessage;
  LMChatChatroomTopicError({
    required this.errorMessage,
  });
  @override
  List<Object?> get props => [errorMessage];
}

class LMChatShowEmojiKeyboardState extends LMChatroomActionState {
  final int conversationId;

  LMChatShowEmojiKeyboardState({required this.conversationId});
  @override
  List<Object?> get props => [conversationId];
}

class LMChatHideEmojiKeyboardState extends LMChatroomActionState {
  LMChatHideEmojiKeyboardState();
  @override
  List<Object?> get props => [];
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/handler/hide_emoji_keyboard_handler.dart
================================================
part of '../chatroom_action_bloc.dart';

void _handleHideEmojiKeyboard(Emitter<LMChatroomActionState> emit) {
  emit(LMChatHideEmojiKeyboardState());
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/handler/mark_read_chatroom_handler.dart
================================================
part of '../chatroom_action_bloc.dart';

Future<void> _handleMarkReadChatroom(LMChatMarkReadChatroomEvent event) async {
  // ignore: unused_local_variable
  LMResponse response = await LMChatCore.client.markReadChatroom(
      (MarkReadChatroomRequestBuilder()..chatroomId(event.chatroomId)).build());
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/handler/set_chatroom_topic_handler.dart
================================================
part of '../chatroom_action_bloc.dart';

Future<void> _handleSetChatroomTopic(LMChatSetChatroomTopicEvent event,
    Emitter<LMChatroomActionState> emit) async {
  try {
    emit(LMChatChatroomActionLoading());
    LMResponse<void> response = await LMChatCore.client
        .setChatroomTopic((SetChatroomTopicRequestBuilder()
              ..chatroomId(event.chatroomId)
              ..conversationId(event.conversationId))
            .build());
    if (response.success) {
      emit(LMChatChatroomTopicSet(event.topic));
    } else {
      emit(LMChatChatroomTopicError(errorMessage: response.errorMessage!));
    }
  } catch (e) {
    emit(LMChatChatroomTopicError(
        errorMessage: "An error occurred while setting topic"));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/chatroom_action/handler/show_emoji_keyboard_handler.dart
================================================
part of '../chatroom_action_bloc.dart';

void _handleShowEmojiKeyboard(
    LMChatShowEmojiKeyboardEvent event, Emitter<LMChatroomActionState> emit) {
  emit(LMChatShowEmojiKeyboardState(
    conversationId: event.conversationId,
  ));
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/conversation_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/services/media_service.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';

part 'conversation_event.dart';
part 'conversation_state.dart';

part 'handler/post_conversation_handler.dart';
part 'handler/post_multimedia_conversation_handler.dart';
part 'handler/fetch_conversation_handler.dart';
part 'handler/update_conversation_handler.dart';
part 'handler/initialise_conversations_handler.dart';
part 'handler/local_conversation_handler.dart';
part 'handler/post_poll_handler.dart';

/// LMChatConversationBloc is the BLoC that manages conversations
///
/// It is used to fetch, refresh, and post conversations.
///
/// Uses a combination of LMChatConversationEvent, and LMChatVonversationState objects.
class LMChatConversationBloc
    extends Bloc<LMChatConversationEvent, LMChatConversationState> {
  /// Last conversation id for this instance of [LMChatConversationBloc]
  int? lastConversationId;

  /// A reference to the real-time database for the chatroom.
  ///
  /// This is an instance of [DatabaseReference] obtained from the
  /// [LMChatRealtime] singleton. It is used to interact with the
  /// real-time chatroom data in the Firebase Realtime Database.
  final DatabaseReference realTime = LMChatRealtime.instance.chatroom();

  static LMChatConversationBloc? _instance;

  /// The ID of the current chatroom.
  ///
  /// This is a static variable that holds the ID of the chatroom that is
  /// currently active or being interacted with. It can be `null` if no
  /// chatroom is currently selected.
  static int? currentChatroomId;

  /// The reply conversation if user taps on reply and is not present in the current list
  static LMChatConversationViewData? replyConversation;

  /// Creates and maintains a singleton instance of this BLoC
  static LMChatConversationBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatConversationBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatConversationBloc._() : super(LMChatConversationInitialState()) {
    // Handle initialise conversation event through handler
    on<LMChatInitialiseConversationsEvent>(initialiseConversationsEventHandler);
    // Handle fetch conversation events through handler
    on<LMChatFetchConversationsEvent>(fetchConversationsEventHandler);
    // Handle post conversation event through handler
    on<LMChatPostConversationEvent>(postConversationEventHandler);
    // Handle post multimedia conversation event through handler
    on<LMChatPostMultiMediaConversationEvent>(
        postMultimediaConversationEventHandler);
    // Handle update conversations event through handler
    on<LMChatUpdateConversationsEvent>(updateConversationsEventHandler);
    // Handle adding of local conversation through handler
    on<LMChatLocalConversationEvent>(localConversationEventHandler);
    // Handle posting of poll conversation through handler
    on<LMChatPostPollConversationEvent>(postPollConversationHandler);
  }

  @override
  Future<void> close() {
    currentChatroomId = null;
    LMChatConversationBloc.replyConversation = null;
    return super.close();
  }

  /// Handles the initialization of conversation events.
  ///
  /// This method sets the current chatroom ID and the last conversation ID
  /// from the provided event. It also listens for real-time updates on child
  /// changes and triggers an update event if a new conversation is detected.
  ///
  /// Parameters:
  /// - `event`: The event containing the chatroom ID and conversation ID to initialize.
  /// - `emit`: The emitter used to emit new states.
  ///
  /// Listens to:
  /// - `realTime.onChildChanged`: Listens for changes in the real-time database.
  ///   If a change is detected and it is not the same as the last conversation ID,
  ///   an update event is added to the conversation bloc.
  initialiseConversationsEventHandler(
    LMChatInitialiseConversationsEvent event,
    Emitter<LMChatConversationState> emit,
  ) async {
    currentChatroomId = event.chatroomId;
    lastConversationId = event.conversationId;

    realTime.onChildChanged.listen(
      (event) {
        if (event.snapshot.value != null && currentChatroomId != null) {
          final response = event.snapshot.value as Map;
          final conversationId = int.tryParse(response["answer_id"]);
          if (lastConversationId != null &&
              conversationId != lastConversationId &&
              conversationId != null) {
            LMChatConversationBloc.instance.add(LMChatUpdateConversationsEvent(
              chatroomId: currentChatroomId!,
              conversationId: conversationId,
            ));
          }
        }
      },
    );
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/conversation_event.dart
================================================
part of 'conversation_bloc.dart';

/// Abstract class representing a conversation event
abstract class LMChatConversationEvent extends Equatable {}

/// Event responsible for initialising LMChatConversationBloc
class LMChatInitialiseConversationsEvent extends LMChatConversationEvent {
  /// Id of the chatroom where conversations are being initialized
  final int chatroomId;

  /// Last conversation id of the chatroom of conversations
  final int conversationId;

  /// Creates and returns a new instance of initialize event
  LMChatInitialiseConversationsEvent({
    required this.chatroomId,
    required this.conversationId,
  });

  @override
  List<Object?> get props => [chatroomId, conversationId];
}

/// Event responsible for fetching conversations in a chatroom
class LMChatFetchConversationsEvent extends LMChatConversationEvent {
  /// Id of the chatroom where conversations are being fetched
  final int chatroomId;

  /// Page number of the conversations
  final int page;

  /// Number of conversations to be fetched
  final int pageSize;

  /// Minimum timestamp for filtering conversations.
  /// If provided, only conversations after this timestamp will be fetched.
  final int? minTimestamp;

  /// Maximum timestamp for filtering conversations.
  /// If provided, only conversations before this timestamp will be fetched.
  final int? maxTimestamp;

  /// Direction of pagination for fetching conversations.
  /// This determines whether to fetch newer or older conversations.
  final LMPaginationDirection direction;

  /// ID of the last conversation fetched.
  /// Used for pagination to fetch the next set of conversations.
  final int? lastConversationId;

  /// ID of the conversation being replied to, if any.
  final int? replyId;

  /// Order in which conversations should be fetched.
  /// Can be ascending or descending.
  final OrderBy? orderBy;

  /// Flag indicating whether to reinitialize the conversation list.
  /// If true, the conversation list will be reinitialized.
  final bool reInitialize;

  /// Creates and returns a new instance of [LMChatFetchConversationsEvent]
  LMChatFetchConversationsEvent({
    required this.chatroomId,
    required this.page,
    required this.pageSize,
    required this.direction,
    required this.lastConversationId,
    this.minTimestamp,
    this.maxTimestamp,
    this.replyId,
    this.orderBy,
    this.reInitialize = false,
  });

  @override
  List<Object> get props => [
        chatroomId,
        page,
        pageSize,
        direction,
        lastConversationId ?? -1,
        minTimestamp ?? 0,
        maxTimestamp ?? 0,
        replyId ?? -1,
        orderBy ?? OrderBy.descending,
        reInitialize,
      ];
}

/// Event responsible for creating and posting a new conversation
class LMChatPostConversationEvent extends LMChatConversationEvent {
  /// Text of the conversation
  final String text;

  /// Chatroom id where the conversation is to be posted
  final int chatroomId;

  /// Id of the conversation being replied to if any
  final int? replyId;

  /// Reply object of the conversation being replied to if any
  final LMChatConversationViewData? repliedTo;

  /// Link String if present
  final String? shareLink;

  /// Attachment count of the conversation
  final int? attachmentCount;

  /// Has files of the conversation
  final bool? hasFiles;

  /// Trigger bot of the conversation
  final bool? triggerBot;

  /// A map containing additional metadata for the conversation event.
  /// This can be used to store any extra information related to the event.
  final Map<String, dynamic>? metadata;

  /// Creates and returns a new instance of [LMChatPostConversationEvent]
  LMChatPostConversationEvent({
    required this.chatroomId,
    required this.text,
    this.replyId,
    this.repliedTo,
    this.shareLink,
    this.attachmentCount,
    this.hasFiles,
    this.triggerBot,
    this.metadata,
  });

  @override
  List<Object?> get props => [
        chatroomId,
        text,
        replyId,
        repliedTo,
        shareLink,
        attachmentCount,
        hasFiles,
        triggerBot,
        metadata,
      ];
}

/// Event responsible for creating and posting a multimedia conversation
class LMChatPostMultiMediaConversationEvent extends LMChatConversationEvent {
  /// Request object containing the details of the conversation to be posted
  final PostConversationRequest postConversationRequest;

  /// List of media files to be included in the conversation
  final List<LMChatMediaModel> mediaFiles;

  /// Creates and returns a new instance of [LMChatPostMultiMediaConversationEvent]
  LMChatPostMultiMediaConversationEvent(
    this.postConversationRequest,
    this.mediaFiles,
  );

  @override
  List<Object> get props => [
        postConversationRequest,
        mediaFiles,
      ];
}

/// Event responsible for updating the conversations of a chatroom
///
/// This could be because of a realtime update, or a notification
class LMChatUpdateConversationsEvent extends LMChatConversationEvent {
  /// Id of the conversation to be updated
  final int conversationId;

  /// Id of the chatroom where the conversation is to be updated
  final int chatroomId;

  /// check if the conversation should be updated explicitly
  /// irrespective of the last conversation id
  /// This is useful when editing a poll
  final bool shouldUpdate;

  /// Creates and returns a new instance of [LMChatUpdateConversationsEvent]
  LMChatUpdateConversationsEvent({
    required this.conversationId,
    required this.chatroomId,
    this.shouldUpdate = false,
  });

  @override
  List<Object> get props => [
        conversationId,
        chatroomId,
        shouldUpdate,
      ];
}

class LMChatLocalConversationEvent extends LMChatConversationEvent {
  final LMChatConversationViewData conversation;

  LMChatLocalConversationEvent({
    required this.conversation,
  });

  @override
  List<Object> get props => [
        conversation,
      ];
}

/// {@template lm_chat_post_poll_conversation_event}
/// Event responsible for creating and posting a poll conversation
/// {@endtemplate}
class LMChatPostPollConversationEvent extends LMChatConversationEvent {
  /// The ID of the chatroom.
  final int chatroomId;

  /// The text content of the conversation.
  final String text;

  /// The state of the conversation.
  final int state;

  /// A list of poll options.
  final List<String> polls;

  /// The type of the poll.
  final int pollType;

  /// The state of multiple selection.
  final int multipleSelectState;

  /// The number of multiple selections allowed.
  final int multipleSelectNo;

  /// Indicates if the conversation is anonymous.
  final bool isAnonymous;

  /// Allows adding options to the poll.
  final bool allowAddOption;

  /// The expiry time of the poll.
  final int? expiryTime;

  /// A temporary ID for the conversation.
  final String temporaryId;

  /// The ID of the replied conversation, if any.
  final String? repliedConversationId;

  /// Indicates if the poll has no expiry.
  /// If true, the poll will not expire.
  final bool? noPollExpiry;

  /// Indicates if the vote can be changed.
  /// If true, the user can change their vote.
  /// in case of open and instant polls, the user can change their vote.
  /// in case of deferred polls, it is set to true.
  final bool? allowVoteChange;

  /// {@macro lm_chat_post_poll_conversation_event}
  LMChatPostPollConversationEvent({
    required this.chatroomId,
    required this.text,
    this.state = 10,
    required this.polls,
    required this.pollType,
    required this.multipleSelectState,
    required this.multipleSelectNo,
    required this.isAnonymous,
    required this.allowAddOption,
    this.expiryTime,
    required this.temporaryId,
    this.repliedConversationId,
    this.noPollExpiry,
    this.allowVoteChange,
  });

  @override
  List<Object> get props => [
        chatroomId,
        text,
        state,
        polls,
        pollType,
        multipleSelectState,
        multipleSelectNo,
        isAnonymous,
        allowAddOption,
        expiryTime ?? -1,
        temporaryId,
        repliedConversationId ?? -1,
        noPollExpiry ?? false,
        allowVoteChange ?? false,
      ];
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/conversation_state.dart
================================================
part of 'conversation_bloc.dart';

/// Abtract class representing a LMChat conversation state
abstract class LMChatConversationState extends Equatable {
  @override
  List<Object> get props => [];
}

/// Represents the initial state of a conversation.
class LMChatConversationInitialState extends LMChatConversationState {}

/// Represents the loading state of a conversation.
class LMChatConversationLoadingState extends LMChatConversationState {}

/// Represents the loaded state of a conversation.
class LMChatConversationLoadedState extends LMChatConversationState {
  /// The response containing the loaded conversation data.
  final GetConversationResponse getConversationResponse;

  final LMPaginationDirection direction;
  final int page;
  final bool reInitialize;

  /// Creates and returns a new instance of [LMChatConversationLoadedState]
  LMChatConversationLoadedState(this.getConversationResponse, this.direction, this.page, {this.reInitialize = false});

  @override
  List<Object> get props => [getConversationResponse, direction, page, reInitialize];
}

/// Represents an error state in the conversation.
class LMChatConversationErrorState extends LMChatConversationState {
  /// The error message.
  final String message;

  /// A temporary identifier associated with the error.
  final String temporaryId;

  /// Creates and returns a new instance of [LMChatConversationErrorState]
  LMChatConversationErrorState(
    this.message,
    this.temporaryId,
  );

  @override
  List<Object> get props => [message];
}

/// Represents an updated state of the conversation.
class LMChatConversationUpdatedState extends LMChatConversationState {
  /// The updated conversation data.
  final LMChatConversationViewData conversationViewData;

  final Map<String, List<LMChatAttachmentViewData>> attachments;

  /// check if the conversation should be updated explicitly
  /// irrespective of the last conversation id
  /// This is useful when editing a poll
  final bool shouldUpdate;

  /// Creates and returns a new instance of [LMChatConversationUpdatedState]
  LMChatConversationUpdatedState({
    required this.conversationViewData,
    required this.attachments,
    this.shouldUpdate = false,
  });

  @override
  List<Object> get props => [
        conversationViewData,
        attachments,
        shouldUpdate,
      ];
}

/// Represents a local state of the conversation.
class LMChatLocalConversationState extends LMChatConversationState {
  /// The local conversation data.
  final LMChatConversationViewData conversationViewData;

  /// Creates and returns a new instance of [LMChatLocalConversationState]
  LMChatLocalConversationState(this.conversationViewData);

  @override
  List<Object> get props => [conversationViewData];
}

/// Represents the state after a conversation has been posted.
class LMChatConversationPostedState extends LMChatConversationState {
  /// The response received after posting the conversation.
  final LMChatConversationViewData conversationViewData;

  /// Creates and returns a new instance of [LMChatConversationPostedState]
  LMChatConversationPostedState(
    this.conversationViewData,
  );

  @override
  List<Object> get props => [
        conversationViewData,
      ];
}

/// Represents the loading state for a multimedia conversation.
class LMChatMultiMediaConversationLoadingState extends LMChatConversationState {
  /// The conversation being posted.
  final Conversation postConversation;

  /// The list of media files associated with the conversation.
  final List<LMChatMediaModel> mediaFiles;

  /// Creates and returns a new instance of [LMChatMultiMediaConversationLoadingState]
  LMChatMultiMediaConversationLoadingState(
    this.postConversation,
    this.mediaFiles,
  );

  @override
  List<Object> get props => [mediaFiles, postConversation];
}

/// Represents the state after a multimedia conversation has been posted.
class LMChatMultiMediaConversationPostedState extends LMChatConversationState {
  /// The response received after posting the conversation.
  final PostConversationResponse postConversationResponse;

  /// The response received after putting (uploading) the media files.
  final List<LMChatMediaModel> putMediaResponse;

  /// Creates and returns a new instance of [LMChatMultiMediaConversationPostedState]
  LMChatMultiMediaConversationPostedState(
    this.postConversationResponse,
    this.putMediaResponse,
  );

  @override
  List<Object> get props => [postConversationResponse, putMediaResponse];
}

/// Represents an error state in a multimedia conversation.
class LMChatMultiMediaConversationErrorState extends LMChatConversationState {
  /// The error message.
  final String errorMessage;

  /// A temporary identifier associated with the error.
  final String temporaryId;

  /// Creates and returns a new instance of [LMChatMultiMediaConversationErrorState]
  LMChatMultiMediaConversationErrorState(
    this.errorMessage,
    this.temporaryId,
  );

  @override
  List<Object> get props => [errorMessage, temporaryId];
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/fetch_conversation_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler responsible for fetching conversation event
fetchConversationsEventHandler(
  LMChatFetchConversationsEvent event,
  Emitter<LMChatConversationState> emit,
) async {
  emit(LMChatConversationLoadingState());
  final currentTime = DateTime.now().millisecondsSinceEpoch;
  final int minTimestamp = event.minTimestamp ?? 0;
  final int maxTimestamp = event.maxTimestamp ?? currentTime;
  final GetConversationRequestBuilder getConversationRequestBuilder =
      GetConversationRequestBuilder()
        ..chatroomId(event.chatroomId)
        ..page(event.page)
        ..pageSize(event.pageSize)
        ..isLocalDB(false)
        ..minTimestamp(minTimestamp)
        ..orderBy(event.orderBy ?? OrderBy.descending)
        ..maxTimestamp(maxTimestamp);
  if (event.replyId != null) {
    getConversationRequestBuilder.conversationId(event.replyId!);
  }
  LMResponse response = await LMChatCore.client
      .getConversation(getConversationRequestBuilder.build());
  if (response.success) {
    GetConversationResponse conversationResponse = response.data;
    for (var element in conversationResponse.conversationData!) {
      //Assigning member to the conversation from userMeta
      element.member = conversationResponse.userMeta?[element.memberId];
      //Assigning reply to the conversation from conversationMeta
      String? replyId = element.replyId == null
          ? element.replyConversation?.toString()
          : element.replyId.toString();
      element.replyConversationObject =
          conversationResponse.conversationMeta?[replyId];
      element.replyConversationObject?.member = conversationResponse
          .userMeta?[element.replyConversationObject?.memberId];
      //Assigning attachment to the conversation from attachmentMeta
    }
    emit(LMChatConversationLoadedState(
      conversationResponse,
      event.direction,
      event.page,
      reInitialize: event.reInitialize,
    ));
  } else {
    emit(LMChatConversationErrorState(response.errorMessage!, ''));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/initialise_conversations_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler for updating conversations in a chatroom
initialiseConversationsEventHandler(
  LMChatInitialiseConversationsEvent event,
  Emitter<LMChatConversationState> emit,
) async {
  final DatabaseReference realTime = LMChatRealtime.instance.chatroom();
  int? lastConversationId = LMChatConversationBloc.instance.lastConversationId;
  int chatroomId = event.chatroomId;
  lastConversationId = event.conversationId;

  realTime.onValue.listen(
    (event) {
      if (event.snapshot.value != null) {
        final response = event.snapshot.value as Map;
        final conversationId = int.parse(response["collabcard"]["answer_id"]);
        if (lastConversationId != null &&
            conversationId != lastConversationId) {
          LMChatConversationBloc.instance.add(LMChatUpdateConversationsEvent(
            chatroomId: chatroomId,
            conversationId: conversationId,
          ));
        }
      }
    },
  );
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/local_conversation_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler for updating conversations in a chatroom
localConversationEventHandler(
  LMChatLocalConversationEvent event,
  Emitter<LMChatConversationState> emit,
) async {
  int? lastConversationId = LMChatConversationBloc.instance.lastConversationId;
  if (lastConversationId != null &&
      event.conversation.id != lastConversationId) {
    emit(LMChatLocalConversationState(event.conversation));
    lastConversationId = event.conversation.id;
  }

  LMChatConversationBloc.instance.lastConversationId = lastConversationId;
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/post_conversation_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler for managing post conversation event
postConversationEventHandler(
  LMChatPostConversationEvent event,
  Emitter<LMChatConversationState> emit,
) async {
  final DateTime dateTime = DateTime.now();
  final tempId = "-${dateTime.millisecondsSinceEpoch.toString()}";
  try {
    User user = LMChatLocalPreference.instance.getUser();

    final PostConversationRequestBuilder postConversationRequest =
        PostConversationRequestBuilder()
          ..chatroomId(event.chatroomId)
          ..text(event.text)
          ..replyId(event.replyId)
          ..triggerBot(event.triggerBot ?? false)
          ..hasFiles(event.hasFiles ?? false)
          ..temporaryId(tempId);

    LMChatConversationViewDataBuilder conversationViewDataBuilder =
        LMChatConversationViewDataBuilder()
          ..answer(event.text)
          ..chatroomId(event.chatroomId)
          ..createdAt("")
          ..memberId(user.id)
          ..header("")
          ..date(DateFormat('dd MMM yyyy').format(dateTime))
          ..attachmentsUploaded(false)
          ..replyId(event.replyId)
          ..replyConversationObject(event.repliedTo)
          ..hasFiles(event.hasFiles ?? false)
          ..member(user.toUserViewData())
          ..temporaryId(tempId)
          ..createdEpoch(dateTime.millisecondsSinceEpoch)
          ..id(1);

    if (event.metadata != null) {
      postConversationRequest.metadata(event.metadata!);

      LMChatWidgetViewData widgetViewData = (LMWidgetViewDataBuilder()
            ..id(tempId)
            ..metadata(event.metadata))
          .build();

      conversationViewDataBuilder
        ..widget(widgetViewData)
        ..widgetId(tempId);
    }

    LMChatConversationViewData conversationViewData =
        conversationViewDataBuilder.build();

    emit(LMChatLocalConversationState(conversationViewData));

    if (event.replyId == null &&
        event.shareLink != null &&
        event.shareLink!.isNotEmpty) {
      postConversationRequest.shareLink(event.shareLink!);
    }
    LMResponse<PostConversationResponse> response =
        await LMChatCore.client.postConversation(
      postConversationRequest.build(),
    );

    if (response.success && response.data != null) {
      Conversation conversation = response.data!.conversation!;
      conversationViewData = conversation.toConversationViewData();
      if (conversation.replyId != null ||
          conversation.replyConversation != null) {
        conversationViewData = conversationViewData.copyWith(
          replyConversationObject: event.repliedTo,
        );
      }
      emit(LMChatConversationPostedState(conversationViewData));
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.chatroomResponded,
          eventProperties: {
            'chatroom_id': event.chatroomId,
            'chatroom_type': 'normal',
            'community_id':
                LMChatLocalPreference.instance.getCommunityData()?.id,
          },
        ),
      );
      LMChatConversationBloc.instance.lastConversationId = conversation.id;
      return false;
    } else {
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.messageSendingError,
          eventProperties: {
            'chatroom_id': event.chatroomId,
            'chatroom_type': 'normal',
          },
        ),
      );
      emit(LMChatConversationErrorState(
        response.errorMessage!,
        tempId,
      ));
      return false;
    }
  } catch (e) {
    LMChatAnalyticsBloc.instance.add(
      LMChatFireAnalyticsEvent(
        eventName: LMChatAnalyticsKeys.messageSendingError,
        eventProperties: {
          'chatroom_id': event.chatroomId,
          'chatroom_type': 'normal',
        },
      ),
    );
    emit(LMChatConversationErrorState(
      "An error occurred",
      tempId,
    ));
    return false;
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/post_multimedia_conversation_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler for managing post multimedia conversation event
postMultimediaConversationEventHandler(
  LMChatPostMultiMediaConversationEvent event,
  Emitter<LMChatConversationState> emit,
) async {
  final List<LMChatMediaModel> mediaList = event.mediaFiles.copy();
  try {
    // Generate thumbnails for videos before creating temporary conversation
    for (LMChatMediaModel media in mediaList) {
      if (media.mediaType == LMChatMediaType.video) {
        media.thumbnailFile ??= await getVideoThumbnail(media);
      }
    }

    // Create temporary conversation
    DateTime dateTime = DateTime.now();
    User user = LMChatLocalPreference.instance.getUser();
    String temporaryId = "-${event.postConversationRequest.temporaryId}";

    // Create temporary conversation object
    Conversation temporaryConversation = Conversation(
      answer: event.postConversationRequest.text,
      chatroomId: event.postConversationRequest.chatroomId,
      createdAt: "",
      header: "",
      date: DateFormat('dd MMM yyyy').format(dateTime),
      replyId: event.postConversationRequest.replyId,
      hasFiles: event.postConversationRequest.hasFiles,
      member: user,
      temporaryId: temporaryId,
      id: 1, // Temporary ID for local handling
      memberId: user.id,
      ogTags: event.postConversationRequest.ogTags,
      createdEpoch: dateTime.millisecondsSinceEpoch,
      attachments: mediaList
          .map((media) => media.toAttachmentViewData().toAttachment())
          .toList(),
    );

    // Emit loading state with temporary conversation
    emit(LMChatMultiMediaConversationLoadingState(
      temporaryConversation,
      mediaList,
    ));

    // Handle file uploads
    List<Attachment> uploadedAttachments = [];
    for (int index = 0; index < mediaList.length; index++) {
      LMChatMediaModel media = mediaList[index];
      try {
        // Upload main file
        String? url;
        if (media.mediaFile != null) {
          final response = await LMChatMediaService.uploadFile(
            media.mediaFile!.readAsBytesSync(),
            user.sdkClientInfo?.uuid ?? user.userUniqueId!,
            fileName: media.mediaFile!.path.split('/').last,
            chatroomId: event.postConversationRequest.chatroomId,
          );

          if (response.success) {
            url = response.data;
            media.mediaUrl = url;
          }
        } else {
          url = media.mediaUrl;
        }

        // Handle video thumbnail
        String? thumbnailUrl;
        if (media.mediaType == LMChatMediaType.video) {
          final response = await LMChatMediaService.uploadFile(
            media.thumbnailFile!.readAsBytesSync(),
            user.userUniqueId!,
            fileName: media.thumbnailFile!.path.split('/').last,
            chatroomId: event.postConversationRequest.chatroomId,
          );

          if (response.success) {
            thumbnailUrl = response.data;
            media.thumbnailUrl = thumbnailUrl;
          }
        }

        // Create attachment model
        uploadedAttachments.add(media
            .copyWith(
              mediaUrl: url,
              thumbnailUrl: thumbnailUrl,
              mediaFile: null,
              thumbnailFile: null,
            )
            .toAttachmentViewData()
            .copyWith(index: index)
            .toAttachment());
      } catch (e) {
        _callAnalyticEvent(event);
        emit(LMChatMultiMediaConversationErrorState(
          e.toString(),
          temporaryId,
        ));
        return;
      }
    }

    final requestBuilder = (PostConversationRequestBuilder()
      ..attachments(uploadedAttachments)
      ..temporaryId(temporaryId)
      ..text(event.postConversationRequest.text)
      ..chatroomId(event.postConversationRequest.chatroomId)
      ..hasFiles(event.postConversationRequest.hasFiles)
      ..replyId(event.postConversationRequest.replyId)
      ..triggerBot(event.postConversationRequest.triggerBot ?? false));

    if (event.postConversationRequest.ogTags != null) {
      requestBuilder.ogTags(event.postConversationRequest.ogTags!);
    }
    // Post conversation to server
    final response = await LMChatCore.client.postConversation(
      requestBuilder.build(),
    );
    if (response.success) {
      emit(LMChatMultiMediaConversationPostedState(
        response.data!,
        mediaList,
      ));

      // Fire analytics event
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.chatroomResponded,
          eventProperties: {
            'chatroom_id': event.postConversationRequest.chatroomId,
            'chatroom_type': 'normal',
            'community_id':
                LMChatLocalPreference.instance.getCommunityData()?.id,
          },
        ),
      );

      LMChatMediaHandler.instance.clearPickedMedia();
      LMChatConversationBloc.instance.lastConversationId = response.data!.id;
    } else {
      _callAnalyticEvent(event);
      emit(LMChatMultiMediaConversationErrorState(
        response.errorMessage!,
        temporaryId,
      ));
    }
  } catch (e) {
    _callAnalyticEvent(event);
    emit(LMChatConversationErrorState(
      "An error occurred",
      event.postConversationRequest.temporaryId,
    ));
  }
}

void _callAnalyticEvent(event) {
  LMChatAnalyticsBloc.instance.add(
    LMChatFireAnalyticsEvent(
      eventName: LMChatAnalyticsKeys.attachmentUploadedError,
      eventProperties: {
        'chatroom_id': event.postConversationRequest.chatroomId,
        'chatroom_type': 'normal',
      },
    ),
  );
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/post_poll_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler for posting a poll conversation
void postPollConversationHandler(
    LMChatPostPollConversationEvent event, emit) async {
  emit(LMChatConversationLoadingState());
  User user = LMChatLocalPreference.instance.getUser();
  // map poll options
  final pollOptions =
      event.polls.map((option) => PollOption(text: option)).toList();
  // create request builder
  final PostPollConversationRequestBuilder requestBuilder =
      PostPollConversationRequestBuilder()
        ..chatroomId(event.chatroomId)
        ..text(event.text)
        ..state(10)
        ..polls(pollOptions)
        ..pollType(event.pollType)
        ..multipleSelectState(event.multipleSelectState)
        ..multipleSelectNo(event.multipleSelectNo)
        ..isAnonymous(event.isAnonymous)
        ..allowAddOption(event.allowAddOption)
        ..expiryTime(event.expiryTime)
        ..temporaryId(event.temporaryId)
        ..noPollExpiry(event.noPollExpiry)
        ..allowVoteChange(event.allowVoteChange);
  if (event.repliedConversationId != null) {
    requestBuilder.repliedConversationId(event.repliedConversationId!);
  }
  // create request object
  final PostPollConversationRequest pollRequest = requestBuilder.build();

  final DateTime dateTime = DateTime.now();
  // create local conversation
  LMChatConversationViewData conversationViewData =
      (LMChatConversationViewDataBuilder()
            ..allowAddOption(event.allowAddOption)
            ..answer(event.text)
            ..chatroomId(event.chatroomId)
            ..createdAt("")
            ..expiryTime(event.expiryTime)
            ..memberId(user.id)
            ..member(user.toUserViewData())
            ..multipleSelectNo(event.multipleSelectNo)
            ..multipleSelectState(
                LMChatPollMultiSelectState.fromValue(event.multipleSelectState))
            ..date("${dateTime.day} ${dateTime.month} ${dateTime.year}")
            ..state(10)
            ..poll(pollOptions.map((e) => e.toPollOptionViewData()).toList())
            ..pollType(LMChatPollType.fromValue(event.pollType))
            ..member(user.toUserViewData())
            ..temporaryId(event.temporaryId)
            ..id(int.parse(event.temporaryId))
            ..toShowResults(true)
            ..submitTypeText(
                event.isAnonymous ? "Secret voting " : "Public voting"))
          .build();
  emit(LMChatLocalConversationState(conversationViewData));
// post conversation to server
  LMResponse<PostConversationResponse> response =
      await LMChatCore.client.postPollConversation(pollRequest);
  if (response.success && response.data != null) {
    // update local conversation with server response
    Conversation conversation = response.data!.conversation!;
    conversationViewData = conversation.toConversationViewData();
    emit(LMChatConversationPostedState(conversationViewData));
  } else {
    emit(LMChatConversationErrorState(
      response.errorMessage!,
      pollRequest.temporaryId,
    ));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation/handler/update_conversation_handler.dart
================================================
part of '../conversation_bloc.dart';

/// Handler for updating conversations in a chatroom
updateConversationsEventHandler(
  LMChatUpdateConversationsEvent event,
  Emitter<LMChatConversationState> emit,
) async {
  int? lastConversationId = LMChatConversationBloc.instance.lastConversationId;
  if (lastConversationId != null &&
          event.conversationId != lastConversationId ||
      event.shouldUpdate) {
    int maxTimestamp = DateTime.now().millisecondsSinceEpoch;
    final response =
        await LMChatCore.client.getConversation((GetConversationRequestBuilder()
              ..chatroomId(event.chatroomId)
              ..minTimestamp(0)
              ..maxTimestamp(maxTimestamp * 1000)
              ..isLocalDB(false)
              ..page(1)
              ..pageSize(50)
              ..conversationId(event.conversationId))
            .build());
    debugPrint("updateConversationsEventHandler: $response");
    if (response.success) {
      GetConversationResponse conversationResponse = response.data!;
      for (var element in conversationResponse.conversationData!) {
        element.member = conversationResponse.userMeta?[element.memberId];
      }
      for (var element in conversationResponse.conversationData!) {
        String? replyId = element.replyId == null
            ? element.replyConversation?.toString()
            : element.replyId.toString();
        element.replyConversationObject =
            conversationResponse.conversationMeta?[replyId];
        element.replyConversationObject?.member = conversationResponse
            .userMeta?[element.replyConversationObject?.memberId];
      }
      Conversation realTimeConversation =
          response.data!.conversationData!.first;
      if (response.data!.conversationMeta != null &&
          realTimeConversation.replyId != null) {
        Conversation? replyConversationObject = response
            .data!.conversationMeta![realTimeConversation.replyId.toString()];
        realTimeConversation.replyConversationObject = replyConversationObject;
      }

      Map<String, List<LMChatAttachmentViewData>> attachments = {};
      if (conversationResponse.conversationAttachmentsMeta != null &&
          conversationResponse.conversationAttachmentsMeta!.isNotEmpty) {
        Map<String, List<LMChatAttachmentViewData>>
            getConversationAttachmentData =
            conversationResponse.conversationAttachmentsMeta!.map((key, value) {
          return MapEntry(
              key,
              (value as List<Attachment>?)
                      ?.map((e) => e.toAttachmentViewData())
                      .toList() ??
                  []);
        });
        attachments.addAll(getConversationAttachmentData);
      }

      emit(
        LMChatConversationUpdatedState(
          conversationViewData: realTimeConversation.toConversationViewData(
            conversationPollsMeta: conversationResponse.conversationPollsMeta,
            userMeta: conversationResponse.userMeta,
            attachmentMeta: conversationResponse.conversationAttachmentsMeta,
            reactionMeta: conversationResponse.conversationReactionMeta,
            conversationMeta: conversationResponse.conversationMeta,
          ),
          attachments: attachments,
          shouldUpdate: event.shouldUpdate,
        ),
      );
      lastConversationId = event.conversationId;
    }
  }
  LMChatConversationBloc.instance.lastConversationId = lastConversationId;
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/conversation_action_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/analytics/analytics_bloc.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

part 'conversation_action_event.dart';
part 'conversation_action_state.dart';
part 'handler/delete_conversation_event_handler.dart';
part 'handler/edit_conversation_event_handler.dart';
part 'handler/reply_conversation_event_handler.dart';
part 'handler/refresh_bar_event_handler.dart';
part 'handler/text_change_event_handler.dart';
part 'handler/link_preview_removed_event_handler.dart';
part 'handler/put_reaction_handler.dart';
part 'handler/delete_reaction_handler.dart';

/// {@template lm_chat_conversation_action_bloc}
/// [LMChatConversationActionBloc] is responsible for handling the conversation actions.
/// It extends [Bloc] and uses [LMChatConversationActionEvent] and [LMChatConversationActionState].
/// It has a singleton instance [instance] which is used to access the bloc.
/// {@endtemplate}
class LMChatConversationActionBloc
    extends Bloc<LMChatConversationActionEvent, LMChatConversationActionState> {
  /// Singleton instance of [LMChatConversationActionBloc]
  static LMChatConversationActionBloc? _instance;

  /// {@macro lm_chat_conversation_action_bloc}
  static LMChatConversationActionBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatConversationActionBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatConversationActionBloc._() : super(LMChatConversationActionInitial()) {
    // map the events to the event handlers
    on<LMChatEditConversationEvent>(_editConversationEventHandler);
    on<LMChatEditingConversationEvent>(_editingConversationEventHandler);
    on<LMChatEditRemoveEvent>(_editRemoveEventHandler);
    on<LMChatReplyConversationEvent>(_replyEventHandler);
    on<LMChatReplyRemoveEvent>(_replyRemoveEventHandler);
    on<LMChatDeleteConversationEvent>(_deleteConversationEventHandler);
    on<LMChatRefreshBarEvent>(_refreshBarEventHandler);
    on<LMChatConversationTextChangeEvent>(_textChangeEventHandler);
    on<LMChatLinkPreviewRemovedEvent>(_linkPreviewRemovedEventHandler);
    on<LMChatPutReaction>(_putReactionHandler);
    on<LMChatDeleteReaction>(_deleteReactionHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/conversation_action_event.dart
================================================
part of 'conversation_action_bloc.dart';

/// [LMChatConversationActionEvent] is the base class for all the events related to conversation actions.
@immutable
abstract class LMChatConversationActionEvent extends Equatable {}

///{@template lm_chat_edit_conversation_event}
/// [LMChatEditConversationEvent] is used to edit a conversation.
/// It extends [LMChatConversationActionEvent] and has the following properties:
/// - [EditConversationRequest] editConversationRequest is the request to edit a conversation.
/// - [Conversation] replyConversation is the conversation to be replied.
/// {@endtemplate}
class LMChatEditConversationEvent extends LMChatConversationActionEvent {
  /// [EditConversationRequest] editConversationRequest is the request to edit a conversation.
  final EditConversationRequest editConversationRequest;

  /// [Conversation] replyConversation is the conversation to be replied.
  final Conversation? replyConversation;

  /// {@macro lm_chat_edit_conversation_event}
  LMChatEditConversationEvent(this.editConversationRequest,
      {this.replyConversation});

  @override
  List<Object> get props => [
        editConversationRequest,
      ];
}

/// {@template lm_chat_editing_conversation_event}
/// [LMChatEditingConversationEvent] is used to edit a conversation.
/// It extends [LMChatConversationActionEvent] and has the following properties:
/// - [int] conversationId is the id of the conversation to be edited.
/// - [int] chatroomId is the id of the chatroom.
/// - [LMChatConversationViewData] editConversation is the conversation to be edited.
/// {@endtemplate}
class LMChatEditingConversationEvent extends LMChatConversationActionEvent {
  /// [int] conversationId is the id of the conversation to be edited.
  final int conversationId;

  /// [int] chatroomId is the id of the chatroom.
  final int chatroomId;

  /// [LMChatConversationViewData] editConversation is the conversation to be edited.
  final LMChatConversationViewData editConversation;

  /// {@macro lm_chat_editing_conversation_event}
  LMChatEditingConversationEvent({
    required this.conversationId,
    required this.chatroomId,
    required this.editConversation,
  });

  @override
  List<Object> get props => [
        conversationId,
        chatroomId,
        editConversation,
      ];
}

class LMChatEditRemoveEvent extends LMChatConversationActionEvent {
  @override
  List<Object> get props => [];
}

/// {@macro lm_chat_delete_conversation_event} is used to delete a conversation.
class LMChatDeleteConversationEvent extends LMChatConversationActionEvent {
  /// [List<int>] conversationIds is the list of conversation ids to be deleted.
  final List<int> conversationIds;

  /// [String] reason is the reason for deleting the conversation.
  final String reason;

  /// {@macro lm_chat_delete_conversation_event}
  LMChatDeleteConversationEvent({
    required this.conversationIds,
    this.reason = "Delete",
  });

  @override
  List<Object> get props => [
        conversationIds,
        reason,
      ];
}

/// {@macro lm_chat_reply_conversation_event} is used to reply to a conversation.
class LMChatReplyConversationEvent extends LMChatConversationActionEvent {
  /// [int] conversationId is the id of the conversation to be replied.
  final int conversationId;

  /// [int] chatroomId is the id of the chatroom.
  final int chatroomId;

  /// [LMChatConversationViewData] replyConversation is the conversation to be replied.
  final LMChatConversationViewData replyConversation;

  final List<LMChatAttachmentViewData>? attachments;

  /// {@macro lm_chat_reply_conversation_event}
  LMChatReplyConversationEvent({
    required this.conversationId,
    required this.chatroomId,
    required this.replyConversation,
    required this.attachments,
  });

  @override
  List<Object> get props => [
        conversationId,
        chatroomId,
        replyConversation,
      ];
}

/// {@macro lm_chat_reply_remove_event} is used to remove the reply state.
class LMChatReplyRemoveEvent extends LMChatConversationActionEvent {
  /// [int] time is the time in milliseconds.
  final int time = DateTime.now().millisecondsSinceEpoch;
  @override
  List<Object> get props => [time];
}

/// {@macro lm_chat_refresh_bar_event} is used to refresh the chatroom bar.}
class LMChatRefreshBarEvent extends LMChatConversationActionEvent {
  final LMChatRoomViewData chatroom;

  LMChatRefreshBarEvent({
    required this.chatroom,
  });

  @override
  List<Object> get props => [chatroom];
}

class LMChatConversationTextChangeEvent extends LMChatConversationActionEvent {
  final String text;
  final String previousLink;

  LMChatConversationTextChangeEvent({
    required this.text,
    required this.previousLink,
  });

  @override
  List<Object> get props => [text, previousLink];
}

class LMChatLinkPreviewRemovedEvent extends LMChatConversationActionEvent {
  final bool isPermanentlyRemoved;
  LMChatLinkPreviewRemovedEvent({
    this.isPermanentlyRemoved = false,
  });
  @override
  List<Object> get props => [
        isPermanentlyRemoved,
      ];
}

class LMChatPutReaction extends LMChatConversationActionEvent {
  final int conversationId;
  final String reaction;

  LMChatPutReaction({
    required this.conversationId,
    required this.reaction,
  });

  @override
  List<Object> get props => [
        conversationId,
        reaction,
      ];
}

class LMChatDeleteReaction extends LMChatConversationActionEvent {
  final int conversationId;
  final String reaction;

  LMChatDeleteReaction({
    required this.conversationId,
    required this.reaction,
  });

  @override
  List<Object> get props => [
        conversationId,
        reaction,
      ];
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/conversation_action_state.dart
================================================
part of 'conversation_action_bloc.dart';

@immutable

/// [LMChatConversationActionState] is the base class for all states in the [ConversationActionBloc].
abstract class LMChatConversationActionState extends Equatable {}

/// [LMChatConversationActionInitial] is the initial state of the [ConversationActionBloc].
class LMChatConversationActionInitial extends LMChatConversationActionState {
  @override
  List<Object> get props => [];
}

/// [LMChatConversationActionLoading] is the loading state of the [ConversationActionBloc].
class LMChatConversationActionError extends LMChatConversationActionState {
  /// The temporary id of the conversation
  final String temporaryId;

  /// The error message
  final String errorMessage;

  /// [LMChatConversationActionError] constructor
  LMChatConversationActionError(this.errorMessage, this.temporaryId);

  @override
  List<Object> get props => [
        temporaryId,
        errorMessage,
      ];
}

/// [LMChatConversationEdited] is the state when a conversation is edited.
class LMChatConversationEdited extends LMChatConversationActionState {
  /// The response of the edit conversation request
  final LMChatConversationViewData conversationViewData;

  /// [LMChatConversationEdited] constructor
  LMChatConversationEdited({
    required this.conversationViewData,
  });

  @override
  List<Object> get props => [
        conversationViewData,
      ];
}

/// [LMChatConversationDelete] is the state when a conversation is deleted.
class LMChatConversationDelete extends LMChatConversationActionState {
  /// List of conversations that are deleted
  final List<LMChatConversationViewData> conversations;

  /// [LMChatConversationDelete] constructor
  LMChatConversationDelete({
    required this.conversations,
  });

  @override
  List<Object> get props => [
        conversations,
      ];
}

/// [LMChatConversationDeleteError] is the state when an error occurs while deleting a conversation.
class LMChatConversationDeleteError extends LMChatConversationActionState {
  /// The error message
  final String errorMessage;

  /// [LMChatConversationDeleteError] constructor
  LMChatConversationDeleteError(this.errorMessage);

  @override
  List<Object> get props => [
        errorMessage,
      ];
}

/// [LMChatReplyConversationState] is the state when a conversation is replied.
class LMChatReplyConversationState extends LMChatConversationActionState {
  /// The chatroom id
  final int chatroomId;

  /// The conversation id
  final int conversationId;

  /// The conversation
  final LMChatConversationViewData conversation;

  final List<LMChatAttachmentViewData>? attachments;

  /// [LMChatReplyConversationState] constructor
  LMChatReplyConversationState({
    required this.chatroomId,
    required this.conversationId,
    required this.conversation,
    this.attachments,
  });

  @override
  List<Object> get props => [
        chatroomId,
        conversationId,
      ];
}

/// [LMChatReplyRemoveState] is the state when a reply is removed.
class LMChatReplyRemoveState extends LMChatConversationActionState {
  /// time in milliseconds
  final int time = DateTime.now().millisecondsSinceEpoch;
  @override
  List<Object> get props => [time];
}

/// [LMChatEditConversationState] is the state when a conversation is edited.
class LMChatEditConversationState extends LMChatConversationActionState {
  /// The chatroom id
  final int chatroomId;

  /// The conversation id
  final int conversationId;

  /// The conversation
  final LMChatConversationViewData editConversation;

  /// [LMChatEditConversationState] constructor
  LMChatEditConversationState({
    required this.chatroomId,
    required this.conversationId,
    required this.editConversation,
  });

  @override
  List<Object> get props => [
        chatroomId,
        conversationId,
        editConversation,
      ];
}

/// [LMChatEditRemoveState] is the state when an edit is removed.
class LMChatEditRemoveState extends LMChatConversationActionState {
  @override
  List<Object> get props => [];
}

class LMChatRefreshBarState extends LMChatConversationActionState {
  final LMChatRoomViewData chatroom;

  LMChatRefreshBarState({
    required this.chatroom,
  });

  @override
  List<Object> get props => [chatroom];
}

/// {@template lm_chat_link_attached_state}
/// It is the state when a link is attached to the conversation.
/// [ogTags] - The Open Graph tags of the link
/// [link] - The link
/// {@endtemplate}
class LMChatLinkAttachedState extends LMChatConversationActionState {
  /// The Open Graph tags of the link
  final LMChatOGTagsViewData ogTags;

  /// The link
  final String link;

  /// {@macro lm_chat_link_attached_state}
  LMChatLinkAttachedState({
    required this.ogTags,
    required this.link,
  });

  @override
  List<Object> get props => [
        ogTags,
        link,
      ];
}

/// {@template lm_chat_link_removed_state}
/// It is the state when a link is removed from the conversation.
/// [isPermanentlyRemoved] - If the link is permanently removed
/// {@endtemplate}
class LMChatLinkRemovedState extends LMChatConversationActionState {
  /// If the link is permanently removed
  final bool isPermanentlyRemoved;

  /// {@macro lm_chat_link_removed_state}
  LMChatLinkRemovedState({
    this.isPermanentlyRemoved = false,
  });

  @override
  List<Object> get props => [
        isPermanentlyRemoved,
      ];
}

class LMChatPutReactionState extends LMChatConversationActionState {
  final int conversationId;
  final String reaction;

  LMChatPutReactionState({
    required this.conversationId,
    required this.reaction,
  });

  @override
  List<Object> get props => [conversationId, reaction];
}

class LMChatPutReactionError extends LMChatConversationActionState {
  final String errorMessage;
  final int conversationId;
  final String reaction;

  LMChatPutReactionError({
    required this.errorMessage,
    required this.conversationId,
    required this.reaction,
  });

  @override
  List<Object> get props => [errorMessage, conversationId, reaction];
}

class LMChatDeleteReactionState extends LMChatConversationActionState {
  final int conversationId;
  final String reaction;

  LMChatDeleteReactionState({
    required this.conversationId,
    required this.reaction,
  });

  @override
  List<Object> get props => [conversationId, reaction];
}

class LMChatDeleteReactionError extends LMChatConversationActionState {
  final String errorMessage;
  final int conversationId;
  final String reaction;

  LMChatDeleteReactionError({
    required this.errorMessage,
    required this.conversationId,
    required this.reaction,
  });

  @override
  List<Object> get props => [errorMessage, conversationId, reaction];
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/delete_conversation_event_handler.dart
================================================
part of "../conversation_action_bloc.dart";

/// Handles the delete conversation event
_deleteConversationEventHandler(
    LMChatDeleteConversationEvent event, emit) async {
  debugPrint(event.conversationIds.toString());
  // create delete conversation request
  try {
    final DeleteConversationRequestBuilder deleteConversationRequestBuilder =
        DeleteConversationRequestBuilder()
          ..conversationIds(event.conversationIds)
          ..reason(event.reason);
    final response = await LMChatCore.client
        .deleteConversation(deleteConversationRequestBuilder.build());
    if (response.success) {
      emit(LMChatConversationDelete(
        conversations: response.data!.conversations!.map((e) {
          return e.toConversationViewData();
        }).toList(),
      ));
    } else {
      emit(LMChatConversationDeleteError(
          response.errorMessage ?? 'An error occurred'));
    }
  } on Exception catch (e) {
    emit(LMChatConversationDeleteError(e.toString()));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/delete_reaction_handler.dart
================================================
part of '../conversation_action_bloc.dart';

_deleteReactionHandler(LMChatDeleteReaction event, emit) async {
  emit(LMChatDeleteReactionState(
    conversationId: event.conversationId,
    reaction: event.reaction,
  ));
  LMResponse response =
      await LMChatCore.client.deleteReaction((DeleteReactionRequestBuilder()
            ..conversationId(event.conversationId)
            ..reaction(event.reaction))
          .build());
  if (!response.success) {
    emit(LMChatDeleteReactionError(
      errorMessage: response.errorMessage ?? 'An error occurred',
      conversationId: event.conversationId,
      reaction: event.reaction,
    ));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/edit_conversation_event_handler.dart
================================================
part of "../conversation_action_bloc.dart";

_editConversationEventHandler(LMChatEditConversationEvent event,
    Emitter<LMChatConversationActionState> emit) async {
  emit(LMChatEditRemoveState());
  try {
    LMResponse<EditConversationResponse> response =
        await LMChatCore.client.editConversation(
      event.editConversationRequest,
    );

    if (response.success) {
      Conversation conversation = response.data!.conversation!;
      if (conversation.replyId != null ||
          conversation.replyConversation != null) {
        conversation.replyConversationObject = event.replyConversation;
      }
      emit(
        LMChatConversationEdited(
          conversationViewData: conversation.toConversationViewData(),
        ),
      );
    } else {
      emit(
        LMChatConversationActionError(
          response.errorMessage!,
          event.editConversationRequest.conversationId.toString(),
        ),
      );
      return false;
    }
  } catch (e) {
    emit(
      LMChatConversationActionError(
        "An error occurred while editing the message",
        event.editConversationRequest.conversationId.toString(),
      ),
    );
    return false;
  }
}

// Handles the editing conversation event
_editingConversationEventHandler(LMChatEditingConversationEvent event,
    Emitter<LMChatConversationActionState> emit) async {
  emit(LMChatEditRemoveState());
  emit(
    LMChatEditConversationState(
      chatroomId: event.chatroomId,
      conversationId: event.conversationId,
      editConversation: event.editConversation,
    ),
  );
}

// Handles the remove edit event
_editRemoveEventHandler(
    LMChatEditRemoveEvent event, Emitter<LMChatConversationActionState> emit) async {
  emit(LMChatEditRemoveState());
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/link_preview_removed_event_handler.dart
================================================
part of '../conversation_action_bloc.dart';

void _linkPreviewRemovedEventHandler(
    LMChatLinkPreviewRemovedEvent event, emit) async {
  emit (
    LMChatLinkRemovedState(
      isPermanentlyRemoved: event.isPermanentlyRemoved,
    ),
  );
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/put_reaction_handler.dart
================================================
part of '../conversation_action_bloc.dart';

_putReactionHandler(LMChatPutReaction event, emit) async {
  emit(
    LMChatPutReactionState(
      conversationId: event.conversationId,
      reaction: event.reaction,
    ),
  );
  LMResponse response =
      await LMChatCore.client.putReaction((PutReactionRequestBuilder()
            ..conversationId(event.conversationId)
            ..reaction(event.reaction))
          .build());
  if (!response.success) {
    emit(LMChatPutReactionError(
      errorMessage: response.errorMessage ?? 'An error occured',
      conversationId: event.conversationId,
      reaction: event.reaction,
    ));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/refresh_bar_event_handler.dart
================================================
part of '../conversation_action_bloc.dart';

_refreshBarEventHandler(LMChatRefreshBarEvent event, emit) {
  emit(LMChatRefreshBarState(chatroom: event.chatroom));
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/reply_conversation_event_handler.dart
================================================
part of "../conversation_action_bloc.dart";

// Handles the reply conversation event
_replyEventHandler(LMChatReplyConversationEvent event, emit) async {
  emit(
    LMChatReplyConversationState(
      chatroomId: event.chatroomId,
      conversationId: event.conversationId,
      conversation: event.replyConversation,
      attachments: event.attachments,
    ),
  );
}

// Handles the remove reply event

_replyRemoveEventHandler(LMChatReplyRemoveEvent event, emit) async {
  emit(LMChatReplyRemoveState());
}



================================================
File: lib/packages/core/lib/src/blocs/conversation_action/handler/text_change_event_handler.dart
================================================
part of '../conversation_action_bloc.dart';

_textChangeEventHandler(LMChatConversationTextChangeEvent event, emit) async {
  String text = event.text;
  String previousLink = event.previousLink;
  if (text.isNotEmpty) {
    final (ogTags, link) =
        await _extractOgTagFromText(text, previousLink, emit);
    debugPrint('ogTags: $ogTags');
    if (ogTags != null && link != null) {
      emit(LMChatLinkAttachedState(
        ogTags: ogTags,
        link: link,
      ));
    } else if (link != null && previousLink == link) {
      // if the link is the same as the previous link, do nothing
      return;
    }
  } else if (previousLink.isNotEmpty) {
    emit(LMChatLinkRemovedState());
  }
}

Future<(LMChatOGTagsViewData?, String?)> _extractOgTagFromText(
  String text,
  String previousLink,
  emit,
) async {
  String link = LMChatTaggingHelper.getFirstValidLinkFromString(text);
  if (link.isNotEmpty) {
    if (previousLink == link) {
      // if the link is the same as the previous link, do nothing
      return (null, previousLink);
    }
    DecodeUrlRequest request = (DecodeUrlRequestBuilder()..url(link)).build();
    LMResponse<DecodeUrlResponse> response =
        await LMChatCore.client.decodeUrl(request);
    if (response.success == true) {
      OgTags? ogTags = response.data!.ogTags;
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.attachmentUploaded,
          eventProperties: {
            'link': link,
          },
        ),
      );
      return (ogTags?.toLMChatOGTagViewData(), link);
    }
  }
  // if no link is found, remove the previous link
  if (previousLink.isNotEmpty) {
    emit(LMChatLinkRemovedState());
  }

  return (null, null);
}



================================================
File: lib/packages/core/lib/src/blocs/dm/dm_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/chatroom/chatroom_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/conversation/conversation_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:meta/meta.dart';
import 'package:equatable/equatable.dart';

import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';

part 'dm_event.dart';
part 'dm_state.dart';

part 'handler/fetch_event_handler.dart';
part 'handler/refresh_event_handler.dart';
part 'handler/parsing_result_handler.dart';

/// BLoC responsible for handling the DM Home Feed,
/// Allows for users to fetch, and refresh the feed,
/// Also, updates the feed based on a realtime update.
class LMChatDMFeedBloc extends Bloc<LMChatDMFeedEvent, LMChatDMFeedState> {
  static LMChatDMFeedBloc? _instance;

  /// Creating a singleton instance of the LMChatDMFeedBloc
  static LMChatDMFeedBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatDMFeedBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatDMFeedBloc._() : super(LMChatDMInitial()) {
    final DatabaseReference realTime = LMChatRealtime.instance.homeFeed();
    realTime.onValue.listen((event) {
      add(LMChatRefreshDMFeedEvent());
    });
    // Event handler for fetch DM Feed event
    on<LMChatFetchDMFeedEvent>(fetchDMFeedEventHandler);
    // Event handler for refresh DM Feed event
    on<LMChatRefreshDMFeedEvent>(refreshDMFeedEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/dm/dm_event.dart
================================================
part of 'dm_bloc.dart';

/// Base event class for [LMChatDMFeedBloc]
/// Tracks events related to DM home feed
@immutable
sealed class LMChatDMFeedEvent extends Equatable {}

/// Event class for fetching DM feed.
/// Requires a page size [int]
class LMChatFetchDMFeedEvent extends LMChatDMFeedEvent {
  final int page;

  LMChatFetchDMFeedEvent({required this.page});

  @override
  List<Object?> get props => [page];
}

/// Event class for refreshing DM feed
/// in cases of realtime update, or changing states
class LMChatRefreshDMFeedEvent extends LMChatDMFeedEvent {
  @override
  List<Object?> get props => [];
}



================================================
File: lib/packages/core/lib/src/blocs/dm/dm_state.dart
================================================
part of 'dm_bloc.dart';

/// Base state class for [LMChatDMFeedBloc]
/// Tracks all states related to DM home feed
@immutable
sealed class LMChatDMFeedState {}

/// State class to represent initial state of DM home feed.
class LMChatDMInitial extends LMChatDMFeedState {}

/// State class to represent loading state of DM home feed.
class LMChatDMFeedLoading extends LMChatDMFeedState {}

/// State class to represent loaded state of DM home feed.
class LMChatDMFeedLoaded extends LMChatDMFeedState {
  final List<LMChatRoomViewData> chatrooms;

  LMChatDMFeedLoaded({
    required this.chatrooms,
  });
}

/// State class to represent updated state of DM home feed.
class LMChatDMFeedUpdated extends LMChatDMFeedState {
  final List<LMChatRoomViewData> chatrooms;

  LMChatDMFeedUpdated({
    required this.chatrooms,
  });
}

/// State class to represent error state of DM home feed.
class LMChatDMFeedError extends LMChatDMFeedState {
  final String errorMessage;

  LMChatDMFeedError({required this.errorMessage});
}



================================================
File: lib/packages/core/lib/src/blocs/dm/handler/fetch_event_handler.dart
================================================
part of '../dm_bloc.dart';

/// Function to handle fetch DM Feed events,
/// emits appropriate state based on response,
/// and converts models to view data models
void fetchDMFeedEventHandler(
  LMChatFetchDMFeedEvent event,
  Emitter<LMChatDMFeedState> emit,
) async {
  emit(LMChatDMFeedLoading());

  //Fetching the current time for the request
  int currentTime = DateTime.now().millisecondsSinceEpoch;

  //Building request and calling the `getHomeFeed` function of the client
  final response =
      await LMChatCore.client.getHomeFeed((GetHomeFeedRequestBuilder()
            ..page(event.page)
            ..pageSize(50)
            ..minTimestamp(0)
            ..maxTimestamp(currentTime)
            ..chatroomTypes([10]))
          .build());

  //Emit error state and fail gracefully
  if (!response.success) {
    emit(LMChatDMFeedError(
      errorMessage:
          response.errorMessage ?? LMChatStringConstants.errorFallback,
    ));
  }

  //Success, now continue with parsing the response
  final List<LMChatRoomViewData> chatrooms = parseDMResponse(response.data!);

  //Finally, emit the loaded success state to show the DM Feed
  emit(LMChatDMFeedLoaded(chatrooms: chatrooms));
}



================================================
File: lib/packages/core/lib/src/blocs/dm/handler/parsing_result_handler.dart
================================================
part of '../dm_bloc.dart';

/// Function to parse the response object into List<LMChatRoomViewData>
List<LMChatRoomViewData> parseDMResponse(GetHomeFeedResponse response) {
  return parseDMHomeFeedToChatrooms(response);
}

/// Function to parse response, and update child models
List<LMChatRoomViewData> parseDMHomeFeedToChatrooms(
  GetHomeFeedResponse response,
) {
  final List<LMChatRoomViewData> chatrooms = response.chatroomsData!.map(
    //Convert chatroom model to LMChatRoomViewData
    (chatroom) {
      LMChatRoomViewData chatroomViewData = chatroom.toChatRoomViewData();
      chatroomViewData = parseDMLastConversation(response, chatroomViewData);
      chatroomViewData = parseDMChatroomUsers(response, chatroomViewData);
      chatroomViewData = parseDMAttachments(response, chatroomViewData);
      return chatroomViewData;
    },
  ).toList();
  //Returns a list of LMChatRoomViewData with all models
  return chatrooms;
}

/// Fucntion to parse chatroom users from response user meta
LMChatRoomViewData parseDMChatroomUsers(
  GetHomeFeedResponse response,
  LMChatRoomViewData chatroom,
) {
  //Convert user model to LMChatUserViewData
  final Map<int, LMChatUserViewData> users = response.userMeta!.map(
    (key, value) => MapEntry(key, value.toUserViewData()),
  );
  //Extract users from users list using IDs
  LMChatUserViewData chatroomUser = users[chatroom.userId]!;
  LMChatUserViewData chatroomWithUser = users[chatroom.chatroomWithUserId]!;
  //Return a copy of passed chatroom with chatroom users updated
  return chatroom.copyWith(
    chatroomWithUser: chatroomWithUser,
    member: chatroomUser,
  );
}

/// Function to parse the last conversation for this chatroom from conversationMeta
LMChatRoomViewData parseDMLastConversation(
  GetHomeFeedResponse response,
  LMChatRoomViewData chatroom,
) {
  //Convert last conversation from response to viewData
  LMChatConversationViewData? lastConversation = response
      .conversationMeta![chatroom.lastConversationId.toString()]!
      .toConversationViewData();
  //Create a new instance with member object copied
  LMChatConversationViewData updated = lastConversation.copyWith(
      member: response.userMeta != null &&
              response.userMeta![lastConversation.memberId] != null
          ? response.userMeta![lastConversation.memberId]!.toUserViewData()
          : null);
  //Return a copy of passed chatroom with lastConversation updated
  return chatroom.copyWith(lastConversation: updated);
}

/// Function to parse attachments from the response object
LMChatRoomViewData parseDMAttachments(
    GetHomeFeedResponse response, LMChatRoomViewData chatroom) {
  // Assuming response.conversationAttachmentsMeta is a map of attachment data
  final Map<String, List<Attachment>>? attachmentData =
      response.conversationAttachmentsMeta;

  // Check if the attachment data exists
  if (attachmentData != null) {
    // Retrieve the last conversation ID from the chatroom
    String lastConversationId = chatroom.lastConversationId.toString();

    // Check if there are attachments for the last conversation ID
    if (attachmentData.containsKey(lastConversationId)) {
      // Create a list to hold the parsed attachments
      List<LMChatAttachmentViewData> attachments = [];

      // Iterate through each entry in the attachment data for the specific conversation
      for (Attachment item in attachmentData[lastConversationId]!) {
        // Convert each attachment entry to LMChatAttachmentViewData
        LMChatAttachmentViewData attachment = item.toAttachmentViewData();
        attachments.add(attachment);
      }

      // Return a copy of the chatroom with the attachments updated
      return chatroom.copyWith(attachments: attachments);
    }
  }

  // If no attachments are found, return the chatroom unchanged
  return chatroom;
}



================================================
File: lib/packages/core/lib/src/blocs/dm/handler/refresh_event_handler.dart
================================================
part of '../dm_bloc.dart';

/// Function to handle fetch DM Feed events,
/// emits appropriate state based on response,
/// and converts models to view data models
void refreshDMFeedEventHandler(
  LMChatRefreshDMFeedEvent event,
  Emitter<LMChatDMFeedState> emit,
) async {
  emit(LMChatDMFeedLoading());

  //Fetching the current time for the request
  int currentTime = DateTime.now().millisecondsSinceEpoch;

  //Building request and calling the `getHomeFeed` function of the client
  final response =
      await LMChatCore.client.getHomeFeed((GetHomeFeedRequestBuilder()
            ..page(1)
            ..pageSize(50)
            ..minTimestamp(0)
            ..maxTimestamp(currentTime)
            ..chatroomTypes([10]))
          .build());

  //Emit error state and fail gracefully
  if (!response.success) {
    emit(LMChatDMFeedError(
      errorMessage:
          response.errorMessage ?? LMChatStringConstants.errorFallback,
    ));
  }

  //Success, now continue with parsing the response
  final List<LMChatRoomViewData> chatrooms = parseDMResponse(response.data!);

  //Finally, emit the loaded success state to show the DM Feed
  emit(LMChatDMFeedUpdated(chatrooms: chatrooms));
}



================================================
File: lib/packages/core/lib/src/blocs/explore/bloc/explore_bloc.dart
================================================
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';

part 'explore_event.dart';
part 'explore_state.dart';

part 'handler/fetch_explore_handler.dart';
part 'handler/pin_explore_space_handler.dart';
part 'handler/refresh_explore_event_handler.dart';

/// A BLoC to manage the Explore Feed of LMChat
///
/// Used to manage, fetch, refresh, and pin explore chatrooms
class LMChatExploreBloc extends Bloc<LMChatExploreEvent, LMChatExploreState> {
  static LMChatExploreBloc? _instance;

  /// Creates and maintains a singleton instance of this BLoC
  static LMChatExploreBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatExploreBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatExploreBloc._() : super(LMChatExploreInitialState()) {
    // Handle fetch explore event using handlers
    on<LMChatFetchExploreEvent>(fetchExploreEventHandler);
    // Handle pin explore space using handlers
    on<LMChatPinSpaceEvent>(pinExploreSpaceEventHandler);
    // Handle refresh explore event using handler
    on<LMChatRefreshExploreEvent>(refreshExploreEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/explore/bloc/explore_event.dart
================================================
part of 'explore_bloc.dart';

/// Abstract class to represent an explore event
abstract class LMChatExploreEvent extends Equatable {
  @override
  List<Object> get props => [];
}

/// Event class to fetch Explore feed
class LMChatFetchExploreEvent extends LMChatExploreEvent {
  final GetExploreFeedRequest getExploreFeedRequest;

  LMChatFetchExploreEvent({required this.getExploreFeedRequest});

  @override
  List<Object> get props => [getExploreFeedRequest.toJson()];
}

/// Event class to refresh Explore feed
class LMChatRefreshExploreEvent extends LMChatExploreEvent {
  final int orderType;
  final bool pinned;

  LMChatRefreshExploreEvent({
    required this.orderType,
    required this.pinned,
  });
}

/// Event class to pin an Explore space to feed
class LMChatPinSpaceEvent extends LMChatExploreEvent {
  final String spaceId;
  final bool isPinned;

  LMChatPinSpaceEvent(this.spaceId, this.isPinned);

  @override
  List<Object> get props => [spaceId, isPinned];
}



================================================
File: lib/packages/core/lib/src/blocs/explore/bloc/explore_state.dart
================================================
part of 'explore_bloc.dart';

/// Abstract class to represent a state for LMChat Explore feed
abstract class LMChatExploreState {}

class LMChatExploreInitialState extends LMChatExploreState {}

class LMChatExploreLoadingState extends LMChatExploreState {}

class LMChatExploreErrorState extends LMChatExploreState {
  final String errorMessage;

  LMChatExploreErrorState(this.errorMessage);
}

class LMChatExploreLoadedState extends LMChatExploreState {
  final GetExploreFeedResponse getExploreFeedResponse;

  LMChatExploreLoadedState(this.getExploreFeedResponse);
}



================================================
File: lib/packages/core/lib/src/blocs/explore/bloc/handler/fetch_explore_handler.dart
================================================
part of '../explore_bloc.dart';

/// Function to handle fetching exlplore feed event
fetchExploreEventHandler(
  LMChatFetchExploreEvent event,
  Emitter<LMChatExploreState> emit,
) async {
  emit(LMChatExploreLoadingState());
  LMResponse response = await LMChatCore.instance.lmChatClient
      .getExploreFeed(event.getExploreFeedRequest);
  if (response.success) {
    GetExploreFeedResponse getExploreFeedResponse =
        response.data as GetExploreFeedResponse;
    emit(LMChatExploreLoadedState(getExploreFeedResponse));
  } else {
    emit(LMChatExploreErrorState(response.errorMessage!));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/explore/bloc/handler/pin_explore_space_handler.dart
================================================
part of '../explore_bloc.dart';

pinExploreSpaceEventHandler(
  LMChatPinSpaceEvent event,
  Emitter<LMChatExploreState> emit,
) {}



================================================
File: lib/packages/core/lib/src/blocs/explore/bloc/handler/refresh_explore_event_handler.dart
================================================
part of '../explore_bloc.dart';

/// Handler to handle refresh explore event
void refreshExploreEventHandler(
  LMChatRefreshExploreEvent event,
  Emitter<LMChatExploreState> emit,
) async {
  emit(LMChatExploreLoadingState());
  LMResponse response = await LMChatCore.instance.lmChatClient
      .getExploreFeed((GetExploreFeedRequestBuilder()
            ..orderType(event.orderType)
            ..page(1)
            ..pinned(event.pinned))
          .build());
  if (response.success) {
    GetExploreFeedResponse getExploreFeedResponse =
        response.data as GetExploreFeedResponse;
    emit(LMChatExploreLoadedState(getExploreFeedResponse));
  } else {
    emit(LMChatExploreErrorState(response.errorMessage!));
  }
}



================================================
File: lib/packages/core/lib/src/blocs/home/home_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';
import 'package:meta/meta.dart';
import 'package:equatable/equatable.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/chatroom/chatroom_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/conversation/conversation_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';

part 'home_event.dart';
part 'home_state.dart';

part 'handler/fetch_event_handler.dart';
part 'handler/refresh_event_handler.dart';
part 'handler/parsing_result_handler.dart';

/// BLoC responsible for handling the Group Home Feed,
/// Allows for users to fetch, and refresh the feed,
/// Also, updates the feed based on a realtime update.
class LMChatHomeFeedBloc
    extends Bloc<LMChatHomeFeedEvent, LMChatHomeFeedState> {
  static LMChatHomeFeedBloc? _instance;

  /// Creates a singleton instance of the LMChatHomeFeedBloc
  static LMChatHomeFeedBloc get instance {
    if (_instance == null || _instance!.isClosed) {
      return _instance = LMChatHomeFeedBloc._();
    } else {
      return _instance!;
    }
  }

  LMChatHomeFeedBloc._() : super(LMChatHomeInitial()) {
    final DatabaseReference realTime = LMChatRealtime.instance.homeFeed();
    realTime.onChildChanged.listen((event) {
      add(LMChatRefreshHomeFeedEvent());
    });
    // Event handler for fetch DM Feed event
    on<LMChatFetchHomeFeedEvent>(fetchHomeFeedEventHandler);
    // Event handler for refresh DM Feed event
    on<LMChatRefreshHomeFeedEvent>(refreshHomeFeedEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/home/home_event.dart
================================================
part of 'home_bloc.dart';

/// Base event class for [LMChatHomeFeedBloc]
/// Tracks events related to DM home feed
@immutable
sealed class LMChatHomeFeedEvent extends Equatable {}

/// {@template lm_chat_home_feed_event}
/// Event class for fetching Home feed.
/// Requires a page size [int]
/// {@endtemplate}
class LMChatFetchHomeFeedEvent extends LMChatHomeFeedEvent {
  /// the page index to fetch chatrooms for
  final int page;

  /// custom tags for which chatrooms need to be fetched
  final String? tag;

  ///{@macro lm_chat_home_feed_event}
  LMChatFetchHomeFeedEvent({
    required this.page,
    this.tag,
  });

  @override
  List<Object?> get props => [page];
}

///{@template lm_chat_refresh_home_feed_event}
/// Event class for refreshing Home feed
/// in cases of realtime update, or changing states
/// {@endtemplate}
class LMChatRefreshHomeFeedEvent extends LMChatHomeFeedEvent {
  /// custom tags for which chatrooms need to be fetched
  final String? tag;

  ///{@macro lm_chat_refresh_home_feed_event}
  LMChatRefreshHomeFeedEvent({this.tag});

  @override
  List<Object?> get props => [];
}



================================================
File: lib/packages/core/lib/src/blocs/home/home_state.dart
================================================
part of 'home_bloc.dart';

/// Base state class for [LMChatDMFeedBloc]
/// Tracks all states related to DM home feed
@immutable
sealed class LMChatHomeFeedState {}

/// State class to represent initial state of DM home feed.
class LMChatHomeInitial extends LMChatHomeFeedState {}

/// State class to represent loading state of DM home feed.
class LMChatHomeFeedLoading extends LMChatHomeFeedState {}

/// State class to represent loaded state of DM home feed.
class LMChatHomeFeedLoaded extends LMChatHomeFeedState {
  final List<LMChatRoomViewData> chatrooms;

  LMChatHomeFeedLoaded({
    required this.chatrooms,
  });
}

/// State class to represent updated state of DM home feed.
class LMChatHomeFeedUpdated extends LMChatHomeFeedState {
  final List<LMChatRoomViewData> chatrooms;

  LMChatHomeFeedUpdated({
    required this.chatrooms,
  });
}

/// State class to represent error state of DM home feed.
class LMChatHomeFeedError extends LMChatHomeFeedState {
  final String errorMessage;

  LMChatHomeFeedError({required this.errorMessage});
}



================================================
File: lib/packages/core/lib/src/blocs/home/handler/fetch_event_handler.dart
================================================
part of '../home_bloc.dart';

/// Function to handle fetch Home Feed events,
/// emits appropriate state based on response,
/// and converts models to view data models
void fetchHomeFeedEventHandler(
  LMChatFetchHomeFeedEvent event,
  Emitter<LMChatHomeFeedState> emit,
) async {
  emit(LMChatHomeFeedLoading());

  //Fetching the current time for the request
  int currentTime = DateTime.now().millisecondsSinceEpoch;

  //Building request and calling the `getHomeFeed` function of the client
  final response =
      await LMChatCore.client.getHomeFeed((GetHomeFeedRequestBuilder()
            ..page(event.page)
            ..pageSize(50)
            ..minTimestamp(0)
            ..maxTimestamp(currentTime)
            ..tag(event.tag)
            ..chatroomTypes([0, 7]))
          .build());

  //Emit error state and fail gracefully
  if (!response.success) {
    emit(LMChatHomeFeedError(
      errorMessage:
          response.errorMessage ?? LMChatStringConstants.errorFallback,
    ));
  }

  //Success, now continue with parsing the response
  final List<LMChatRoomViewData> chatrooms = parseHomeResponse(response.data!);

  //Finally, emit the loaded success state to show the DM Feed
  emit(LMChatHomeFeedLoaded(chatrooms: chatrooms));
}



================================================
File: lib/packages/core/lib/src/blocs/home/handler/parsing_result_handler.dart
================================================
part of '../home_bloc.dart';

/// Function to parse the response object into List<LMChatRoomViewData>
List<LMChatRoomViewData> parseHomeResponse(GetHomeFeedResponse response) {
  return parseHomeFeedToChatrooms(response);
}

/// Function to parse response, and update child models
List<LMChatRoomViewData> parseHomeFeedToChatrooms(
  GetHomeFeedResponse response,
) {
  final List<LMChatRoomViewData> chatrooms = response.chatroomsData!.map(
    //Convert chatroom model to LMChatRoomViewData
    (chatroom) {
      LMChatRoomViewData chatroomViewData = chatroom.toChatRoomViewData();
      chatroomViewData = parseLastConversation(response, chatroomViewData);
      chatroomViewData = parseChatroomUsers(response, chatroomViewData);
      chatroomViewData = parseAttachments(response, chatroomViewData);
      return chatroomViewData;
    },
  ).toList();
  //Returns a list of LMChatRoomViewData with all models
  return chatrooms;
}

/// Fucntion to parse chatroom users from response user meta
LMChatRoomViewData parseChatroomUsers(
  GetHomeFeedResponse response,
  LMChatRoomViewData chatroom,
) {
  //Convert user model to LMChatUserViewData
  final Map<int, LMChatUserViewData> users = response.userMeta!.map(
    (key, value) => MapEntry(key, value.toUserViewData()),
  );
  //Extract users from users list using IDs
  LMChatUserViewData chatroomUser = users[chatroom.userId]!;
  //Return a copy of passed chatroom with chatroom users updated
  return chatroom.copyWith(
    member: chatroomUser,
  );
}

/// Function to parse the last conversation for this chatroom from conversationMeta
LMChatRoomViewData parseLastConversation(
  GetHomeFeedResponse response,
  LMChatRoomViewData chatroom,
) {
  //Convert last conversation from response to viewData
  LMChatConversationViewData? lastConversation = response
      .conversationMeta![chatroom.lastConversationId.toString()]!
      .toConversationViewData();
  //Create a new instance with member object copied
  LMChatConversationViewData updated = lastConversation.copyWith(
      member: response.userMeta != null &&
              response.userMeta![lastConversation.memberId] != null
          ? response.userMeta![lastConversation.memberId]!.toUserViewData()
          : null);
  //Return a copy of passed chatroom with lastConversation updated
  return chatroom.copyWith(lastConversation: updated);
}

/// Function to parse attachments from the response object
LMChatRoomViewData parseAttachments(
    GetHomeFeedResponse response, LMChatRoomViewData chatroom) {
  // Assuming response.conversationAttachmentsMeta is a map of attachment data
  final Map<String, List<Attachment>>? attachmentData =
      response.conversationAttachmentsMeta;

  // Check if the attachment data exists
  if (attachmentData != null) {
    // Retrieve the last conversation ID from the chatroom
    String lastConversationId = chatroom.lastConversationId.toString();

    // Check if there are attachments for the last conversation ID
    if (attachmentData.containsKey(lastConversationId)) {
      // Create a list to hold the parsed attachments
      List<LMChatAttachmentViewData> attachments = [];

      // Iterate through each entry in the attachment data for the specific conversation
      for (Attachment item in attachmentData[lastConversationId]!) {
        // Convert each attachment entry to LMChatAttachmentViewData
        LMChatAttachmentViewData attachment = item.toAttachmentViewData();
        attachments.add(attachment);
      }

      // Return a copy of the chatroom with the attachments updated
      return chatroom.copyWith(attachments: attachments);
    }
  }

  // If no attachments are found, return the chatroom unchanged
  return chatroom;
}



================================================
File: lib/packages/core/lib/src/blocs/home/handler/refresh_event_handler.dart
================================================
part of '../home_bloc.dart';

/// Function to handle fetch Home Feed events,
/// emits appropriate state based on response,
/// and converts models to view data models
void refreshHomeFeedEventHandler(
  LMChatRefreshHomeFeedEvent event,
  Emitter<LMChatHomeFeedState> emit,
) async {
  emit(LMChatHomeFeedLoading());

  //Fetching the current time for the request
  int currentTime = DateTime.now().millisecondsSinceEpoch;

  //Building request and calling the `getHomeFeed` function of the client
  final response =
      await LMChatCore.client.getHomeFeed((GetHomeFeedRequestBuilder()
            ..page(1)
            ..pageSize(50)
            ..minTimestamp(0)
            ..maxTimestamp(currentTime)
            ..tag(event.tag)
            ..chatroomTypes([0, 7]))
          .build());

  //Emit error state and fail gracefully
  if (!response.success) {
    emit(LMChatHomeFeedError(
      errorMessage:
          response.errorMessage ?? LMChatStringConstants.errorFallback,
    ));
  }

  //Success, now continue with parsing the response
  final List<LMChatRoomViewData> chatrooms = parseHomeResponse(response.data!);

  //Finally, emit the loaded success state to show the DM Feed
  emit(LMChatHomeFeedUpdated(chatrooms: chatrooms));
}



================================================
File: lib/packages/core/lib/src/blocs/moderation/moderation_bloc.dart
================================================
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/moderation/report_tag_convertor.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:meta/meta.dart';

part 'moderation_event.dart';
part 'moderation_state.dart';
part 'handler/fetch_report_tag_event_handler.dart';
part 'handler/post_report_event_handler.dart';

/// {@template lm_chat_moderation_bloc}
/// A [Bloc] which manages moderation of chat
/// {@endtemplate}
class LMChatModerationBloc
    extends Bloc<LMChatModerationEvent, LMChatModerationState> {
  /// {@macro lm_chat_moderation_bloc}
  LMChatModerationBloc() : super(LMChatModerationInitialState()) {
    on<LMChatModerationFetchTagsEvent>(_fetchTagsEventHandler);
    on<LMChatModerationPostReportEvent>(_postReportEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/moderation/moderation_event.dart
================================================
part of 'moderation_bloc.dart';

/// {@template lm_chat_moderation_event}
/// A sealed class which describes the states for moderation
/// {@endtemplate}
@immutable
sealed class LMChatModerationEvent {}

/// {@template lm_chat_moderation_feth_tags_event}
/// The event to load tags
/// {@endtemplate}
class LMChatModerationFetchTagsEvent extends LMChatModerationEvent {}

/// {@template lm_chat_moderation_post_report_event}
/// The event to post report
/// {@endtemplate}
class LMChatModerationPostReportEvent extends LMChatModerationEvent {

  /// The id of the entity.
  final String entityId;

  /// The id of the report tag.
  final int reportTagId;

  /// The reason for the report.
  final String reason;

  /// {@macro lm_chat_moderation_post_report_event}
  LMChatModerationPostReportEvent({
    required this.entityId,
    required this.reportTagId,
    required this.reason,
  });
}



================================================
File: lib/packages/core/lib/src/blocs/moderation/moderation_state.dart
================================================
part of 'moderation_bloc.dart';

/// {@template lm_chat_moderation_event}
/// A sealed class which describes the states for moderation
/// {@endtemplate}
@immutable
sealed class LMChatModerationState extends Equatable {
  @override
  List<Object?> get props => [];
}

/// {@template lm_chat_moderation_initial_state}
/// The initial state for the moderation bloc
/// {@endtemplate}
class LMChatModerationInitialState extends LMChatModerationState {}

/// {@template lm_chat_moderation_loading_state}
/// The loading state for the moderation bloc
/// {@endtemplate}
class LMChatModerationTagLoadingState extends LMChatModerationState {}

/// {@template lm_chat_moderation_tag_loaded_state}
/// The loaded state for the moderation bloc
/// {@endtemplate}
class LMChatModerationTagLoadedState extends LMChatModerationState {
  /// The list of tags
  final List<LMChatReportTagViewData> tags;

  /// {@macro lm_chat_moderation_tag_loaded_state}
  LMChatModerationTagLoadedState({
    required this.tags,
  });

  @override
  List<Object?> get props => [tags];
}

/// {@template lm_chat_moderation_tag_loading_error_state}
/// The error state for the moderation bloc
/// {@endtemplate}
class LMChatModerationTagLoadingErrorState extends LMChatModerationState {
  /// The error message
  final String message;

  /// {@macro lm_chat_moderation_tag_loading_error_state}
  LMChatModerationTagLoadingErrorState({
    required this.message,
  });

  @override
  List<Object?> get props => [message];
}

/// {@template lm_chat_moderation_report_posting_state}
/// The posting state for the moderation bloc
/// {@endtemplate}
class LMChatModerationReportPostedState extends LMChatModerationState {}

/// {@template lm_chat_moderation_report_posting_error_state}
/// Error state for the moderation bloc
/// {@endtemplate}
class LMChatModerationReportPostingErrorState extends LMChatModerationState {
  /// The error message
  final String errorMessage;

  /// {@macro lm_chat_moderation_report_posting_error_state}
  LMChatModerationReportPostingErrorState({
    required this.errorMessage,
  });

  @override
  List<Object?> get props => [errorMessage];
}



================================================
File: lib/packages/core/lib/src/blocs/moderation/handler/fetch_report_tag_event_handler.dart
================================================
part of "../moderation_bloc.dart";
// Event handler function to fetch report tags
void _fetchTagsEventHandler(LMChatModerationFetchTagsEvent event, emit) async {
  emit(LMChatModerationTagLoadingState());
  final GetReportTagRequest reportTagRequest =
      (GetReportTagRequestBuilder()..type(3)).build();
  final LMResponse<GetReportTagResponse> response =
      await LMChatCore.instance.lmChatClient.getReportTags(
    reportTagRequest,
  );
  if (response.success && response.data != null) {
    final tags = response.data!.reportTags;
    final List<LMChatReportTagViewData> reportTag =
        tags?.map((tag) => tag.toReportTagViewData()).toList() ?? [];
    emit(
      LMChatModerationTagLoadedState(tags: reportTag),
    );
  } else {
    emit(
      LMChatModerationTagLoadingErrorState(
        message: response.errorMessage!,
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/blocs/moderation/handler/post_report_event_handler.dart
================================================
part of "../moderation_bloc.dart";

/// Event handler function to post report
void _postReportEventHandler(
    LMChatModerationPostReportEvent event, emit) async {
  final PostReportRequestBuilder postConversationRequestBuilder =
      PostReportRequestBuilder()
        ..entityId(event.entityId)
        ..tagId(event.reportTagId)
        ..reason(event.reason);

  final LMResponse<void> response =
      await LMChatCore.instance.lmChatClient.postReport(
    postConversationRequestBuilder.build(),
  );
  if (response.success) {
    emit(LMChatModerationReportPostedState());
  } else {
    emit(
      LMChatModerationTagLoadingErrorState(
        message: response.errorMessage!,
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/blocs/participants/participants_bloc.dart
================================================
import 'package:equatable/equatable.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

part 'participants_event.dart';
part 'participants_state.dart';
part 'handler/get_participants_handler.dart';

/// [LMChatParticipantsBloc] is responsible for handling the participants of a chat room.
/// It extends [Bloc] and uses [LMChatParticipantsEvent] and [LMChatParticipantsState].
/// It has a singleton instance [instance] which is used to access the bloc.
class LMChatParticipantsBloc
    extends Bloc<LMChatParticipantsEvent, LMChatParticipantsState> {
  static LMChatParticipantsBloc? _instance;

  /// Singleton instance of [LMChatParticipantsBloc]
  static LMChatParticipantsBloc get instance =>
      _instance ??= LMChatParticipantsBloc._();
  LMChatParticipantsBloc._() : super(const LMChatParticipantsInitialState()) {
    // handle get participants event
    on<LMChatGetParticipantsEvent>(_getParticipantsEventHandler);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/participants/participants_event.dart
================================================
part of 'participants_bloc.dart';

/// [LMChatParticipantsEvent] is the base class for all the events related to participants of a chat room.
abstract class LMChatParticipantsEvent extends Equatable {
  /// [LMChatParticipantsEvent] constructor to create an instance of [LMChatParticipantsEvent].
  const LMChatParticipantsEvent();

  @override
  List<Object> get props => [];
}

/// [LMChatGetParticipantsEvent] is used to get the participants of a chat room.
class LMChatGetParticipantsEvent extends LMChatParticipantsEvent {
  /// [chatroomId] is the id of the chat room for which the participants are to be fetched.
  final int chatroomId;

  /// [page] is the page number of the participants to be fetched.
  final int page;

  /// [pageSize] is the number of participants to be fetched in a single page.
  final int pageSize;

  /// [search] is the search query to search the participants.
  final String? search;

  /// [isSecret] is a flag to indicate if the chat room is secret or not.
  final bool isSecret;

  /// [LMChatGetParticipantsEvent] constructor to create an instance of [LMChatGetParticipantsEvent].
  const LMChatGetParticipantsEvent({
    required this.chatroomId,
    required this.page,
    required this.pageSize,
    this.search,
    required this.isSecret,
  });
  @override
  List<Object> get props => [
        chatroomId,
        page,
        pageSize,
        search ?? '',
        isSecret,
      ];
}



================================================
File: lib/packages/core/lib/src/blocs/participants/participants_state.dart
================================================
part of 'participants_bloc.dart';

/// abstract class [LMChatParticipantsState] is used to define the state of the participants bloc.
abstract class LMChatParticipantsState extends Equatable {
  /// [LMChatParticipantsState] constructor to create an instance of [LMChatParticipantsState].
  const LMChatParticipantsState();

  @override
  List<Object> get props => [];
}

/// [LMChatParticipantsInitialState] is the initial state of the participants bloc.
class LMChatParticipantsInitialState extends LMChatParticipantsState {
  /// [LMChatParticipantsInitialState] constructor to create an instance of [LMChatParticipantsInitialState].
  const LMChatParticipantsInitialState();
}

/// [LMChatParticipantsLoadingState] is the state when the participants are being loading.
class LMChatParticipantsLoadingState extends LMChatParticipantsState {
  /// [LMChatParticipantsLoadingState] constructor to create an instance of [LMChatParticipantsLoadingState].
  const LMChatParticipantsLoadingState();
}

/// [LMChatParticipantsPaginationLoading] is the state when the participants data loaded.
class LMChatParticipantsLoadedState extends LMChatParticipantsState {
  /// [participants] is the list of participants.
  final List<LMChatUserViewData> participants;

  /// [page] is the current page for pagination.
  final int page;

  /// [LMChatParticipantsLoadedState] constructor to create an instance of [LMChatParticipantsLoadedState].
  const LMChatParticipantsLoadedState({
    required this.participants,
    required this.page,
  });
  @override
  List<Object> get props => [participants];
}

/// [LMChatParticipantsErrorState] is the state when an error occurs while loading participants.
class LMChatParticipantsErrorState extends LMChatParticipantsState {
  /// [errorMessage] is the error message.
  final String errorMessage;

  /// [LMChatParticipantsErrorState] constructor to create an instance of [LMChatParticipantsErrorState].
  const LMChatParticipantsErrorState({
    required this.errorMessage,
  });
  @override
  List<Object> get props => [errorMessage];
}

/// [LMChatParticipantsPaginationLoadingState] is the state when the participants are being loaded for pagination.
class LMChatParticipantsPaginationLoadingState extends LMChatParticipantsState {
  const LMChatParticipantsPaginationLoadingState();
}



================================================
File: lib/packages/core/lib/src/blocs/participants/handler/get_participants_handler.dart
================================================
part of "../participants_bloc.dart";

// get participants event handler for [LMChatParticipantsBloc]
// It fetches the participants of a chat room.
void _getParticipantsEventHandler(LMChatGetParticipantsEvent event,
    Emitter<LMChatParticipantsState> emit) async {
  if (event.page > 1) {
    emit(
        const LMChatParticipantsPaginationLoadingState()); // Emit searching state
  } else {
    emit(const LMChatParticipantsLoadingState());
  }
  try {
    // create get participants request
    final GetParticipantsRequest getParticipantsRequest =
        (GetParticipantsRequestBuilder()
              ..chatroomId(event.chatroomId)
              ..page(event.page)
              ..pageSize(event.pageSize)
              ..search(event.search)
              ..isSecret(event.isSecret))
            .build();
    final LMResponse<GetParticipantsResponse> response =
        await LMChatCore.client.getParticipants(
      getParticipantsRequest,
    );
    // check if response is successful
    // if successful, emit [LMChatParticipantsLoadedState] with participants
    // if unsuccessful, emit [LMChatParticipantsErrorState] with error message
    if (response.success) {
      GetParticipantsResponse getParticipantsResponse = response.data!;
      List<LMChatUserViewData> participants =
          getParticipantsResponse.participants
                  ?.map(
                    (participant) => participant.toUserViewData(),
                  )
                  .toList() ??
              [];

      emit(
        LMChatParticipantsLoadedState(
          participants: participants,
          page: event.page,
        ),
      );
    } else {
      emit(
        LMChatParticipantsErrorState(
          errorMessage:
              response.errorMessage ?? "Error in fetching participants",
        ),
      );
    }
  } catch (e) {
    emit(
      LMChatParticipantsErrorState(
        errorMessage: e.toString(),
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/blocs/profile/profile_bloc.dart
================================================
import 'package:equatable/equatable.dart';
import 'package:bloc/bloc.dart';
import 'package:flutter/material.dart';

part 'profile_event.dart';

part 'profile_state.dart';

part 'event_handler/login_required_event_handler.dart';

part 'event_handler/logout_event_handler.dart';

part 'event_handler/route_to_user_profile_event_handler.dart';

/// {@template lm_profile_bloc}
/// `LMChatProfileBloc` handle all the profile related actions
/// like login, logout, route to user profile.
/// LMChatProfileEvent defines the events which are handled by this bloc.
/// {@endtemplate}
class LMChatProfileBloc extends Bloc<LMChatProfileEvent, LMChatProfileState> {
  static LMChatProfileBloc? _lmProfileBloc;

  /// {@macro lm_profile_bloc}
  static LMChatProfileBloc get instance =>
      _lmProfileBloc ??= LMChatProfileBloc._();

  LMChatProfileBloc._() : super(LMChatProfileInitState()) {
    on<LMChatLoginRequiredEvent>(_handleLMLoginRequiredEvent);
    on<LMChatLogoutEvent>(_handleLMLogoutEvent);
    on<LMChatRouteToUserProfileEvent>(_handleLMRouteToUserProfileEvent);
  }
}



================================================
File: lib/packages/core/lib/src/blocs/profile/profile_event.dart
================================================
part of 'profile_bloc.dart';

/// {@template lm_profile_event}
/// LMChatProfileEvent defines the events which are handled by this bloc.
/// {@endtemplate}
abstract class LMChatProfileEvent extends Equatable {
  /// {@macro lm_profile_event}
  const LMChatProfileEvent();

  @override
  List<Object> get props => [];
}

/// {@template lm_feed_profile_state_init}
/// LMChatProfileStateInitState defines the state when LMChatProfileBloc is initiated.
/// {@endtemplate}
class LMChatProfileEventInitEvent extends LMChatProfileEvent {}

/// {@template lm_route_to_user_profile_event}
/// LMChatRouteToUserProfileEvent defines the event to route to user profile.
/// [uuid] of type String defines the uuid of the user.
/// [context] of type BuildContext defines the context to navigate to user profile.
/// {@endtemplate}
class LMChatRouteToUserProfileEvent extends LMChatProfileEvent {
  /// Uuid of the user
  final String uuid;

  /// Context to navigate to user profile
  final BuildContext context;

  /// {@macro lm_route_to_user_profile_event}
  const LMChatRouteToUserProfileEvent({
    required this.uuid,
    required this.context,
  });

  @override
  List<Object> get props => [uuid, identityHashCode(this)];
}

/// {@template lm_login_required_event}
/// LMChatLoginRequiredEvent defines the event when login is required.
/// {@endtemplate}

class LMChatLoginRequiredEvent extends LMChatProfileEvent {}

/// {@template lm_logout_event}
/// LMChatLogoutEvent defines the event when user logged out.
/// {@endtemplate}
class LMChatLogoutEvent extends LMChatProfileEvent {}



================================================
File: lib/packages/core/lib/src/blocs/profile/profile_state.dart
================================================
part of 'profile_bloc.dart';

/// {@template lm_profile_state}
/// LMChatProfileState defines the states which are emitted by the [LMChatProfileBloc].
/// {@endtemplate}
abstract class LMChatProfileState extends Equatable {
  /// {@macro lm_profile_state}
  const LMChatProfileState();

  @override
  List<Object> get props => [];
}

/// {@template lm_feed_profile_state_init}
/// LMChatProfileStateInitState defines the state when [LMChatProfileBloc] is initiated.
/// {@endtemplate}
class LMChatProfileInitState extends LMChatProfileState {}

/// {@template lm_feed_route_to_user_profile_state}
/// LMChatRouteToUserProfileState defines the state to route to user profile.
/// [uuid] of type String defines the uuid of the user.
/// [context] of type BuildContext defines the context to navigate to user profile.
/// {@endtemplate}
class LMChatRouteToUserProfileState extends LMChatProfileState {
  /// The uuid of the user
  final String uuid;
  /// [BuildContext] of the screen
  final BuildContext context;
  /// [LMChatRouteToUserProfileState] constructor
  const LMChatRouteToUserProfileState({
    required this.uuid,
    required this.context,
  });

  @override
  List<Object> get props => [uuid, identityHashCode(this)];
}

/// {@template lm_feed_login_required_state}
/// LMChatLoginRequiredState defines the state when login is required.
/// {@endtemplate}
class LMChatLoginRequiredState extends LMChatProfileState {}

/// {@template lm_feed_logout_state}
/// LMChatLogoutState defines the state when user logged out.
/// {@endtemplate}
class LMChatLogoutState extends LMChatProfileState {}





================================================
File: lib/packages/core/lib/src/blocs/profile/event_handler/login_required_event_handler.dart
================================================
part of '../profile_bloc.dart';

/// map login required event to the event handler
void _handleLMLoginRequiredEvent(
        LMChatLoginRequiredEvent event, Emitter<LMChatProfileState> emit) =>
    emit(LMChatLoginRequiredState());



================================================
File: lib/packages/core/lib/src/blocs/profile/event_handler/logout_event_handler.dart
================================================
part of '../profile_bloc.dart';

/// map logout event to the event handler
void _handleLMLogoutEvent(
        LMChatLogoutEvent event, Emitter<LMChatProfileState> emit) =>
    emit(LMChatLogoutState());



================================================
File: lib/packages/core/lib/src/blocs/profile/event_handler/route_to_user_profile_event_handler.dart
================================================
part of '../profile_bloc.dart';

// map route to user profile event to the event handler
void _handleLMRouteToUserProfileEvent(
    LMChatRouteToUserProfileEvent event, Emitter<LMChatProfileState> emit) {
  emit(
    LMChatRouteToUserProfileState(
      uuid: event.uuid,
      context: event.context,
    ),
  );
}



================================================
File: lib/packages/core/lib/src/convertors/convertors.dart
================================================
export 'chatroom/chatroom_convertor.dart';
export 'conversation/conversation_convertor.dart';
export 'og_tag/og_tag_convertor.dart';
export 'tag/tag_convertor.dart';
export 'user/user_convertor.dart';
export 'user/sdk_client_info_convertor.dart';
export 'attachment/attachment_convertor.dart';
export 'reaction/reaction_convertor.dart';
export 'widget/widget_convertor.dart';
export 'poll/poll_option_convertor.dart';



================================================
File: lib/packages/core/lib/src/convertors/attachment/attachment_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// [AttachmentViewDataConvertor] is an extension on [Attachment] class.
/// It converts [Attachment] to [LMChatAttachmentViewData].
extension AttachmentViewDataConvertor on Attachment {
  /// Converts [Attachment] to [LMChatAttachmentViewData]
  LMChatAttachmentViewData toAttachmentViewData() {
    final LMChatAttachmentViewDataBuilder attachmentBuilder =
        LMChatAttachmentViewDataBuilder()
          ..answerId(answerId)
          ..attachmentFile(attachmentFile)
          ..createdAt(createdAt)
          ..dimensions(dimensions)
          ..fileUrl(fileUrl)
          ..height(height)
          ..width(width)
          ..id(id)
          ..index(index)
          ..locationLat(locationLat)
          ..locationLong(locationLong)
          ..locationName(locationName)
          ..meta(meta)
          ..name(name)
          ..thumbnailFile(thumbnailFile)
          ..thumbnailUrl(thumbnailUrl)
          ..type(type)
          ..url(url);

    return attachmentBuilder.build();
  }
}

/// [AttachmentConvertor] is an extension on [LMChatAttachmentViewData] class.
/// It converts [LMChatAttachmentViewData] to [Attachment].
extension AttachmentConvertor on LMChatAttachmentViewData {
  /// Converts [LMChatAttachmentViewData] to [Attachment]
  Attachment toAttachment() {
    return Attachment(
      id: id,
      createdAt: createdAt,
      locationLat: locationLat,
      locationLong: locationLong,
      type: type,
      answerId: answerId,
      attachmentFile: attachmentFile,
      dimensions: dimensions,
      height: height,
      width: width,
      index: index,
      locationName: locationName,
      meta: meta,
      name: name,
      thumbnailFile: thumbnailFile,
      thumbnailUrl: thumbnailUrl,
      url: url,
    );
  }
}

/// [MediaConvertor] is an extension on [LMChatAttachmentViewData] class.
/// It converts [LMChatAttachmentViewData] to [LMChatMediaModel].
extension MediaConvertor on LMChatAttachmentViewData {
  /// Converts [LMChatAttachmentViewData] to [LMChatMediaModel]
  LMChatMediaModel toMediaModel() {
    return LMChatMediaModel(
      mediaType: mapStringToMediaType(type!),
      mediaUrl: url ?? fileUrl,
      mediaFile: attachmentFile,
      thumbnailUrl: thumbnailUrl,
      thumbnailFile: thumbnailFile,
      meta: meta,
      height: height,
      width: width,
    );
  }
}

/// [MediaConvertor] is an extension on [LMChatAttachmentViewData] class.
/// It converts [LMChatAttachmentViewData] to [LMChatMediaModel].
extension ViewDataConvertor on LMChatMediaModel {
  /// Converts [LMChatAttachmentViewData] to [LMChatMediaModel]
  LMChatAttachmentViewData toAttachmentViewData() {
    final LMChatAttachmentViewDataBuilder attachmentBuilder =
        LMChatAttachmentViewDataBuilder()
          ..attachmentFile(mediaFile)
          ..fileUrl(mediaUrl)
          ..height(height)
          ..width(width)
          ..meta(meta)
          ..thumbnailFile(thumbnailFile)
          ..thumbnailUrl(thumbnailUrl)
          ..type(mapMediaTypeToString(mediaType))
          ..url(mediaUrl);

    return attachmentBuilder.build();
  }
}



================================================
File: lib/packages/core/lib/src/convertors/chatroom/chatroom_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';

extension ChatRoomViewDataConvertor on ChatRoom {
  LMChatRoomViewData toChatRoomViewData() {
    final LMChatRoomViewDataBuilder chatRoomBuilder =
        LMChatRoomViewDataBuilder()
          ..access(access)
          ..answerText(answerText)
          ..answersCount(answersCount)
          // ..attachment(attachments)
          ..attachmentCount(attachmentCount)
          ..attachmentsUploaded(attachmentsUploaded)
          ..attendingCount(attendingCount)
          ..attendingStatus(attendingStatus)
          ..audioCount(audioCount)
          // ..audios(audios)
          ..autoFollowDone(autoFollowDone)
          ..cardCreationTime(cardCreationTime)
          ..communityId(communityId)
          ..communityName(communityName)
          ..createdAt(createdAt)
          ..date(date)
          ..dateEpoch(dateEpoch)
          ..dateTime(dateTime)
          ..duration(duration)
          ..lastConversationId(lastConversationId)
          ..followStatus(followStatus)
          ..hasEventRecording(hasEventRecording)
          ..unseenCount(unseenCount)
          ..chatroomImageUrl(chatroomImageUrl)
          ..header(header)
          ..id(id)
          ..imageCount(imageCount)
          // ..images(images)
          ..includeMembersLater(includeMembersLater)
          ..isEdited(isEdited)
          ..isGuest(isGuest)
          ..isPaid(isPaid)
          ..isPending(isPending)
          ..isPrivate(isPrivate)
          ..isPrivateMember(isPrivateMember)
          ..isSecret(isSecret)
          ..isTagged(isTagged)
          ..member(member?.toUserViewData())
          // ..topic(topic)
          ..muteStatus(muteStatus)
          ..onlineLinkEnableBefore(onlineLinkEnableBefore)
          ..onlineLinkType(onlineLinkType)
          // ..pdf(pdf)
          ..pdfCount(pdfCount)
          ..pollsCount(pollsCount)
          // ..reactions(reactions)
          ..secretChatroomLeft(secretChatroomLeft)
          ..shareLink(shareLink)
          ..state(state)
          ..title(title)
          ..type(type)
          ..videoCount(videoCount)
          // ..videos(videos)
          ..participantCount(participantCount)
          ..totalResponseCount(totalResponseCount)
          ..isPinned(isPinned)
          ..externalSeen(externalSeen)
          ..chatRequestState(chatRequestState)
          // ..chatRequestedBy(chatRequestedBy)
          ..chatRequestedById(chatRequestedById)
          ..chatroomWithUser(chatroomWithUser?.toUserViewData())
          ..chatroomWithUserId(chatroomWithUserId)
          ..userId(userId)
          // ..lastResponseMembers(lastResponseMembers)
          ..memberCanMessage(memberCanMessage);

    return chatRoomBuilder.build();
  }
}

extension ChatRoomConvertor on LMChatRoomViewData {
  ChatRoom toChatRoom() {
    return ChatRoom(
      access: access,
      answerText: answerText,
      answersCount: answersCount,
      attachmentCount: attachmentCount,
      attachments: attachments,
      attachmentsUploaded: attachmentsUploaded,
      attendingCount: attendingCount,
      attendingStatus: attendingStatus,
      audioCount: audioCount,
      audios: audios,
      autoFollowDone: autoFollowDone,
      cardCreationTime: cardCreationTime,
      communityId: communityId,
      communityName: communityName,
      createdAt: createdAt,
      date: date,
      dateEpoch: dateEpoch,
      dateTime: dateTime,
      duration: duration,
      lastConversationId: lastConversationId,
      followStatus: followStatus,
      hasEventRecording: hasEventRecording,
      unseenCount: unseenCount,
      chatroomImageUrl: chatroomImageUrl,
      header: header,
      id: id,
      imageCount: imageCount,
      images: images,
      includeMembersLater: includeMembersLater,
      isEdited: isEdited,
      isGuest: isGuest,
      isPaid: isPaid,
      isPending: isPending,
      isPrivate: isPrivate,
      isPrivateMember: isPrivateMember,
      isSecret: isSecret,
      isTagged: isTagged,
      member: member?.toUser(),
      // topic: topic, //TODO: implement this
      muteStatus: muteStatus,
      onlineLinkEnableBefore: onlineLinkEnableBefore,
      onlineLinkType: onlineLinkType,
      pdf: pdf,
      pdfCount: pdfCount,
      pollsCount: pollsCount,
      reactions: reactions,
      secretChatroomLeft: secretChatroomLeft,
      shareLink: shareLink,
      state: state,
      title: title,
      type: type,
      videoCount: videoCount,
      videos: videos,
      participantCount: participantCount,
      totalResponseCount: totalResponseCount,
      isPinned: isPinned,
      externalSeen: externalSeen,
      chatRequestState: chatRequestState,
      // chatRequestedBy: chatRequestedBy,//TODO: implement this
      chatRequestedById: chatRequestedById,
      chatroomWithUser: chatroomWithUser?.toUser(),
      chatroomWithUserId: chatroomWithUserId,
      userId: userId,
      // lastResponseMembers: lastResponseMembers,//TODO: implement this
      memberCanMessage: memberCanMessage,
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/conversation/conversation_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// [ConversationViewDataConvertor] is an extension on [Conversation] class.
/// It converts [Conversation] to [LMChatConversationViewData].
extension ConversationViewDataConvertor on Conversation {
  /// Converts [Conversation] to [LMChatConversationViewData]
  LMChatConversationViewData toConversationViewData({
    Map<String, List<PollOption>>? conversationPollsMeta,
    Map<String, List<Attachment>>? attachmentMeta,
    Map<String, Conversation>? conversationMeta,
    Map<String, List<Reaction>>? reactionMeta,
    Map<int, User>? userMeta,
    Map<String, LMWidgetData>? widgets,
  }) {
    // get member from userMeta
    final LMChatUserViewData? member =
        this.member?.toUserViewData() ?? userMeta?[memberId]?.toUserViewData();

    // get replyConversationObject from conversationMeta
    final LMChatConversationViewData? replyConversation =
        replyConversationObject?.toConversationViewData(
              conversationPollsMeta: conversationPollsMeta,
              userMeta: userMeta,
              attachmentMeta: attachmentMeta,
              reactionMeta: reactionMeta,
              conversationMeta: conversationMeta,
              widgets: widgets,
            ) ??
            conversationMeta?[replyId.toString()]?.toConversationViewData(
              conversationPollsMeta: conversationPollsMeta,
              userMeta: userMeta,
              attachmentMeta: attachmentMeta,
              reactionMeta: reactionMeta,
              conversationMeta: conversationMeta,
              widgets: widgets,
            );
    // get attachments from attachmentMeta
    final List<LMChatAttachmentViewData>? attachments =
        attachmentMeta?[id.toString()]
            ?.map((e) => e.toAttachmentViewData())
            .toList();
    // get reactions from reactionMeta
    final List<LMChatReactionViewData>? conversationReactions =
        reactionMeta?[id.toString()]
            ?.map((e) => e.toReactionViewData())
            .toList();

    LMChatConversationViewDataBuilder conversationBuilder =
        LMChatConversationViewDataBuilder()
          ..allowAddOption(allowAddOption)
          ..answer(answer)
          ..attachmentCount(attachmentCount)
          ..attachments(attachments ??
              this.attachments?.map((e) => e.toAttachmentViewData()).toList())
          ..attachmentsUploaded(attachmentsUploaded)
          ..chatroomId(chatroomId)
          ..communityId(communityId)
          ..createdAt(createdAt)
          ..createdEpoch(createdEpoch)
          ..date(date)
          ..deletedByUserId(deletedByUserId)
          ..deviceId(deviceId)
          ..endTime(endTime)
          ..expiryTime(expiryTime)
          ..header(header)
          ..id(id)
          ..internalLink(internalLink)
          ..isAnonymous(isAnonymous)
          ..isEdited(isEdited)
          ..lastUpdated(lastUpdated)
          ..location(location)
          ..locationLat(locationLat)
          ..locationLong(locationLong)
          ..multipleSelectNo(multipleSelectNo)
          ..multipleSelectState(
              LMChatPollMultiSelectState.fromValue(multipleSelectState))
          ..onlineLinkEnableBefore(onlineLinkEnableBefore)
          ..pollAnswerText(pollAnswerText)
          ..pollType(LMChatPollType.fromValue(pollType))
          ..replyChatroomId(replyChatroomId)
          ..replyId(replyId)
          ..startTime(startTime)
          ..state(state)
          ..temporaryId(temporaryId)
          ..memberId(memberId)
          ..toShowResults(toShowResults)
          ..pollTypeText(pollTypeText)
          ..submitTypeText(submitTypeText)
          ..isTimeStamp(isTimeStamp)
          ..member(member)
          ..replyConversation(this.replyConversation)
          ..replyConversationObject(
            replyConversation ??
                replyConversationObject?.toConversationViewData(
                  conversationPollsMeta: conversationPollsMeta,
                  userMeta: userMeta,
                  attachmentMeta: attachmentMeta,
                  reactionMeta: reactionMeta,
                  conversationMeta: conversationMeta,
                  widgets: widgets,
                ),
          )
          ..ogTags(ogTags?.toLMChatOGTagViewData())
          ..hasReactions(hasReactions)
          ..conversationReactions(conversationReactions ??
              this
                  .conversationReactions
                  ?.map((e) => e.toReactionViewData())
                  .toList())
          ..poll(this
              .polls
              ?.map((e) => e.toPollOptionViewData(
                    userMeta: userMeta,
                  ))
              .toList())
          ..noPollExpiry(noPollExpiry)
          ..allowVoteChange(allowVoteChange);

    String? widgetId = this.widgetId;

    if (widgetId != null) {
      LMChatWidgetViewData? widgetsViewDataMeta =
          widgets?[widgetId]?.toWidgetViewData();

      conversationBuilder.widgetId(widgetId);
      conversationBuilder.widget(widgetsViewDataMeta);
    }

    final polls = conversationPollsMeta?[id.toString()];
    if (polls != null) {
      polls.sort((a, b) => a.id!.compareTo(b.id!));
    }
    if (polls != null) {
      conversationBuilder.poll(polls
          .map((e) => e.toPollOptionViewData(
                userMeta: userMeta,
              ))
          .toList());
    }
    return conversationBuilder.build();
  }
}

/// [ConversationConvertor] is an extension on [LMChatConversationViewData] class.
/// It converts [LMChatConversationViewData] to [Conversation].
extension ConversationConvertor on LMChatConversationViewData {
  /// Converts [LMChatConversationViewData] to [Conversation]
  Conversation toConversation() {
    return Conversation(
      allowAddOption: allowAddOption,
      answer: answer,
      attachmentsUploaded: attachmentsUploaded,
      attachmentCount: attachmentCount,
      attachments: attachments?.map((e) => e.toAttachment()).toList(),
      chatroomId: chatroomId,
      communityId: communityId,
      createdAt: createdAt,
      createdEpoch: createdEpoch,
      date: date,
      deletedByUserId: deletedByUserId,
      deviceId: deviceId,
      endTime: endTime,
      expiryTime: expiryTime,
      header: header,
      id: id,
      internalLink: internalLink,
      isAnonymous: isAnonymous,
      isEdited: isEdited,
      lastUpdated: lastUpdated,
      location: location,
      locationLat: locationLat,
      locationLong: locationLong,
      multipleSelectNo: multipleSelectNo,
      multipleSelectState: multipleSelectState?.value,
      onlineLinkEnableBefore: onlineLinkEnableBefore,
      pollAnswerText: pollAnswerText,
      pollType: pollType?.value,
      replyChatroomId: replyChatroomId,
      replyId: replyId,
      startTime: startTime,
      state: state,
      temporaryId: temporaryId,
      memberId: memberId,
      toShowResults: toShowResults,
      pollTypeText: pollTypeText,
      submitTypeText: submitTypeText,
      isTimeStamp: isTimeStamp,
      member: member?.toUser(),
      replyConversation: replyConversation,
      replyConversationObject: replyConversationObject?.toConversation(),
      ogTags: ogTags?.toOGTag(),
      hasReactions: hasReactions,
      conversationReactions: conversationReactions
          ?.map((LMChatReactionViewData reaction) => reaction.toReaction())
          .toList(),
      // poll: poll?.toPoll(),
      noPollExpiry: noPollExpiry,
      allowVoteChange: allowVoteChange,
      widgetId: widgetId,
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/moderation/report_tag_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// [ReportTagViewDataConvertor] is an extension on [ReportTag] class.
/// It converts [ReportTag] to [LMChatReportTagViewData].
/// It is used to convert [ReportTag] to [LMChatReportTagViewData].
extension ReportTagViewDataConvertor on ReportTag {
  /// Converts [ReportTag] to [LMChatReportTagViewData]
  LMChatReportTagViewData toReportTagViewData() {
    return (LMChatReportTagViewDataBuilder()
          ..id(id)
          ..name(name))
        .build();
  }
}

/// [ReportTagConvertor] is an extension on [LMChatReportTagViewData] class.
/// It converts [LMChatReportTagViewData] to [ReportTag].
/// It is used to convert [LMChatReportTagViewData] to [ReportTag].
extension ReportTagConvertor on LMChatReportTagViewData {
  /// Converts [LMChatReportTagViewData] to [ReportTag]
  ReportTag toReportTag() {
    return ReportTag(id: id, name: name);
  }
}



================================================
File: lib/packages/core/lib/src/convertors/og_tag/og_tag_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

extension OGTagConvertor on OgTags {
  LMChatOGTagsViewData toLMChatOGTagViewData() {
    final LMChatOGTagsViewDataBuilder builder = LMChatOGTagsViewDataBuilder()
      ..description(description)
      ..imageUrl(image)
      ..title(title)
      ..url(url);

    return builder.build();
  }
}

extension OGTagViewDataConvertor on LMChatOGTagsViewData {
  OgTags toOGTag() {
    return OgTags(
      description: description,
      image: imageUrl,
      title: title,
      url: url,
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/poll/poll_option_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// Extension to convert [PollOption] to [LMChatPollOptionViewData]
extension PollOptionViewDataConvertor on PollOption {
  /// Converts [PollOption] to [LMChatPollOptionViewData]
  LMChatPollOptionViewData toPollOptionViewData({
    Map<int, User>? userMeta,
  }) {
    LMChatPollOptionViewDataBuilder builder = LMChatPollOptionViewDataBuilder()
      ..id(id)
      ..text(text)
      ..isSelected(isSelected)
      ..percentage(percentage)
      ..noVotes(noVotes)
      ..member(member?.toUserViewData());
    if (userId != null && userMeta != null) {
      final user = userMeta[userId];
      if (user != null) {
        builder.member(user.toUserViewData());
      }
    }

    return builder.build();
  }
}

/// Extension to convert [LMChatPollOptionViewData] to [PollOption]
extension PollOptionConvertor on LMChatPollOptionViewData {
  /// Converts [LMChatPollOptionViewData] to [PollOption]
  PollOption toPollOption() {
    return PollOption(
      id: id,
      text: text,
      isSelected: isSelected,
      percentage: percentage,
      noVotes: noVotes,
      member: member?.toUser(),
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/reaction/reaction_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// [ReactionViewDataConvertor] is an extension on [Reaction] class.
/// It converts [Reaction] to [LMChatReactionViewData].
extension ReactionViewDataConvertor on Reaction {
  /// Converts [Reaction] to [LMChatReactionViewData]
  LMChatReactionViewData toReactionViewData() {
    return (LMChatReactionViewDataBuilder()
          ..chatroomId(chatroomId)
          ..conversationId(conversationId)
          ..reaction(reaction)
          ..reactionId(reactionId)
          ..userId(userId))
        .build();
  }
}

/// [ReactionConvertor] is an extension on [LMChatReactionViewData] class.
/// It converts [LMChatReactionViewData] to [Reaction].
extension ReactionConvertor on LMChatReactionViewData {
  /// Converts [LMChatReactionViewData] to [Reaction]
  Reaction toReaction() {
    return Reaction(
      conversationId: conversationId,
      userId: userId,
      reaction: reaction,
      chatroomId: chatroomId,
      reactionId: reactionId,
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/tag/tag_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/sdk_client_info_convertor.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

extension GroupTagConvertor on GroupTag {
  LMChatTagViewData toLMChatTagViewData() {
    LMChatTagViewDataBuilder builder = LMChatTagViewDataBuilder()
      ..name(name!)
      ..imageUrl(imageUrl!)
      ..tagType(LMTagType.groupTag)
      ..description(description)
      ..route(route)
      ..tag(tag);
    return builder.build();
  }
}

extension UserTagConvertor on UserTag {
  LMChatTagViewData toLMChatTagViewData() {
    LMChatTagViewDataBuilder builder = LMChatTagViewDataBuilder()
      ..name(name!)
      ..imageUrl(imageUrl!)
      ..tagType(LMTagType.userTag)
      ..customTitle(customTitle)
      ..id(id)
      ..isGuest(isGuest)
      ..userUniqueId(userUniqueId)
      ..uuid(uuid)
      ..sdkClientInfoViewData(sdkClientInfo?.toSDKClientInfoViewdata());
    return builder.build();
  }
}



================================================
File: lib/packages/core/lib/src/convertors/user/sdk_client_info_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// Extension to convert SDKClientInfo to view data
extension SdkClientInfoConvertor on SDKClientInfo {
  /// Converts SDKClientInfo to LMChatSDKClientInfoViewData
  LMChatSDKClientInfoViewData toSDKClientInfoViewdata() {
    LMSDKClientInfoViewDataBuilder builder = LMSDKClientInfoViewDataBuilder()
      ..community(community ?? 0)
      ..user(user ?? 0)
      ..uuid(uuid ?? '');
    return builder.build();
  }
}

/// Extension to convert LMChatSDKClientInfoViewData back to SDKClientInfo
extension LMChatSDKClientInfoViewDataConvertor on LMChatSDKClientInfoViewData {
  /// Converts LMChatSDKClientInfoViewData to SDKClientInfo
  SDKClientInfo toSDKClientInfo() {
    return SDKClientInfo(
      community: community,
      user: user,
      uuid: uuid,
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/user/user_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/sdk_client_info_convertor.dart';

/// Extension to convert between UserRole and LMChatUserRole
extension UserRoleConvertor on UserRole {
  /// Converts UserRole to LMChatUserRole
  LMChatUserRole toLMChatUserRole() {
    return LMChatUserRole.values[index];
  }
}

/// Extension to convert between LMChatUserRole and UserRole
extension LMChatUserRoleConvertor on LMChatUserRole {
  /// Converts LMChatUserRole to UserRole
  UserRole toUserRole() {
    return UserRole.values[index];
  }
}

/// Extension to convert User to LMChatUserViewData
extension UserViewDataConvertor on User {
  /// Converts User to LMChatUserViewData
  LMChatUserViewData toUserViewData() {
    final LMChatUserViewDataBuilder userBuilder = LMChatUserViewDataBuilder()
      ..id(id)
      ..name(name)
      ..imageUrl(imageUrl)
      ..isGuest(isGuest)
      ..uuid(userUniqueId)
      ..organisationName(organisationName)
      ..sdkClientInfo(sdkClientInfo?.toSDKClientInfoViewdata())
      ..updatedAt(updatedAt)
      ..isOwner(isOwner)
      ..customTitle(customTitle)
      ..memberSince(memberSince)
      ..route(route)
      ..state(state)
      ..communityId(communityId)
      ..createdAt(createdAt)
      ..roles(roles?.map((role) => role.toLMChatUserRole()).toList());
    return userBuilder.build();
  }
}

/// Extension to convert LMChatUserViewData to User
extension UserViewConvertor on LMChatUserViewData {
  /// Converts LMChatUserViewData to User
  User toUser() {
    return User(
      id: id,
      name: name,
      imageUrl: imageUrl,
      isGuest: isGuest!,
      userUniqueId: uuid,
      organisationName: organisationName,
      sdkClientInfo: sdkClientInfo?.toSDKClientInfo(),
      updatedAt: updatedAt,
      isOwner: isOwner,
      customTitle: customTitle,
      memberSince: memberSince,
      route: route,
      state: state,
      communityId: communityId,
      createdAt: createdAt,
      roles: roles?.map((role) => role.toUserRole()).toList(),
    );
  }
}



================================================
File: lib/packages/core/lib/src/convertors/widget/widget_convertor.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// Extension to convert LMWidgetData to LMChatWidgetViewData
extension LMChatWidgetViewDataConvertor on LMWidgetData {
  /// Converts LMWidgetData to LMChatWidgetViewData
  LMChatWidgetViewData toWidgetViewData() {
    final LMWidgetViewDataBuilder widgetBuilder = LMWidgetViewDataBuilder()
      ..id(id)
      ..lmMeta(lmMeta)
      ..createdAt(createdAt)
      ..metadata(metadata)
      ..parentEntityId(parentEntityId)
      ..parentEntityType(parentEntityType)
      ..updatedAt(updatedAt);
    return widgetBuilder.build();
  }
}

/// Extension to convert LMChatWidgetViewData to LMWidgetData
extension LMWidgetDataConvertor on LMChatWidgetViewData {
  /// Converts LMChatWidgetViewData to LMWidgetData
  LMWidgetData toWidgetData() {
    return LMWidgetData(
      id: id,
      lmMeta: lmMeta,
      createdAt: createdAt,
      metadata: metadata,
      parentEntityId: parentEntityId,
      parentEntityType: parentEntityType,
      updatedAt: updatedAt,
    );
  }
}



================================================
File: lib/packages/core/lib/src/core/core.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/blocs.dart';
import 'package:likeminds_chat_flutter_core/src/core/configurations/chat_config.dart';
import 'package:likeminds_chat_flutter_core/src/utils/firebase/firebase.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';

import 'package:media_kit/media_kit.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

export 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
export 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
export 'package:custom_pop_up_menu/custom_pop_up_menu.dart';

/// {@template lm_chat_core}
/// The core class of the LikeMinds Chat SDK.
/// This class is used to initialize the chat, show the chat, and logout the user session.
///
/// The [LMChatCore] class is a singleton class.
/// It has a singleton instance [instance] which is used to access the core class.
///
/// {@endtemplate}
class LMChatCore {
  /// Instance of [LMChatClient] class accessible through core class.
  late final LMChatClient lmChatClient;

  /// Instance of [LMChatConfig] class accessible through core class.
  late final LMChatConfig _lmChatConfig;

  /// [String] domain passed from client's end. used in generating the URL for sharing.
  late String _clientDomain;

  /// Singleton class for LMChatCore
  LMChatCore._();
  static LMChatCore? _instance;

  /// Singleton instance of [LMChatCore]
  static LMChatCore get instance => _instance ??= LMChatCore._();

  /// Instance of client [LMChatClient] accessible through core class.
  static LMChatClient get client => instance.lmChatClient;

  /// Instance of configuration file passed while initialising
  static LMChatConfig get config => instance._lmChatConfig;

  /// Domain passed from client's end [String]
  static String get domain => instance._clientDomain;

  /// Static setter for LMChatTheme
  static void setTheme(LMChatThemeData theme) {
    LMChatTheme.setTheme(theme);
  }

  /// Static setter for TextTheme
  static void setTextTheme(TextTheme theme) {
    LMChatTheme.setTextTheme(theme);
  }

  /// This function is used to initialize the chat.
  /// The [lmChatClient] parameter is optional and is used to pass the instance of the [LMChatClient] class.
  /// The [domain] parameter is optional and is used to pass the domain of the client.
  /// The [config] parameter is optional and is used to pass the configuration of the chat.
  /// The [widgets] parameter is optional and is used to pass the utility widgets of the chat.
  /// The [theme] parameter is optional and is used to pass the theme of the chat.
  /// The [lmChatCallback] parameter is optional and is used to pass the callback functions of the chat.
  /// The function returns a [LMResponse] object.
  /// If the initialization is successful, the [LMResponse] object give [success] as true and [data] as null.
  Future<LMResponse<void>> initialize({
    @Deprecated(
        "Use [LMChatCore.instance.client] to get an instance of [LMChatClient] instead of passing it as a parameter.")
    LMChatClient? lmChatClient,
    String? domain,
    LMChatConfig? config,
    LMChatThemeData? theme,
    LMChatCoreCallback? lmChatCallback,
    List<ConversationState>? excludedConversationStates,
    Function(LMChatAnalyticsEventFired)? analyticsListener,
    Function(LMChatProfileState)? profileListener,
  }) async {
    final lmChatSDKCallback =
        LMChatSDKCallbackImpl(lmChatCallback: lmChatCallback);
    this.lmChatClient = lmChatClient ??
        (LMChatClientBuilder()
              ..sdkCallback(lmChatSDKCallback)
              ..excludedConversationStates(excludedConversationStates ?? []))
            .build();
    if (domain != null) _clientDomain = domain;
    LMChatTheme.instance.initialise(theme: theme);
    _lmChatConfig = config ?? LMChatConfig();
    LMResponse isDBInitiated = await this.lmChatClient.initiateDB();
    if (!isDBInitiated.success) {
      return LMResponse.error(
          errorMessage: isDBInitiated.errorMessage ??
              "Error in setting up local storage");
    }
    if (analyticsListener != null) {
      LMChatAnalyticsBloc.instance.stream.listen((LMChatAnalyticsState event) {
        if (event is LMChatAnalyticsEventFired) {
          analyticsListener.call(event);
        }
      });
    }
    if (profileListener != null) {
      LMChatProfileBloc.instance.stream.listen((event) {
        profileListener.call(event);
      });
    }
    await initFirebase();
    MediaKit.ensureInitialized();
    return LMResponse.success(data: null);
  }

  /// This function is used to close the blocs of the chat.
  Future<void> closeBlocs() async {
    // await LMChatPostBloc.instance.close();
    // await LMChatRoutingBloc.instance.close();
    // await LMChatProfileBloc.instance.close();
    // await LMChatAnalyticsBloc.instance.close();
  }

  /// This function is the starting point of the chat.
  /// It must be executed before displaying the chat home screen or accessing any other [LMChatCore] widgets or screens.
  /// The [initiateUserRequest] parameter is required to initiate the user session.
  Future<LMResponse> showChatWithApiKey({
    required String apiKey,
    required String uuid,
    required String userName,
    String? imageUrl,
    bool? isGuest,
  }) async {
    String? existingAccessToken = LMChatLocalPreference.instance
        .fetchCache(LMChatStringConstants.accessToken)
        ?.value;
    String? existingRefreshToken = LMChatLocalPreference.instance
        .fetchCache(LMChatStringConstants.refreshToken)
        ?.value;

    if (existingAccessToken == null || existingRefreshToken == null) {
      InitiateUserRequestBuilder initiateUserRequestBuilder =
          InitiateUserRequestBuilder()
            ..apiKey(apiKey)
            ..userId(uuid)
            ..userName(userName);
      if (imageUrl != null) {
        initiateUserRequestBuilder.imageUrl(imageUrl);
      }
      if (isGuest != null) {
        initiateUserRequestBuilder.isGuest(isGuest);
      }
      InitiateUserRequest initiateUserRequest =
          initiateUserRequestBuilder.build();

      LMResponse<InitiateUserResponse> initiateUserResponse =
          await initiateUser(initiateUserRequest: initiateUserRequest);
      if (initiateUserResponse.success) {
        // get member state and store them in local preference
        LMResponse memberState = await _getMemberState();
        // get community configurations and store them in local preference
        LMResponse communityConfigurations =
            await _getCommunityConfigurations();

        // check if member state or community configurations are not fetched successfully
        if (!memberState.success) {
          return LMResponse(
              success: false, errorMessage: memberState.errorMessage);
        } else if (!communityConfigurations.success) {
          return LMResponse(
              success: false,
              errorMessage: communityConfigurations.errorMessage);
        }
      }
      return initiateUserResponse;
    } else {
      return await showChatWithoutApiKey(
        accessToken: existingAccessToken,
        refreshToken: existingRefreshToken,
      );
    }
  }

  /// This function is the starting point of the chat.
  /// It must be executed before displaying the chat home screen or accessing any other [LMChatCore] widgets or screens.
  /// The [accessToken] and [refreshToken] parameters are required to show the home screen.
  /// If the [accessToken] and [refreshToken] parameters are not provided, the function will fetch them from the local preference.
  Future<LMResponse> showChatWithoutApiKey({
    String? accessToken,
    String? refreshToken,
  }) async {
    String? existingAccessToken;
    String? existingRefreshToken;
    if (accessToken == null || refreshToken == null) {
      existingAccessToken = LMChatLocalPreference.instance
          .fetchCache(LMChatStringConstants.accessToken)
          ?.value;

      existingRefreshToken = LMChatLocalPreference.instance
          .fetchCache(LMChatStringConstants.refreshToken)
          ?.value;
    } else {
      existingAccessToken = accessToken;
      existingRefreshToken = refreshToken;
    }

    if (existingAccessToken == null || existingRefreshToken == null) {
      return LMResponse(
          success: false,
          errorMessage: "Access token and Refresh token are required");
    }

    ValidateUserRequest request = (ValidateUserRequestBuilder()
          ..accessToken(existingAccessToken)
          ..refreshToken(existingRefreshToken))
        .build();

    ValidateUserResponse? validateUserResponse =
        (await _validateUser(request)).data;

    if (validateUserResponse == null) {
      return LMResponse(success: false, errorMessage: "User validation failed");
    }

    LMChatNotificationHandler.instance.registerDevice(
      validateUserResponse.user!.id,
    );

    // get member state store them in local preference
    LMResponse memberStateResponse = await _getMemberState();

    // get community configurations and store them in local preference
    LMResponse communityConfigurations = await _getCommunityConfigurations();

    // check if member state or community configurations are not fetched successfully
    if (!memberStateResponse.success) {
      return LMResponse(
        success: false,
        errorMessage: memberStateResponse.errorMessage,
      );
    } else if (!communityConfigurations.success) {
      return LMResponse(
        success: false,
        errorMessage: communityConfigurations.errorMessage,
      );
    }

    return LMResponse(success: true, data: validateUserResponse);
  }

  /// This function is used to logout the user session.
  Future<LMResponse<void>> logout(LogoutRequest? request) async {
    LMResponse<void> response = await lmChatClient.logout(
      request ?? LogoutRequestBuilder().build(),
    );
    return response;
  }

  /// This function is used to initiate the user session.
  /// The [initiateUserRequest] parameter is required to initiate the user session.
  /// The [initiateUserRequest] parameter must contain the [apiKey], [userId], and [userName].
  Future<LMResponse<InitiateUserResponse>> initiateUser(
      {required InitiateUserRequest initiateUserRequest}) async {
    if (initiateUserRequest.apiKey == null &&
        initiateUserRequest.userId == null &&
        initiateUserRequest.userName == null) {
      return LMResponse.error(
        errorMessage: "ApiKey, UUID and Username are required",
      );
    } else {
      LMResponse<InitiateUserResponse> response =
          await lmChatClient.initiateUser(initiateUserRequest);

      if (!response.success) {
        return LMResponse(success: false, errorMessage: response.errorMessage);
      }
      // register device for push notification
      final User? user = response.data!.user;
      if (user != null) {
        LMChatNotificationHandler.instance.registerDevice(user.id);
      }
      return response;
    }
  }

  /// This function is used to get the member state and store them in the local preference.
  /// The function returns a [LMResponse] object.
  /// If the member state is fetched successfully, the [LMResponse] object gives [success] as true and [data] as [MemberStateResponse].
  Future<LMResponse<MemberStateResponse>> _getMemberState() async {
    LMResponse<MemberStateResponse> response = await client.getMemberState();
    if (response.success && response.data != null) {
      await LMChatLocalPreference.instance.storeMemberRights(response.data!);
    }
    return response;
  }

  /// This function is used to validate the user session. using the [accessToken] and [refreshToken] parameters.
  Future<LMResponse<ValidateUserResponse>> _validateUser(
      ValidateUserRequest request) async {
    return client.validateUser(request);
  }

  Future<LMResponse<GetCommunityConfigurationsResponse>>
      _getCommunityConfigurations() async {
    final response = await lmChatClient.getCommunityConfigurations();

    if (response.success && response.data != null) {
      await LMChatLocalPreference.instance.clearCommunityConfiguration();
      for (CommunityConfigurations configuration
          in response.data!.communityConfigurations) {
        if (configuration.type == 'chat_poll') {
          await LMChatLocalPreference.instance
              .storeCommunityConfiguration(configuration);
          return response;
        }
      }
    }

    return response;
  }
}



================================================
File: lib/packages/core/lib/src/core/configurations/chat_builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// {@template lm_widget_builder_delegate}
/// Delegate class for the widget builder.
/// {@endtemplate}
class LMChatWidgetBuilderDelegate {
  /// {@macro lm_widget_builder_delegate}
  const LMChatWidgetBuilderDelegate();

  /// Builds a [Scaffold] widget with the given parameters.
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.home,
    bool canPop = true,
    Function(bool)? onPopInvoked,
    SystemUiOverlayStyle? systemUiOverlay,
  }) {
    return AnnotatedRegion<SystemUiOverlayStyle>(
      value: systemUiOverlay ??
          LMChatCore.config.globalSystemOverlayStyle ??
          (LMChatTheme.isThemeDark
              ? SystemUiOverlayStyle.light
              : SystemUiOverlayStyle.dark),
      child: WillPopScope(
        onWillPop: () async {
          onPopInvoked?.call(canPop);
          return Future.value(canPop);
        },
        child: Scaffold(
          key: key,
          extendBody: extendBody,
          extendBodyBehindAppBar: extendBodyBehindAppBar,
          appBar: appBar,
          body: body,
          floatingActionButton: floatingActionButton,
          floatingActionButtonLocation: floatingActionButtonLocation,
          floatingActionButtonAnimator: floatingActionButtonAnimator,
          persistentFooterButtons: persistentFooterButtons,
          persistentFooterAlignment: persistentFooterAlignment,
          drawer: drawer,
          onDrawerChanged: onDrawerChanged,
          endDrawer: endDrawer,
          onEndDrawerChanged: onEndDrawerChanged,
          drawerScrimColor: drawerScrimColor,
          backgroundColor: backgroundColor,
          bottomNavigationBar: bottomNavigationBar,
          bottomSheet: bottomSheet,
          resizeToAvoidBottomInset: resizeToAvoidBottomInset,
          primary: primary,
          drawerDragStartBehavior: drawerDragStartBehavior,
          drawerEdgeDragWidth: drawerEdgeDragWidth,
          drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
          endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
          restorationId: restorationId,
        ),
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/core/configurations/chat_config.dart
================================================
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/src/core/configurations/chat_builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/explore/configurations/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/home/configurations/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/participants/configurations/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/poll/configurations/config.dart';
import 'package:likeminds_chat_flutter_core/src/views/report/configurations/config.dart';

// export all the configurations
export 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/explore/configurations/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/home/configurations/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/participants/configurations/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/report/configurations/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/config.dart';
export 'package:likeminds_chat_flutter_core/src/views/poll/configurations/config.dart';

/// {@template lm_chat_config}
/// Configuration class for the Likeminds Chat SDK.
/// {@endtemplate}
class LMChatConfig {
  /// {@macro lm_chat_chatroom_config}
  final LMChatroomConfig chatRoomConfig;

  /// {@macro lm_chat_explore_config}
  final LMChatExploreConfig exploreConfig;

  /// {@macro lm_chat_home_config}
  final LMChatHomeConfig homeConfig;

  /// {@macro lm_chat_participant_config}
  final LMChatParticipantConfig participantConfig;

  /// {@macro lm_chat_report_config}
  final LMChatReportConfig reportConfig;

  /// {@macro lm_chat_media_forwarding_config}
  final LMChatMediaForwardingConfig mediaForwardingConfig;

  /// {@macro lm_chat_media_preview_config}
  final LMChatMediaPreviewConfig mediaPreviewConfig;

  /// {@macro lm_chat_poll_config}
  final LMChatPollConfig pollConfig;

  /// {@macro lm_widget_builder_delegate}
  final LMChatWidgetBuilderDelegate widgetBuilderDelegate;

  /// [globalSystemOverlayStyle] is the system overlay style for the app.
  final SystemUiOverlayStyle? globalSystemOverlayStyle;

  /// {@macro lm_chat_config}
  LMChatConfig({
    this.chatRoomConfig = const LMChatroomConfig(),
    this.exploreConfig = const LMChatExploreConfig(),
    this.homeConfig = const LMChatHomeConfig(),
    this.participantConfig = const LMChatParticipantConfig(),
    this.reportConfig = const LMChatReportConfig(),
    this.mediaForwardingConfig = const LMChatMediaForwardingConfig(),
    this.mediaPreviewConfig = const LMChatMediaPreviewConfig(),
    this.pollConfig = const LMChatPollConfig(),
    this.widgetBuilderDelegate = const LMChatWidgetBuilderDelegate(),
    this.globalSystemOverlayStyle,
  });
}



================================================
File: lib/packages/core/lib/src/core/configurations/widget_source.dart
================================================
/// {@template lm_chat_widget_source}
/// enum to describe the source of widget
/// {@endtemplate}
enum LMChatWidgetSource {
  /// home screen
  home,

  /// explore screen
  explore,

  /// chatroom screen
  chatroom,

  /// participants screen
  participants,

  /// report screen
  report,

  /// media forwarding screen
  mediaForwarding,

  /// media preview screen
  mediaPreview,

  /// poll result screen
  pollResult,

  /// create poll screen
  createPoll,

  /// other screen
  other,
}



================================================
File: lib/packages/core/lib/src/services/lm_amazon_s3_service.dart
================================================
import 'dart:convert';

import 'package:amazon_cognito_identity_dart_2/sig_v4.dart';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';

class LMChatAWSClient {
  const LMChatAWSClient();

  static Future<LMResponse<String>> uploadFile({
    required String s3UploadUrl,
    required String s3SecretKey,
    required String s3Region,
    required String s3AccessKey,
    required String s3BucketName,
    required String folderName,
    required String fileName,
    required Uint8List fileBytes,
  }) async {
    final length = fileBytes.length;
    Map<String, String> headers = {
      "Access-Control-Allow-Origin": "*",
      // Required for CORS support to work
      "Access-Control-Allow-Credentials": "true",
      // Required for cookies, authorization headers with HTTPS
      "Access-Control-Allow-Headers":
          "Origin,Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,locale",
      "Access-Control-Allow-Methods": "POST, OPTIONS"
    };

    final uri = Uri.parse(s3UploadUrl);
    final req = http.MultipartRequest("POST", uri);
    final multipartFile = http.MultipartFile(
        'file', http.ByteStream.fromBytes(fileBytes), length,
        filename: fileName);
    final policy = Policy.fromS3PresignedPost('$folderName/$fileName',
        s3BucketName, s3AccessKey, 15, length, s3Region);
    final key =
        SigV4.calculateSigningKey(s3SecretKey, policy.datetime, s3Region, 's3');
    final signature = SigV4.calculateSignature(key, policy.encode());
    req.headers.addAll(headers);
    req.files.add(multipartFile);
    req.fields['key'] = policy.key;
    req.fields['acl'] = 'public-read';
    req.fields['X-Amz-Credential'] = policy.credential;
    req.fields['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
    req.fields['X-Amz-Date'] = policy.datetime;
    req.fields['Policy'] = policy.encode();
    req.fields['X-Amz-Signature'] = signature;

    try {
      final res = await req.send();
      debugPrint('S3UploadRequest : ${res.request}');
      var response = await http.Response.fromStream(res);
      print('s3 statusCode :${response.statusCode}');
      print('$fileName uploaded to s3Bucket');
      String url = "$s3UploadUrl$folderName/$fileName";

      return LMResponse(success: true, data: url);
    } catch (e) {
      print(e.toString());
      return LMResponse(success: false, errorMessage: e.toString());
    }
  }
}

class Policy {
  String expiration;
  String region;
  String bucket;
  String key;
  String credential;
  String datetime;
  int maxFileSize;

  Policy(this.key, this.bucket, this.datetime, this.expiration, this.credential,
      this.maxFileSize, this.region);

  factory Policy.fromS3PresignedPost(
    String key,
    String bucket,
    String accessKeyId,
    int expiryMinutes,
    int maxFileSize,
    String region,
  ) {
    final datetime = SigV4.generateDatetime();
    final expiration = (DateTime.now())
        .add(Duration(minutes: expiryMinutes))
        .toUtc()
        .toString()
        .split(' ')
        .join('T');
    final cred =
        '$accessKeyId/${SigV4.buildCredentialScope(datetime, region, 's3')}';
    final p =
        Policy(key, bucket, datetime, expiration, cred, maxFileSize, region);
    return p;
  }

  String encode() {
    final bytes = utf8.encode(toString());
    return base64.encode(bytes);
  }

  @override
  String toString() {
    return '''
{ "expiration": "$expiration",
  "conditions": [
    {"bucket": "$bucket"},
    ["starts-with", "\$key", "$key"],
    {"acl": "public-read"},
    ["content-length-range", 1, $maxFileSize],
    {"x-amz-credential": "$credential"},
    {"x-amz-algorithm": "AWS4-HMAC-SHA256"},
    {"x-amz-date": "$datetime" }
  ]
}
''';
  }
}



================================================
File: lib/packages/core/lib/src/services/media_service.dart
================================================
import 'dart:typed_data';

import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/services/lm_amazon_s3_service.dart';
import 'package:likeminds_chat_flutter_core/src/utils/credentials/credentials.dart';

/// Flutter flavour/environment manager v0.0.1
const _prod = !bool.fromEnvironment('LM_DEBUG_ENV');

class LMChatMediaService {
  late final String _bucketName;
  late final String _region;
  late final String _accessKey;
  late final String _secretKey;

  static LMChatMediaService? _instance;

  static LMChatMediaService get instance =>
      _instance ??= LMChatMediaService._();

  LMChatMediaService._() {
    _bucketName =
        _prod ? LMChatAWSCredsProd.bucketName : LMChatAWSCredsDev.bucketName;
    _region = _prod ? LMChatAWSCredsProd.region : LMChatAWSCredsDev.region;
    _accessKey =
        _prod ? LMChatAWSCredsProd.accessKey : LMChatAWSCredsDev.accessKey;
    _secretKey =
        _prod ? LMChatAWSCredsProd.secretKey : LMChatAWSCredsDev.secretKey;
  }

  static Future<LMResponse<String>> uploadFile(
    Uint8List bytes,
    String uuid, {
    String? fileName,
    int? chatroomId,
    int? conversationId,
  }) async {
    return instance._uploadFile(
      bytes,
      uuid,
      fileName: fileName,
      chatroomId: chatroomId,
      conversationId: conversationId,
    );
  }

  Future<LMResponse<String>> _uploadFile(
    Uint8List bytes,
    String uuid, {
    String? fileName,
    int? chatroomId,
    int? conversationId,
  }) async {
    try {
      String url = "https://$_bucketName.s3.$_region.amazonaws.com/";
      String folderName = "files/collabcard/$chatroomId/conversation/$uuid";
      String generateFileName =
          fileName ?? "$uuid-${DateTime.now().millisecondsSinceEpoch}";
      LMResponse<String> response = await LMChatAWSClient.uploadFile(
        s3UploadUrl: url,
        s3SecretKey: _secretKey,
        s3Region: _region,
        s3AccessKey: _accessKey,
        s3BucketName: _bucketName,
        folderName: folderName,
        fileName: generateFileName,
        fileBytes: bytes,
      );

      return response;
    } on Exception catch (err) {
      return LMResponse.error(errorMessage: err.toString());
    }
  }
}



================================================
File: lib/packages/core/lib/src/utils/utils.dart
================================================
export 'constants/strings.dart';
export 'constants/enums.dart';
export 'constants/analytics.dart';

export 'preferences/preferences.dart';

export 'conversation/conversation_utils.dart';

export 'notifications/notification_handler.dart';

export 'callback/lm_chat_callback.dart';

export 'chatroom/chatroom_utils.dart';
export 'chatroom/explore_utils.dart';

export 'extension/extension.dart';

export 'media/media_handler.dart';
export 'media/permission_handler.dart';



================================================
File: lib/packages/core/lib/src/utils/callback/lm_chat_callback.dart
================================================
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// Callback class for the core module
/// This class is used to handle the callback events from the core module
/// The core module will call the methods in this class when the corresponding events are triggered
class LMChatCoreCallback {
  /// This method is called when the access token is expired and refreshed
  Function(String accessToken, String refreshToken)?
      onAccessTokenExpiredAndRefreshed;

  /// This method is called when the refresh token is expired
  Future<LMAuthToken> Function()? onRefreshTokenExpired;

  /// Constructor for the LMChatCoreCallback
  LMChatCoreCallback({
    this.onAccessTokenExpiredAndRefreshed,
    this.onRefreshTokenExpired,
  });
}

/// Implementation of the LMChatSDKCallback
/// This class is used to handle the callback events from the core module
/// The core module will call the methods in this class when the corresponding events are triggered
class LMChatSDKCallbackImpl implements LMChatSDKCallback {
  final LMChatCoreCallback? _lmChatCoreCallback;

  /// Constructor for the LMChatSDKCallbackImpl
  LMChatSDKCallbackImpl({LMChatCoreCallback? lmChatCallback})
      : _lmChatCoreCallback = lmChatCallback;
  @override
  void eventFiredCallback(
      String eventKey, Map<String, dynamic> propertiesMap) {}

  @override
  void loginRequiredCallback() {}

  @override
  void logoutCallback() {}

  @override
  void onAccessTokenExpiredAndRefreshed(
      String accessToken, String refreshToken) {
    debugPrint("onAccessTokenExpiredAndRefreshed: $accessToken, $refreshToken");
    //Redirecting from core to example app
    _lmChatCoreCallback?.onAccessTokenExpiredAndRefreshed
        ?.call(accessToken, refreshToken);
  }

  @override
  Future<LMAuthToken> onRefreshTokenExpired() async {
    String? apiKey = LMChatLocalPreference.instance
        .fetchCache(LMChatStringConstants.apiKey)
        ?.value as String?;

    if (apiKey != null) {
      User user = LMChatLocalPreference.instance.getUser();

      InitiateUserRequest initiateUserRequest = (InitiateUserRequestBuilder()
            ..apiKey(apiKey)
            ..userName(user.name)
            ..userId(user.sdkClientInfo!.uuid ?? ""))
          .build();

      LMResponse<InitiateUserResponse> initiateUserResponse = await LMChatCore
          .instance
          .initiateUser(initiateUserRequest: initiateUserRequest);

      if (initiateUserResponse.success) {
        return (LMAuthTokenBuilder()
              ..accessToken(initiateUserResponse.data!.accessToken!)
              ..refreshToken(initiateUserResponse.data!.refreshToken!))
            .build();
      } else {
        throw Exception(initiateUserResponse.errorMessage);
      }
    } else {
      final onRefreshTokenExpired = _lmChatCoreCallback?.onRefreshTokenExpired;
      if (onRefreshTokenExpired == null) {
        throw Exception("onRefreshTokenExpired callback is not implemented");
      }
      return onRefreshTokenExpired();
    }
  }

  @override
  void profileRouteCallback({required String lmUserId}) {}
}



================================================
File: lib/packages/core/lib/src/utils/chatroom/chatroom_utils.dart
================================================
import 'package:intl/intl.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/enums.dart';
import 'package:likeminds_chat_flutter_core/src/utils/conversation/conversation_utils.dart';
import 'package:likeminds_chat_flutter_core/src/utils/preferences/preferences.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

List<int> getChatroomTypes(LMChatroomType type) {
  List<int> chatrooms = [];
  if (type == LMChatroomType.dm) chatrooms.add(10);
  if (type == LMChatroomType.group) chatrooms.addAll([0, 7]);
  return chatrooms;
}

String getUserHomePrefixPreviewMessage(
  LMChatConversationViewData conversation,
) {
  String personLabel = "";
  final user = LMChatLocalPreference.instance.getUser();
  bool isByCurrentUser = conversation.member!.id == user.id;
  personLabel = isByCurrentUser
      ? 'You: '
      : '${conversation.member!.name.split(' ').first}: ';
  return personLabel;
}

String getUserDMPrefixPreviewMessage(
  LMChatConversationViewData conversation,
  LMChatUserViewData conversationUser,
  LMChatUserViewData chatroomUser,
  LMChatUserViewData chatroomWithUser,
) {
  String personLabel = "";
  final user = LMChatLocalPreference.instance.getUser();
  bool a = conversationUser.id == chatroomWithUser.id &&
      user.id == chatroomWithUser.id;
  bool b = conversationUser.id == chatroomUser.id && user.id == chatroomUser.id;
  personLabel = a
      ? 'You: '
      : b
          ? 'You: '
          : '';
  return personLabel;
}

String getDMChatroomPreviewMessage(
  LMChatConversationViewData conversation,
  LMChatUserViewData conversationUser,
  LMChatUserViewData chatroomUser,
  LMChatUserViewData chatroomWithUser,
) {
  String personLabel = "";
  final user = LMChatLocalPreference.instance.getUser();
  bool a = conversationUser.id == chatroomWithUser.id &&
      user.id == chatroomWithUser.id;
  bool b = conversationUser.id == chatroomUser.id && user.id == chatroomUser.id;
  personLabel = a
      ? 'You: '
      : b
          ? 'You: '
          : '';
  String message = conversation.deletedByUserId == null
      ? conversation.attachmentCount == 0
          ? '$personLabel${conversation.state != 0 ? LMChatTaggingHelper.extractStateMessage(
              conversation.answer,
            ) : LMChatTaggingHelper.convertRouteToTag(
              conversation.answer,
              withTilde: false,
            )}'
          : personLabel
      : getDeletedText(conversation, user.toUserViewData());
  return message;
}

String getHomeChatroomPreviewMessage(
  LMChatConversationViewData conversation,
) {
  String personLabel = "";
  final user = LMChatLocalPreference.instance.getUser();
  bool isByCurrentUser = conversation.member!.id == user.id;
  personLabel = isByCurrentUser
      ? 'You: '
      : '${conversation.member!.name.split(' ').first}: ';
  String message = conversation.deletedByUserId == null
      ? conversation.attachmentCount == 0 && conversation.state != 10
          ? '$personLabel${conversation.state != 0 ? LMChatTaggingHelper.extractStateMessage(
              conversation.answer,
            ) : LMChatTaggingHelper.convertRouteToTag(
              conversation.answer,
              withTilde: false,
            )}'
          : personLabel
      : getDeletedText(conversation, user.toUserViewData());
  return message;
}

String getGIFText(LMChatConversationViewData conversation) {
  String gifText = conversation.answer;
  const String gifMessageIndicator =
      "* This is a gif message. Please update your app *";

  if (gifText.endsWith(gifMessageIndicator)) {
    gifText = gifText
        .substring(0, gifText.length - gifMessageIndicator.length)
        .trim();
  }

  return gifText;
}

String getTime(String time) {
  final int time0 = int.tryParse(time) ?? 0;
  final DateTime now = DateTime.now();
  final DateTime messageTime = DateTime.fromMillisecondsSinceEpoch(time0);
  final Duration difference = now.difference(messageTime);
  if (difference.inDays > 0 || now.day != messageTime.day) {
    return DateFormat('dd/MM/yyyy').format(messageTime);
  }
  return DateFormat('HH:mm')
      .format(messageTime); // Using HH instead of kk for proper 24-hour format
}

/// Checks if the other user in a DM chatroom is an AI Chatbot
bool isOtherUserAIChatbot(LMChatRoomViewData chatroom) {
  // Get logged in user's UUID
  final String loggedInUserUUID =
      LMChatLocalPreference.instance.getUser().sdkClientInfo?.uuid ?? '';

  // Determine the other member based on UUID comparison
  LMChatUserViewData? otherMember;
  if (loggedInUserUUID == chatroom.member?.sdkClientInfo?.uuid) {
    otherMember = chatroom.chatroomWithUser;
  } else {
    otherMember = chatroom.member;
  }

  // Check if the other member has the chatbot role
  return otherMember?.roles?.contains(LMChatUserRole.chatbot) ?? false;
}



================================================
File: lib/packages/core/lib/src/utils/chatroom/explore_utils.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// Utility function to map a LMChatSpace to int
int mapLMChatSpacesToInt(LMChatSpace space) {
  switch (space) {
    case LMChatSpace.newest:
      return 0;
    case LMChatSpace.active:
      return 1;
    case LMChatSpace.mostMessages:
      return 2;
    case LMChatSpace.mostParticipants:
      return 3;
  }
}

/// Utility function to get a String representation of a LMChatSpace
String getStateSpace(LMChatSpace space) {
  switch (space) {
    case LMChatSpace.newest:
      return "Newest";
    case LMChatSpace.active:
      return "Recently Active";
    case LMChatSpace.mostParticipants:
      return "Most Participants";
    case LMChatSpace.mostMessages:
      return "Most Messages";
  }
}



================================================
File: lib/packages/core/lib/src/utils/constants/analytics.dart
================================================
class LMChatAnalyticsKeys {
  static const String chatroomCreationStarted = 'Chatroom creation started';
  static const String chatroomCreationCompleted = 'Chatroom creation completed';
  static const String chatroomRenamed = 'Chatroom renamed';
  static const String chatroomMuted = 'Chatroom muted';
  static const String chatroomDeleted = 'Chatroom deleted';
  static const String chatroomReported = 'Chatroom reported';
  static const String chatroomFollowed = 'Chatroom followed';
  static const String chatroomUnfollowed = 'Chatroom unfollowed';
  static const String chatroomResponded = 'Chatroom responded';
  static const String chatroomOpened = 'Chatroom opened';
  static const String viewChatroomParticipants = 'View Chatroom participants';
  static const String viewCommunity = 'View community';
  static const String chatroomCreationError = 'Chatroom creation error';
  static const String attachmentUploadedError = 'Attachment uploaded error';
  static const String messageSendingError = 'Message sending error';
  static const String followBeforeLogin = 'Follow before login';
  static const String autoFollowEnabled = 'Auto follow enabled';
  static const String attachmentsUploaded = 'Attachments uploaded';
  static const String imageViewed = 'Image viewed';
  static const String markChatroomActive = 'Mark chatroom active';
  static const String markChatroomInActive = 'Mark chatroom inactive';
  static const String chatroomSharingStarted = 'Chatroom sharing started';
  static const String userTagsSomeone = 'User tags someone';
  static const String groupTagged = 'Group tagged';
  static const String eventAttended = 'Event attended';
  static const String scrollUpToView = 'Scroll up to view';
  static const String chatroomCreated = 'Chatroom created';
  static const String participantsAdded = 'Participants added';
  static const String chatroomAccessRestricted = 'Chatroom access restricted';
  static const String videoPlayed = 'Video played';
  static const String audioPlayed = 'Audio played';
  static const String chatLinkClicked = 'Chat link clicked';
  static const String notificationPageOpened = 'Notification page opened';
  static const String notificationRemoved = 'Notification removed';
  static const String notificationMuted = 'Notification muted';
  static const String aboutSectionViewed = 'About section viewed';
  static const String pinnedChatroomsViewed = 'Pinned chatrooms viewed';
  static const String memberGroupAdded = 'Member group added';
  static const String chatroomLeft = 'Chatroom left';
  static const String secretChatroomInvite = 'Secret Chatroom invite';
  static const String communityTabClicked = 'Community Tab clicked';
  static const String groupDetailsScreen = 'Group details screen';
  static const String syncComplete = 'Sync Complete';
  static const String chatroomUnMuted = 'Chatroom unmuted';
  static const String voiceMessageRecorded = 'Voice message recorded';
  static const String voiceMessagePreviewed = 'Voice message previewed';
  static const String voiceMessageCancelled = 'Voice message cancelled';
  static const String voiceMessageSent = 'Voice message sent';
  static const String voiceMessagePlayed = 'Voice message played';
  static const String attachmentUploaded = 'Attachment uploaded';
  static const String messageSelected = 'Messages selected';
  static const String messageDeleted = 'Message deleted';
  static const String messageCopied = 'Message copied';
  static const String messageReply = 'Message reply';
  static const String messageReported = 'Message reported';
  static const String messageEdited = 'Messages edited';
  static const String emoticonTrayOpened = 'Emoticon Tray Opened';
  static const String reactionAdded = 'Reaction Added';
  static const String reactionListOpened = 'Reaction List Opened';
  static const String reactionRemoved = 'Reaction Removed';
  static const String dmScreenOpened = 'Direct messages screen opened';
}



================================================
File: lib/packages/core/lib/src/utils/constants/assets.dart
================================================
const exploreIcon =
    'packages/likeminds_chat_flutter_core/assets/icons/explore.svg';
const exploreJoinIcon =
    'packages/likeminds_chat_flutter_core/assets/icons/explore_join.svg';
const exploreJoinnedIcon =
    'packages/likeminds_chat_flutter_core/assets/icons/explore_joinned.svg';
const secretLockIcon =
    'packages/likeminds_chat_flutter_core/assets/icons/secret_lock.svg';
const emptyPollResult =
    'packages/likeminds_chat_flutter_core/assets/icons/empty_poll_result.svg';
const emptyViewImage =
    'packages/likeminds_chat_flutter_core/assets/images/empty_view.png';
const aiChatbotLoadingAnimation =
    'https://likeminds-configs-prod.s3.ap-south-1.amazonaws.com/sdk-configs/ai-chatbot-initiate-lottie-animation.json';



================================================
File: lib/packages/core/lib/src/utils/constants/enums.dart
================================================
/// Enum for the type of chatroom
enum LMChatroomType {
  /// Direct Message
  dm,

  /// Group
  group,
}



================================================
File: lib/packages/core/lib/src/utils/constants/strings.dart
================================================
class LMChatStringConstants {
  static const String homeFeedTitle = "Chatrooms";
  static const String apiKey = "apiKey";
  static const String uuid = "uuid";
  static const String userName = "userName";
  static const String authToken = "authToken";
  static const String accessToken = "accessToken";
  static const String refreshToken = 'refreshToken';
  static const String dmHomeFeedTitle = "Direct Messages";

  static const String groupHomeTabTitle = "Groups";
  static const String dmHomeTabTitle = "DMs";

  static const String errorFallback = "Something went wrong, please try again!";
}



================================================
File: lib/packages/core/lib/src/utils/conversation/conversation_action_helper.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/audio_handler.dart';
import 'package:likeminds_chat_flutter_core/src/utils/member_rights/member_rights.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:overlay_support/overlay_support.dart';

/// Example implementation of the UI-layer interface.
/// This keeps business logic in the core.
class LMChatConversationActionHelper extends LMChatConversationActionInterface {
  /// The selection type for the chatroom
  final LMChatSelectionType selectionType;

  /// The selected ids for the chatroom
  final List<int> selectedIds;

  /// The function to call when the selection is reset
  final Function() onResetSelection;

  /// The conversation action bloc
  final LMChatConversationActionBloc convActionBloc;

  /// The chatroom id
  final int chatroomId;

  /// The conversations to be shown in the menu
  final List<LMChatConversationViewData> conversations;

  /// The chat request state
  final int chatRequestState;

  /// Pass in the selection type from wherever you set it in config.
  LMChatConversationActionHelper({
    required this.selectionType,
    required this.selectedIds,
    required this.onResetSelection,
    required this.convActionBloc,
    required this.chatroomId,
    required this.conversations,
    this.chatRequestState = 0,
  });

  @override
  void onCopy(List<LMChatConversationViewData> conversations) {
    String copiedMessage = "";
    if (conversations.length > 1) {
      for (LMChatConversationViewData convo in conversations) {
        copiedMessage +=
            "[${convo.date}] ${convo.member!.name} : ${convo.answer}\n";
      }
    } else {
      copiedMessage = conversations.first.answer;
    }
    Clipboard.setData(ClipboardData(text: copiedMessage)).then((_) {
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.messageCopied,
          eventProperties: {
            'type': 'text',
            'chatroom_id': chatroomId,
          },
        ),
      );
      toast("Copied to clipboard");
      onResetSelection();
    });
  }

  @override
  void onDelete(BuildContext context, List<int> conversationIds) {
    showDialog(
      context: context,
      builder: (dialogContext) {
        return LMChatDialog(
          style: LMChatDialogStyle(
            backgroundColor: LMChatTheme.theme.container,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
          title: LMChatText(
            "Delete Message?",
            style: LMChatTextStyle(
              textStyle: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w500,
                color: LMChatTheme.theme.onContainer,
              ),
            ),
          ),
          content: LMChatText(
            "Are you sure you want to delete this message? This action cannot be reversed.",
            style: LMChatTextStyle(
              textStyle: TextStyle(
                color: LMChatTheme.theme.onContainer,
              ),
            ),
          ),
          actions: [
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 8.0, vertical: 2.0),
              child: LMChatText(
                "CANCEL",
                style: LMChatTextStyle(
                  textStyle: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: LMChatTheme.theme.onContainer,
                  ),
                ),
                onTap: () {
                  Navigator.of(dialogContext).pop();
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8.0),
              child: LMChatText(
                "DELETE",
                style: LMChatTextStyle(
                  backgroundColor: LMChatTheme.theme.primaryColor,
                  padding: const EdgeInsets.all(6),
                  textStyle: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: LMChatTheme.theme.onPrimary,
                  ),
                ),
                onTap: () {
                  convActionBloc.add(
                    LMChatDeleteConversationEvent(
                      conversationIds: conversationIds,
                      reason: "Delete",
                    ),
                  );
                  LMChatAnalyticsBloc.instance.add(
                    LMChatFireAnalyticsEvent(
                      eventName: LMChatAnalyticsKeys.messageDeleted,
                      eventProperties: {
                        'type': 'text',
                        'chatroom_id': chatroomId,
                      },
                    ),
                  );
                  onResetSelection();
                  Navigator.of(dialogContext).pop();
                  LMChatCoreAudioHandler.instance.stopAudio();
                  LMChatCoreAudioHandler.instance.stopRecording();
                },
              ),
            ),
          ],
        );
      },
    );
  }

  @override
  void onEdit(LMChatConversationViewData conversation) {
    selectedIds.clear();
    convActionBloc.add(
      LMChatEditingConversationEvent(
        conversationId: conversation.id,
        chatroomId: chatroomId,
        editConversation: conversation,
      ),
    );
    onResetSelection();
  }

  @override
  void onReply(LMChatConversationViewData conversation) {
    convActionBloc.add(
      LMChatReplyConversationEvent(
        conversationId: conversation.id,
        chatroomId: chatroomId,
        replyConversation: conversation,
        attachments: conversation.attachments,
      ),
    );
    onResetSelection();
  }

  @override
  void onReport(LMChatConversationViewData conversation, BuildContext context) {
    selectedIds.clear();
    onResetSelection();
    context.push(
      LMChatReportScreen(
        entityId: conversation.id.toString(),
        entityCreatorId: conversation.member!.id.toString(),
        entityType: 3,
      ),
    );
  }

  @override
  void onReaction() {
    // TODO: Implement reaction handling
  }

  @override
  void showSelectionMenu(BuildContext context, Offset? position) {
    // Depending on selectionType, you can steer
    // the UI to show appbar, floating menu, or bottomsheet
    switch (selectionType) {
      case LMChatSelectionType.appbar:
        // Appbar actions are handled in chatroom.dart
        break;
      case LMChatSelectionType.floating:
        _showFloatingMenu(context, position);
        break;
      case LMChatSelectionType.bottomsheet:
        _showBottomSheetMenu(context);
        break;
    }
  }

  // Example private helper for floating popup flow
  void _showFloatingMenu(BuildContext context, Offset? position) {
    if (position == null) return;

    final selectedConversations =
        conversations.where((conv) => selectedIds.contains(conv.id)).toList();
    if (selectedConversations.isEmpty) return;

    final RenderBox overlay =
        Overlay.of(context).context.findRenderObject() as RenderBox;

    // Ensure menu stays within screen bounds
    final double screenWidth = overlay.size.width;
    const double menuWidth = 180.0;

    // Adjust x position if menu would go off screen
    double adjustedX = position.dx;
    if (adjustedX < 0) {
      adjustedX = 0;
    } else if (adjustedX + menuWidth > screenWidth) {
      adjustedX = screenWidth - menuWidth;
    }

    showMenu(
      context: context,
      color: LMChatTheme.theme.container,
      elevation: 8,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      constraints: const BoxConstraints(
        minWidth: 180,
        maxWidth: 180,
      ),
      position: RelativeRect.fromLTRB(
        adjustedX,
        position.dy,
        screenWidth - adjustedX - menuWidth,
        overlay.size.height - position.dy,
      ),
      items: [
        PopupMenuItem(
          height: 40,
          child: ListTile(
            dense: true,
            leading: Icon(Icons.copy, color: LMChatTheme.theme.onContainer),
            title: Text(
              'Copy',
              style: TextStyle(
                color: LMChatTheme.theme.onContainer,
                fontSize: 14,
              ),
            ),
          ),
          onTap: () => onCopy(selectedConversations),
        ),
        if (selectedConversations.length == 1) ...[
          PopupMenuItem(
            height: 40,
            child: ListTile(
              dense: true,
              leading: Icon(Icons.reply, color: LMChatTheme.theme.onContainer),
              title: Text(
                'Reply',
                style: TextStyle(
                  color: LMChatTheme.theme.onContainer,
                  fontSize: 14,
                ),
              ),
            ),
            onTap: () => onReply(selectedConversations.first),
          ),
          PopupMenuItem(
            height: 40,
            child: ListTile(
              dense: true,
              leading: Icon(Icons.edit, color: LMChatTheme.theme.onContainer),
              title: Text(
                'Edit',
                style: TextStyle(
                  color: LMChatTheme.theme.onContainer,
                  fontSize: 14,
                ),
              ),
            ),
            onTap: () => onEdit(selectedConversations.first),
          ),
        ],
        if (selectedConversations.length == 1 &&
            LMChatMemberRightUtil.isReportAllowed(
                selectedConversations.first) &&
            chatRequestState != 2)
          PopupMenuItem(
            height: 40,
            child: ListTile(
              dense: true,
              leading: Icon(Icons.info_outline,
                  color: LMChatTheme.theme.onContainer),
              title: Text(
                'Report',
                style: TextStyle(
                  color: LMChatTheme.theme.onContainer,
                  fontSize: 14,
                ),
              ),
            ),
            onTap: () => onReport(selectedConversations.first, context),
          ),
        PopupMenuItem(
          height: 40,
          child: const ListTile(
            dense: true,
            leading: Icon(Icons.delete_outline, color: Colors.red),
            title: Text(
              'Delete',
              style: TextStyle(
                color: Colors.red,
                fontSize: 14,
              ),
            ),
          ),
          onTap: () => onDelete(context, selectedIds),
        ),
      ],
    );
  }

  // Example private helper for bottomsheet flow
  void _showBottomSheetMenu(BuildContext context) {
    final selectedConversations =
        conversations.where((conv) => selectedIds.contains(conv.id)).toList();
    if (selectedConversations.isEmpty) return;

    showModalBottomSheet(
      context: context,
      builder: (sheetContext) {
        return SafeArea(
          child: Wrap(
            children: [
              ListTile(
                leading: const Icon(Icons.copy),
                title: const Text('Copy'),
                onTap: () {
                  onCopy(selectedConversations);
                  Navigator.pop(sheetContext);
                },
              ),
              if (selectedConversations.length == 1) ...[
                ListTile(
                  leading: const Icon(Icons.subdirectory_arrow_left),
                  title: const Text('Reply'),
                  onTap: () {
                    onReply(selectedConversations.first);
                    Navigator.pop(sheetContext);
                  },
                ),
                ListTile(
                  leading: const Icon(Icons.edit),
                  title: const Text('Edit'),
                  onTap: () {
                    onEdit(selectedConversations.first);
                    Navigator.pop(sheetContext);
                  },
                ),
              ],
              ListTile(
                leading: const Icon(Icons.delete),
                title: const Text('Delete'),
                onTap: () {
                  onDelete(context, selectedIds);
                  Navigator.pop(sheetContext);
                },
              ),
            ],
          ),
        );
      },
    );
  }
}



================================================
File: lib/packages/core/lib/src/utils/conversation/conversation_utils.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/helpers/tagging_helper.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// Helps us handle the state message addition to the list locally on
/// new chatroom topic selection by creating it using the [User] and [Conversation]
/// params - [User] loggedInUser, [Conversation] newTopic
Conversation conversationToLocalTopicStateMessage(
    User loggedInUser, Conversation newTopic) {
  Conversation stateMessage;
  String mockBackendMessage = newTopic.answer.isNotEmpty
      ? "${loggedInUser.name} changed current topic to ${LMChatTaggingHelper.extractStateMessage(newTopic.answer)}"
      : "${loggedInUser.name} set a media message as current topic";
  stateMessage = Conversation(
    answer: mockBackendMessage,
    createdAt: DateTime.now().millisecondsSinceEpoch.toString(),
    header: null,
    id: 0,
    state: 1,
  );
  return stateMessage;
}

String getDeletedText(
    LMChatConversationViewData conversation, LMChatUserViewData user) {
  return conversation.deletedByUserId == conversation.memberId
      ? conversation.deletedByUserId == user.id
          ? 'You deleted this message'
          : "This message was deleted by user"
      : "This message was deleted by Admin";
}

LMChatText getDeletedTextWidget(
    LMChatConversationViewData conversation, LMChatUserViewData user,
    {int? maxLines}) {
  return LMChatText(
    getDeletedText(conversation, user),
    style: LMChatTextStyle(
      maxLines: maxLines,
      textStyle: const TextStyle(
        color: LMChatDefaultTheme.greyColor,
        fontStyle: FontStyle.italic,
        fontSize: 13,
      ),
    ),
  );
}

Map<String, List<Reaction>> convertListToMapReaction(List<Reaction> reaction) {
  Map<String, List<Reaction>> mappedReactions = {};
  mappedReactions = {'All': reaction};
  for (var element in reaction) {
    if (mappedReactions.containsKey(element.reaction)) {
      mappedReactions[element.reaction]?.add(element);
    } else {
      mappedReactions[element.reaction] = [element];
    }
  }
  return mappedReactions;
}

/// Return list of [LMChatConversationViewData] with [LMChatConversationViewType] top and bottom
/// based on the member id and date of the conversation
/// and add date conversation in between if the date is different
/// should be used when we are fetching the conversations for the first time, i.e page 1
List<LMChatConversationViewData> groupConversationsAndAddDates(
    List<LMChatConversationViewData> conversations) {
  List<LMChatConversationViewData> updatedConversations = [];

  for (int index = 0; index < conversations.length; index++) {
    LMChatConversationViewData conversation = conversations[index];
    int? nextMemberId;
    bool isNextDateConversation = false;

    if (index + 1 < conversations.length) {
      nextMemberId = conversations[index + 1].memberId;
      isNextDateConversation =
          conversations[index + 1].date != conversation.date;
    } else {
      nextMemberId = null;
    }

    if (isNextDateConversation || (conversation.memberId != nextMemberId)) {
      conversation = conversation.copyWith(
          conversationViewType: LMChatConversationViewType.top);
    } else {
      conversation = conversation.copyWith(
          conversationViewType: LMChatConversationViewType.bottom);
    }

    updatedConversations.add(conversation);

    if (isNextDateConversation) {
      updatedConversations.add(
        Conversation(
          isTimeStamp: true,
          answer: conversation.date ?? '',
          communityId: conversation.communityId,
          chatroomId: conversation.chatroomId,
          createdAt: conversation.date ?? '',
          header: conversation.date,
          id: 0,
          pollAnswerText: conversation.date,
        ).toConversationViewData(),
      );
      isNextDateConversation = false;
    }
  }

  return updatedConversations;
}

/// Return list of [LMChatConversationViewData] with [LMChatConversationViewType] top and bottom
/// based on the member id and date of the conversation
/// and add date conversation in between if the date is different
/// should be used when a new conversation is being added to the list
List<LMChatConversationViewData> updateRealTimeConversationsViewType(
    LMChatConversationViewData newConversation,
    List<LMChatConversationViewData> oldConversations) {
  List<LMChatConversationViewData> updatedConversations = [];
  int? previousMemberId =
      oldConversations.isNotEmpty ? oldConversations.first.memberId : null;
  String? previousMessageDate =
      oldConversations.isNotEmpty ? oldConversations.first.date : null;
  bool isNextDateConversation = previousMessageDate != newConversation.date;

  if (previousMemberId == newConversation.memberId) {
    if (isNextDateConversation) {
      updatedConversations.add(
        Conversation(
          isTimeStamp: true,
          answer: newConversation.date ?? '',
          communityId: newConversation.communityId,
          chatroomId: newConversation.chatroomId,
          createdAt: newConversation.date ?? '',
          header: newConversation.date,
          id: 0,
          pollAnswerText: newConversation.date,
        ).toConversationViewData(),
      );
      newConversation = newConversation.copyWith(
          conversationViewType: LMChatConversationViewType.top);
    } else {
      newConversation = newConversation.copyWith(
          conversationViewType: LMChatConversationViewType.bottom);
    }
  } else {
    if (isNextDateConversation) {
      updatedConversations.add(
        Conversation(
          isTimeStamp: true,
          answer: newConversation.date ?? '',
          communityId: newConversation.communityId,
          chatroomId: newConversation.chatroomId,
          createdAt: newConversation.date ?? '',
          header: newConversation.date,
          id: 0,
          pollAnswerText: newConversation.date,
        ).toConversationViewData(),
      );
    }
    newConversation = newConversation.copyWith(
        conversationViewType: LMChatConversationViewType.top);
  }

  updatedConversations.add(newConversation);
  return updatedConversations;
}

/// Return list of [LMChatConversationViewData] with [LMChatConversationViewType] top and bottom
/// based on the member id and date of the conversation
/// and add date conversation in between if the date is different
/// should be used when we are fetching the conversations with page > 1
List<LMChatConversationViewData> updatePaginationConversationsViewType(
  List<LMChatConversationViewData> oldConversations,
  List<LMChatConversationViewData> newConversations,
) {
  if (newConversations.isEmpty) {
    return oldConversations;
  }
  List<LMChatConversationViewData> updatedConversations = [];
  String? previousMessageDate =
      oldConversations.isNotEmpty ? oldConversations.last.date : null;
  bool isPreviousMessageInSameDate =
      previousMessageDate == newConversations.first.date;

  if (isPreviousMessageInSameDate) {
    oldConversations.removeLast();
  }

  int? previousMemberId =
      oldConversations.isNotEmpty ? oldConversations.last.memberId : null;

  if (previousMemberId == newConversations.first.memberId) {
    oldConversations.last = oldConversations.last
        .copyWith(conversationViewType: LMChatConversationViewType.bottom);
    updatedConversations
        .addAll(groupConversationsAndAddDates(newConversations));
  } else {
    updatedConversations
        .addAll(groupConversationsAndAddDates(newConversations));
  }

  return updatedConversations;
}



================================================
File: lib/packages/core/lib/src/utils/credentials/credentials.dart
================================================
import 'package:envied/envied.dart';

/// This file contains the credentials classes for the sample app.
/// You can use the default credentials provided by the Flutter Sample community.
/// Or you can create your own community and use the credentials from there.
/// To use your own community, create a file named [.env.dev] in the root directory
/// for beta credentials and [.env.prod] for production credentials.
/// Then run the following command to generate the credentials classes:
///   flutter pub run build_runner build
/// This will automatically generate the file [credentials.g.dart] in the same directory.

part 'credentials.g.dart';

///These are BETA sample community credentials
@Envied(name: 'CredsDev', path: '.env.dev')
abstract class LMChatAWSCredsDev {
  @EnviedField(varName: 'BUCKET_NAME', obfuscate: true)
  static final String bucketName = _CredsDev.bucketName;
  @EnviedField(varName: 'POOL_ID', obfuscate: true)
  static final String poolId = _CredsDev.poolId;
  @EnviedField(varName: 'REGION', obfuscate: true)
  static final String region = _CredsDev.region;
  @EnviedField(varName: 'ACCESS_KEY', obfuscate: true)
  static final String accessKey = _CredsDev.accessKey;
  @EnviedField(varName: 'SECRET_KEY', obfuscate: true)
  static final String secretKey = _CredsDev.secretKey;
}

///These are PROD community credentials
@Envied(name: 'CredsProd', path: '.env.prod')
abstract class LMChatAWSCredsProd {
  @EnviedField(varName: 'BUCKET_NAME', obfuscate: true)
  static final String bucketName = _CredsProd.bucketName;
  @EnviedField(varName: 'POOL_ID', obfuscate: true)
  static final String poolId = _CredsProd.poolId;
  @EnviedField(varName: 'REGION', obfuscate: true)
  static final String region = _CredsProd.region;
  @EnviedField(varName: 'ACCESS_KEY', obfuscate: true)
  static final String accessKey = _CredsProd.accessKey;
  @EnviedField(varName: 'SECRET_KEY', obfuscate: true)
  static final String secretKey = _CredsProd.secretKey;
}



================================================
File: lib/packages/core/lib/src/utils/credentials/credentials.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'credentials.dart';

// **************************************************************************
// EnviedGenerator
// **************************************************************************

class _CredsDev {
  static const List<int> _enviedkeybucketName = [
    2252050981,
    155922617,
    152184416,
    46399122,
    1316181814,
    1055577990,
    1162385248,
    1981487175,
    3037918184,
    604491721,
    2921710695,
    1769866581,
    3817454675,
    2328061229,
    3792896459,
    3568974274,
    677324581,
    1363431820,
    1424257834,
    3374097044
  ];
  static const List<int> _envieddatabucketName = [
    2252051015,
    155922652,
    152184340,
    46399219,
    1316181787,
    1055578090,
    1162385161,
    1981487148,
    3037918093,
    604491684,
    2921710606,
    1769866555,
    3817454647,
    2328061278,
    3792896486,
    3568974255,
    677324608,
    1363431912,
    1424257859,
    3374097141
  ];
  static final bucketName = String.fromCharCodes(
    List.generate(_envieddatabucketName.length, (i) => i, growable: false)
        .map((i) => _envieddatabucketName[i] ^ _enviedkeybucketName[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeypoolId = [
    3733612398,
    3041880412,
    2929465436,
    627776640,
    1381111087,
    1550815104,
    2818953867,
    265339527,
    1662880167,
    1437316498,
    291680866,
    621845950,
    3852310228,
    2341956890,
    1680320423,
    2667862518,
    2978192911,
    3811126686,
    1995168065,
    322080905,
    3401631167,
    3019748217,
    1287826425,
    4156715316,
    3851867076,
    1763978808,
    1169070198,
    777091271,
    3379817473,
    3192297350,
    1241864169,
    333270159,
    1364313808,
    1932840578,
    524759048,
    3252650893,
    1084229179,
    3627037891,
    2391577550,
    699790979,
    2216091086,
    3566748392,
    968171976,
    3274712155,
    1269671008,
    2236242986,
    2028605903
  ];
  static const List<int> _envieddatapoolId = [
    3733612303,
    3041880364,
    2929465457,
    627776755,
    1381111104,
    1550815221,
    2818953983,
    265339631,
    1662880138,
    1437316515,
    291680856,
    621845903,
    3852310252,
    2341956907,
    1680320414,
    2667862464,
    2978192956,
    3811126780,
    1995168032,
    322080932,
    3401631193,
    3019748171,
    1287826333,
    4156715350,
    3851867113,
    1763978764,
    1169070147,
    777091319,
    3379817571,
    3192297387,
    1241864145,
    333270206,
    1364313833,
    1932840635,
    524759077,
    3252650932,
    1084229133,
    3627037943,
    2391577519,
    699791034,
    2216091130,
    3566748377,
    968171946,
    3274712168,
    1269671000,
    2236243017,
    2028605949
  ];
  static final poolId = String.fromCharCodes(
    List.generate(_envieddatapoolId.length, (i) => i, growable: false)
        .map((i) => _envieddatapoolId[i] ^ _enviedkeypoolId[i])
        .toList(growable: false),
  );

  static const List<int> _enviedkeyregion = <int>[
    1823962864,
    712589961,
    1262972004,
    978010342,
    2126042137,
    872401169,
    2420983682,
    4109419824,
    2357811873,
    2562416032,
  ];

  static const List<int> _envieddataregion = <int>[
    1823962769,
    712590073,
    1262971977,
    978010261,
    2126042230,
    872401252,
    2420983798,
    4109419864,
    2357811852,
    2562416017,
  ];

  static final String region = String.fromCharCodes(List<int>.generate(
    _envieddataregion.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddataregion[i] ^ _enviedkeyregion[i]));

  static const List<int> _enviedkeyaccessKey = <int>[
    2642237559,
    4059989065,
    1329496792,
    429820556,
    2102788239,
    2019140158,
    1131681576,
    1378491150,
    3621541831,
    1251680946,
    4287082041,
    4157080658,
    3572741569,
    1377082335,
    862914278,
    3921873000,
    2092649989,
    2757818047,
    576790132,
    4264223055,
  ];

  static const List<int> _envieddataaccessKey = <int>[
    2642237494,
    4059988994,
    1329496721,
    429820621,
    2102788284,
    2019140214,
    1131681637,
    1378491226,
    3621541763,
    1251681019,
    4287082106,
    4157080593,
    3572741528,
    1377082269,
    862914212,
    3921872945,
    2092650050,
    2757818102,
    576790082,
    4264222981,
  ];

  static final String accessKey = String.fromCharCodes(List<int>.generate(
    _envieddataaccessKey.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddataaccessKey[i] ^ _enviedkeyaccessKey[i]));

  static const List<int> _enviedkeysecretKey = <int>[
    1630865515,
    3222018276,
    205869190,
    2296865549,
    1943010310,
    2890286675,
    1778993366,
    1819805008,
    3470869151,
    364165513,
    4030687499,
    3931201600,
    1055228674,
    2134076470,
    915982707,
    3030844493,
    2968923485,
    553885026,
    1628204665,
    3256857055,
    969334290,
    1340910707,
    95811325,
    1841971043,
    3054242641,
    471965284,
    3269381516,
    2652836158,
    668423557,
    834980406,
    3322534925,
    3191367017,
    154080453,
    1530866400,
    827595887,
    2555694514,
    3229929647,
    824531212,
    695607835,
    525827173,
  ];

  static const List<int> _envieddatasecretKey = <int>[
    1630865490,
    3222018179,
    205869261,
    2296865652,
    1943010412,
    2890286613,
    1778993301,
    1819804967,
    3470869223,
    364165578,
    4030687567,
    3931201558,
    1055228758,
    2134076431,
    915982635,
    3030844453,
    2968923428,
    553884975,
    1628204590,
    3256857002,
    969334362,
    1340910663,
    95811258,
    1841970977,
    3054242592,
    471965201,
    3269381539,
    2652836203,
    668423628,
    834980353,
    3322535037,
    3191366952,
    154080404,
    1530866346,
    827595817,
    2555694553,
    3229929625,
    824531307,
    695607918,
    525827083,
  ];

  static final String secretKey = String.fromCharCodes(List<int>.generate(
    _envieddatasecretKey.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddatasecretKey[i] ^ _enviedkeysecretKey[i]));
}

class _CredsProd {
  static const List<int> _enviedkeybucketName = [
    781386828,
    3491641944,
    4114286948,
    841737643,
    2213543656,
    3019934881,
    2160767401,
    4188838316,
    1620383883,
    1061503446,
    2030899627,
    3145762963,
    3325941330,
    1235954610,
    4002223896,
    513307897,
    757448404,
    3826045539,
    1194177854,
    879466546
  ];
  static const List<int> _envieddatabucketName = [
    781386812,
    3491641898,
    4114286859,
    841737679,
    2213543621,
    3019934925,
    2160767424,
    4188838343,
    1620383982,
    1061503419,
    2030899650,
    3145763069,
    3325941302,
    1235954625,
    4002223925,
    513307796,
    757448369,
    3826045447,
    1194177879,
    879466579
  ];
  static final bucketName = String.fromCharCodes(
    List.generate(_envieddatabucketName.length, (i) => i, growable: false)
        .map((i) => _envieddatabucketName[i] ^ _enviedkeybucketName[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeypoolId = [
    2730347082,
    3827831918,
    39941283,
    3294715010,
    2737441668,
    3576002832,
    2120228590,
    2611245319,
    683014200,
    1966198683,
    2340697579,
    1090545007,
    222191068,
    4255973146,
    1253903542,
    2616572870,
    2984846888,
    1953272280,
    4087630014,
    3435910156,
    998845809,
    3771109329,
    2251811676,
    461849390,
    2479588690,
    1526508132,
    1726658252,
    3337233123,
    3070786539,
    3337972251,
    4159279270,
    1961856151,
    3850781902,
    730903035,
    24104751,
    2115258982,
    1066648872,
    916039734,
    1110225191,
    22542577,
    979203548,
    705091766,
    2164098704,
    2413967815,
    3582554341,
    905714519,
    3645348199
  ];
  static const List<int> _envieddatapoolId = [
    2730347051,
    3827831838,
    39941262,
    3294715121,
    2737441771,
    3576002917,
    2120228506,
    2611245423,
    683014165,
    1966198698,
    2340697553,
    1090544907,
    222191083,
    4255973161,
    1253903572,
    2616572837,
    2984846874,
    1953272253,
    4087630042,
    3435910177,
    998845715,
    3771109300,
    2251811640,
    461849419,
    2479588735,
    1526508112,
    1726658302,
    3337233024,
    3070786515,
    3337972278,
    4159279300,
    1961856246,
    3850781868,
    730902988,
    24104706,
    2115258966,
    1066648905,
    916039764,
    1110225218,
    22542529,
    979203517,
    705091718,
    2164098720,
    2413967862,
    3582554326,
    905714533,
    3645348178
  ];
  static final poolId = String.fromCharCodes(
    List.generate(_envieddatapoolId.length, (i) => i, growable: false)
        .map((i) => _envieddatapoolId[i] ^ _enviedkeypoolId[i])
        .toList(growable: false),
  );

  static const List<int> _enviedkeyregion = <int>[
    68281840,
    1218806903,
    1602019334,
    3184256766,
    2934713706,
    1890224591,
    1224817181,
    4151578199,
    1012320907,
    696479812,
  ];

  static const List<int> _envieddataregion = <int>[
    68281745,
    1218806791,
    1602019371,
    3184256653,
    2934713605,
    1890224570,
    1224817257,
    4151578175,
    1012320934,
    696479861,
  ];

  static final String region = String.fromCharCodes(List<int>.generate(
    _envieddataregion.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddataregion[i] ^ _enviedkeyregion[i]));

  static const List<int> _enviedkeyaccessKey = <int>[
    1104637160,
    526312764,
    749951175,
    382942725,
    1342406129,
    961380773,
    1040789462,
    404520365,
    1395790178,
    4240567997,
    1587669408,
    1549879647,
    1858701262,
    1662172578,
    1158596627,
    983538816,
    3290459232,
    322044666,
    3302420917,
    4037332690,
  ];

  static const List<int> _envieddataaccessKey = <int>[
    1104637097,
    526312823,
    749951118,
    382942788,
    1342406082,
    961380845,
    1040789403,
    404520441,
    1395790118,
    4240568052,
    1587669475,
    1549879580,
    1858701209,
    1662172640,
    1158596672,
    983538887,
    3290459190,
    322044620,
    3302420866,
    4037332616,
  ];

  static final String accessKey = String.fromCharCodes(List<int>.generate(
    _envieddataaccessKey.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddataaccessKey[i] ^ _enviedkeyaccessKey[i]));

  static const List<int> _enviedkeysecretKey = <int>[
    2236582107,
    4061556477,
    1791429792,
    1735765277,
    1629323122,
    2415703818,
    1035304545,
    4047242032,
    1555810261,
    2526074010,
    2914114156,
    815809410,
    101471000,
    3252417283,
    4079391020,
    4249956068,
    2534702964,
    1669936354,
    3885311494,
    2544478509,
    235024569,
    706163702,
    3645200432,
    686728614,
    760593254,
    801564037,
    4285926861,
    2447813662,
    2939719883,
    3471136766,
    140351367,
    1912592087,
    1193274875,
    1770380688,
    1856621878,
    439599705,
    2550362242,
    2051464167,
    3258909137,
    2016166080,
  ];

  static const List<int> _envieddatasecretKey = <int>[
    2236582067,
    4061556371,
    1791429832,
    1735765328,
    1629323010,
    2415703919,
    1035304489,
    4047242086,
    1555810210,
    2526074029,
    2914114082,
    815809457,
    101471041,
    3252417385,
    4079391080,
    4249955977,
    2534702849,
    1669936315,
    3885311564,
    2544478470,
    235024596,
    706163640,
    3645200508,
    686728589,
    760593169,
    801564131,
    4285926907,
    2447813739,
    2939719846,
    3471136648,
    140351404,
    1912592056,
    1193274803,
    1770380785,
    1856621900,
    439599712,
    2550362340,
    2051464064,
    3258909111,
    2016166049,
  ];

  static final String secretKey = String.fromCharCodes(List<int>.generate(
    _envieddatasecretKey.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddatasecretKey[i] ^ _enviedkeysecretKey[i]));
}



================================================
File: lib/packages/core/lib/src/utils/credentials/giphy.dart
================================================
import 'package:envied/envied.dart';

part 'giphy.g.dart';

/// A class that holds Giphy API credentials using environment variables.
///
/// This class uses the Envied package to load the Giphy API key from
/// a specified environment file (.env). The API key is obfuscated for security.
@Envied(name: 'GiphyCredentials', path: '.env')
abstract class LMChatGiphyCredentials {
  /// The Giphy API key, loaded from the environment variable 'GIPHY_API_KEY'.
  ///
  /// This key is obfuscated to prevent exposure in the source code.
  @EnviedField(varName: 'GIPHY_API_KEY', obfuscate: true)
  static final String apiKey = _GiphyCredentials.apiKey;
}



================================================
File: lib/packages/core/lib/src/utils/credentials/giphy.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'giphy.dart';

// **************************************************************************
// EnviedGenerator
// **************************************************************************

// coverage:ignore-file
// ignore_for_file: type=lint
final class _GiphyCredentials {
  static const List<int> _enviedkeyapiKey = <int>[
    3638595454,
    924453418,
    888495403,
    1337728520,
    963570068,
    991101645,
    2831613611,
    2871306793,
    3750524576,
    1308725821,
    3334195934,
    1194083624,
    3344311135,
    2765890336,
    788933556,
    3247462624,
    1871151805,
    3415790712,
    2883979554,
    3311539264,
    4068195886,
    2323147040,
    649423572,
    822445799,
    422268542,
    3789545882,
    1807127557,
    3669221229,
    2746021427,
    4205544377,
    689066496,
    2722065968,
  ];

  static const List<int> _envieddataapiKey = <int>[
    3638595339,
    924453484,
    888495484,
    1337728623,
    963570172,
    991101688,
    2831613677,
    2871306821,
    3750524569,
    1308725877,
    3334195949,
    1194083676,
    3344311069,
    2765890381,
    788933595,
    3247462535,
    1871151848,
    3415790601,
    2883979585,
    3311539234,
    4068195946,
    2323147082,
    649423589,
    822445730,
    422268440,
    3789545972,
    1807127636,
    3669221181,
    2746021456,
    4205544436,
    689066581,
    2722066024,
  ];

  static final String apiKey = String.fromCharCodes(List<int>.generate(
    _envieddataapiKey.length,
    (int i) => i,
    growable: false,
  ).map((int i) => _envieddataapiKey[i] ^ _enviedkeyapiKey[i]));
}



================================================
File: lib/packages/core/lib/src/utils/extension/container_extension.dart
================================================
import 'package:flutter/material.dart';

/// [LMChatContainerExtension] is an extension on [Container]
/// to add a copyWith method to update the properties of the container
extension LMChatContainerExtension on Container {
  /// copyWith method for Container
  /// to update the properties of the container
  /// with new values without changing the original container
  /// height and width are not included in the copyWith method
  /// as they are not mutable properties of the container
  /// to update the height and width of the container
  /// use `constraints` property of the container
  Container copyWith({
    Key? key,
    Alignment? alignment,
    EdgeInsetsGeometry? padding,
    Color? color,
    Decoration? decoration,
    Decoration? foregroundDecoration,
    BoxConstraints? constraints,
    EdgeInsetsGeometry? margin,
    Matrix4? transform,
    AlignmentGeometry? transformAlignment,
    Clip clipBehavior = Clip.none,
    Widget? child,
  }) {
    return Container(
      key: key ?? this.key,
      alignment: alignment ?? this.alignment,
      padding: padding ?? this.padding,
      color: color ?? this.color,
      decoration: decoration ?? this.decoration,
      foregroundDecoration: foregroundDecoration ?? this.foregroundDecoration,
      constraints: constraints ?? this.constraints,
      margin: margin ?? this.margin,
      transform: transform ?? this.transform,
      transformAlignment: transformAlignment ?? this.transformAlignment,
      clipBehavior: clipBehavior,
      child: child ?? this.child,
    );
  }
}



================================================
File: lib/packages/core/lib/src/utils/extension/context_extension.dart
================================================
import 'package:flutter/material.dart';

/// {@template context_extension}
/// Extension methods for BuildContext
/// {@endtemplate}
extension BuildContextExtension on BuildContext {
  /// Push a new page to the navigator stack
  Future<T?> push<T extends Object?>(Widget page) async => Navigator.push<T>(
        this,
        MaterialPageRoute<T>(
          builder: (context) => page,
        ),
      );

  /// Replace the current page with a new page in the navigator stack
  Future<T?> replace<T extends Object?, TO extends Object?>(
          Widget page) async =>
      Navigator.pushReplacement<T, TO>(
        this,
        MaterialPageRoute<T>(
          builder: (context) => page,
        ),
      );

  /// Pop the current page from the navigator stack
  void pop<T extends Object?>([T? result]) => Navigator.pop<T>(this, result);
}



================================================
File: lib/packages/core/lib/src/utils/extension/custom_pop_up_menu_extension.dart
================================================
import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:flutter/material.dart';

/// [LMChatCustomPopUpMenu] is an extension on [CustomPopupMenu]
/// to add a copyWith method to update the properties of the menu
extension LMChatCustomPopUpMenu on CustomPopupMenu {
  /// copyWith method for CustomPopupMenu
  /// to update the properties of the menu
  /// with new values without changing the original menu
  CustomPopupMenu copyWith({
    Widget? child,
    Widget Function()? menuBuilder,
    PressType? pressType,
    CustomPopupMenuController? controller,
    Color arrowColor = const Color(0xFF4C4C4C),
    bool showArrow = true,
    Color barrierColor = Colors.black12,
    double arrowSize = 10.0,
    double horizontalMargin = 10.0,
    double verticalMargin = 10.0,
    PreferredPosition? position,
    void Function(bool)? menuOnChange,
    bool enablePassEvent = true,
  }) {
    return CustomPopupMenu(
      menuBuilder: menuBuilder ?? this.menuBuilder,
      pressType: pressType ?? this.pressType,
      controller: controller ?? this.controller,
      arrowColor: arrowColor,
      showArrow: showArrow,
      barrierColor: barrierColor,
      arrowSize: arrowSize,
      horizontalMargin: horizontalMargin,
      verticalMargin: verticalMargin,
      position: position ?? this.position,
      menuOnChange: menuOnChange ?? this.menuOnChange,
      enablePassEvent: enablePassEvent,
      child: child ?? this.child,
    );
  }
}



================================================
File: lib/packages/core/lib/src/utils/extension/extension.dart
================================================
export 'package:likeminds_chat_flutter_core/src/utils/extension/list_extension.dart';
export 'package:likeminds_chat_flutter_core/src/utils/extension/context_extension.dart';
export 'package:likeminds_chat_flutter_core/src/utils/extension/custom_pop_up_menu_extension.dart';
export 'package:likeminds_chat_flutter_core/src/utils/extension/tab_bar_extension.dart';
export 'package:likeminds_chat_flutter_core/src/utils/extension/container_extension.dart';  



================================================
File: lib/packages/core/lib/src/utils/extension/list_extension.dart
================================================
/// List extension methods
/// used to extend the functionality of List class
/// and add some extra methods to it
extension LMChatListExtension on List {
  /// Copy the list
  /// return a new list with the same elements
  List<T> copy<T>() {
    return <T>[...this];
  }
}



================================================
File: lib/packages/core/lib/src/utils/extension/tab_bar_extension.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// [LMChatTabBar] is an extension on [TabBar]
/// to add a copyWith method to update the properties of the TabBar
extension LMChatTabBar on TabBar {
  /// copyWith method for TabBar
  TabBar copyWith({
    Key? key,
    List<Widget>? tabs,
    TabController? controller,
    bool isScrollable = false,
    EdgeInsetsGeometry? padding,
    Color? indicatorColor,
    bool? automaticIndicatorColorAdjustment,
    double? indicatorWeight,
    EdgeInsetsGeometry? indicatorPadding,
    Decoration? indicator,
    TabBarIndicatorSize? indicatorSize,
    Color? dividerColor,
    double? dividerHeight,
    Color? labelColor,
    TextStyle? labelStyle,
    EdgeInsetsGeometry? labelPadding,
    Color? unselectedLabelColor,
    TextStyle? unselectedLabelStyle,
    DragStartBehavior? dragStartBehavior,
    MaterialStateProperty<Color?>? overlayColor,
    MouseCursor? mouseCursor,
    bool? enableFeedback,
    void Function(int)? onTap,
    ScrollPhysics? physics,
    InteractiveInkFeatureFactory? splashFactory,
    BorderRadius? splashBorderRadius,
    TabAlignment? tabAlignment,
  }) {
    return TabBar(
      key: key ?? this.key,
      tabs: tabs ?? this.tabs,
      controller: controller ?? this.controller,
      isScrollable: isScrollable,
      padding: padding ?? this.padding,
      indicatorColor: indicatorColor ?? this.indicatorColor,
      automaticIndicatorColorAdjustment: automaticIndicatorColorAdjustment ??
          this.automaticIndicatorColorAdjustment,
      indicatorWeight: indicatorWeight ?? this.indicatorWeight,
      indicatorPadding: indicatorPadding ?? this.indicatorPadding,
      indicator: indicator ?? this.indicator,
      indicatorSize: indicatorSize ?? this.indicatorSize,
      dividerColor: dividerColor ?? this.dividerColor,
      dividerHeight: dividerHeight ?? this.dividerHeight,
      labelColor: labelColor ?? this.labelColor,
      labelStyle: labelStyle ?? this.labelStyle,
      labelPadding: labelPadding ?? this.labelPadding,
      unselectedLabelColor: unselectedLabelColor ?? this.unselectedLabelColor,
      unselectedLabelStyle: unselectedLabelStyle ?? this.unselectedLabelStyle,
      dragStartBehavior: dragStartBehavior ?? this.dragStartBehavior,
      overlayColor: overlayColor ?? this.overlayColor,
      mouseCursor: mouseCursor ?? this.mouseCursor,
      enableFeedback: enableFeedback ?? this.enableFeedback,
      onTap: onTap ?? this.onTap,
      physics: physics ?? this.physics,
      splashFactory: splashFactory ?? this.splashFactory,
      splashBorderRadius: splashBorderRadius ?? this.splashBorderRadius,
      tabAlignment: tabAlignment ?? this.tabAlignment,
    );
  }
}



================================================
File: lib/packages/core/lib/src/utils/firebase/firebase.dart
================================================
import 'dart:io';

import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/firebase/firebase_credentials.dart';

initFirebase() async {
  try {
    // final clientFirebase = Firebase.app();
    final ourFirebase = await Firebase.initializeApp(
      name: 'likeminds_chat',
      options: !isDebug
          ?
          //Prod Firebase options
          Platform.isIOS
              ? FirebaseOptions(
                  apiKey: FbCredsProd.fbApiKey,
                  appId: FbCredsProd.fbAppIdIOS,
                  messagingSenderId: FbCredsProd.fbMessagingSenderId,
                  projectId: FbCredsProd.fbProjectId,
                  databaseURL: FbCredsProd.fbDatabaseUrl,
                )
              : FirebaseOptions(
                  apiKey: FbCredsProd.fbApiKey,
                  appId: FbCredsProd.fbAppIdAN,
                  messagingSenderId: FbCredsProd.fbMessagingSenderId,
                  projectId: FbCredsProd.fbProjectId,
                  databaseURL: FbCredsProd.fbDatabaseUrl,
                )
          //Beta Firebase options
          : Platform.isIOS
              ? FirebaseOptions(
                  apiKey: FbCredsDev.fbApiKey,
                  appId: FbCredsDev.fbAppIdIOS,
                  messagingSenderId: FbCredsDev.fbMessagingSenderId,
                  projectId: FbCredsDev.fbProjectId,
                  databaseURL: FbCredsDev.fbDatabaseUrl,
                )
              : FirebaseOptions(
                  apiKey: FbCredsDev.fbApiKey,
                  appId: FbCredsDev.fbAppIdAN,
                  messagingSenderId: FbCredsDev.fbMessagingSenderId,
                  projectId: FbCredsDev.fbProjectId,
                  databaseURL: FbCredsDev.fbDatabaseUrl,
                ),
    );
    // debugPrint("Client Firebase - ${clientFirebase.options.appId}");
    debugPrint("Our Firebase - ${ourFirebase.options.appId}");
  } on FirebaseException catch (e) {
    debugPrint("Make sure you have initialized firebase, ${e.toString()}");
  }
}



================================================
File: lib/packages/core/lib/src/utils/firebase/firebase_credentials.dart
================================================
import 'package:envied/envied.dart';

/// DO NOT MODIFY THIS FILE
/// This file contains the credentials for the core firebase systems

part 'firebase_credentials.g.dart';

///These are BETA firebase credentials
@Envied(name: 'FbCredsDev', path: '.env.fb-dev')
abstract class FbCredsDev {
  @EnviedField(varName: 'FB_API_KEY', obfuscate: true)
  static final String fbApiKey = _FbCredsDev.fbApiKey;
  @EnviedField(varName: 'FB_APP_ID_AN', obfuscate: true)
  static final String fbAppIdAN = _FbCredsDev.fbAppIdAN;
  @EnviedField(varName: 'FB_APP_ID_IOS', obfuscate: true)
  static final String fbAppIdIOS = _FbCredsDev.fbAppIdIOS;
  @EnviedField(varName: 'FB_MESSAGING_SENDER_ID', obfuscate: true)
  static final String fbMessagingSenderId = _FbCredsDev.fbMessagingSenderId;
  @EnviedField(varName: 'FB_PROJECT_ID', obfuscate: true)
  static final String fbProjectId = _FbCredsDev.fbProjectId;
  @EnviedField(varName: 'FB_DATABASE_URL', obfuscate: true)
  static final String fbDatabaseUrl = _FbCredsDev.fbDatabaseUrl;
}

///These are PROD firebase credentials
@Envied(name: 'FbCredsProd', path: '.env.fb-prod')
abstract class FbCredsProd {
  @EnviedField(varName: 'FB_API_KEY', obfuscate: true)
  static final String fbApiKey = _FbCredsProd.fbApiKey;
  @EnviedField(varName: 'FB_APP_ID_AN', obfuscate: true)
  static final String fbAppIdAN = _FbCredsProd.fbAppIdAN;
  @EnviedField(varName: 'FB_APP_ID_IOS', obfuscate: true)
  static final String fbAppIdIOS = _FbCredsProd.fbAppIdIOS;
  @EnviedField(varName: 'FB_MESSAGING_SENDER_ID', obfuscate: true)
  static final String fbMessagingSenderId = _FbCredsProd.fbMessagingSenderId;
  @EnviedField(varName: 'FB_PROJECT_ID', obfuscate: true)
  static final String fbProjectId = _FbCredsProd.fbProjectId;
  @EnviedField(varName: 'FB_DATABASE_URL', obfuscate: true)
  static final String fbDatabaseUrl = _FbCredsProd.fbDatabaseUrl;
}



================================================
File: lib/packages/core/lib/src/utils/firebase/firebase_credentials.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'firebase_credentials.dart';

// **************************************************************************
// EnviedGenerator
// **************************************************************************

class _FbCredsDev {
  static const List<int> _enviedkeyfbApiKey = [
    2470654693,
    1979536507,
    91193127,
    751061647,
    616160811,
    166180155,
    3872774417,
    4029896871,
    2385931924,
    3576603109,
    1206585948,
    2426772334,
    376587942,
    3737967489,
    1909816753,
    1150854790,
    2223711222,
    1394426537,
    3409571765,
    2148583382,
    3752406435,
    1403080210,
    1643273819,
    3576901292,
    2821757493,
    2571966770,
    1289010176,
    1342795515,
    1357255398,
    4155727086,
    3663945918,
    2849344127,
    2794401742,
    379912555,
    822990767,
    1217424620,
    4250882737,
    1269596901,
    1587801599
  ];
  static const List<int> _envieddatafbApiKey = [
    2470654628,
    1979536434,
    91193181,
    751061742,
    616160888,
    166180162,
    3872774483,
    4029896944,
    2385932030,
    3576603041,
    1206585869,
    2426772267,
    376587983,
    3737967576,
    1909816826,
    1150854882,
    2223711143,
    1394426571,
    3409571812,
    2148583320,
    3752406485,
    1403080317,
    1643273778,
    3576901370,
    2821757507,
    2571966788,
    1289010255,
    1342795413,
    1357255353,
    4155726989,
    3663945948,
    2849344010,
    2794401704,
    379912506,
    822990805,
    1217424538,
    4250882790,
    1269596816,
    1587801488
  ];
  static final String fbApiKey = String.fromCharCodes(
    List.generate(_envieddatafbApiKey.length, (i) => i, growable: false)
        .map((i) => _envieddatafbApiKey[i] ^ _enviedkeyfbApiKey[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbAppIdAN = [
    3014681533,
    1427042864,
    2852344177,
    945090193,
    2999460681,
    725475805,
    4174429528,
    668882280,
    4098551357,
    2407986493,
    1589222958,
    1191967763,
    912406217,
    903920174,
    2776037288,
    2439053370,
    207081692,
    2668850404,
    1458690573,
    1071238595,
    3950597813,
    2667981366,
    1398352688,
    3665784694,
    843959887,
    2287265321,
    1062068460,
    3965123989,
    317923822,
    3949800410,
    2556370560,
    1019110021,
    4290112650,
    2945472698,
    3382858738,
    3678389758,
    2752706671,
    134260383,
    1682322469,
    3917832271,
    2071608696,
    520263366,
    2909450268,
    681199045,
    2414885848
  ];
  static const List<int> _envieddatafbAppIdAN = [
    3014681484,
    1427042826,
    2852344136,
    945090217,
    2999460730,
    725475819,
    4174429537,
    668882264,
    4098551310,
    2407986445,
    1589222940,
    1191967776,
    912406270,
    903920150,
    2776037266,
    2439053403,
    207081650,
    2668850304,
    1458690687,
    1071238572,
    3950597852,
    2667981394,
    1398352650,
    3665784642,
    843959929,
    2287265352,
    1062068366,
    3965124084,
    317923722,
    3949800431,
    2556370616,
    1019110066,
    4290112698,
    2945472655,
    3382858693,
    3678389702,
    2752706655,
    134260478,
    1682322461,
    3917832318,
    2071608602,
    520263423,
    2909450285,
    681199009,
    2414885867
  ];
  static final String fbAppIdAN = String.fromCharCodes(
    List.generate(_envieddatafbAppIdAN.length, (i) => i, growable: false)
        .map((i) => _envieddatafbAppIdAN[i] ^ _enviedkeyfbAppIdAN[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbAppIdIOS = [
    1381513257,
    1160921951,
    4148722671,
    1111561893,
    913904954,
    1539378099,
    848313920,
    1364816562,
    893155258,
    462465425,
    3348532508,
    3115825478,
    3546856609,
    2276908681,
    2770524831,
    1073286033,
    3731640047,
    2290310973,
    129208258,
    3991775545,
    3212562409,
    1738768026,
    594496480,
    2749287392,
    2003362361,
    4127803138,
    626973052,
    1673613265,
    3196675793,
    2193220273,
    2252789004,
    4122479531,
    2306117661,
    4063042855,
    4117806525,
    1851190396,
    2257267090,
    39907852,
    947175458,
    581477614,
    2544557550
  ];
  static const List<int> _envieddatafbAppIdIOS = [
    1381513240,
    1160921957,
    4148722646,
    1111561885,
    913904905,
    1539378053,
    848313977,
    1364816514,
    893155209,
    462465441,
    3348532526,
    3115825525,
    3546856598,
    2276908721,
    2770524837,
    1073286136,
    3731639936,
    2290310990,
    129208312,
    3991775497,
    3212562393,
    1738768127,
    594496389,
    2749287381,
    2003362314,
    4127803239,
    626972997,
    1673613232,
    3196675763,
    2193220232,
    2252789101,
    4122479565,
    2306117752,
    4063042847,
    4117806472,
    1851190349,
    2257267184,
    39907893,
    947175443,
    581477514,
    2544557533
  ];
  static final String fbAppIdIOS = String.fromCharCodes(
    List.generate(_envieddatafbAppIdIOS.length, (i) => i, growable: false)
        .map((i) => _envieddatafbAppIdIOS[i] ^ _enviedkeyfbAppIdIOS[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbMessagingSenderId = [
    1475392749,
    8549412,
    1949173207,
    4163735700,
    563325381,
    2415974040,
    939006329,
    3876463204,
    1359081749,
    2004626427,
    3111965024,
    4191555221
  ];
  static const List<int> _envieddatafbMessagingSenderId = [
    1475392724,
    8549404,
    1949173220,
    4163735714,
    563325436,
    2415974056,
    939006282,
    3876463188,
    1359081767,
    2004626376,
    3111965015,
    4191555245
  ];
  static final String fbMessagingSenderId = String.fromCharCodes(
    List.generate(_envieddatafbMessagingSenderId.length, (i) => i,
            growable: false)
        .map((i) =>
            _envieddatafbMessagingSenderId[i] ^
            _enviedkeyfbMessagingSenderId[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbProjectId = [
    4063341532,
    1534750140,
    376844877,
    3296284428,
    1234734933,
    2994906062,
    1695466702,
    4044892296,
    615505951,
    2983587029,
    1521912271,
    1495402138,
    2718839628,
    2439868692,
    810907832,
    2660879560
  ];
  static const List<int> _envieddatafbProjectId = [
    4063341503,
    1534750163,
    376844833,
    3296284512,
    1234734900,
    2994906028,
    1695466659,
    4044892393,
    615506027,
    2983586992,
    1521912252,
    1495402167,
    2718839598,
    2439868785,
    810907852,
    2660879529
  ];
  static final String fbProjectId = String.fromCharCodes(
    List.generate(_envieddatafbProjectId.length, (i) => i, growable: false)
        .map((i) => _envieddatafbProjectId[i] ^ _enviedkeyfbProjectId[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbDatabaseUrl = [
    2761651611,
    2816568176,
    410050138,
    1823264875,
    683914119,
    1549103965,
    2328825646,
    2286487584,
    2856508311,
    2281838217,
    2601722830,
    683709924,
    483503380,
    2627282555,
    2089659620,
    4144134041,
    3931866590,
    2625218281,
    2159294608,
    3300334608,
    813371193,
    3719042340,
    625106293,
    68491479,
    174166582,
    817665347,
    1033202165,
    2524744581,
    24544380,
    2360667086,
    2839615551,
    509504320,
    646117610,
    365219729,
    56727993,
    3079906632,
    1830749794,
    3370588776,
    17561512,
    2037093797
  ];
  static const List<int> _envieddatafbDatabaseUrl = [
    2761651699,
    2816568068,
    410050094,
    1823264795,
    683914228,
    1549103975,
    2328825601,
    2286487567,
    2856508404,
    2281838310,
    2601722786,
    683709832,
    483503477,
    2627282457,
    2089659529,
    4144134136,
    3931866538,
    2625218188,
    2159294691,
    3300334653,
    813371227,
    3719042369,
    625106177,
    68491446,
    174166552,
    817665317,
    1033202076,
    2524744695,
    24544281,
    2360667052,
    2839615582,
    509504307,
    646117519,
    365219832,
    56728022,
    3079906662,
    1830749697,
    3370588679,
    17561541,
    2037093770
  ];
  static final String fbDatabaseUrl = String.fromCharCodes(
    List.generate(_envieddatafbDatabaseUrl.length, (i) => i, growable: false)
        .map((i) => _envieddatafbDatabaseUrl[i] ^ _enviedkeyfbDatabaseUrl[i])
        .toList(growable: false),
  );
}

class _FbCredsProd {
  static const List<int> _enviedkeyfbApiKey = [
    2481163228,
    3584244936,
    3958249241,
    1675506945,
    851945721,
    3140643453,
    2963358590,
    2311733468,
    640504498,
    970676680,
    3246575724,
    1807350635,
    2838693341,
    1528156870,
    534327496,
    2744498744,
    3965349150,
    2193157117,
    928506632,
    2320261998,
    127677767,
    767093456,
    2008381143,
    600118107,
    1834458595,
    223897150,
    788741554,
    1009461564,
    3624813350,
    4016840226,
    3837495327,
    3969495979,
    3001125082,
    1394438077,
    1080795322,
    2828622237,
    1446751906,
    1437368194,
    1864570334
  ];
  static const List<int> _envieddatafbApiKey = [
    2481163165,
    3584244865,
    3958249315,
    1675507040,
    851945642,
    3140643332,
    2963358525,
    2311733425,
    640504519,
    970676631,
    3246575641,
    1807350598,
    2838693299,
    1528156917,
    534327545,
    2744498752,
    3965349164,
    2193157034,
    928506693,
    2320261951,
    127677739,
    767093383,
    2008381078,
    600118072,
    1834458506,
    223897198,
    788741511,
    1009461614,
    3624813410,
    4016840314,
    3837495384,
    3969496005,
    3001125096,
    1394438092,
    1080795383,
    2828622312,
    1446751994,
    1437368304,
    1864570297
  ];
  static final String fbApiKey = String.fromCharCodes(
    List.generate(_envieddatafbApiKey.length, (i) => i, growable: false)
        .map((i) => _envieddatafbApiKey[i] ^ _enviedkeyfbApiKey[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbAppIdAN = [
    3125963067,
    1498452389,
    1150600369,
    1941925957,
    207573516,
    167541040,
    2309201881,
    1495594753,
    1763353891,
    709033910,
    3104031321,
    3591755551,
    1857818820,
    2219016413,
    1685560680,
    4251818388,
    2459717203,
    3450102369,
    143073115,
    980885770,
    1410772483,
    3809644092,
    3105302291,
    1943270155,
    861405480,
    1607487613,
    2816946536,
    2325215863,
    975348983,
    3003190340,
    3637298286,
    563031159,
    239265452,
    656165337,
    3713020724,
    3469232303,
    2865242169,
    3814369694,
    404247937
  ];
  static const List<int> _envieddatafbAppIdAN = [
    3125963018,
    1498452383,
    1150600327,
    1941926001,
    207573561,
    167540999,
    2309201896,
    1495594807,
    1763353879,
    709033859,
    3104031329,
    3591755560,
    1857818877,
    2219016430,
    1685560658,
    4251818485,
    2459717181,
    3450102277,
    143073065,
    980885861,
    1410772586,
    3809644120,
    3105302313,
    1943270249,
    861405456,
    1607487563,
    2816946512,
    2325215765,
    975348942,
    3003190384,
    3637298188,
    563031105,
    239265434,
    656165345,
    3713020679,
    3469232278,
    2865242121,
    3814369707,
    404248036
  ];
  static final String fbAppIdAN = String.fromCharCodes(
    List.generate(_envieddatafbAppIdAN.length, (i) => i, growable: false)
        .map((i) => _envieddatafbAppIdAN[i] ^ _enviedkeyfbAppIdAN[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbAppIdIOS = [
    2929219593,
    3511352698,
    119268595,
    2233180008,
    2297165794,
    1354661338,
    893908843,
    702538155,
    4207248850,
    1245654092,
    2530910020,
    3409817938,
    370696631,
    1800257242,
    125312770,
    280607857,
    2297989870,
    3839892011,
    629324456,
    2470564813,
    1205928564,
    2713018756,
    3838798888,
    2806952135,
    828349936,
    2927863040,
    4182309601,
    3529047882,
    2300188527,
    4209391445,
    2454461476,
    1708907691,
    4044210324,
    1774536880,
    1234358600,
    1284975061,
    258241704,
    3473024176,
    4240537686,
    1050341438,
    4059268346
  ];
  static const List<int> _envieddatafbAppIdIOS = [
    2929219640,
    3511352640,
    119268549,
    2233179996,
    2297165783,
    1354661357,
    893908826,
    702538141,
    4207248870,
    1245654137,
    2530910076,
    3409817957,
    370696590,
    1800257257,
    125312824,
    280607768,
    2297989761,
    3839892056,
    629324434,
    2470564863,
    1205928516,
    2713018855,
    3838798875,
    2806952183,
    828349894,
    2927863137,
    4182309588,
    3529047932,
    2300188508,
    4209391414,
    2454461456,
    1708907720,
    4044210338,
    1774536917,
    1234358570,
    1284975028,
    258241739,
    3473024136,
    4240537652,
    1050341389,
    4059268290
  ];
  static final String fbAppIdIOS = String.fromCharCodes(
    List.generate(_envieddatafbAppIdIOS.length, (i) => i, growable: false)
        .map((i) => _envieddatafbAppIdIOS[i] ^ _enviedkeyfbAppIdIOS[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbMessagingSenderId = [
    651415748,
    3166002440,
    2014535123,
    2348936415,
    2409861821,
    2215701386,
    3006189207,
    2528036520,
    3174786398,
    638194214,
    2551322005,
    3012148149
  ];
  static const List<int> _envieddatafbMessagingSenderId = [
    651415794,
    3166002492,
    2014535142,
    2348936424,
    2409861772,
    2215701436,
    3006189219,
    2528036509,
    3174786406,
    638194193,
    2551322028,
    3012148102
  ];
  static final String fbMessagingSenderId = String.fromCharCodes(
    List.generate(_envieddatafbMessagingSenderId.length, (i) => i,
            growable: false)
        .map((i) =>
            _envieddatafbMessagingSenderId[i] ^
            _enviedkeyfbMessagingSenderId[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbProjectId = [
    82650649,
    629031581,
    341524442,
    2464780564,
    2898950820,
    1882059816,
    193194874,
    4027668169,
    3218158505,
    1592820481,
    103012573,
    483120949,
    1513353980,
    759114650,
    583547941,
    3699354962,
    860455763
  ];
  static const List<int> _envieddatafbProjectId = [
    82650746,
    629031666,
    341524406,
    2464780664,
    2898950853,
    1882059850,
    193194775,
    4027668136,
    3218158557,
    1592820580,
    103012526,
    483120920,
    1513353935,
    759114750,
    583547923,
    3699354978,
    860455778
  ];
  static final String fbProjectId = String.fromCharCodes(
    List.generate(_envieddatafbProjectId.length, (i) => i, growable: false)
        .map((i) => _envieddatafbProjectId[i] ^ _enviedkeyfbProjectId[i])
        .toList(growable: false),
  );
  static const List<int> _enviedkeyfbDatabaseUrl = [
    2382041340,
    2797656321,
    384590725,
    1691451984,
    2137116496,
    1610686703,
    1108853542,
    3523733050,
    1040989610,
    1745450700,
    1414102928,
    148862513,
    1116049239,
    2671397375,
    2748592352,
    2703763264,
    2202648562,
    1307109480,
    3621650991,
    548930150,
    1883807429,
    3586731989,
    3724991963,
    4160227067,
    1901536843,
    332046165,
    3548714283,
    2231878006,
    370216076,
    4204333962,
    329256711,
    3597487189,
    1750604379,
    2970117934,
    351844798,
    3145279962,
    532453597,
    3282888930,
    3873984884,
    4064656527,
    1347585133
  ];
  static const List<int> _envieddatafbDatabaseUrl = [
    2382041236,
    2797656437,
    384590833,
    1691451936,
    2137116451,
    1610686677,
    1108853513,
    3523733013,
    1040989641,
    1745450659,
    1414103036,
    148862557,
    1116049206,
    2671397277,
    2748592269,
    2703763233,
    2202648454,
    1307109389,
    3621651036,
    548930123,
    1883807478,
    3586731953,
    3724991981,
    4160227019,
    1901536890,
    332046203,
    3548714317,
    2231877919,
    370216190,
    4204334063,
    329256805,
    3597487156,
    1750604328,
    2970117963,
    351844823,
    3145279925,
    532453619,
    3282888833,
    3873984795,
    4064656610,
    1347585090
  ];
  static final String fbDatabaseUrl = String.fromCharCodes(
    List.generate(_envieddatafbDatabaseUrl.length, (i) => i, growable: false)
        .map((i) => _envieddatafbDatabaseUrl[i] ^ _enviedkeyfbDatabaseUrl[i])
        .toList(growable: false),
  );
}



================================================
File: lib/packages/core/lib/src/utils/media/audio_handler.dart
================================================
import 'dart:async';
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/permission_handler.dart';

/// A class to manage all audio recording and playing
class LMChatCoreAudioHandler implements LMChatAudioHandler {
  static final LMChatAudioHandler _instance =
      LMChatCoreAudioHandler._internal();
  final FlutterSoundPlayer _player = FlutterSoundPlayer();
  final FlutterSoundRecorder _recorder = FlutterSoundRecorder();
  bool _isPlayerInitialized = false;
  bool _isRecorderInitialized = false;
  bool _hasRecordingPermission = true;

  // Stream controller for currently playing URL
  final _currentlyPlayingController = StreamController<String>.broadcast();
  String? _currentlyPlayingUrl;

  // Map to store progress controllers for each audio URL
  final _progressControllers = <String, StreamController<PlaybackProgress>>{};
  StreamSubscription? _currentProgressSubscription;

  // Add these new variables for recording management
  String? _currentRecordingPath;
  bool _isRecording = false;
  final _recordingLevelController = StreamController<double>.broadcast();

  // Getters for recording state
  bool get isRecording => _isRecording;
  Stream<double> get recordingLevel => _recordingLevelController.stream;
  String? get currentRecordingPath => _currentRecordingPath;

  // Add codec constant only for recording
  static const Codec _recordingCodec = Codec.defaultCodec;

  // Add this to store the last known duration
  Duration? _lastKnownDuration;

  // Add a map to store durations for each audio path
  final Map<String, Duration> _audioDurations = {};

  // Add new stream controller for duration updates
  final _durationController =
      StreamController<Map<String, Duration>>.broadcast();

  /// Stream controller and stream for audio state changes
  final StreamController<LMChatAudioState> _audioStateController =
      StreamController<LMChatAudioState>.broadcast();

  // Add getter for the duration stream
  @override
  Stream<Duration> getDurationStream(String path) => _durationController.stream
      .where((map) => map.containsKey(path))
      .map((map) => map[path]!);

  LMChatCoreAudioHandler._internal();

  /// Returns the singleton instance of [LMChatAudioHandler].
  static LMChatAudioHandler get instance => _instance;

  /// Stream of currently playing audio URL
  @override
  String? get currentlyPlayingUrl => _currentlyPlayingUrl;

  @override
  Stream<String> get currentlyPlayingStream =>
      _currentlyPlayingController.stream;

  /// Returns the instance of [FlutterSoundPlayer] player
  @override
  FlutterSoundPlayer get player => _player;

  /// Returns the instance of [FlutterSoundRecorder] recorder
  @override
  FlutterSoundRecorder get recorder => _recorder;

  /// Returns whether recording permission is granted
  bool get hasRecordingPermission => _hasRecordingPermission;

  /// Initializes the audio player and recorder with proper permission checks
  @override
  Future<void> init() async {
    // Initialize player first as it doesn't need permissions
    if (!_isPlayerInitialized) {
      await _player.openPlayer();
      _isPlayerInitialized = true;
    }

    // // Check for microphone permission before initializing recorder
    // _hasRecordingPermission = await handlePermissions(3); // 3 is for microphone

    if (_hasRecordingPermission && !_isRecorderInitialized) {
      await _recorder.openRecorder();
      _isRecorderInitialized = true;
    }
  }

  // Request microphone permission and initialize recorder if not already initialized
  Future<bool> requestRecordingPermission() async {
    _hasRecordingPermission = await handlePermissions(3);

    if (_hasRecordingPermission && !_isRecorderInitialized) {
      try {
        await _recorder.openRecorder();
        _isRecorderInitialized = true;
      } catch (e) {
        print('Error initializing recorder: $e');
        _hasRecordingPermission = false;
      }
    }

    return _hasRecordingPermission;
  }

  /// Starts a new recording session
  @override
  Future<String?> startRecording() async {
    // Stop any playing audio before starting recording
    await stopAudio();

    // Check and request permissions first
    _hasRecordingPermission = await handlePermissions(3); // 3 for microphone
    if (!_hasRecordingPermission) {
      print('Recording permission not granted');
      throw Exception('Recording permission not granted');
    }

    if (!_isRecorderInitialized) {
      await init();
    }

    try {
      await _cleanupOldRecordings();
      _currentRecordingPath = await _generateRecordingPath();

      // Verify the directory exists and is writable
      final Directory dir = Directory(File(_currentRecordingPath!).parent.path);
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }

      await _recorder.startRecorder(
        toFile: _currentRecordingPath,
        codec: _recordingCodec,
      );

      _isRecording = true;
      _lastKnownDuration = null; // Reset duration on start
      return _currentRecordingPath;
    } catch (e) {
      print('Error starting recording: $e');
      if (e is FileSystemException) {
        print('File system error: ${e.message}');
        print('Path: ${e.path}');
        print('OS Error: ${e.osError}');
      }
      _currentRecordingPath = null;
      _isRecording = false;
      return null;
    }
  }

  /// Stops the current recording and returns the file path
  /// [recordedDuration] should be provided from the UI timer
  @override
  Future<String?> stopRecording({Duration? recordedDuration}) async {
    if (!_isRecording) return null;

    try {
      final String? path = await _recorder.stopRecorder();
      _isRecording = false;
      _audioStateController.add(LMChatAudioState.stopped);

      if (path != null) {
        final File recordingFile = File(path);
        if (await recordingFile.exists()) {
          // Store the duration provided by the UI timer
          _lastKnownDuration = recordedDuration;

          // Initialize progress controller with the known duration
          if (_lastKnownDuration != null) {
            _progressControllers[path] =
                StreamController<PlaybackProgress>.broadcast();
            _updateProgress(
              path,
              PlaybackProgress(
                duration: _lastKnownDuration!,
                position: Duration.zero,
              ),
            );
          }

          return path;
        }
      }
      return null;
    } catch (e) {
      print('Error stopping recording: $e');
      return null;
    } finally {
      _currentRecordingPath = null;
      _isRecording = false;
    }
  }

  /// Get the last known duration of the recording
  Duration? getLastRecordingDuration() => _lastKnownDuration;

  /// Cancels and deletes the current recording
  @override
  Future<void> cancelRecording() async {
    if (!_isRecording) return;

    try {
      await _recorder.stopRecorder();
      _audioStateController.add(LMChatAudioState.stopped);

      if (_currentRecordingPath != null) {
        final File recordingFile = File(_currentRecordingPath!);
        if (await recordingFile.exists()) {
          await recordingFile.delete();
        }
      }
    } catch (e) {
      print('Error canceling recording: $e');
    } finally {
      _currentRecordingPath = null;
      _isRecording = false;
    }
  }

  /// Checks if a file is a valid audio file
  Future<bool> isValidAudioFile(String path) async {
    try {
      final File file = File(path);
      if (!await file.exists()) return false;

      final int fileSize = await file.length();
      if (fileSize < 100) return false; // Arbitrary minimum size

      // Try to get audio duration as validation
      final Duration? duration = await _player.startPlayer(
        fromURI: path,
        codec: Codec.defaultCodec,
      );

      await _player.stopPlayer();

      return duration != null && duration.inMilliseconds > 0;
    } catch (e) {
      print('Error validating audio file: $e');
      return false;
    }
  }

  /// Get progress stream for specific audio URL
  @override
  Stream<PlaybackProgress> getProgressStream(String audioUrl) {
    _progressControllers[audioUrl] ??=
        StreamController<PlaybackProgress>.broadcast();
    return _progressControllers[audioUrl]!.stream;
  }

  /// Plays audio from the specified [path].
  @override
  Future<void> playAudio(String path) async {
    if (!_isPlayerInitialized) {
      await init();
    }

    try {
      await stopAudio();

      _currentlyPlayingUrl = path;
      _currentlyPlayingController.add(path);
      _audioStateController.add(LMChatAudioState.playing);

      bool isLocalFile = path.startsWith('/');
      Codec codec = isLocalFile ? _recordingCodec : Codec.defaultCodec;

      if (isLocalFile) {
        final File audioFile = File(path);
        if (!await audioFile.exists()) {
          throw Exception('Audio file not found');
        }

        await _player.startPlayer(
          fromURI: path,
          codec: codec,
          whenFinished: () async {
            await _onPlaybackComplete(path);
          },
        );
      } else {
        await _player.startPlayer(
          fromURI: path,
          codec: codec,
          whenFinished: () async {
            await _onPlaybackComplete(path);
          },
        );
      }

      // Set up progress tracking for this specific path
      _setupProgressTracking(path);
    } catch (e) {
      print('Error playing audio: $e');
      await _onPlaybackError(path);
    }
  }

  /// Pauses the currently playing audio.
  @override
  Future<void> pauseAudio() async {
    if (!_isPlayerInitialized) return;

    try {
      if (_player.isPlaying) {
        await _player.pausePlayer();
        _audioStateController.add(LMChatAudioState.paused);
        _currentlyPlayingController.add('');
      }
    } catch (e) {
      print('Error pausing audio: $e');
    }
  }

  /// Resumes the paused audio.
  @override
  Future<void> resumeAudio() async {
    if (!_isPlayerInitialized || _currentlyPlayingUrl == null) return;

    try {
      if (_player.isPaused) {
        await _player.resumePlayer();
        _audioStateController.add(LMChatAudioState.playing);
        _currentlyPlayingController.add(_currentlyPlayingUrl!);
      }
    } catch (e) {
      print('Error resuming audio: $e');
    }
  }

  /// Stops the currently playing audio.
  @override
  Future<void> stopAudio() async {
    if (!_isPlayerInitialized) return;

    try {
      if (_player.isPlaying || _player.isPaused) {
        await _player.stopPlayer();
        _audioStateController.add(LMChatAudioState.stopped);

        if (_currentlyPlayingUrl != null) {
          // Reset progress for the current URL
          _updateProgress(
            _currentlyPlayingUrl!,
            PlaybackProgress(
              duration: _audioDurations[_currentlyPlayingUrl!] ?? Duration.zero,
              position: Duration.zero,
            ),
          );
        }
      }

      // Clear current playback state
      _currentlyPlayingUrl = null;
      _currentlyPlayingController.add('');
      await _currentProgressSubscription?.cancel();
      _currentProgressSubscription = null;
    } catch (e) {
      print('Error stopping audio: $e');
    }
  }

  /// Seeks to a specific position in the audio
  @override
  Future<void> seekTo(Duration position) async {
    if (!_isPlayerInitialized) return;

    try {
      await _player.seekToPlayer(position);
    } catch (e) {
      print('Error seeking audio: $e');
    }
  }

  void _updateProgress(String audioUrl, PlaybackProgress progress) {
    _progressControllers[audioUrl]?.add(progress);
  }

  /// Disposes of all resources
  @override
  Future<void> dispose() async {
    try {
      // Stop any ongoing playback or recording
      if (_isRecording) {
        await cancelRecording();
      }
      await stopAudio();

      // Clean up player resources
      await _currentProgressSubscription?.cancel();
      if (_isPlayerInitialized) {
        await _player.closePlayer();
        _isPlayerInitialized = false;
      }

      // Clean up recorder resources
      if (_isRecorderInitialized) {
        await _recorder.closeRecorder();
        _isRecorderInitialized = false;
      }

      // Clear all stored state and controllers
      _audioDurations.clear();
      for (final controller in _progressControllers.values) {
        await controller.close();
      }
      _progressControllers.clear();

      await _currentlyPlayingController.close();
      _currentlyPlayingUrl = null;
      _hasRecordingPermission = false;
      await _recordingLevelController.close();

      // Clean up any temporary files
      await _cleanupOldRecordings();

      // Clean up duration controller
      await _durationController.close();

      // Add cleanup of audio state controller
      await _audioStateController.close();
    } catch (e) {
      print('Error in dispose: $e');
    }
  }

  // @override
  // // TODO: implement playbackProgress
  // Stream<PlaybackProgress> get playbackProgress => throw UnimplementedError();

  Future<void> _onPlaybackComplete(String path) async {
    await _player.stopPlayer();
    _audioStateController.add(LMChatAudioState.stopped);

    // Store final duration before clearing state
    final duration = _audioDurations[path] ?? Duration.zero;

    // Clear state for this path
    _currentlyPlayingUrl = null;
    _currentlyPlayingController.add('');

    // Reset progress with the stored duration
    _updateProgress(
      path,
      PlaybackProgress(
        duration: duration,
        position: Duration.zero,
        isCompleted: true,
      ),
    );

    await _currentProgressSubscription?.cancel();
    _currentProgressSubscription = null;
  }

  Future<void> _onPlaybackError(String path) async {
    _currentlyPlayingUrl = null;
    _currentlyPlayingController.add('');
    await _currentProgressSubscription?.cancel();
    _currentProgressSubscription = null;
    _updateProgress(
      path,
      const PlaybackProgress(
        duration: Duration.zero,
        position: Duration.zero,
      ),
    );
  }

  void _setupProgressTracking(String path) {
    _currentProgressSubscription?.cancel();
    _player.setSubscriptionDuration(const Duration(milliseconds: 100));

    _currentProgressSubscription = _player.onProgress!.listen(
      (e) {
        if (path == _currentlyPlayingUrl || _player.isPaused) {
          // Store duration for this path
          _audioDurations[path] = e.duration;

          _updateProgress(
            path,
            PlaybackProgress(
              duration: e.duration,
              position: e.position,
            ),
          );
        }
      },
      onError: (error) {
        print('Progress tracking error: $error');
        _onPlaybackError(path);
      },
    );
  }

  // Helper method to generate unique file path for recordings
  Future<String> _generateRecordingPath() async {
    // On iOS, we should use the temporary directory for recording files
    final Directory tempDir = await getTemporaryDirectory();
    final String recordingDir = '${tempDir.path}/recordings';
    await Directory(recordingDir).create(recursive: true);

    final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();
    return '$recordingDir/recording_$timestamp.aac';
  }

  // Helper method to clean up old recordings
  Future<void> _cleanupOldRecordings() async {
    try {
      final Directory tempDir = await getTemporaryDirectory();
      final String recordingDir = '${tempDir.path}/recordings';
      final Directory directory = Directory(recordingDir);

      if (await directory.exists()) {
        // Delete files older than 24 hours
        final cutoffDate = DateTime.now().subtract(const Duration(hours: 24));

        await for (final FileSystemEntity file in directory.list()) {
          if (file is File) {
            final FileStat stat = await file.stat();
            if (stat.modified.isBefore(cutoffDate)) {
              await file.delete();
            }
          }
        }
      }
    } catch (e) {
      print('Error cleaning up recordings: $e');
    }
  }

  /// Gets the duration of an audio file without playing it
  @override
  Future<Duration?> getDuration(String path) async {
    if (!_isPlayerInitialized) {
      await init();
    }

    // Return cached duration if available
    if (_audioDurations.containsKey(path)) {
      _durationController.add({path: _audioDurations[path]!});
      return _audioDurations[path];
    }

    try {
      // Create a temporary player for duration check
      final tempPlayer = FlutterSoundPlayer();
      await tempPlayer.openPlayer();

      Duration? duration = await tempPlayer.startPlayer(
        fromURI: path,
        whenFinished: () async {
          await tempPlayer.stopPlayer();
        },
      );

      await tempPlayer.stopPlayer();
      await tempPlayer.closePlayer();

      if (duration != null && duration.inMilliseconds > 0) {
        _audioDurations[path] = duration;
        _durationController.add({path: duration});
      }

      return duration;
    } catch (e) {
      print('Error getting audio duration: $e');
      return null;
    }
  }

  @override
  Stream<LMChatAudioState> get audioStateStream => _audioStateController.stream;
}



================================================
File: lib/packages/core/lib/src/utils/media/media_handler.dart
================================================
import 'dart:io';
import 'dart:ui' as ui;

import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:giphy_get/giphy_get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/attachment/attachment_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/utils/credentials/giphy.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// A class to manage all media picking, and accessing
///
/// Gives access to functions that handles media picking natively
class LMChatMediaHandler {
  static final LMChatMediaHandler _instance = LMChatMediaHandler._internal();

  LMChatMediaHandler._internal();

  /// Returns the singleton instance of [LMChatMediaHandler].
  ///
  /// This getter provides access to the singleton instance of [LMChatMediaHandler],
  /// which is used to manage media picking and accessing.
  ///
  /// Returns a [LMChatMediaHandler] object.
  static LMChatMediaHandler get instance => _instance;

  /// List of media items that have been picked/selected
  ///
  /// This list stores [LMChatMediaModel] objects representing images, videos,
  /// documents or GIFs that have been selected by the user
  final List<LMChatMediaModel> pickedMedia = [];

  /// Adds one or more media items to the pickedMedia list
  ///
  /// [media] can be a single LMChatMediaModel or a List<LMChatMediaModel>
  void addPickedMedia(dynamic media) {
    if (media is LMChatMediaModel) {
      pickedMedia.add(media);
    } else if (media is List<LMChatMediaModel>) {
      pickedMedia.addAll(media);
    } else if (media is LMChatAttachmentViewData) {
      pickedMedia.add(media.toMediaModel());
    } else if (media is List<LMChatAttachmentViewData>) {
      pickedMedia.addAll(media.map((e) => e.toMediaModel()).toList());
    } else {
      throw Exception('Incorrect format for adding media');
    }
  }

  /// Clears all items from the pickedMedia list
  void clearPickedMedia() {
    pickedMedia.clear();
  }

  /// Picks multiple video files from the device storage
  ///
  /// [currentMediaLength] is the current number of media items already selected
  /// Returns an [LMResponse] containing a list of [LMChatMediaModel] for videos
  /// Enforces a size limit of 100MB per video file
  Future<LMResponse<List<LMChatMediaModel>>> pickVideos(
      {int mediaCount = 0}) async {
    try {
      List<LMChatMediaModel> videoFiles = [];
      final FilePickerResult? pickedFiles = await FilePicker.platform.pickFiles(
        allowMultiple: true,
        type: FileType.video,
      );

      if (pickedFiles == null || pickedFiles.files.isEmpty) {
        return LMResponse(success: true);
      }

      const double sizeLimit = 100;
      if (mediaCount + pickedMedia.length + pickedFiles.files.length > 10) {
        return LMResponse(
            success: false,
            errorMessage:
                'A total of 10 attachments can be added to a message');
      }
      for (PlatformFile pFile in pickedFiles.files) {
        double fileSize = getFileSizeInDouble(pFile.size);

        if (fileSize > sizeLimit) {
          return LMResponse(
              success: false,
              errorMessage:
                  'Max file size allowed: ${sizeLimit.toStringAsFixed(2)}MB');
        } else {
          LMChatMediaModel videoFile;
          if (kIsWeb) {
            videoFile = LMChatMediaModel(
              mediaType: LMChatMediaType.video,
              mediaFile: File(pFile.path!),
              size: fileSize.toInt(),
              duration: 10,
              meta: {
                'file_name': pFile.name,
              },
            );
          } else {
            videoFile = LMChatMediaModel(
              mediaType: LMChatMediaType.video,
              mediaFile: File(pFile.path!),
              size: fileSize.toInt(),
              duration: 10,
              meta: {
                'file_name': pFile.name,
              },
            );
          }
          videoFiles.add(videoFile);
          addPickedMedia(videoFile);
        }
        return LMResponse(success: true, data: videoFiles);
      }
      return LMResponse(success: true);
    } on Exception catch (err) {
      return LMResponse(
        success: false,
        errorMessage: 'An error occurred\n${err.toString()}',
      );
    }
  }

  /// Picks a single image file from the device storage
  ///
  /// Returns an [LMResponse] containing an [LMChatMediaModel] for the selected image
  /// Enforces a size limit of 5MB for the image file
  Future<LMResponse<LMChatMediaModel>> pickSingleImage() async {
    final XFile? image =
        await ImagePicker().pickImage(source: ImageSource.camera);
    const double sizeLimit = 5;

    if (image == null) {
      return LMResponse(
        success: false,
        errorMessage: 'No image selected.',
      );
    }

    final File imageFile = File(image.path);
    final int fileSizeInBytes = await imageFile.length();
    final ui.Image decodedImage =
        await decodeImageFromList(await imageFile.readAsBytes());
    final double fileSizeInMB = fileSizeInBytes / (1024 * 1024);

    if (fileSizeInMB > sizeLimit) {
      return LMResponse(
        success: false,
        errorMessage:
            'Max file size allowed: ${sizeLimit.toStringAsFixed(2)}MB',
      );
    }

    LMChatMediaModel mediaFile = LMChatMediaModel(
        mediaType: LMChatMediaType.image,
        height: decodedImage.height,
        width: decodedImage.width,
        mediaFile: File(image.path),
        size: fileSizeInBytes ~/ 1024,
        meta: {
          'file_name': image.name,
        });

    addPickedMedia(mediaFile);
    return LMResponse(success: true, data: mediaFile);
  }

  /// Picks multiple image files from the device storage
  ///
  /// [mediaCount] is the current number of media items already selected
  /// Returns an [LMResponse] containing a list of [LMChatMediaModel] for images
  /// Enforces a size limit of 5MB per image file and a maximum of 10 total attachments
  Future<LMResponse<List<LMChatMediaModel>>> pickImages(
      {int mediaCount = 0}) async {
    final FilePickerResult? list = await FilePicker.platform.pickFiles(
      allowMultiple: true,
      type: FileType.image,
      compressionQuality: 0,
    );
    const double sizeLimit = 5;

    if (list != null && list.files.isNotEmpty) {
      if (mediaCount + pickedMedia.length + list.files.length > 10) {
        return LMResponse(
            success: false,
            errorMessage:
                'A total of 10 attachments can be added to a message');
      }
      for (PlatformFile image in list.files) {
        int fileBytes = image.size;
        double fileSize = getFileSizeInDouble(fileBytes);
        if (fileSize > sizeLimit) {
          return LMResponse(
            success: false,
            errorMessage:
                'Max file size allowed: ${sizeLimit.toStringAsFixed(2)}MB',
          );
        }
      }

      List<LMChatMediaModel> attachedImages;

      attachedImages = list.files.map((e) {
        return LMChatMediaModel(
            mediaType: LMChatMediaType.image,
            mediaFile: File(e.path!),
            meta: {
              'file_name': e.name,
            });
      }).toList();

      addPickedMedia(attachedImages);
      return LMResponse(success: true, data: attachedImages);
    } else {
      return LMResponse(success: true);
    }
  }

  /// Picks media files from the device storage
  ///
  /// [mediaCount] is the current number of media items already selected
  /// Returns an [LMResponse] containing a list of [LMChatMediaModel] for the selected media
  /// Enforces a maximum of 10 total attachments
  Future<LMResponse<List<LMChatMediaModel>>> pickMedia(
      {int mediaCount = 10}) async {
    final FilePickerResult? list = await FilePicker.platform.pickFiles(
      allowMultiple: mediaCount == 1 ? false : true,
      type: mediaCount == 1 ? FileType.image : FileType.media,
    );
    final pickedFiles = list?.files;

    List<LMChatMediaModel> attachedMedia = [];
    if (pickedFiles != null && pickedFiles.isNotEmpty) {
      if (pickedFiles.length > 10) {
        return LMResponse(
            success: false,
            errorMessage:
                'A total of 10 attachments can be added to a message');
      }
      for (PlatformFile file in pickedFiles) {
        if (checkFileType(file)) {
          // image case
          const double sizeLimit = 5;
          int fileBytes = file.size;
          double fileSize = getFileSizeInDouble(fileBytes);
          if (fileSize > sizeLimit) {
            return LMResponse(
              success: false,
              errorMessage:
                  'Max file size allowed: ${sizeLimit.toStringAsFixed(2)}MB',
            );
          }
          attachedMedia.add(
            LMChatMediaModel(
              mediaType: LMChatMediaType.image,
              mediaFile: File(file.path!),
              meta: {
                'file_name': file.name,
              },
            ),
          );
        } else {
          // video case
          const double sizeLimit = 100;
          int fileBytes = file.size;
          double fileSize = getFileSizeInDouble(fileBytes);
          if (fileSize > sizeLimit) {
            return LMResponse(
              success: false,
              errorMessage:
                  'Max file size allowed: ${sizeLimit.toStringAsFixed(2)}MB',
            );
          }
          attachedMedia.add(
            LMChatMediaModel(
              mediaType: LMChatMediaType.video,
              mediaFile: File(file.path!),
              meta: {
                'file_name': file.name,
              },
            ),
          );
        }
      }

      addPickedMedia(attachedMedia);
      return LMResponse(success: true, data: attachedMedia);
    } else {
      return LMResponse(success: true);
    }
  }

  /// Picks multiple document files (PDFs) from the device storage
  ///
  /// [currentMediaLength] is the current number of media items already selected
  /// Returns an [LMResponse] containing a list of [LMChatMediaModel] for documents
  /// Enforces a size limit of 100MB per document file
  Future<LMResponse<List<LMChatMediaModel>>> pickDocuments(
      {int mediaCount = 0}) async {
    try {
      final pickedFiles = await FilePicker.platform.pickFiles(
        allowMultiple: true,
        type: FileType.custom,
        dialogTitle: 'Select files',
        allowedExtensions: [
          'pdf',
        ],
      );
      if (pickedFiles != null) {
        for (var pickedFile in pickedFiles.files) {
          final size = getFileSizeInDouble(pickedFile.size);
          if (size > 100) {
            return LMResponse(
                success: false,
                errorMessage: 'File size should be smaller than 100MB');
          } else {
            LMChatMediaModel documentFile;
            documentFile = LMChatMediaModel(
                mediaType: LMChatMediaType.document,
                mediaFile: File(pickedFile.path!),
                size: pickedFile.size,
                meta: {
                  'file_name': pickedFile.name,
                  'size': pickedFile.size,
                });

            addPickedMedia(documentFile);
          }
        }

        return LMResponse(success: true, data: pickedMedia);
      } else {
        return LMResponse(success: true);
      }
    } on Exception catch (err) {
      return LMResponse(
        success: false,
        errorMessage: 'An error occurred\n${err.toString()}',
      );
    }
  }

  /// A constant list of file extensions that are considered as photo/image files
  static const List<String> photoExtentions = [
    'jpg',
    'jpeg',
    'png',
    'gif',
    'webp'
  ];

  /// Calculates and returns the file size in megabytes (MB) from bytes
  ///
  /// [bytes] The size in bytes to convert
  /// Returns the size as a double representing megabytes
  double getFileSizeInDouble(int bytes) {
    return bytes / (1024 * 1024);
  }

  /// Checks if the given file is an image based on its extension
  ///
  /// [file] The PlatformFile to check
  /// Returns true if the file extension matches known image formats
  bool checkFileType(PlatformFile file) {
    return photoExtentions.contains(file.extension);
  }

  /// Picks a GIF using the GIPHY picker interface
  ///
  /// [context] The BuildContext required to show the GIPHY picker
  /// Returns an [LMResponse] containing the selected GIF as [LMChatMediaModel]
  Future<LMResponse<LMChatMediaModel>> pickGIF(BuildContext context) async {
    try {
      GiphyGif? gif = await GiphyGet.getGif(
        context: context, //Required
        apiKey: LMChatGiphyCredentials.apiKey, //Required.
        lang: GiphyLanguage.english, //Optional - Language for query.
        randomID: "lm-gif", // Optional - An ID/proxy for a specific user.
        tabColor:
            LMChatTheme.theme.primaryColor, // Optional- default accent color.
        debounceTimeInMilliseconds: 350,
      );

      if (gif == null) {
        return LMResponse.error(errorMessage: "No GIF picked up");
      }

      LMChatMediaModel pickedGif = LMChatMediaModel(
          mediaType: LMChatMediaType.gif,
          mediaUrl: gif.images?.original?.url,
          height: int.tryParse(gif.images?.fixedHeight?.height ?? "0"),
          width: int.tryParse(gif.images?.fixedHeight?.width ?? "0"),
          meta: {
            "title": gif.title ?? "GIF from GIPHY",
            "url": gif.url,
          });

      addPickedMedia(pickedGif);
      return LMResponse(success: true, data: pickedGif);
    } catch (e) {
      debugPrint(e.toString());
      return LMResponse.error(errorMessage: "An error in picking up GIF");
    }
  }
}



================================================
File: lib/packages/core/lib/src/utils/media/permission_handler.dart
================================================
import 'dart:io';

import 'package:device_info_plus/device_info_plus.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:permission_handler/permission_handler.dart';

/// Media types:
/// 1 - Photos
/// 2 - Videos
/// 3 - Microphone/Audio
Future<bool> handlePermissions(int mediaType) async {
  if (Platform.isAndroid) {
    DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();
    AndroidDeviceInfo androidInfo = await deviceInfo.androidInfo;

    if (androidInfo.version.sdkInt >= 33) {
      return await _handleAndroidPermissions(mediaType);
    } else {
      return await _handleStoragePermission(mediaType);
    }
  } else if (Platform.isIOS) {
    return await _handleIOSPermissions(mediaType);
  } else {
    return true;
  }
}

Future<bool> _handleAndroidPermissions(int mediaType) async {
  Permission permission;
  switch (mediaType) {
    case 1:
      permission = Permission.photos;
      break;
    case 2:
      permission = Permission.videos;
      break;
    case 3:
      permission = Permission.microphone;
      break;
    default:
      permission = Permission.storage;
  }
  return await _requestPermission(permission);
}

Future<bool> _handleStoragePermission(int mediaType) async {
  if (mediaType == 3) {
    return await _requestPermission(Permission.microphone);
  }
  return await _requestPermission(Permission.storage);
}

Future<bool> _handleIOSPermissions(int mediaType) async {
  Permission permission;
  switch (mediaType) {
    case 1:
      permission = Permission.photos;
      break;
    case 2:
      permission = Permission.videos;
      break;
    case 3:
      permission = Permission.microphone;
      break;
    default:
      permission = Permission.storage;
  }
  return await _requestPermission(permission);
}

Future<bool> _requestPermission(Permission permission) async {
  PermissionStatus permissionStatus = await permission.status;
  if (permissionStatus == PermissionStatus.granted) {
    return true;
  } else if (permissionStatus == PermissionStatus.denied) {
    permissionStatus = await permission.request();
    return _handlePermissionResponse(permissionStatus);
  }
  return false;
}

bool _handlePermissionResponse(PermissionStatus status) {
  if (status == PermissionStatus.permanentlyDenied) {
    toast(
      'Permissions denied, change app settings',
      duration: Toast.LENGTH_LONG,
    );
    openAppSettings();
    return false;
  }
  return status == PermissionStatus.granted;
}



================================================
File: lib/packages/core/lib/src/utils/member_rights/member_rights.dart
================================================
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_member_right_util}
/// A utility class to check the rights of a member.
/// {@endtemplate}
class LMChatMemberRightUtil {
  /// check if user has read permissions
  static bool checkRespondRights(MemberStateResponse? memberStateResponse) {
    if (memberStateResponse == null ||
        memberStateResponse.memberRights == null) {
      return true;
    }
    MemberRight? respondRights = memberStateResponse.memberRights
        ?.firstWhere((element) => element.state == 3);
    if (respondRights == null) {
      return true;
    } else {
      return respondRights.isSelected;
    }
  }

  /// check if user has delete permissions
  /// [conversationViewData] is the conversation for which delete permissions are to be checked.
  static bool checkDeletePermissions(
      LMChatConversationViewData conversationViewData) {
    final MemberStateResponse? memberRight =
        LMChatLocalPreference.instance.getMemberRights();
    // check if user is cm state = 4 and owner state = 1
    if (memberRight != null &&
        memberRight.member?.state == 1 &&
        conversationViewData.deletedByUserId == null) {
      return true;
    } else {
      // check if conversation is created by user
      final currentUser = LMChatLocalPreference.instance.getUser();
      if (currentUser.id == conversationViewData.memberId &&
          conversationViewData.deletedByUserId == null) {
        return true;
      }
    }
    return false;
  }

  /// check if user has edit permissions
  /// [conversationViewData] is the conversation for which edit permissions are to be checked.
  static bool checkEditPermissions(
      LMChatConversationViewData conversationViewData) {
    final currentUser = LMChatLocalPreference.instance.getUser();
    return currentUser.id == conversationViewData.memberId &&
        conversationViewData.state != 10;
  }

  static bool isReportAllowed(LMChatConversationViewData conversationViewData) {
    final currentUser = LMChatLocalPreference.instance.getUser();
    final memberState = LMChatLocalPreference.instance.getMemberRights();
    if (currentUser.id == conversationViewData.memberId ||
        memberState?.state == 1) {
      return false;
    }
    return true;
  }
}



================================================
File: lib/packages/core/lib/src/utils/notifications/notification_handler.dart
================================================
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
// import 'package:likeminds_chat_flutter_core/src/utils/constants/enums.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/views/views.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:overlay_support/overlay_support.dart';

/// This class handles all the notification related logic
/// It registers the device for notifications in the SDK
/// It handles the notification when it is received and shows it
/// It routes the notification to the appropriate screen
/// Since this is a singleton class, it is initialized on the client side
class LMChatNotificationHandler {
  String? deviceId;
  String? fcmToken;
  int? memberId;

  static LMChatNotificationHandler? _instance;
  static LMChatNotificationHandler get instance =>
      _instance ??= LMChatNotificationHandler._();

  LMChatNotificationHandler._();

  /// Initialize the notification handler
  /// This is called from the client side
  /// It initializes the [fcmToken] and the [deviceId]
  void init({
    required String deviceId,
    required String fcmToken,
  }) {
    this.deviceId = deviceId;
    this.fcmToken = fcmToken;
  }

  /// Register the device for notifications
  /// This is called from the client side
  /// It calls the [registerDevice] method of the [LikeMindsService]
  /// It initializes the [memberId] which is used to route the notification
  /// If the registration is successful, it prints success message
  void registerDevice(int memberId) async {
    if (fcmToken == null || deviceId == null) {
      return;
    }
    RegisterDeviceRequest request = RegisterDeviceRequest(
      token: fcmToken!,
      memberId: memberId,
      deviceId: deviceId!,
    );
    this.memberId = memberId;
    final response = await LMChatCore.client.registerDevice(request);
    if (response.success) {
      debugPrint("Device registered for notifications successfully");
    } else {
      throw Exception("Device registration for notification failed");
    }
  }

  Future<void> handleBackgroundNotification(RemoteMessage message) {
    return Future.value();
  }

  /// Handle the notification when it is received
  /// This is called from the client side when notification [message] is received
  /// and is needed to be handled, i.e. shown and routed to the appropriate screen
  Future<void> handleNotification(RemoteMessage message, bool show,
      GlobalKey<NavigatorState> rootNavigatorKey) async {
    debugPrint("--- Notification received in LEVEL 2 ---");
    if (message.data.containsKey('category') &&
        message.data["category"].contains("Chat")) {
      // First, check if the message contains a data payload.
      if (show && message.data.isNotEmpty) {
        //Add LM check for showing LM notifications
        showNotification(message, rootNavigatorKey);
      } else if (message.data.isNotEmpty) {
        // Second, extract the notification data and routes to the appropriate screen
        routeNotification(message, rootNavigatorKey);
      }
    }
  }

  void routeNotification(
    RemoteMessage message,
    GlobalKey<NavigatorState> rootNavigatorKey,
  ) async {
    Map<String, String> queryParams = {};
    String host = "";

    // Only notifications with data payload are handled
    if (message.data.isNotEmpty) {
      final Map<String, dynamic> notifData = message.data;
      final String category = notifData["category"];
      final String route = notifData["route"]!;

      // If the notification is a feed notification, extract the route params
      if (category.toString().toLowerCase() == "chat room") {
        final Uri routeUri = Uri.parse(route);
        final Map<String, String> routeParams =
            routeUri.hasQuery ? routeUri.queryParameters : {};
        final String routeHost = routeUri.host;
        host = routeHost;
        debugPrint("The route host is $routeHost");
        queryParams.addAll(routeParams);
        queryParams.forEach((key, value) {
          debugPrint("$key: $value");
        });
      }
    }

    if (host == "collabcard") {
      await LMChatCore.instance.showChatWithoutApiKey();

      rootNavigatorKey.currentState?.push(MaterialPageRoute(
        builder: (context) => LMChatroomScreen(
          chatroomId: int.parse(
            queryParams["collabcard_id"]!,
          ),
        ),
      ));
    } else if (host == 'chatroom_detail') {
      await LMChatCore.instance.showChatWithoutApiKey();

      rootNavigatorKey.currentState?.push(MaterialPageRoute(
        builder: (context) => LMChatroomScreen(
          chatroomId: int.parse(
            queryParams["chatroom_id"]!,
          ),
        ),
      ));
    }
  }

  /// Show a simple notification using overlay package
  /// This is a dismissable notification shown on the top of the screen
  /// It is shown when the notification is received in foreground
  void showNotification(
    RemoteMessage message,
    GlobalKey<NavigatorState> rootNavigatorKey,
  ) {
    if (message.data.isNotEmpty) {
      showSimpleNotification(
        GestureDetector(
          onTap: () {
            routeNotification(
              message,
              rootNavigatorKey,
            );
          },
          behavior: HitTestBehavior.opaque,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.start,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              LMChatText(
                message.data["title"],
                style: LMChatTextStyle(
                  textStyle: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                    color: LMChatTheme.theme.onContainer,
                  ),
                ),
              ),
              const SizedBox(height: 4),
              LMChatText(
                message.data["sub_title"],
                style: LMChatTextStyle(
                  maxLines: 1,
                  textStyle: TextStyle(
                    fontSize: 12,
                    color: LMChatTheme.theme.onContainer,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ),
            ],
          ),
        ),
        background: LMChatTheme.theme.container,
        duration: const Duration(seconds: 3),
        leading: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.notifications,
          style: LMChatIconStyle(
            color: LMChatTheme.theme.primaryColor,
            size: 28,
          ),
        ),
        trailing: const LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.swipe_right_outlined,
          style: LMChatIconStyle(
            color: LMChatDefaultTheme.greyColor,
            size: 28,
          ),
        ),
        position: NotificationPosition.top,
        slideDismissDirection: DismissDirection.horizontal,
      );
    }
  }
}



================================================
File: lib/packages/core/lib/src/utils/preferences/preferences.dart
================================================
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// [LMChatLocalPreference] is responsible for handling the local preferences of the chat.
/// It has a singleton instance [instance] which is used to access the preferences.
/// It has functions to store and fetch the user data, member rights, community data, cache data and clear the local data.
class LMChatLocalPreference {
  // Singleton instance of LMChatPreference class
  static LMChatLocalPreference? _instance;

  /// Singleton instance of [LMChatLocalPreference]
  static LMChatLocalPreference get instance =>
      _instance ??= LMChatLocalPreference._();

  LMChatLocalPreference._();

  /// This function is used to store the user data in the local preferences.
  Future<void> storeUserData(User user) async {
    await LMChatCore.instance.lmChatClient.insertOrUpdateLoggedInUser(user);
  }

  /// This function is used to fetch the user data from the local preferences.
  User getUser() {
    final User? user = LMChatCore.instance.lmChatClient.getLoggedInUser().data;
    return user ?? (throw Exception('User not found'));
  }

  /// This function is used to clear the user data from the local preferences.
  Future<void> clearUserData() async {
    await LMChatCore.instance.lmChatClient.deleteLoggedInUser();
  }

  /// This function is used to store the member rights in the local preferences.
  Future<void> storeMemberRights(MemberStateResponse memberState) async {
    await LMChatCore.instance.lmChatClient
        .insertOrUpdateLoggedInMemberState(memberState);
  }

  /// This function is used to fetch the member rights from the local preferences.
  MemberStateResponse? getMemberRights() {
    return LMChatCore.instance.lmChatClient.getLoggedInMemberState().data;
  }

  /// This function is used to fetch the member right of a particular state from the local preferences.
  bool fetchMemberRight(int id) {
    final memberStateResponse = getMemberRights();
    if (memberStateResponse == null) {
      return false;
    }
    final memberRights = memberStateResponse.memberRights;
    if (memberRights == null) {
      return false;
    } else {
      final right = memberRights.where((element) => element.state == id);
      if (right.isEmpty) {
        return false;
      } else {
        return right.first.isSelected;
      }
    }
  }

  /// This function is used to clear the member rights from the local preferences.
  Future<void> clearMemberRights() async {
    await LMChatCore.instance.lmChatClient.deleteLoggedInMemberState();
  }

  /// This function is used to store the community data in the local preferences.
  Future<void> storeCommunityData(Community community) async {
    await clearCommunityData();
    await LMChatCore.instance.lmChatClient.insertOrUpdateCommunity(community);
  }

  /// This function is used to fetch the community data from the local preferences.
  Community? getCommunityData() {
    return LMChatCore.instance.lmChatClient.getCommunity().data;
  }

  /// This function is used to clear the community data from the local preferences.
  Future<void> clearCommunityData() async {
    await LMChatCore.instance.lmChatClient.deleteCommunity();
  }

  /// This function is used to store the chatroom id with AI chatbot in the local preferences.
  Future<void> storeChatroomIdWithAIChatbot(int chatroomId) async {
    await LMChatCore.instance.lmChatClient
        .setChatroomIdWithAIChatbot(chatroomId);
  }

  /// This function is used to fetch the chatroom id with AI chatbot from the local preferences.
  int? getChatroomIdWithAIChatbot() {
    return LMChatCore.instance.lmChatClient.getChatroomIdWithAIChatbot().data;
  }

  /// This function is used to store the cache data in the local preferences.
  Future<LMResponse> storeCache(LMChatCache cache) {
    return LMChatCore.client.insertOrUpdateCache(cache);
  }

  /// This function is used to fetch the cache data from the local preferences.
  LMChatCache? fetchCache(String key) {
    LMResponse response = LMChatCore.client.getCache(key);

    if (response.success) {
      return response.data!;
    } else {
      return null;
    }
  }

  /// This function is used to delete the cache data from the local preferences.
  Future<LMResponse> deleteCache(String key) {
    return LMChatCore.client.deleteCache(key);
  }

  /// This function is used to clear the cache data from the local preferences.
  Future<LMResponse> clearCache() {
    return LMChatCore.client.clearCache();
  }

  /// This function is used to store the community configuration in the local preferences.
  Future<LMResponse> storeCommunityConfiguration(
      CommunityConfigurations communityConfiguration) async {
    return await LMChatCore.client
        .insertOrUpdateCommunityConfigurationsDB([communityConfiguration]);
  }

  /// This function is used to fetch the community configuration from the local preferences.
  LMResponse<CommunityConfigurations>? fetchCommunityConfiguration(
      String type) {
    LMResponse<CommunityConfigurations> response =
        LMChatCore.client.getCommunityConfigurationDB(type);

    return response;
  }

  /// This function is used to clear the community configuration from the local preferences.
  Future<LMResponse> clearCommunityConfiguration() {
    return LMChatCore.client.clearCommunityConfigurationDB();
  }

  /// This function is used to clear the local data from the local preferences.
  Future<void> clearLocalData() async {
    await clearUserData();
    await clearMemberRights();
    await clearCommunityData();
    await clearCache();
    await clearCommunityConfiguration();
  }
}



================================================
File: lib/packages/core/lib/src/utils/realtime/realtime.dart
================================================
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_flutter_core/src/utils/preferences/preferences.dart';

class LMChatRealtime {
  static LMChatRealtime? _instance;
  static LMChatRealtime get instance =>
      _instance ??= LMChatRealtime._internal();

  late final FirebaseDatabase database;
  final int _communityId =
      LMChatLocalPreference.instance.getCommunityData()!.id;
  int? _chatroomId;

  LMChatRealtime._internal() {
    debugPrint('LMRealtime initialized');
    FirebaseApp app = Firebase.app('likeminds_chat');
    database = FirebaseDatabase.instanceFor(app: app);
    debugPrint("Database is ${database.toString()}");
  }

  set chatroomId(int chatroomId) {
    debugPrint("Chatroom ID set to $chatroomId");
    _chatroomId = chatroomId;
  }

  DatabaseReference homeFeed() {
    return database.ref().child("community").child(_communityId.toString()).ref;
  }

  DatabaseReference chatroom() {
    return database.ref().child("collabcards").child("$_chatroomId").ref;
  }
}



================================================
File: lib/packages/core/lib/src/views/views.dart
================================================
export 'chatroom/chatroom.dart';
export 'home/home.dart';
export 'explore/explore.dart';
export 'participants/participants.dart';
export 'report/report.dart';
export 'media/media_forwarding.dart';
export 'media/media_preview.dart';
export 'poll/create_poll.dart';
export 'poll/poll_result.dart';



================================================
File: lib/packages/core/lib/src/views/chatbot/init_chatbot.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:lottie/lottie.dart';

/// A screen that handles the initialization of an AI chatbot
/// and navigates to the appropriate chatroom once setup is complete.
class LMChatAIBotInitiationScreen extends StatefulWidget {
  /// Custom Lottie animation JSON asset path to show during initialization
  final String? animationToShow;

  /// Text to display during initialization
  final LMChatTextBuilder? previewText;

  /// Creates an AI chatbot initialization screen with optional custom animation and preview text
  const LMChatAIBotInitiationScreen({
    Key? key,
    this.animationToShow,
    this.previewText,
  }) : super(key: key);

  @override
  State<LMChatAIBotInitiationScreen> createState() =>
      _LMChatAIBotInitiationScreenState();
}

class _LMChatAIBotInitiationScreenState
    extends State<LMChatAIBotInitiationScreen> with TickerProviderStateMixin {
  final LMChatClient _chatClient = LMChatCore.client;
  late AnimationController _animationController;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 1),
    );
    _initializeChatbot();
  }

  Future<void> _initializeChatbot() async {
    try {
      final response = await _chatClient.getAIChatbots(
        (GetAIChatbotsRequestBuilder()
              ..page(1)
              ..pageSize(10))
            .build(),
      );

      if (!response.success) {
        _handleError(response.errorMessage);
        return;
      }

      if (response.data?.users.isEmpty ?? true) {
        _handleError('No chatbots available');
        return;
      }

      final chatbot = response.data!.users[0];
      final chatbotUUID = chatbot.sdkClientInfo!.uuid;

      final dmStatusResponse = await _chatClient.checkDMStatus(
        (CheckDMStatusRequestBuilder()
              ..reqFrom('member_profile')
              ..uuid(chatbotUUID!))
            .build(),
      );

      if (!dmStatusResponse.success) {
        _handleError(dmStatusResponse.errorMessage);
        return;
      }

      final cta = dmStatusResponse.data?.cta;
      final ctaURL = Uri.parse(cta ?? '');
      final chatroomId = ctaURL.queryParameters['chatroom_id'];

      if (chatroomId != null) {
        await _handleExistingChatroom(int.parse(chatroomId));
      } else {
        await _createNewChatroom(chatbotUUID);
      }
    } catch (e) {
      _handleError('An error occurred: $e');
    }
  }

  Future<void> _handleExistingChatroom(int chatroomId) async {
    await _saveChatroomId(chatroomId);
    _navigateToChatroom(chatroomId);
  }

  Future<void> _createNewChatroom(String chatbotUUID) async {
    final response = await _chatClient.createDMChatroom(
      (CreateDMChatroomRequestBuilder()..uuid(chatbotUUID)).build(),
    );

    if (!response.success) {
      _handleError(response.errorMessage);
      return;
    }

    final chatroomId = response.data?.chatRoom?.id;

    if (chatroomId != null) {
      await _saveChatroomId(chatroomId);
      _navigateToChatroom(chatroomId);
    } else {
      _handleError('Failed to create chatroom');
    }
  }

  Future<void> _saveChatroomId(int chatroomId) async {
    await LMChatLocalPreference.instance
        .storeChatroomIdWithAIChatbot(chatroomId);
  }

  void _navigateToChatroom(int chatroomId) {
    Navigator.pushReplacement(
      context,
      MaterialPageRoute(
        builder: (context) => LMChatroomScreen(chatroomId: chatroomId),
      ),
    );
  }

  void _handleError(String? message) {
    _stopAnimation();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message ?? 'An error occurred')),
    );
    Navigator.pop(context);
  }

  void _stopAnimation() {
    _animationController.stop();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: LMChatTheme.theme.container,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Expanded(
              child: Lottie.network(
                widget.animationToShow ?? aiChatbotLoadingAnimation,
              ),
            ),
            widget.previewText?.call(
                  context,
                  const LMChatText(
                    "Setting up AI Chatbot...",
                  ),
                ) ??
                const LMChatText(
                  "Setting up AI Chatbot...",
                ),
            const SizedBox(height: 28),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
}



================================================
File: lib/packages/core/lib/src/views/chatroom/chatroom.dart
================================================
import 'dart:io';

import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/blocs.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/observer.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/chatroom/chatroom_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/audio_handler.dart';
import 'package:likeminds_chat_flutter_core/src/utils/member_rights/member_rights.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';
import 'package:likeminds_chat_flutter_core/src/utils/conversation/conversation_action_helper.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/config.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:super_sliver_list/super_sliver_list.dart';

/// {@template chatroom_screen}
/// Chatroom screen is the main screen where the user can chat with other users.
/// It has a chatroom list, chatroom bar, and chatroom menu.
///  {@endtemplate}
class LMChatroomScreen extends StatefulWidget {
  static const routeName = '/chatroom';

  /// [chatroomId] is the id of the chatroom.
  final int chatroomId;

  /// {@macro chatroom_screen}
  const LMChatroomScreen({
    super.key,
    required this.chatroomId,
  });

  @override
  State<LMChatroomScreen> createState() => _LMChatroomScreenState();
}

class _LMChatroomScreenState extends State<LMChatroomScreen> {
  late LMChatroomBloc _chatroomBloc;
  late LMChatroomActionBloc _chatroomActionBloc;
  late LMChatConversationBloc _conversationBloc;
  late LMChatConversationActionBloc _convActionBloc;
  late LMChatConversationActionHelper _conversationActionHelper;

  late ChatRoom chatroom;
  late User currentUser;
  List<ChatroomAction> actions = [];
  Conversation? localTopic;

  int lastConversationId = 0;
  bool showChatTopic = true;
  bool showScrollButton = false;

  ValueNotifier<bool> rebuildConversationList = ValueNotifier(false);
  ValueNotifier<bool> rebuildChatBar = ValueNotifier(false);
  ValueNotifier<bool> rebuildChatTopic = ValueNotifier(true);
  ValueNotifier<bool> rebuildAppBar = ValueNotifier(false);
  ValueNotifier<bool> rebuildFloatingButton = ValueNotifier(false);

  final ScrollController scrollController = ScrollController();
  final ListController listController = ListController();
  late LMDualSidePaginationController<LMChatConversationViewData>
      pagedListController = LMDualSidePaginationController(
    listController: listController,
    scrollController: scrollController,
  );

  final List<int> _selectedIds = <int>[];
  final LMChatroomBuilderDelegate _screenBuilder =
      LMChatCore.config.chatRoomConfig.builder;
  final LMChatroomSetting _chatroomSetting =
      LMChatCore.config.chatRoomConfig.setting;
  final CustomPopupMenuController _menuController = CustomPopupMenuController();
  final MemberStateResponse? getMemberState =
      LMChatLocalPreference.instance.getMemberRights();

  bool isAnyMessageSelected() {
    return _selectedIds.isNotEmpty;
  }

  @override
  void initState() {
    super.initState();
    LMChatRealtime.instance.chatroomId = widget.chatroomId;
    Bloc.observer = LMChatBlocObserver();
    currentUser = LMChatLocalPreference.instance.getUser();
    _chatroomBloc = LMChatroomBloc.instance
      ..add(LMChatFetchChatroomEvent(chatroomId: widget.chatroomId));
    _chatroomActionBloc = LMChatroomActionBloc.instance;
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    _conversationActionHelper = LMChatConversationActionHelper(
      selectionType:
          _chatroomSetting.selectionType ?? LMChatSelectionType.appbar,
      selectedIds: _selectedIds,
      onResetSelection: _resetSelection,
      convActionBloc: _convActionBloc,
      chatroomId: widget.chatroomId,
      conversations: pagedListController.itemList,
      chatRequestState: 0, //TODO: update proper chat request state
    );
    scrollController.addListener(() {
      _showScrollToBottomButton();
    });
  }

  @override
  void didUpdateWidget(LMChatroomScreen old) {
    super.didUpdateWidget(old);
    LMChatRealtime.instance.chatroomId = widget.chatroomId;
    Bloc.observer = LMChatBlocObserver();
    currentUser = LMChatLocalPreference.instance.getUser();
    _chatroomBloc = LMChatroomBloc.instance;
    _chatroomActionBloc = LMChatroomActionBloc.instance;
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    scrollController.addListener(() {
      _showScrollToBottomButton();
    });
  }

  @override
  void didChangeDependencies() {
    LMChatRealtime.instance.chatroomId = widget.chatroomId;
    _chatroomBloc = LMChatroomBloc.instance;
    _chatroomActionBloc = LMChatroomActionBloc.instance;
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    ScreenSize.init(context);
    super.didChangeDependencies();
  }

  @override
  void dispose() {
    _chatroomBloc.close();
    _convActionBloc.close();
    _conversationBloc.close();
    _chatroomActionBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return _screenBuilder.scaffold(
      resizeToAvoidBottomInset: true,
      onPopInvoked: (p) {
        _chatroomActionBloc.add(LMChatMarkReadChatroomEvent(
          chatroomId: chatroom.id,
        ));
        if (LMChatCoreAudioHandler.instance.player.isPlaying ||
            LMChatCoreAudioHandler.instance.recorder.isRecording) {
          LMChatCoreAudioHandler.instance.stopAudio();
          LMChatCoreAudioHandler.instance.stopRecording();
        }
      },
      backgroundColor: LMChatTheme.theme.backgroundColor,
      floatingActionButton: ValueListenableBuilder(
        valueListenable: rebuildFloatingButton,
        builder: (context, _, __) {
          return Padding(
            padding: EdgeInsets.only(
              bottom: Platform.isIOS ? 64.0 : 96.0,
              right: Platform.isIOS ? 2 : 4,
            ),
            child: showScrollButton
                ? _screenBuilder.floatingActionButton(_defaultScrollButton())
                : null,
          );
        },
      ),
      body: SafeArea(
        bottom: false,
        child: BlocConsumer<LMChatroomBloc, LMChatroomState>(
          bloc: _chatroomBloc,
          listener: (context, state) {
            if (state is LMChatroomLoadedState) {
              chatroom = state.chatroom;
              lastConversationId = state.lastConversationId;
              _conversationBloc.add(LMChatInitialiseConversationsEvent(
                chatroomId: chatroom.id,
                conversationId: lastConversationId,
              ));
              _chatroomActionBloc.add(LMChatMarkReadChatroomEvent(
                chatroomId: chatroom.id,
              ));
              LMChatAnalyticsBloc.instance.add(
                const LMChatFireAnalyticsEvent(
                  eventName: LMChatAnalyticsKeys.syncComplete,
                  eventProperties: {'sync_complete': true},
                ),
              );
              LMChatAnalyticsBloc.instance.add(
                LMChatFireAnalyticsEvent(
                  eventName: LMChatAnalyticsKeys.chatroomOpened,
                  eventProperties: {
                    'chatroom_id': chatroom.id,
                    'community_id': chatroom.communityId,
                    'chatroom_type': chatroom.type,
                    'source': 'home_feed',
                  },
                ),
              );
              updateChatBotChatroom();
            }
          },
          builder: (chatroomContext, chatroomState) {
            if (chatroomState is LMChatroomLoadedState) {
              chatroom = chatroomState.chatroom;
              actions = chatroomState.actions;
              return Column(
                children: [
                  BlocListener<LMChatConversationActionBloc,
                      LMChatConversationActionState>(
                    bloc: _convActionBloc,
                    listener: (context, state) {
                      if (state is LMChatRefreshBarState) {
                        chatroom = state.chatroom.toChatRoom();
                      }
                    },
                    child: _screenBuilder.appBarBuilder.call(
                      context,
                      chatroom.toChatRoomViewData(),
                      _defaultAppBar(
                        chatroom,
                        chatroomState.participantCount,
                      ),
                      chatroomState.participantCount,
                    ),
                  ),
                  Expanded(
                    child: Listener(
                      behavior: HitTestBehavior.opaque,
                      onPointerDown: (_) {
                        if (FocusScope.of(context).hasFocus) {
                          FocusScope.of(context).unfocus();
                        }
                      },
                      child: ValueListenableBuilder(
                        valueListenable: rebuildConversationList,
                        builder: (context, value, child) {
                          return _chatroomList();
                        },
                      ),
                    ),
                  ),
                  BlocBuilder(
                      bloc: _chatroomActionBloc,
                      builder: (context, state) {
                        if (state is LMChatShowEmojiKeyboardState) {
                          return SafeArea(
                            child: LMChatReactionKeyboard(
                              onEmojiSelected: (reaction) {
                                LMChatAnalyticsBloc.instance.add(
                                  LMChatFireAnalyticsEvent(
                                    eventName:
                                        LMChatAnalyticsKeys.reactionAdded,
                                    eventProperties: {
                                      'reaction': reaction,
                                      'from': 'keyboard',
                                      'message_id': state.conversationId,
                                      'chatroom_id': chatroom.id,
                                    },
                                  ),
                                );
                                _convActionBloc.add(
                                  LMChatPutReaction(
                                    conversationId: state.conversationId,
                                    reaction: reaction,
                                  ),
                                );
                                _chatroomActionBloc.add(
                                  LMChatHideEmojiKeyboardEvent(),
                                );
                              },
                            ),
                          );
                        }
                        return _screenBuilder.chatBarBuilder(
                          context,
                          LMChatroomBar(
                            chatroom: chatroom.toChatRoomViewData(),
                            scrollToBottom: _scrollToBottom,
                            enableTagging: chatroom.type != 10,
                          ),
                        );
                      }),
                  if (isOtherUserAIChatbot(chatroom.toChatRoomViewData()))
                    LMChatText(
                      "AI may make mistakes",
                      style: LMChatTextStyle(
                        padding: const EdgeInsets.only(
                          bottom: 10,
                          top: 6,
                        ),
                        textStyle: TextStyle(
                          color: LMChatTheme.theme.onContainer.withOpacity(0.6),
                        ),
                      ),
                    )
                ],
              );
            }
            return _screenBuilder.loadingPageWidgetBuilder(
              context,
              const LMChatSkeletonChatPage(),
            );
          },
        ),
      ),
    );
  }

  Widget _chatroomList() {
    return chatroom.type != 10
        ? _screenBuilder.conversationList(
            chatroom.id,
            _defaultConvList(),
          )
        : _screenBuilder.dmConversationList(
            chatroom.id,
            _defaultDMConvList(),
          );
  }

  LMChatDMConversationList _defaultDMConvList() {
    return LMChatDMConversationList(
      chatroomId: widget.chatroomId,
      appBarNotifier: rebuildAppBar,
      selectedConversations: _selectedIds,
      isOtherUserAIChatbot: isOtherUserAIChatbot(
        chatroom.toChatRoomViewData(),
      ),
      conversationHelper: _conversationActionHelper,
      paginatedListController: pagedListController,
    );
  }

  LMChatConversationList _defaultConvList() {
    return LMChatConversationList(
      chatroomId: widget.chatroomId,
      appBarNotifier: rebuildAppBar,
      selectedConversations: _selectedIds,
      paginatedListController: pagedListController,
      conversationHelper: _conversationActionHelper,
    );
  }

  LMChatAppBar _defaultAppBar(
    ChatRoom chatroom,
    int participants,
  ) {
    User? chatUser;
    if (chatroom.type! == 10) {
      chatUser = currentUser.id == chatroom.chatroomWithUser!.id
          ? chatroom.member!
          : chatroom.chatroomWithUser!;
    }
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        height: 72,
        gap: 2.6.w,
        backgroundColor: LMChatTheme.theme.container,
        padding: const EdgeInsets.symmetric(horizontal: 18),
      ),
      leading: LMChatButton(
        onTap: () {
          if (_selectedIds.isNotEmpty) {
            _selectedIds.clear();
            rebuildAppBar.value = !rebuildAppBar.value;
            rebuildConversationList.value = !rebuildConversationList.value;
          } else {
            LMChatCoreAudioHandler.instance.stopAudio();
            LMChatCoreAudioHandler.instance.stopRecording();
            Navigator.of(context).pop();
            _chatroomActionBloc.add(
              LMChatMarkReadChatroomEvent(
                chatroomId: widget.chatroomId,
              ),
            );
          }
        },
        style: LMChatButtonStyle(
          height: 28,
          width: 28,
          borderRadius: 6,
          padding: EdgeInsets.zero,
          icon: LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.arrow_back,
            style: LMChatIconStyle(
              color: LMChatTheme.theme.onContainer,
              size: 24,
              boxSize: 28,
            ),
          ),
          backgroundColor: LMChatTheme.theme.container,
        ),
      ),
      banner: ValueListenableBuilder(
        valueListenable: rebuildAppBar,
        builder: (context, _, __) {
          return isAnyMessageSelected()
              ? const SizedBox.shrink()
              : chatroom.type! == 10
                  ? LMChatProfilePicture(
                      imageUrl: chatUser?.imageUrl ?? chatroom.chatroomImageUrl,
                      fallbackText: chatUser?.name ?? chatroom.header,
                      style: LMChatProfilePictureStyle(
                        size: 36,
                        backgroundColor: LMChatTheme.theme.primaryColor,
                      ),
                    )
                  : const SizedBox.shrink();
        },
      ),
      title: ValueListenableBuilder(
        valueListenable: rebuildAppBar,
        builder: (context, _, __) {
          return LMChatText(
            isAnyMessageSelected()
                ? _selectedIds.length.toString()
                : chatUser?.name ?? chatroom.header,
            style: LMChatTextStyle(
              maxLines: 1,
              textStyle: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w500,
                overflow: TextOverflow.ellipsis,
                color: LMChatTheme.theme.onContainer,
              ),
            ),
          );
        },
      ),
      subtitle: chatroom.type != 10
          ? ValueListenableBuilder(
              valueListenable: rebuildAppBar,
              builder: (context, _, __) {
                return isAnyMessageSelected()
                    ? const SizedBox.shrink()
                    : LMChatText(
                        "${participants.toString()} participants",
                        style: const LMChatTextStyle(
                          textStyle: TextStyle(
                            color: LMChatDefaultTheme.greyColor,
                          ),
                        ),
                      );
              },
            )
          : const SizedBox.shrink(),
      trailing: isOtherUserAIChatbot(chatroom.toChatRoomViewData())
          ? []
          : [
              ValueListenableBuilder(
                  valueListenable: rebuildAppBar,
                  builder: (context, _, __) {
                    return (isAnyMessageSelected() &&
                                _chatroomSetting.selectionType ==
                                    LMChatSelectionType.appbar) ||
                            (isAnyMessageSelected() && _selectedIds.length > 1)
                        ? Row(
                            children: _defaultSelectedChatroomMenu(),
                          )
                        : _screenBuilder.chatroomMenu(
                            context,
                            actions,
                            _defaultChatroomMenu(),
                          );
                  }),
            ],
    );
  }

  List<Widget> _defaultSelectedChatroomMenu() {
    final LMChatConversationViewData conversationViewData = pagedListController
        .itemList
        .firstWhere((element) => element.id == _selectedIds.first);
    final bool haveDeletePermission =
        LMChatMemberRightUtil.checkDeletePermissions(conversationViewData) &&
            chatroom.chatRequestState != 2;
    final bool haveEditPermission =
        LMChatMemberRightUtil.checkEditPermissions(conversationViewData) &&
            chatroom.chatRequestState != 2;
    final bool isVoiceNote = conversationViewData.attachments
            ?.any((attachment) => attachment.type == 'voice_note') ??
        false;

    final List<Widget> menuWidgets = [];

    // Reply option
    if (_selectedIds.length == 1 && _isRespondingAllowed()) {
      menuWidgets.addAll(_buildReplyOption(conversationViewData));
    }

    // Copy option - Only show if not a voice note
    if (!isVoiceNote) {
      menuWidgets.addAll(_buildCopyOption(conversationViewData));
    }

    // Edit option - Only show if not a voice note
    if (haveEditPermission && _selectedIds.length == 1 && !isVoiceNote) {
      menuWidgets.addAll(_buildEditOption(conversationViewData));
    }

    // Delete option
    if (haveDeletePermission) {
      menuWidgets.addAll(_buildDeleteOption(conversationViewData));
    }

    // Report option
    if (_selectedIds.length == 1 &&
        LMChatMemberRightUtil.isReportAllowed(conversationViewData) &&
        chatroom.chatRequestState != 2) {
      menuWidgets.addAll(_buildReportOption(conversationViewData));
    }

    return menuWidgets;
  }

  void _resetSelection() {
    _selectedIds.clear();
    rebuildAppBar.value = !rebuildAppBar.value;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  List<Widget> _buildReplyOption(
      LMChatConversationViewData conversationViewData) {
    return [
      const SizedBox(width: 8),
      _screenBuilder.replyButton(
        context,
        conversationViewData,
        LMChatButton(
          onTap: () {
            _conversationActionHelper.onReply(conversationViewData);
          },
          style: LMChatButtonStyle.basic().copyWith(
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.reply,
              style: LMChatIconStyle(
                color: LMChatTheme.theme.primaryColor,
              ),
            ),
          ),
        ),
      ),
    ];
  }

  List<Widget> _buildCopyOption(
      LMChatConversationViewData conversationViewData) {
    return [
      const SizedBox(width: 8),
      _screenBuilder.copyButton(
        context,
        pagedListController.itemList
            .where((c) => _selectedIds.contains(c.id))
            .toList(),
        LMChatButton(
          onTap: () {
            _conversationActionHelper.onCopy(
              pagedListController.itemList
                  .where((c) => _selectedIds.contains(c.id))
                  .toList(),
            );
          },
          style: LMChatButtonStyle.basic().copyWith(
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.copy,
              style: LMChatIconStyle(
                color: LMChatTheme.theme.primaryColor,
              ),
            ),
          ),
        ),
      ),
    ];
  }

  List<Widget> _buildEditOption(
      LMChatConversationViewData conversationViewData) {
    return [
      const SizedBox(width: 8),
      _screenBuilder.editButton(
        context,
        conversationViewData,
        LMChatButton(
          onTap: () {
            _conversationActionHelper.onEdit(conversationViewData);
          },
          style: LMChatButtonStyle.basic().copyWith(
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.edit,
              style: LMChatIconStyle(
                color: LMChatTheme.theme.primaryColor,
              ),
            ),
          ),
        ),
      ),
    ];
  }

  List<Widget> _buildDeleteOption(
      LMChatConversationViewData conversationViewData) {
    return [
      const SizedBox(width: 8),
      _screenBuilder.deleteButton(
        context,
        conversationViewData,
        LMChatButton(
          onTap: () {
            _conversationActionHelper.onDelete(context, [..._selectedIds]);
          },
          style: LMChatButtonStyle.basic().copyWith(
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.delete,
              style: LMChatIconStyle(
                color: LMChatTheme.theme.primaryColor,
              ),
            ),
          ),
        ),
      ),
    ];
  }

  List<Widget> _buildReportOption(
      LMChatConversationViewData conversationViewData) {
    return [
      const SizedBox(width: 8),
      _screenBuilder.moreOptionButton(
        context,
        (conversation) =>
            _conversationActionHelper.onReport(conversation, context),
        CustomPopupMenu(
          pressType: PressType.singleClick,
          showArrow: false,
          controller: CustomPopupMenuController(),
          enablePassEvent: false,
          menuBuilder: () => ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: 60.w,
              color: LMChatTheme.theme.container,
              child: LMChatText(
                "Report Message",
                onTap: () {
                  _conversationActionHelper.onReport(
                      conversationViewData, context);
                },
                style: LMChatTextStyle(
                  maxLines: 1,
                  padding: EdgeInsets.symmetric(
                    horizontal: 6.w,
                    vertical: 2.h,
                  ),
                  textStyle: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w400,
                    color: LMChatTheme.theme.primaryColor,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ),
            ),
          ),
          child: LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.more_vert_rounded,
            style: LMChatIconStyle(
              size: 28,
              color: LMChatTheme.theme.primaryColor,
            ),
          ),
        ),
      ),
    ];
  }

  LMChatroomMenu _defaultChatroomMenu() {
    return LMChatroomMenu(
      chatroom: chatroom,
      controller: _menuController,
      chatroomActions: actions,
    );
  }

  LMChatButton _defaultScrollButton() {
    return LMChatButton(
      onTap: () {
        _scrollToBottom(false);
      },
      style: LMChatButtonStyle.basic().copyWith(
        height: 42,
        width: 42,
        borderRadius: 24,
        border: Border.all(
          color: LMChatTheme.theme.onContainer.withOpacity(0.2),
        ),
        backgroundColor: LMChatTheme.theme.container,
        icon: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.keyboard_arrow_down,
          style: LMChatIconStyle(
            size: 28,
            boxSize: 28,
            boxPadding: const EdgeInsets.all(2),
            color: LMChatTheme.theme.onContainer,
          ),
        ),
      ),
    );
  }

  void _scrollToBottom(bool isPostingNewConversation) {
    if (LMChatConversationBloc.replyConversation != null) {
      if (!isPostingNewConversation) {
        _conversationBloc.add(LMChatFetchConversationsEvent(
          chatroomId: widget.chatroomId,
          page: 1,
          pageSize: 100,
          direction: LMPaginationDirection.top,
          lastConversationId: lastConversationId,
          reInitialize: true,
        ));
      }
      LMChatConversationBloc.instance.stream.listen((state) async {
        if (state is LMChatConversationPostedState) {
          _conversationBloc.add(LMChatFetchConversationsEvent(
            chatroomId: widget.chatroomId,
            page: 1,
            pageSize: 100,
            direction: LMPaginationDirection.top,
            lastConversationId: lastConversationId,
            reInitialize: true,
          ));
          _scrollToBottom(isPostingNewConversation);
        }
        if (state is LMChatConversationLoadedState) {
          if (state.reInitialize) {
            LMChatConversationBloc.replyConversation = null;
            _scrollToBottom(isPostingNewConversation);
          }
        }
      });
    } else {
      scrollController
          .animateTo(
        scrollController.position.minScrollExtent,
        duration: const Duration(milliseconds: 500),
        curve: Curves.easeInOut,
      )
          .then(
        (value) {
          rebuildChatTopic.value = !rebuildChatTopic.value;
          showChatTopic = true;
        },
      );
    }
  }

  void _showScrollToBottomButton() {
    if (scrollController.position.pixels >
        scrollController.position.viewportDimension) {
      showScrollButton = true;
      rebuildFloatingButton.value = !rebuildFloatingButton.value;
    }
    if (scrollController.position.pixels <
        scrollController.position.viewportDimension) {
      showScrollButton = false;
      rebuildFloatingButton.value = !rebuildFloatingButton.value;
    }
  }

  bool _isRespondingAllowed() {
    if (getMemberState?.member?.state != 1 && chatroom.type == 7) {
      return false;
    } else if (!LMChatMemberRightUtil.checkRespondRights(getMemberState)) {
      return false;
    } else if (chatroom.chatRequestState == 2) {
      return false;
    } else {
      return true;
    }
  }

  void updateChatBotChatroom() {
    if (isOtherUserAIChatbot(chatroom.toChatRoomViewData()) &&
        widget.chatroomId !=
            LMChatLocalPreference.instance.getChatroomIdWithAIChatbot()) {
      LMChatLocalPreference.instance
          .storeChatroomIdWithAIChatbot(widget.chatroomId);
    }
  }
}



================================================
File: lib/packages/core/lib/src/views/chatroom/configurations/builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// {@template lm_chatroom_builder}
/// [LMChatroomBuilderDelegate] is a class which is used to build the chatroom
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatroomBuilderDelegate {
  /// {@macro lm_chatroom_builder}
  const LMChatroomBuilderDelegate();

  /// chatWidgetBuilder
  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Builder for the attachment menu
  Widget attachmentMenuBuilder(
    BuildContext context,
    List<LMAttachmentMenuItemData> items,
    LMAttachmentMenu defaultMenu,
  ) {
    return defaultMenu;
  }

  /// Builder for individual attachment menu items
  Widget attachmentMenuItemBuilder(
    BuildContext context,
    LMAttachmentMenuItemData item,
    LMAttachmentMenuItem defaultMenuItem,
  ) {
    return defaultMenuItem;
  }

  /// Builds the scaffold for the screen
  /// Builds a [Scaffold] widget with the given parameters.
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.home,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds the scroll to bottom button

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatRoomViewData chatroom,
    LMChatAppBar appBar,
    int participantsCount,
  ) {
    return appBar;
  }

  /// Builds the chat bubble for conversation having custom widget
  Widget customChatBubbleBuilder(BuildContext context,
      LMChatConversationViewData conversation, int chatroomId) {
    return const SizedBox.shrink();
  }

  /// Builds the sent chat bubble.
  Widget sentChatBubbleBuilder(
    BuildContext context,
    LMChatConversationViewData conversation,
    LMChatBubble bubble,
  ) {
    return bubble;
  }

  /// Builds the received chat bubble.
  Widget receivedChatBubbleBuilder(
    BuildContext context,
    LMChatConversationViewData conversation,
    LMChatBubble bubble,
  ) {
    return bubble;
  }

  /// Builds the state bubble.
  Widget stateBubbleBuilder(
    BuildContext context,
    String message,
    LMChatStateBubble stateBubble,
  ) {
    return stateBubble;
  }

  /// Builds the conversation list for group chatroom
  Widget conversationList(
    int chatroomId,
    LMChatConversationList conversationList,
  ) {
    return conversationList;
  }

  /// Builds the conversation list for DM chatroom
  Widget dmConversationList(
    int chatroomId,
    LMChatDMConversationList dmConversationList,
  ) {
    return dmConversationList;
  }

  /// Builds the floating action button for chatroom
  /// it is used to display scroll to bottom button
  Widget floatingActionButton(LMChatButton floatingActionButton) {
    return floatingActionButton;
  }

  /// Builds the loading page widget.
  Widget loadingPageWidgetBuilder(
    BuildContext context,
    Widget loadingPageWidget,
  ) {
    return loadingPageWidget;
  }

  /// Builds the loading list widget.
  Widget loadingListWidgetBuilder(
    BuildContext context,
    Widget loadingListWidget,
  ) {
    return loadingListWidget;
  }

  /// Builds the empty list widget.
  Widget noItemInListWidgetBuilder(
    BuildContext context,
    Widget noItemInListWidget,
  ) {
    return noItemInListWidget;
  }

  /// Builds the paginated loading widget.
  Widget paginatedLoadingWidgetBuilder(
    BuildContext context,
    Widget paginatedLoadingWidget,
  ) {
    return paginatedLoadingWidget;
  }

  /// Builds the chat bar.
  Widget chatBarBuilder(
    BuildContext context,
    LMChatroomBar chatBar,
  ) {
    return chatBar.copyWith();
  }

  /// Builds the whole container for the bottom bar
  /// which includes the chatroom text field, voice notes button and send button
  Widget chatroomBottomBarContainer(
    BuildContext context,
    Container chatroomBottomBar,
    LMChatButton sendButton,
    Widget voiceNotesButton,
    LMChatTextField chatroomTextField,
    CustomPopupMenu? attachmentMenu,
  ) {
    return chatroomBottomBar;
  }

  /// Builds the chatroom text field.
  Widget chatroomTextField(
    BuildContext context,
    TextEditingController textController,
    LMChatTextField chatroomTextField,
    CustomPopupMenu? attachmentMenu,
  ) {
    return chatroomTextField;
  }

  /// Builds edit text field Header.
  Widget editTextTextFieldHeader(
    BuildContext context,
    TextEditingController textController,
    LMChatBarHeader chatBarHeader,
  ) {
    return chatBarHeader;
  }

  /// Builds the reply text field header.
  Widget replyTextFieldHeader(
    BuildContext context,
    TextEditingController textController,
    LMChatBarHeader chatBarHeader,
  ) {
    return chatBarHeader;
  }

  /// Builds the link preview bar.
  Widget linkPreviewBar(
    BuildContext context,
    LMChatLinkPreviewBar oldLinkPreviewBar,
  ) {
    return oldLinkPreviewBar;
  }

  /// Builds the send button for chatroom
  Widget sendButton(
    BuildContext context,
    TextEditingController textController,
    VoidCallback onPressed,
    LMChatButton sendButton,
  ) {
    return sendButton;
  }

  /// Builds the start voice recording button for chatroom
  /// This button is used to start voice recording
  Widget voiceNotesButton(
    BuildContext context,
    LMChatButton voiceNotesButton,
  ) {
    return voiceNotesButton;
  }

  /// Builds the lock icon during voice recording
  /// This icon is displayed when voice recording is in progress
  Widget voiceNotesLockIcon(
    BuildContext context,
    LMChatIcon voiceNotesLockIcon,
    double animationValue,
  ) {
    return voiceNotesLockIcon;
  }

  /// Builds the chatroom menu
  Widget chatroomMenu(
    BuildContext context,
    List<ChatroomAction> chatroomActions,
    LMChatroomMenu chatroomMenu,
  ) {
    return chatroomMenu;
  }

  /// Builds the reply button. This button is used to reply to a message.
  Widget replyButton(
    BuildContext context,
    LMChatConversationViewData conversation,
    LMChatButton replyButton,
  ) {
    return replyButton;
  }

  /// Builds the edit button. This button is used to edit a message.
  Widget editButton(
    BuildContext context,
    LMChatConversationViewData conversation,
    LMChatButton editButton,
  ) {
    return editButton;
  }

  /// Builds the copy button. This button is used to copy a message.
  Widget copyButton(
    BuildContext context,
    List<LMChatConversationViewData> conversations,
    LMChatButton copyButton,
  ) {
    return copyButton;
  }

  /// Builds the delete button. This button is used to delete a message.
  Widget deleteButton(
    BuildContext context,
    LMChatConversationViewData conversation,
    LMChatButton deleteButton,
  ) {
    return deleteButton;
  }

  /// Builds the more option button. This button is used to show more options.
  Widget moreOptionButton(
    BuildContext context,
    Function(LMChatConversationViewData conversation) onTap,
    Widget moreOptionButton,
  ) {
    return moreOptionButton;
  }
}



================================================
File: lib/packages/core/lib/src/views/chatroom/configurations/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/style.dart';

// export all the configurations
export 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/setting.dart';
export 'package:likeminds_chat_flutter_core/src/views/chatroom/configurations/style.dart';


/// {@template lm_chatroom_config}
/// [LMChatroomConfig] is a class which is used to configure the chatroom
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatroomConfig {
  /// {@macro lm_chatroom_config}
  final LMChatroomBuilderDelegate builder;

  /// {@macro lm_chatroom_config}
  final LMChatroomSetting setting;

  /// {@macro lm_chatroom_config}
  final LMChatroomStyle style;

  /// {@macro lm_chatroom_config}
  const LMChatroomConfig({
    this.builder = const LMChatroomBuilderDelegate(),
    this.setting = const LMChatroomSetting(),
    this.style = const LMChatroomStyle(),
  });
}



================================================
File: lib/packages/core/lib/src/views/chatroom/configurations/setting.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template chatroom_setting}
/// [LMChatroomSetting] is a class which is used to configure the chatroom
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatroomSetting {
  /// The selection type for the chatroom
  final LMChatSelectionType? selectionType;

  /// {@macro chatroom_setting}
  const LMChatroomSetting({this.selectionType = LMChatSelectionType.appbar});
}



================================================
File: lib/packages/core/lib/src/views/chatroom/configurations/style.dart
================================================
/// {@template lm_chatroom_style}
/// [LMChatroomStyle] is a class which is used to style the chatroom
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatroomStyle {
  /// {@macro lm_chatroom_style}
  const LMChatroomStyle();
}



================================================
File: lib/packages/core/lib/src/views/explore/explore.dart
================================================
// ignore_for_file: public_member_api_docs, sort_constructors_first

import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

import 'package:likeminds_chat_flutter_core/src/blocs/explore/bloc/explore_bloc.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/chatroom/chatroom_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_explore_page}
/// A screen to show the Explore Feed of LMChat
///
/// Creates a new instance for [LMChatExplorePage]
///
/// Gives access to customizations through instance builder variables
///
/// To configure the page, use [LMChatExplorePageConfig]
/// {@endtemplate}
class LMChatExplorePage extends StatefulWidget {
  /// {@macro lm_chat_explore_page}
  const LMChatExplorePage({super.key});

  @override
  State<LMChatExplorePage> createState() => _LMChatExplorePageState();
}

class _LMChatExplorePageState extends State<LMChatExplorePage> {
  final LMChatExploreBloc exploreBloc = LMChatExploreBloc.instance;
  LMChatSpace _space = LMChatSpace.newest;

  ValueNotifier<bool> rebuildPin = ValueNotifier(false);
  ValueNotifier<bool> rebuildLMChatSpace = ValueNotifier(false);
  final CustomPopupMenuController _controller = CustomPopupMenuController();
  PagingController<int, ChatRoom> exploreFeedPagingController =
      PagingController<int, ChatRoom>(firstPageKey: 1);
  final _screenBuilder = LMChatCore.config.exploreConfig.builder;

  int pinnedChatroomCount = 0;
  int _page = 1;
  bool pinnedChatroom = false;
  final LMChatCustomPopupMenuStyle _defMenuStyle = LMChatCustomPopupMenuStyle(
    textStyle: LMChatTextStyle(
      maxLines: 1,
      textStyle: TextStyle(
        fontSize: 16,
        color: LMChatTheme.theme.onContainer,
      ),
    ),
    iconStyle: LMChatIconStyle(
      size: 28,
      color: LMChatTheme.theme.onContainer,
    ),
    menuBoxWidth: 52.w,
    menuBoxDecoration: BoxDecoration(
      color: LMChatTheme.theme.container,
      borderRadius: BorderRadius.circular(10),
    ),
    menuTextStyle: TextStyle(
      fontSize: 14,
      color: LMChatTheme.theme.onContainer,
    ),
  );

  LMChatCustomPopupMenuStyle _popUpMenuStyle() =>
      LMChatCore.config.exploreConfig.style.popUpMenuStyle?.call(
        _defMenuStyle,
      ) ??
      _defMenuStyle;

  @override
  void initState() {
    super.initState();
    _addPaginationListener();
  }

  @override
  void dispose() {
    exploreBloc.close();
    exploreFeedPagingController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return _screenBuilder.scaffold(
      backgroundColor: LMChatTheme.theme.scaffold,
      appBar: _screenBuilder.appBarBuilder(context, _defaultExploreAppBar()),
      body: Padding(
        padding: EdgeInsets.symmetric(horizontal: 2.w),
        child: _defaultExploreBody(),
      ),
    );
  }

  Column _defaultExploreBody() {
    return Column(
      children: [
        kVerticalPaddingSmall,
        Padding(
          padding: EdgeInsets.symmetric(horizontal: 2.w),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              _screenBuilder.exploreMenuBuilder(
                context,
                _shortNewest,
                _shortRecentlyActive,
                _shortMostParticipants,
                _shortMostMessages,
                _defaultExploreMenu(),
              ),
              const Spacer(),
              _defaultExplorePinButton(),
            ],
          ),
        ),
        kVerticalPaddingXLarge,
        Expanded(
          child: _defaultExploreBlocConsumer(),
        ),
        SizedBox(height: 2.h),
      ],
    );
  }

  BlocConsumer<LMChatExploreBloc, LMChatExploreState>
      _defaultExploreBlocConsumer() {
    return BlocConsumer<LMChatExploreBloc, LMChatExploreState>(
      bloc: exploreBloc,
      listener: (context, state) {
        _updatePagingController(state);
      },
      builder: (context, state) {
        return _defaultExploreFeedList();
      },
    );
  }

  LMChatAppBar _defaultExploreAppBar() {
    return LMChatAppBar(
      style: LMChatTheme.theme.appBarStyle.copyWith(
        height: 72,
        gap: 4.w,
        padding: EdgeInsets.all(4.w),
      ),
      title: LMChatText(
        'Explore Chatrooms',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            color: LMChatTheme.theme.onContainer,
            fontSize: 18,
            fontWeight: FontWeight.w400,
          ),
        ),
      ),
    );
  }

  CustomPopupMenu _defaultExploreMenu() {
    return CustomPopupMenu(
      pressType: PressType.singleClick,
      controller: _controller,
      showArrow: false,
      menuBuilder: () => _defaultExploreMenuBox(),
      child: ValueListenableBuilder(
          valueListenable: rebuildLMChatSpace,
          builder: (context, _, __) {
            return Container(
              color: _popUpMenuStyle().backgroundColor,
              child: Row(
                children: [
                  LMChatText(
                    getStateSpace(_space),
                    style: _popUpMenuStyle().textStyle?.copyWith(
                          textStyle: _popUpMenuStyle()
                              .textStyle
                              ?.textStyle
                              ?.copyWith(color: LMChatTheme.theme.onContainer),
                        ),
                  ),
                  const SizedBox(width: 8),
                  LMChatIcon(
                    type: LMChatIconType.icon,
                    icon: Icons.arrow_downward,
                    style: _popUpMenuStyle().iconStyle,
                  ),
                ],
              ),
            );
          }),
    );
  }

  Container _defaultExploreMenuBox() {
    return Container(
      width: _popUpMenuStyle().menuBoxWidth ?? 52.w,
      height: _popUpMenuStyle().menuBoxHeight,
      decoration: _popUpMenuStyle().menuBoxDecoration ??
          BoxDecoration(
            color: LMChatTheme.theme.container,
            borderRadius: BorderRadius.circular(10),
          ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        mainAxisAlignment: MainAxisAlignment.start,
        children: [
          ListTile(
            title: Text(
              "Newest",
              style: _popUpMenuStyle().menuTextStyle,
            ),
            onTap: _shortNewest,
          ),
          ListTile(
            title: Text(
              "Recently Active",
              style: _popUpMenuStyle().menuTextStyle,
            ),
            onTap: _shortRecentlyActive,
          ),
          ListTile(
            title: Text(
              "Most Participants",
              style: _popUpMenuStyle().menuTextStyle,
            ),
            onTap: _shortMostParticipants,
          ),
          ListTile(
            title: Text(
              "Most Messages",
              style: _popUpMenuStyle().menuTextStyle,
            ),
            onTap: _shortMostMessages,
          ),
        ],
      ),
    );
  }

  void _shortMostMessages() {
    _controller.hideMenu();
    _space = LMChatSpace.mostMessages;
    rebuildLMChatSpace.value = !rebuildLMChatSpace.value;
    _refreshExploreFeed();
  }

  void _shortMostParticipants() {
    _controller.hideMenu();
    _space = LMChatSpace.mostParticipants;
    rebuildLMChatSpace.value = !rebuildLMChatSpace.value;
    _refreshExploreFeed();
  }

  void _shortRecentlyActive() {
    _controller.hideMenu();
    _space = LMChatSpace.active;
    rebuildLMChatSpace.value = !rebuildLMChatSpace.value;
    _refreshExploreFeed();
  }

  void _shortNewest() {
    _controller.hideMenu();
    _space = LMChatSpace.newest;
    rebuildLMChatSpace.value = !rebuildLMChatSpace.value;
    _refreshExploreFeed();
  }

  PagedListView<int, ChatRoom> _defaultExploreFeedList() {
    return PagedListView(
      pagingController: exploreFeedPagingController,
      padding: EdgeInsets.zero,
      physics: const ClampingScrollPhysics(),
      builderDelegate: PagedChildBuilderDelegate<ChatRoom>(
        noItemsFoundIndicatorBuilder: (context) => _defaultEmptyView(),
        newPageProgressIndicatorBuilder: (context) => const LMChatLoader(),
        firstPageProgressIndicatorBuilder: (context) => const LMChatLoader(),
        itemBuilder: (context, item, index) =>
            _screenBuilder.exploreTileBuilder(
          context,
          item.toChatRoomViewData(),
          _defaultExploreTile(item, context),
        ),
      ),
    );
  }

  Widget _defaultEmptyView() {
    return Center(
        child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const LMChatIcon(
          type: LMChatIconType.png,
          assetPath: emptyViewImage,
          style: LMChatIconStyle(
            size: 100,
          ),
        ),
        const SizedBox(height: 12),
        LMChatText(
          'Oops! No chatrooms found.',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              color: LMChatTheme.theme.inActiveColor,
            ),
          ),
        )
      ],
    ));
  }

  LMChatExploreTile _defaultExploreTile(ChatRoom item, BuildContext context) {
    return LMChatExploreTile(
      style: LMChatTheme.theme.chatTileStyle.copyWith(
        gap: 6,
        padding: EdgeInsets.symmetric(
          horizontal: 4.w,
          vertical: 1.h,
        ),
      ),
      chatroom: item.toChatRoomViewData(),
      onTap: () {
        LMChatRealtime.instance.chatroomId = item.id;
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => LMChatroomScreen(
              chatroomId: item.id,
            ),
          ),
        ).then((d) {
          _refreshExploreFeed();
        });
        _markRead(item.id);
      },
    );
  }

  Widget _defaultExplorePinButton() {
    return ValueListenableBuilder(
      valueListenable: rebuildPin,
      builder: (context, _, __) {
        return pinnedChatroomCount <= 3
            ? const SizedBox()
            : pinnedChatroom
                ? _screenBuilder.pinnedButtonBuilder(
                    context,
                    _defaultPinnedButton(),
                  )
                : _screenBuilder.pinButtonBuilder(
                    context,
                    _defaultPinButton(),
                  );
      },
    );
  }

  LMChatButton _defaultPinButton() {
    return LMChatButton(
      onTap: () {
        pinnedChatroom = !pinnedChatroom;
        rebuildPin.value = !rebuildPin.value;
        _refreshExploreFeed();
        LMChatAnalyticsBloc.instance.add(
          const LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.pinnedChatroomsViewed,
            eventProperties: {'source': 'banner'},
          ),
        );
        debugPrint("Pin button tapped");
      },
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.push_pin_outlined,
        style: LMChatIconStyle(
          size: 20,
          color: LMChatTheme.theme.onContainer,
        ),
      ),
      style: LMChatButtonStyle(
        height: 32,
        width: 32,
        border: Border.all(
          color: LMChatTheme.theme.onContainer,
        ),
        borderRadius: 16,
        backgroundColor: Colors.transparent,
      ),
    );
  }

  LMChatButton _defaultPinnedButton() {
    return LMChatButton(
      onTap: () {
        pinnedChatroom = !pinnedChatroom;
        rebuildPin.value = !rebuildPin.value;
        _refreshExploreFeed();
        debugPrint("Pin button tapped");
      },
      text: LMChatText(
        "Pinned",
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 14,
            color: LMChatTheme.theme.onContainer,
          ),
        ),
      ),
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.push_pin_outlined,
        style: LMChatIconStyle(
          size: 18,
          boxBorder: 1,
          boxBorderRadius: 11,
          boxPadding: const EdgeInsets.all(2),
          boxSize: 22,
          color: LMChatTheme.theme.onContainer,
          boxBorderColor: LMChatTheme.theme.onContainer,
        ),
      ),
      style: LMChatButtonStyle(
        height: 32,
        spacing: 6,
        border: Border.all(
          color: LMChatTheme.theme.onContainer,
        ),
        borderRadius: 16,
        padding: const EdgeInsets.symmetric(
          horizontal: 6,
          vertical: 4,
        ),
        backgroundColor: Colors.transparent,
      ),
    );
  }

  void _refreshExploreFeed() {
    exploreFeedPagingController.refresh();
  }

  _addPaginationListener() {
    exploreFeedPagingController.addPageRequestListener(
      (pageKey) {
        exploreBloc.add(
          LMChatFetchExploreEvent(
            getExploreFeedRequest: (GetExploreFeedRequestBuilder()
                  ..orderType(mapLMChatSpacesToInt(_space))
                  ..page(pageKey)
                  ..pinned(pinnedChatroom))
                .build(),
          ),
        );
      },
    );
  }

  void _markRead(int chatroomId) async {
    await LMChatCore.instance.lmChatClient.markReadChatroom(
      (MarkReadChatroomRequestBuilder()..chatroomId(chatroomId)).build(),
    );
  }

  void _updatePagingController(LMChatExploreState state) {
    if (state is LMChatExploreLoadedState) {
      pinnedChatroomCount =
          state.getExploreFeedResponse.pinnedChatroomCount ?? 0;
      _page++;
      if (state.getExploreFeedResponse.chatrooms == null ||
          state.getExploreFeedResponse.chatrooms!.isEmpty) {
        exploreFeedPagingController.appendLastPage([]);
      } else {
        exploreFeedPagingController.appendPage(
          state.getExploreFeedResponse.chatrooms!,
          _page,
        );
      }
      rebuildPin.value = !rebuildPin.value;
    } else if (state is LMChatExploreErrorState) {
      exploreFeedPagingController.error = state.errorMessage;
    }
  }
}



================================================
File: lib/packages/core/lib/src/views/explore/configurations/builder.dart
================================================
import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_explore_builder_delegate}
/// [LMChatExploreBuilderDelegate] is a class which is used to build the explore
/// screen. It is used to customize the explore screen.
/// {@endtemplate}
class LMChatExploreBuilderDelegate {
  /// {@macro lm_chat_explore_builder_delegate}
  const LMChatExploreBuilderDelegate();

  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Build a [Scaffold] widget with the given parameters
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.home,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatAppBar appBar,
  ) {
    return appBar;
  }

  /// Builds the explore tile
  Widget exploreTileBuilder(
    BuildContext context,
    LMChatRoomViewData chatRoomViewData,
    LMChatExploreTile tile,
  ) {
    return tile;
  }

  /// Builds the explore menu
  Widget exploreMenuBuilder(
    BuildContext context,
    VoidCallback onNewestTap,
    VoidCallback onRecentlyActiveTap,
    VoidCallback onMostParticipantsTap,
    VoidCallback onMostMessagesTap,
    CustomPopupMenu menu,
  ) {
    return menu;
  }

  /// Builds Pin Button
  Widget pinButtonBuilder(
    BuildContext context,
    LMChatButton pinButton,
  ) {
    return pinButton;
  }

  /// Builds Pinned Button
  Widget pinnedButtonBuilder(
    BuildContext context,
    LMChatButton pinnedButton,
  ) {
    return pinnedButton;
  }

  /// Builds pin icon on the explore tile avatar
  Widget pinIconBuilder(
    BuildContext context,
    LMChatIcon pinIcon,
  ) {
    return pinIcon;
  }

  /// Builds header for the explore screen tile
  Widget headerBuilder(
    BuildContext context,
    LMChatText header,
  ) {
    return header;
  }

  /// Builds the lock icon in case of secret chatroom
  Widget lockIconBuilder(
    BuildContext context,
    LMChatIcon lockIcon,
  ) {
    return lockIcon;
  }

  /// Builds the subtitle for the explore screen tile
  Widget subtitleBuilder(
    BuildContext context,
    LMChatText subtitle,
  ) {
    return subtitle;
  }

  /// Builds the member count for the explore screen tile
  Widget memberCountBuilder(
    BuildContext context,
    int memberCount,
    LMChatText memberCountText,
  ) {
    return memberCountText;
  }

  /// Builds the member count icon for the explore screen tile
  Widget memberCountIconBuilder(
    BuildContext context,
    LMChatIcon memberCountIcon,
  ) {
    return memberCountIcon;
  }

  /// Builds the unread count for the explore screen tile
  Widget totalResponseCountBuilder(
    BuildContext context,
    int totalResponseCount,
    LMChatText totalResponseCountText,
  ) {
    return totalResponseCountText;
  }

  /// Builds the unread count icon for the explore screen tile
  Widget totalResponseCountIconBuilder(
    BuildContext context,
    LMChatIcon totalResponseCountIcon,
  ) {
    return totalResponseCountIcon;
  }
}



================================================
File: lib/packages/core/lib/src/views/explore/configurations/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/explore/configurations/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/explore/configurations/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/explore/configurations/style.dart';

// export all the configurations
export 'package:likeminds_chat_flutter_core/src/views/explore/configurations/builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/explore/configurations/setting.dart';
export 'package:likeminds_chat_flutter_core/src/views/explore/configurations/style.dart';

/// {@template lm_chat_explore_config}
/// [LMChatExploreConfig] is a class which is used to configure the explore
/// screen. It is used to customize the explore screen.
/// {@endtemplate}
class LMChatExploreConfig {
  /// {@macro lm_chat_explore_config}
  final LMChatExploreBuilderDelegate builder;

  /// {@macro lm_chat_explore_config}
  final LMChatExploreSetting setting;

  /// {@macro lm_chat_explore_config}
  final LMChatExploreStyle style;

  /// {@macro lm_chat_explore_config}
  const LMChatExploreConfig({
    this.builder = const LMChatExploreBuilderDelegate(),
    this.setting = const LMChatExploreSetting(),
    this.style = const LMChatExploreStyle(),
  });
}



================================================
File: lib/packages/core/lib/src/views/explore/configurations/setting.dart
================================================
/// {@template lm_chat_explore_setting}
/// [LMChatExploreSetting] is a class which is used to configure the explore
/// screen. It is used to customize the explore screen.
/// {@endtemplate}
class LMChatExploreSetting {
  /// {@macro lm_chat_explore_setting}
  const LMChatExploreSetting  ();
}


================================================
File: lib/packages/core/lib/src/views/explore/configurations/style.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_explore_style}
/// [LMChatExploreStyle] is a class which is used to style the explore
/// screen. It is used to customize the explore screen.
/// {@endtemplate}
class LMChatExploreStyle {
  /// {@macro lm_chat_explore_style}
  const LMChatExploreStyle({
    this.popUpMenuStyle,
  });

  /// The style for the popup menu.
  final LMChatCustomPopupMenuStyle Function(
      LMChatCustomPopupMenuStyle oldStyle)? popUpMenuStyle;
}



================================================
File: lib/packages/core/lib/src/views/home/home.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// LMChatHomeScreen is the main screen to enter LM Chat experience.
///
/// To customize it pass appropriate builders to constructor.
class LMChatHomeScreen extends StatefulWidget {
  /// Constructor for LMChatHomeScreen
  ///
  /// Creates a new instance of the screen widget
  const LMChatHomeScreen({
    super.key,
  });

  @override
  State<LMChatHomeScreen> createState() => _LMChatHomeScreenState();
}

class _LMChatHomeScreenState extends State<LMChatHomeScreen> {
  final LMChatUserViewData user =
      LMChatLocalPreference.instance.getUser().toUserViewData();
  final _homeScreenBuilder = LMChatCore.config.homeConfig.builder;

  @override
  void didUpdateWidget(covariant LMChatHomeScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
  }

  @override
  Widget build(BuildContext context) {
    ScreenSize.init(context);
    return DefaultTabController(
      length: 2,
      child: Builder(builder: (context) {
        return _homeScreenBuilder.scaffold(
          backgroundColor: LMChatTheme.theme.backgroundColor,
          appBar: _homeScreenBuilder.appBarBuilder(
            context,
            user,
            DefaultTabController.of(context),
            _defAppBar(context),
          ),
          body: const TabBarView(
            children: [
              LMChatHomeFeedList(),
              LMChatDMFeedList(),
            ],
          ),
        );
      }),
    );
  }

  LMChatAppBar _defAppBar(BuildContext context) {
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        height: 120,
        gap: 8,
        backgroundColor: LMChatTheme.theme.container,
      ),
      leading: const SizedBox.shrink(),
      trailing: [
        const SizedBox(width: 8),
        LMChatProfilePicture(
          fallbackText: user.name,
          imageUrl: user.imageUrl,
          style: const LMChatProfilePictureStyle(
            size: 32,
          ),
        ),
        const SizedBox(width: 8),
      ],
      bottom: _homeScreenBuilder.tabBarBuilder(
        context,
        DefaultTabController.of(context),
        _defTabBar(),
      ),
      title: LMChatText(
        LMChatStringConstants.homeFeedTitle,
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 22.0.sp,
            fontWeight: FontWeight.w600,
            color: LMChatTheme.theme.onContainer,
          ),
        ),
      ),
    );
  }

  TabBar _defTabBar() {
    return TabBar(
      labelColor: LMChatTheme.theme.onContainer,
      indicatorColor: LMChatTheme.theme.primaryColor,
      labelStyle: TextStyle(color: LMChatTheme.theme.onContainer),
      unselectedLabelStyle: TextStyle(color: LMChatTheme.theme.onContainer),
      tabs: const [
        Tab(text: LMChatStringConstants.groupHomeTabTitle),
        Tab(text: LMChatStringConstants.dmHomeTabTitle),
      ],
    );
  }

  LMChatAIButton _floatingActionButton() {
    return const LMChatAIButton();
  }
}



================================================
File: lib/packages/core/lib/src/views/home/configurations/builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_home_builder_delegate}
/// [LMChatHomeBuilderDelegate] is a class which is used to build the home
/// screen. It is used to customize the home screen.
/// To customize the home screen, create a class that extends
/// [LMChatHomeBuilderDelegate] and override the methods.
/// Then pass the instance of this class to the [LMChatHomeConfig] class.
/// which is used to configure the home screen.
///
/// example:
/// ```dart
/// class ExampleHomeBuilder extends LMChatHomeBuilderDelegate {
///  @override
///  appBarBuilder(BuildContext context, LMChatAppBar appBar) {
///   return appBar.copyWith(
///    style: LMChatAppBarStyle.basic().copyWith(
///     backgroundColor: Colors.green,
///       ),
///     );
///   }
/// }
/// ```
/// Then pass the instance of this class to the [LMChatHomeConfig] class.
/// ```dart
/// LMChatHomeConfig(
///  builder: ExampleHomeBuilder(),
///   );
/// ```
/// Use This [LMChatHomeConfig] instance to configure the home screen
/// by passing it to the [LMChatCore] class. in initialize method.
/// ```dart
/// LMChatCore.instance.initialize(
///   config: LMChatConfig(
///     config: LMChatConfig(
///      homeConfig: LMChatHomeConfig(
///        builder: ExampleHomeBuilder(),
///      ),
///    ),
/// );
/// ```
/// {@endtemplate}
class LMChatHomeBuilderDelegate {
  /// {@macro lm_chat_home_builder_delegate}
  const LMChatHomeBuilderDelegate();

  /// chatWidgetBuilder
  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Builds a [Scaffold] widget with the given parameters.
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.home,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds [AppBar] widget for home screen
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatUserViewData userViewData,
    TabController tabController,
    LMChatAppBar appBar,
  ) {
    return appBar;
  }

  /// Builds [TabBar] widget for home screen
  PreferredSizeWidget tabBarBuilder(
    BuildContext context,
    TabController tabController,
    TabBar tabBar,
  ) {
    return tabBar;
  }

  // Builders for home feed list

  /// Builds a home feed chatroom tile
  Widget homeFeedTileBuilder(
    BuildContext context,
    LMChatRoomViewData chatroom,
    LMChatTile tile,
  ) {
    return tile;
  }

  /// Builds a home feed explore tile
  Widget homeFeedExploreTileBuilder(
    BuildContext context,
    LMChatTile tile,
  ) {
    return tile;
  }

  /// Builds the explore chip
  Widget homeFeedExploreChipBuilder(
    BuildContext context,
    LMChatChip chip,
  ) {
    return chip;
  }

  /// Builds mute icon in home feed
  Widget homeFeedMuteIconBuilder(LMChatIcon icon) {
    return icon;
  }

  /// Builds search icon in home feed
  Widget homeFeedSecretChatroomIconBuilder(LMChatIcon icon) {
    return icon;
  }

  /// Builds the first page error indicator.
  Widget homeFeedFirstPageErrorIndicatorBuilder(
    BuildContext context,
    Widget errorWidget,
  ) {
    return errorWidget;
  }

  /// Builds the new page error indicator.
  Widget homeFeedNewPageErrorIndicatorBuilder(
    BuildContext context,
    Widget errorWidget,
  ) {
    return errorWidget;
  }

  /// Builds the first page progress indicator.
  Widget homeFeedFirstPageProgressIndicatorBuilder(
    BuildContext context,
    Widget loaderWidget,
  ) {
    return loaderWidget;
  }

  /// Builds the new page progress indicator.
  Widget homeFeedNewPageProgressIndicatorBuilder(
    BuildContext context,
    Widget loaderWidget,
  ) {
    return loaderWidget;
  }

  /// Builds the no items found indicator.
  Widget homeFeedNoItemsFoundIndicatorBuilder(
    BuildContext context,
    Widget noItemsFoundWidget,
  ) {
    return noItemsFoundWidget;
  }

  /// Builds the no more items indicator.
  Widget homeFeedNoMoreItemsIndicatorBuilder(
    BuildContext context,
    Widget noMoreItemsWidget,
  ) {
    return noMoreItemsWidget;
  }

  // Builders for dm feed list

  /// Builds a dm feed chatroom tile
  Widget dmFeedTileBuilder(
    BuildContext context,
    LMChatRoomViewData chatroom,
    LMChatTile tile,
  ) {
    return tile;
  }

  /// Builds mute icon in dm feed
  Widget dmFeedMuteIconBuilder(LMChatIcon icon) {
    return icon;
  }

  /// Builds the first page error indicator.
  Widget dmFeedFirstPageErrorIndicatorBuilder(
    BuildContext context,
    Widget errorWidget,
  ) {
    return errorWidget;
  }

  /// Builds the new page error indicator.
  Widget dmFeedNewPageErrorIndicatorBuilder(
    BuildContext context,
    Widget errorWidget,
  ) {
    return errorWidget;
  }

  /// Builds the first page progress indicator.
  Widget dmFeedFirstPageProgressIndicatorBuilder(
    BuildContext context,
    Widget loaderWidget,
  ) {
    return loaderWidget;
  }

  /// Builds the new page progress indicator.
  Widget dmFeedNewPageProgressIndicatorBuilder(
    BuildContext context,
    Widget loaderWidget,
  ) {
    return loaderWidget;
  }

  /// Builds the no items found indicator.

  Widget dmFeedNoItemsFoundIndicatorBuilder(
    BuildContext context,
    Widget noItemsFoundWidget,
  ) {
    return noItemsFoundWidget;
  }

  /// Builds the no more items indicator.
  Widget dmFeedNoMoreItemsIndicatorBuilder(
    BuildContext context,
    Widget noMoreItemsWidget,
  ) {
    return noMoreItemsWidget;
  }
}



================================================
File: lib/packages/core/lib/src/views/home/configurations/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/home/configurations/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/home/configurations/settings.dart';
import 'package:likeminds_chat_flutter_core/src/views/home/configurations/style.dart';

// export all the configurations
export 'package:likeminds_chat_flutter_core/src/views/home/configurations/builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/home/configurations/settings.dart';
export 'package:likeminds_chat_flutter_core/src/views/home/configurations/style.dart';

/// {@template lm_chat_home_config}
/// [LMChatHomeConfig] is a class which is used to configure the home
/// screen. It is used to customize the home screen.
/// {@endtemplate}
class LMChatHomeConfig {
  /// {@macro lm_chat_home_config}
  final LMChatHomeBuilderDelegate builder;

  /// {@macro lm_chat_home_config}
  final LMChatHomeSetting setting;

  /// {@macro lm_chat_home_config}
  final LMChatHomeStyle style;

  /// {@macro lm_chat_home_config}
  const LMChatHomeConfig({
    this.builder = const LMChatHomeBuilderDelegate(),
    this.setting = const LMChatHomeSetting(),
    this.style = const LMChatHomeStyle(),
  });
}



================================================
File: lib/packages/core/lib/src/views/home/configurations/settings.dart
================================================
/// {@template lm_chat_home_setting}
/// [LMChatHomeSetting] is a class which is used to configure the home
/// screen. It is used to customize the home screen.
/// {@endtemplate}
class LMChatHomeSetting {
  /// Custom tags to be used for fetching group chatrooms
  final String? tag;

  /// {@macro lm_chat_home_setting}
  const LMChatHomeSetting({
    this.tag,
  });
}



================================================
File: lib/packages/core/lib/src/views/home/configurations/style.dart
================================================
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';

/// {@template lm_chat_home_style}
/// [LMChatHomeStyle] is a class which is used to style the home
/// screen. It is used to customize the home screen.
/// {@endtemplate}
class LMChatHomeStyle {
  /// {@macro lm_chat_home_style}
  const LMChatHomeStyle({
    this.homeFeedListStyle,
    this.dmFeedListStyle,
  });

  final LMChatHomeFeedListStyle Function(LMChatHomeFeedListStyle)?
      homeFeedListStyle;
  final LMChatDMFeedListStyle Function(LMChatDMFeedListStyle)? dmFeedListStyle;
}



================================================
File: lib/packages/core/lib/src/views/media/media_forwarding.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/blocs.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/builder.dart';
import 'package:overlay_support/overlay_support.dart';

/// {@template lm_chat_media_forwarding_screen}
/// A screen to preview media before adding attachments to a conversation
///
/// Creates a new instance for [LMChatMediaForwardingScreen]
///
/// Gives access to customizations through instance builder variables
///
/// To configure the page, use [LMChatMediaForwardingScreenConfig]
/// {@endtemplate}
class LMChatMediaForwardingScreen extends StatefulWidget {
  /// Required chatrooom ID for th chatroom media is being sent to
  final int chatroomId;

  final LMChatConversationViewData? replyConversation;

  final String? textFieldText;

  final String? chatroomName;

  final bool triggerBot;

  ///{@macro lm_chat_media_forwarding_screen}
  const LMChatMediaForwardingScreen({
    super.key,
    required this.chatroomId,
    this.replyConversation,
    this.textFieldText,
    this.chatroomName,
    this.triggerBot = false,
  });

  @override
  State<LMChatMediaForwardingScreen> createState() =>
      _LMChatMediaForwardingScreenState();
}

class _LMChatMediaForwardingScreenState
    extends State<LMChatMediaForwardingScreen> {
  int currPosition = 0;
  List<LMChatMediaModel> mediaList = [];
  LMChatConversationBloc? conversationBloc;
  LMChatConversationViewData? replyConversation;
  String? textFieldText;

  ValueNotifier<bool> rebuildCurr = ValueNotifier<bool>(false);
  final TextEditingController _textEditingController = TextEditingController();

  final LMChatMediaForwardingBuilderDelegate _screenBuilder =
      LMChatCore.config.mediaForwardingConfig.builder;

  List<LMChatTagViewData> tags = [];
  final _themeData = LMChatTheme.theme;

  @override
  void initState() {
    super.initState();
    replyConversation = widget.replyConversation;
    textFieldText = widget.textFieldText;
    if (textFieldText != null) _textEditingController.text = textFieldText!;
    mediaList = LMChatMediaHandler.instance.pickedMedia;
  }

  @override
  void didUpdateWidget(covariant LMChatMediaForwardingScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    replyConversation = widget.replyConversation;
    textFieldText = widget.textFieldText;
    if (textFieldText != null) _textEditingController.text = textFieldText!;
    mediaList = LMChatMediaHandler.instance.pickedMedia;
  }

  @override
  Widget build(BuildContext context) {
    return _screenBuilder.scaffold(
      onPopInvoked: (p0) {
        LMChatMediaHandler.instance.clearPickedMedia();
      },
      systemUiOverlay: SystemUiOverlayStyle.light,
      backgroundColor: LMChatTheme.isThemeDark
          ? LMChatTheme.theme.container
          : LMChatTheme.theme.onContainer,
      appBar: _screenBuilder.appBarBuilder(
        context,
        _defAppBar(),
        LMChatMediaHandler.instance.pickedMedia.length,
        currPosition,
      ),
      body: Column(
        children: [
          Expanded(
            child: ValueListenableBuilder(
              valueListenable: rebuildCurr,
              builder: (context, _, __) {
                return _buildMediaPreview();
              },
            ),
          ),
          _screenBuilder.chatroomBottomBarContainer(
            context,
            _defChatBar(),
            _defSendButton(context),
            _defInnerTextField(context),
            _defAttachmentButton(),
          ),
        ],
      ),
    );
  }

  Widget _buildMediaPreview() {
    return Column(
      children: [
        Expanded(
          child: _buildMainPreview(),
        ),
        if (mediaList.length > 1)
          _screenBuilder.mediaPreviewBuilder(
            context,
            LMChatMediaHandler.instance.pickedMedia,
            currPosition,
            _buildPreviewBar(),
          )
      ],
    );
  }

  Widget _buildMainPreview() {
    // Move the main preview logic here
    if (mediaList.first.mediaType == LMChatMediaType.image ||
        mediaList.first.mediaType == LMChatMediaType.video) {
      return Center(
        child: mediaList[currPosition].mediaType == LMChatMediaType.image
            ? _screenBuilder.image(context, _defImage())
            : Padding(
                padding: EdgeInsets.symmetric(vertical: 2.h),
                child: _screenBuilder.video(context, _defVideo()),
              ),
      );
    } else if (mediaList.first.mediaType == LMChatMediaType.document) {
      return _screenBuilder.document(context, _defDocument());
    } else if (mediaList.first.mediaType == LMChatMediaType.gif) {
      return Center(child: _defaultGIF());
    }
    return const SizedBox();
  }

  Widget _buildPreviewBar() {
    return Container(
      decoration: BoxDecoration(
        color: LMChatTheme.isThemeDark
            ? LMChatTheme.theme.container.withOpacity(0.5)
            : LMChatTheme.theme.onContainer.withOpacity(0.5),
        border: Border(
          top: BorderSide(
            color: LMChatTheme.theme.disabledColor,
            width: 0.1,
          ),
        ),
      ),
      padding: EdgeInsets.symmetric(
        vertical: 2.h,
        horizontal: 2.w,
      ),
      child: SizedBox(
        height: 15.w,
        child: _defPreviewList(),
      ),
    );
  }

  Container _defChatBar() {
    return Container(
      color: _themeData.backgroundColor,
      child: Padding(
        padding: EdgeInsets.only(
          bottom: 2.h,
          left: 2.w,
          right: 2.w,
          top: 1.5.h,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: <Widget>[
            Expanded(
              child: _defTextField(),
            ),
            _screenBuilder.sendButton(
              context,
              _onSend,
              _defSendButton(context),
            ),
          ],
        ),
      ),
    );
  }

  Widget _defTextField() {
    return Column(
      children: [
        if (replyConversation != null)
          _screenBuilder.replyWidget(
            context,
            _defReplyConversationWidget(),
          ),
        Container(
          width: 80.w,
          constraints: BoxConstraints(
            minHeight: 5.2.h,
            maxHeight: 24.h,
          ),
          child: _screenBuilder.chatroomTextField(
            context,
            _textEditingController,
            _defInnerTextField(context),
            _defAttachmentButton(),
          ),
        ),
      ],
    );
  }

  LMChatTextField _defInnerTextField(BuildContext context) {
    return LMChatTextField(
      isDown: false,
      chatroomId: widget.chatroomId,
      style: Theme.of(context)
          .textTheme
          .bodyMedium
          ?.copyWith(color: LMChatTheme.theme.onContainer),
      onChange: (value) {
        // Handle text change if needed
      },
      onTagSelected: (tag) {
        tags.add(tag);
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.userTagsSomeone,
            eventProperties: {
              'community_id': widget.chatroomId,
              'chatroom_name': widget.chatroomName,
              'tagged_user_id': tag.sdkClientInfoViewData?.uuid,
              'tagged_user_name': tag.name,
            },
          ),
        );
      },
      decoration: InputDecoration(
        border: OutlineInputBorder(
          borderRadius: replyConversation == null
              ? BorderRadius.circular(24)
              : const BorderRadius.vertical(
                  bottom: Radius.circular(24),
                ),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: replyConversation == null
              ? BorderRadius.circular(24)
              : const BorderRadius.vertical(
                  bottom: Radius.circular(24),
                ),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: replyConversation == null
              ? BorderRadius.circular(24)
              : const BorderRadius.vertical(
                  bottom: Radius.circular(24),
                ),
          borderSide: BorderSide.none,
        ),
        enabled: true,
        hintMaxLines: 1,
        hintStyle: TextStyle(
          fontSize: 14,
          color: _themeData.inActiveColor,
        ),
        hintText: "Type something..",
        suffixIcon: (mediaList.isNotEmpty &&
                mediaList.first.mediaType != LMChatMediaType.gif &&
                widget.chatroomId !=
                    LMChatLocalPreference.instance.getChatroomIdWithAIChatbot())
            ? _screenBuilder.attachmentButton(
                context,
                _defAttachmentButton(),
              )
            : null,
        filled: true,
        fillColor: _themeData.container,
      ),
      controller: _textEditingController,
      focusNode: FocusNode(),
    );
  }

  LMChatButton _defAttachmentButton() {
    return LMChatButton(
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.attachment,
        style: LMChatIconStyle(
          color: _themeData.inActiveColor,
        ),
      ),
      style: LMChatButtonStyle(
        height: 4.h,
        margin: EdgeInsets.symmetric(
          horizontal: 2.w,
        ),
        backgroundColor: Colors.transparent,
      ),
      onTap: () async {
        if ((mediaList.first.mediaType == LMChatMediaType.image) ||
            (mediaList.first.mediaType == LMChatMediaType.video)) {
          await LMChatMediaHandler.instance.pickMedia();
        } else if (mediaList.first.mediaType == LMChatMediaType.document) {
          await LMChatMediaHandler.instance.pickDocuments();
        }

        mediaList = LMChatMediaHandler.instance.pickedMedia;
        rebuildCurr.value = !rebuildCurr.value;
      },
    );
  }

  /// Sends a post with the selected media to the server.
  ///
  /// This function is called when the user taps the send button.
  /// It sends a [LMChatPostMultiMediaConversationEvent] event to the
  /// [LMChatConversationBloc] with the selected media and the chatroom id.
  /// It also pops the current route.
  void _onSend() {
    if (_textEditingController.text.trim().isEmpty && mediaList.isEmpty) {
      toast("Text or Media can't be empty");
      return;
    }

    // Encode tags in the message
    String result = LMChatTaggingHelper.encodeString(
      _textEditingController.text,
      tags,
    ).trim();

    LMChatConversationBloc.instance.add(
      LMChatPostMultiMediaConversationEvent(
        (PostConversationRequestBuilder()
              ..replyId(replyConversation?.id)
              ..chatroomId(widget.chatroomId)
              ..temporaryId(DateTime.now().millisecondsSinceEpoch.toString())
              ..text(result)
              ..triggerBot(widget.triggerBot)
              ..hasFiles(true))
            .build(),
        LMChatMediaHandler.instance.pickedMedia.copy(),
      ),
    );
    LMChatMediaHandler.instance.clearPickedMedia();
    Navigator.pop(context, true);
  }

  LMChatAppBar _defAppBar() {
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        height: 60,
        gap: 12,
        backgroundColor: LMChatTheme.isThemeDark
            ? LMChatTheme.theme.container.withOpacity(0.5)
            : LMChatTheme.theme.onContainer.withOpacity(0.5),
        padding: EdgeInsets.symmetric(horizontal: 4.w),
      ),
      leading: LMChatButton(
        onTap: () {
          LMChatMediaHandler.instance.clearPickedMedia();
          Navigator.pop(context);
        },
        icon: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.arrow_back,
          style: LMChatIconStyle(
            color: LMChatTheme.isThemeDark
                ? LMChatTheme.theme.onContainer
                : LMChatTheme.theme.container,
          ),
        ),
      ),
      title: LMChatText(
        "Add Media",
        style: LMChatTextStyle(
          maxLines: 1,
          padding: const EdgeInsets.only(top: 2),
          textStyle: Theme.of(context).textTheme.bodyLarge?.copyWith(
                fontWeight: FontWeight.w500,
                color: LMChatTheme.isThemeDark
                    ? LMChatTheme.theme.onContainer
                    : LMChatTheme.theme.container,
              ),
        ),
      ),
    );
  }

  LMChatButton _defSendButton(BuildContext context) {
    return LMChatButton(
      onTap: _onSend,
      style: LMChatButtonStyle(
        backgroundColor: LMChatTheme.theme.primaryColor,
        borderRadius: 100,
        height: 50,
        width: 50,
      ),
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.send,
        style: LMChatIconStyle(
          size: 26,
          boxSize: 26,
          boxPadding: const EdgeInsets.only(left: 2),
          color: _themeData.container,
        ),
      ),
    );
  }

  LMChatGIF _defaultGIF() => LMChatGIF(
        media: mediaList.first,
        autoplay: true,
        style: LMChatGIFStyle(
          width: 100.w,
        ),
      );

  ListView _defPreviewList() {
    return ListView.builder(
      padding: EdgeInsets.zero,
      itemCount: mediaList.length,
      scrollDirection: Axis.horizontal,
      itemBuilder: (context, index) => GestureDetector(
        onTap: () {
          currPosition = index;
          rebuildCurr.value = !rebuildCurr.value;
        },
        child: Stack(
          // Use Stack to overlay the remove button
          alignment: Alignment.topRight,
          children: [
            Container(
              margin: const EdgeInsets.symmetric(horizontal: 3.0),
              clipBehavior: Clip.hardEdge,
              decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(12.0),
                  border: currPosition == index
                      ? Border.all(
                          color: LMChatTheme.theme.secondaryColor,
                          width: 2.0,
                          strokeAlign: BorderSide.strokeAlignOutside,
                        )
                      : null),
              width: 15.w,
              height: 15.w,
              child: mediaList[index].mediaType == LMChatMediaType.image
                  ? _defImageThumbnail(index)
                  : mediaList[index].mediaType == LMChatMediaType.video
                      ? _defVideoThumbnail(index)
                      : _defDocumentThumbnail(index),
            ),
            Visibility(
              visible: currPosition == index,
              child: Positioned(
                // Position the remove button
                top: 2,
                right: 4,
                child: InkWell(
                  onTap: () => _removeMedia(index),
                  child: LMChatIcon(
                    type: LMChatIconType.icon,
                    icon: CupertinoIcons.xmark,
                    style: LMChatIconStyle(
                      color: LMChatTheme.theme.onContainer,
                      boxPadding: const EdgeInsets.all(4),
                      size: 12,
                      boxSize: 18,
                      boxBorderRadius: 12,
                      backgroundColor: LMChatTheme.theme.container,
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _removeMedia(int index) {
    setState(() {
      mediaList.removeAt(index);
      if (currPosition >= mediaList.length) {
        currPosition =
            mediaList.length - 1; // Adjust current position if needed
      }
      rebuildCurr.value = !rebuildCurr.value; // Trigger rebuild
    });
  }

  LMChatImage _defImage() {
    return LMChatImage(
      imageFile: mediaList[currPosition].mediaFile!,
      style: const LMChatImageStyle(
        boxFit: BoxFit.cover,
      ),
    );
  }

  LMChatImage _defImageThumbnail(int index) {
    return LMChatImage(
      imageFile: mediaList[index].mediaFile!,
      style: const LMChatImageStyle(
        boxFit: BoxFit.cover,
      ),
    );
  }

  LMChatDocumentPreview _defDocument() {
    return LMChatDocumentPreview(
      media: mediaList[currPosition],
      style: LMChatDocumentPreviewStyle(
        maxHeight: 50.h,
      ),
    );
  }

  LMChatDocumentThumbnail _defDocumentThumbnail(int index) {
    return LMChatDocumentThumbnail(
      media: mediaList[index],
      style: LMChatDocumentThumbnailStyle(
        height: 15.w,
        width: 15.w,
      ),
    );
  }

  LMChatVideo _defVideo() => LMChatVideo(
        media: mediaList[currPosition],
        key: ObjectKey(mediaList[currPosition].hashCode),
        style: const LMChatVideoStyle(),
      );

  Widget _defVideoThumbnail(int index) {
    return mediaList[index].thumbnailFile != null
        ? ClipRRect(
            borderRadius: BorderRadius.circular(8.0),
            child: LMChatImage(
              imageFile: mediaList[index].thumbnailFile!,
              style: LMChatImageStyle(
                boxFit: BoxFit.cover,
                width: 15.w,
              ),
            ),
          )
        : ClipRRect(
            borderRadius: BorderRadius.circular(8.0),
            child: FutureBuilder(
              future: getVideoThumbnail(mediaList[index]),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const LMChatMediaShimmerWidget();
                } else if (snapshot.data != null) {
                  return Image.file(
                    snapshot.data!,
                    fit: BoxFit.cover,
                  );
                } else {
                  return SizedBox(
                    child: Icon(
                      Icons.error,
                      color: LMChatTheme.theme.secondaryColor,
                    ),
                  );
                }
              },
            ),
          );
  }

  LMChatBarHeader _defReplyConversationWidget() {
    String userText = replyConversation?.member?.name ?? '';
    final currentUser = LMChatLocalPreference.instance.getUser();
    if (replyConversation?.memberId == currentUser.id) {
      userText = 'You';
    }
    return LMChatBarHeader(
      style: LMChatBarHeaderStyle.basic(),
      titleText: userText,
      onCanceled: () {
        setState(() {
          replyConversation = null;
        });
      },
      subtitle: LMChatText(
        LMChatTaggingHelper.convertRouteToTag(replyConversation?.answer) ?? "",
        style: LMChatTextStyle(
          textStyle: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: LMChatTheme.theme.onContainer,
              ),
        ),
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/views/media/media_preview.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/builder.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:carousel_slider/carousel_slider.dart';
import 'package:photo_view/photo_view.dart';

/// {@template lm_chat_media_preview_screen}
/// A screen to preview media before adding attachments to a conversation
///
/// Creates a new instance for [LMChatMediaPreviewScreen]
///
/// Gives access to customizations through instance builder variables
///
/// To configure the page, use [LMChatMediaForwardingScreenConfig]
/// {@endtemplate}
class LMChatMediaPreviewScreen extends StatefulWidget {
  /// required conversation object to fetch media and title
  final LMChatConversationViewData? conversation;

  /// Controls whether to show the preview bar at the bottom
  final bool showPreview;

  /// {@macro lm_chat_media_preview_screen}
  const LMChatMediaPreviewScreen({
    super.key,
    this.conversation,
    this.showPreview = false,
  });

  @override
  State<LMChatMediaPreviewScreen> createState() =>
      _LMChatMediaPreviewScreenState();
}

class _LMChatMediaPreviewScreenState extends State<LMChatMediaPreviewScreen> {
  late ValueNotifier<int> _currentPosition;
  List<LMChatMediaModel> mediaList = [];
  late CarouselSliderController _carouselController;

  final LMChatMediaPreviewBuilderDelegate _screenBuilder =
      LMChatCore.config.mediaPreviewConfig.builder;

  @override
  void initState() {
    super.initState();
    mediaList = LMChatMediaHandler.instance.pickedMedia;
    _currentPosition = ValueNotifier<int>(0);
    _carouselController = CarouselSliderController();
  }

  @override
  void dispose() {
    _currentPosition.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(covariant LMChatMediaPreviewScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    mediaList = LMChatMediaHandler.instance.pickedMedia;
  }

  @override
  void deactivate() {
    LMChatMediaHandler.instance.clearPickedMedia();
    super.deactivate();
  }

  @override
  Widget build(BuildContext context) {
    return _screenBuilder.scaffold(
      onPopInvoked: (p0) {
        LMChatMediaHandler.instance.clearPickedMedia();
      },
      systemUiOverlay: SystemUiOverlayStyle.light,
      backgroundColor: LMChatTheme.isThemeDark
          ? LMChatTheme.theme.container
          : LMChatTheme.theme.onContainer,
      appBar: _screenBuilder.appBarBuilder(
        context,
        _defAppBar(),
        LMChatMediaHandler.instance.pickedMedia.length,
        _currentPosition.value,
      ),
      body: ValueListenableBuilder(
        valueListenable: _currentPosition,
        builder: (context, _, __) {
          return getMediaPreview();
        },
      ),
      bottomNavigationBar: widget.showPreview
          ? ValueListenableBuilder(
              valueListenable: _currentPosition,
              builder: (context, _, __) {
                return (mediaList.isNotEmpty)
                    ? _screenBuilder.mediaPreviewBuilder(
                        context,
                        LMChatMediaHandler.instance.pickedMedia.copy(),
                        _currentPosition.value,
                        _defPreviewBar(),
                      )
                    : const SizedBox.shrink();
              },
            )
          : null,
    );
  }

  LMChatAppBar _defAppBar() {
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        height: 60,
        gap: 12,
        backgroundColor: LMChatTheme.isThemeDark
            ? LMChatTheme.theme.container.withOpacity(0.5)
            : LMChatTheme.theme.onContainer.withOpacity(0.5),
        padding: EdgeInsets.symmetric(horizontal: 4.w),
      ),
      leading: LMChatButton(
        onTap: () {
          LMChatMediaHandler.instance.clearPickedMedia();
          Navigator.pop(context);
        },
        icon: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.arrow_back,
          style: LMChatIconStyle(
            color: LMChatTheme.isThemeDark
                ? LMChatTheme.theme.onContainer
                : LMChatTheme.theme.container,
          ),
        ),
      ),
      title: LMChatText(
        widget.conversation == null
            ? "Attachments"
            : widget.conversation!.member!.name,
        style: LMChatTextStyle(
          maxLines: 1,
          padding: const EdgeInsets.only(top: 2),
          textStyle: Theme.of(context).textTheme.bodyLarge?.copyWith(
                fontWeight: FontWeight.w500,
                color: LMChatTheme.isThemeDark
                    ? LMChatTheme.theme.onContainer
                    : LMChatTheme.theme.container,
              ),
        ),
      ),
      subtitle: _buildAppBarSubtitle(),
    );
  }

  Widget _buildAppBarSubtitle() {
    return ValueListenableBuilder(
      valueListenable: _currentPosition,
      builder: (context, position, _) {
        final DateTime now = DateTime.now();
        final String formattedDate =
            DateFormat('dd MMM yyyy, HH:mm').format(now);

        return LMChatText(
          "${position + 1} of ${mediaList.length} attachments • $formattedDate",
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: LMChatTheme.isThemeDark
                      ? LMChatTheme.theme.onContainer
                      : LMChatTheme.theme.container,
                ),
          ),
        );
      },
    );
  }

  String _getMonth(int month) {
    const List<String> months = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec'
    ];
    return months[month - 1];
  }

  Widget getMediaPreview() {
    if (mediaList.isEmpty) {
      return const SizedBox();
    }

    return PhotoViewGestureDetectorScope(
      axis: Axis.horizontal,
      child: CarouselSlider.builder(
        carouselController: _carouselController,
        itemCount: mediaList.length,
        options: CarouselOptions(
          height: 90.h,
          viewportFraction: 1.0,
          enlargeCenterPage: false,
          animateToClosest: false,
          enableInfiniteScroll: false,
          onPageChanged: (index, reason) {
            _currentPosition.value = index;
          },
        ),
        itemBuilder: (context, index, realIndex) {
          final media = mediaList[index];
          return Container(
            color: LMChatTheme.isThemeDark
                ? LMChatTheme.theme.container
                : LMChatTheme.theme.onContainer,
            child: Padding(
              padding: EdgeInsets.symmetric(vertical: 2.h),
              child: Center(
                child: media.mediaType == LMChatMediaType.image
                    ? _screenBuilder.image(
                        context,
                        _buildImageWidget(media),
                        media,
                      )
                    : _screenBuilder.video(
                        context,
                        _buildVideoWidget(media),
                        media,
                      ),
              ),
            ),
          );
        },
      ),
    );
  }

  Container _defPreviewBar() {
    return Container(
      decoration: BoxDecoration(
          color: LMChatTheme.theme.container,
          border: Border(
            top: BorderSide(
              color: LMChatTheme.theme.disabledColor,
              width: 0.1,
            ),
          )),
      padding: EdgeInsets.only(
        left: 2.w,
        right: 5.0,
        top: 2.h,
        bottom: 4.h,
      ),
      child: SizedBox(
        height: 15.w,
        child: _defPreviewList(),
      ),
    );
  }

  ListView _defPreviewList() {
    return ListView.builder(
      padding: EdgeInsets.zero,
      itemCount: mediaList.length,
      scrollDirection: Axis.horizontal,
      itemBuilder: (context, index) => ValueListenableBuilder(
        valueListenable: _currentPosition,
        builder: (context, currentPos, _) {
          return GestureDetector(
            onTap: () {
              _carouselController.animateToPage(
                index,
                duration: const Duration(milliseconds: 300),
                curve: Curves.easeInOut,
              );
            },
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 3.0),
              clipBehavior: Clip.hardEdge,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12.0),
                border: currentPos == index
                    ? Border.all(
                        color: LMChatTheme.theme.secondaryColor,
                        width: 2.0,
                        strokeAlign: BorderSide.strokeAlignOutside,
                      )
                    : null,
              ),
              width: 15.w,
              height: 15.w,
              child: mediaList[index].mediaType == LMChatMediaType.image
                  ? _buildThumbnailImage(mediaList[index])
                  : _buildThumbnailVideo(mediaList[index]),
            ),
          );
        },
      ),
    );
  }

  LMChatImage _buildImageWidget(LMChatMediaModel media) {
    return LMChatImage(
      imageUrl: media.mediaUrl,
      imageFile: media.mediaFile,
      style: LMChatImageStyle(
        boxFit: BoxFit.cover,
        height: media.height?.toDouble(),
        width: media.width?.toDouble(),
      ),
    );
  }

  LMChatImage _buildThumbnailImage(LMChatMediaModel media) {
    return LMChatImage(
      imageUrl: media.thumbnailUrl ?? media.mediaUrl,
      imageFile: media.thumbnailFile ?? media.mediaFile,
      style: LMChatImageStyle(
        boxFit: BoxFit.cover,
        borderRadius: BorderRadius.circular(8.0),
        width: 100.w,
      ),
    );
  }

  LMChatVideo _buildVideoWidget(LMChatMediaModel media) => LMChatVideo(
        media: media,
        key: ObjectKey(media.hashCode),
      );

  Widget _buildThumbnailVideo(LMChatMediaModel media) {
    return ClipRRect(
      borderRadius: BorderRadius.circular(8.0),
      child: Stack(
        alignment: Alignment.center,
        children: [
          LMChatImage(
            imageUrl: media.thumbnailUrl,
            imageFile: media.thumbnailFile,
            style: const LMChatImageStyle(
              boxFit: BoxFit.fill,
            ),
          ),
        ],
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/forwarding/builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_media_forwarding_builder_delegate}
/// Delegate class for building the widgets related to [LMChatMediaForwardingScreen]
/// {@endtemplate}
class LMChatMediaForwardingBuilderDelegate {
  /// {@macro lm_chat_media_forwarding_builder_delegate}
  const LMChatMediaForwardingBuilderDelegate();

  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Build a [Scaffold] widget with the given parameters
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.mediaForwarding,
    bool canPop = true,
    Function(bool)? onPopInvoked,
    SystemUiOverlayStyle? systemUiOverlay,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      systemUiOverlay: systemUiOverlay,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
      onPopInvoked: onPopInvoked,
      canPop: canPop,
    );
  }

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatAppBar appBar,
    int mediaLength,
    int index,
  ) {
    return appBar;
  }

  /// Builds the app bar.
  Widget mediaPreviewBuilder(
    BuildContext context,
    List<LMChatMediaModel> media,
    int index,
    Widget currentPreview,
  ) {
    return currentPreview;
  }

  /// Builds the whole container for the bottom bar
  /// which includes the chatroom text field, voice notes button and send button
  Widget chatroomBottomBarContainer(
    BuildContext context,
    Container chatroomBottomBar,
    LMChatButton sendButton,
    LMChatTextField chatroomTextField,
    LMChatButton attachmentButton,
  ) {
    return chatroomBottomBar;
  }

  /// Builds the chatroom text field.
  Widget chatroomTextField(
    BuildContext context,
    TextEditingController textController,
    LMChatTextField chatroomTextField,
    LMChatButton attachmentMenu,
  ) {
    return chatroomTextField;
  }

  /// Builds the chatroom bar send button
  Widget sendButton(
    BuildContext context,
    VoidCallback onSend,
    LMChatButton sendButton,
  ) {
    return sendButton;
  }

  /// Build the chatroom bar attachment button
  Widget attachmentButton(
    BuildContext context,
    LMChatButton attachmentButton,
  ) {
    return attachmentButton;
  }

  /// Builds the LMChatImage widget of the screen
  Widget image(
    BuildContext context,
    LMChatImage image,
  ) {
    return image;
  }

  /// Builds the LMChatImage widget of the screen
  Widget video(
    BuildContext context,
    LMChatVideo video,
  ) {
    return video;
  }

  /// Builds the LMChatDocumentPreview widget of the screen
  Widget document(
    BuildContext context,
    LMChatDocumentPreview document,
  ) {
    return document;
  }

  /// Builds the LMChatGIF widget of the screen
  Widget gif(
    BuildContext context,
    LMChatGIF gif,
  ) {
    return gif;
  }

  /// Builds the LMChatBarHeader reply widget of the keyboard on screen
  Widget replyWidget(
    BuildContext context,
    LMChatBarHeader reply,
  ) {
    return reply;
  }
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/forwarding/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/style.dart';

export 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/setting.dart';
export 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/style.dart';
export 'package:likeminds_chat_flutter_core/src/views/media/configurations/forwarding/builder.dart';

/// {@template lm_chat_media_forwarding_config}
/// [LMChatMediaForwardingConfig] is a class which is used to configure the chat media_forwarding
/// screen. It is used to customize the chat media_forwarding screen.
/// [builder] is used to set builders for the chat media_forwarding screen.
/// [setting] is used to set the settings for the chat media_forwarding screen.
/// [style] is used to set the style for the chat media_forwarding screen.
/// {@endtemplate}
class LMChatMediaForwardingConfig {
  /// {@macro lm_chat_media_forwarding_builder_delegate}
  final LMChatMediaForwardingBuilderDelegate builder;

  /// {@macro lm_chat_media_forwarding_setting}
  final LMChatMediaForwardingSetting setting;

  /// {@macro lm_chat_media_forwarding_style}
  final LMChatMediaForwardingStyle style;

  /// {@macro lm_chat_media_forwarding_config}
  const LMChatMediaForwardingConfig({
    this.builder = const LMChatMediaForwardingBuilderDelegate(),
    this.style = const LMChatMediaForwardingStyle(),
    this.setting = const LMChatMediaForwardingSetting(),
  });
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/forwarding/setting.dart
================================================
/// {@template lm_chat_media_forwarding_setting}
/// Setting class for the Chat MediaForwarding Screen.
/// {@endtemplate}
class LMChatMediaForwardingSetting {
  /// {@macro lm_chat_media_forwarding_setting}
  const LMChatMediaForwardingSetting();
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/forwarding/style.dart
================================================
/// {@template lm_chat_media_forwarding_style}
/// Style class for the Chat MediaForwarding Screen.
/// {@endtemplate}
class LMChatMediaForwardingStyle {
  /// {@macro lm_chat_media_forwarding_style}
  const LMChatMediaForwardingStyle();
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/preview/builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_media_preview_builder_delegate}
/// Delegate class for building the widgets related to [LMChatMediaPreviewScreen]
/// {@endtemplate}
class LMChatMediaPreviewBuilderDelegate {
  /// {@macro lm_chat_media_preview_builder_delegate}
  const LMChatMediaPreviewBuilderDelegate();

  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Build a [Scaffold] widget with the given parameters
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.mediaPreview,
    bool canPop = true,
    Function(bool)? onPopInvoked,
    SystemUiOverlayStyle? systemUiOverlay,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      systemUiOverlay: systemUiOverlay,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
      onPopInvoked: onPopInvoked,
      canPop: canPop,
    );
  }

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatAppBar appBar,
    int mediaLength,
    int index,
  ) {
    return appBar;
  }

  /// Builds the app bar.
  Widget mediaPreviewBuilder(
    BuildContext context,
    List<LMChatMediaModel> media,
    int index,
    Widget currentPreview,
  ) {
    return currentPreview;
  }

  /// Builds the LMChatImage widget of the list
  Widget image(
    BuildContext context,
    LMChatImage image,
    LMChatMediaModel media,
  ) {
    return image;
  }

  /// Builds the LMChatImage widget of the list
  Widget video(
    BuildContext context,
    LMChatVideo video,
    LMChatMediaModel media,
  ) {
    return video;
  }
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/preview/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/style.dart';

export 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/setting.dart';
export 'package:likeminds_chat_flutter_core/src/views/media/configurations/preview/style.dart';

/// {@template lm_chat_media_preview_config}
/// [LMChatMediaPreviewConfig] is a class which is used to configure the chat media_preview
/// screen. It is used to customize the chat media_preview screen.
/// [builder] is used to set builders for the chat media_preview screen.
/// [setting] is used to set the settings for the chat media_preview screen.
/// [style] is used to set the style for the chat media_preview screen.
/// {@endtemplate}
class LMChatMediaPreviewConfig {
  /// {@macro lm_chat_media_preview_builder_delegate}
  final LMChatMediaPreviewBuilderDelegate builder;

  /// {@macro lm_chat_media_preview_setting}
  final LMChatMediaPreviewSetting setting;

  /// {@macro lm_chat_media_preview_style}
  final LMChatMediaPreviewStyle style;

  /// {@macro lm_chat_media_preview_config}
  const LMChatMediaPreviewConfig({
    this.builder = const LMChatMediaPreviewBuilderDelegate(),
    this.style = const LMChatMediaPreviewStyle(),
    this.setting = const LMChatMediaPreviewSetting(),
  });
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/preview/setting.dart
================================================
/// {@template lm_chat_media_preview_setting}
/// Setting class for the Chat MediaForwarding Screen.
/// {@endtemplate}
class LMChatMediaPreviewSetting {
  /// {@macro lm_chat_media_preview_setting}
  const LMChatMediaPreviewSetting();
}



================================================
File: lib/packages/core/lib/src/views/media/configurations/preview/style.dart
================================================
/// {@template lm_chat_media_preview_style}
/// Style class for the Chat MediaForwarding Screen.
/// {@endtemplate}
class LMChatMediaPreviewStyle {
  /// {@macro lm_chat_media_preview_style}
  const LMChatMediaPreviewStyle();
}



================================================
File: lib/packages/core/lib/src/views/participants/participants.dart
================================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/participants/participants_bloc.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// [LMChatroomParticipantsPage] is a page to display the participants of a chat room.
/// It uses [LMChatParticipantsBloc] to fetch the participants of a chat room.
class LMChatroomParticipantsPage extends StatefulWidget {
  /// [chatroomViewData] is the chat room for which the participants are to be fetched.
  final LMChatRoomViewData chatroomViewData;

  /// [LMChatroomParticipantsPage] constructor to create an instance of [LMChatroomParticipantsPage].
  const LMChatroomParticipantsPage({
    super.key,
    required this.chatroomViewData,
  });

  @override
  State<LMChatroomParticipantsPage> createState() =>
      _LMChatroomParticipantsPageState();
}

class _LMChatroomParticipantsPageState
    extends State<LMChatroomParticipantsPage> {
  LMChatParticipantsBloc? participantsBloc = LMChatParticipantsBloc.instance;
  FocusNode focusNode = FocusNode();
  String? searchTerm;
  final ValueNotifier<bool> _showSearchBarTextField =
      ValueNotifier<bool>(false);
  final TextEditingController _searchController = TextEditingController();
  final PagingController<int, LMChatUserViewData> _pagingController =
      PagingController(firstPageKey: 1);
  Timer? _debounce;
  final int _pageSize = 10;
  final LMChatParticipantBuilderDelegate _screenBuilder =
      LMChatCore.config.participantConfig.builder;

  @override
  void initState() {
    super.initState();
    _addPaginationListener();
  }

  @override
  void dispose() {
    focusNode.dispose();
    _searchController.dispose();
    _showSearchBarTextField.dispose();
    _pagingController.dispose();
    _debounce?.cancel();
    super.dispose();
  }

  _addPaginationListener() {
    _pagingController.addPageRequestListener((pageKey) {
      participantsBloc!.add(
        LMChatGetParticipantsEvent(
          chatroomId: widget.chatroomViewData.id,
          page: pageKey,
          pageSize: _pageSize,
          search: searchTerm,
          isSecret: widget.chatroomViewData.isSecret ?? false,
        ),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    return _screenBuilder.scaffold(
      backgroundColor: LMChatTheme.instance.themeData.scaffold,
      appBar: _screenBuilder.appBarBuilder(
        context,
        _searchController,
        _onSearchTap,
        _defAppBar(),
      ),
      body: SafeArea(
        child: Column(
          children: [
            Expanded(
              child:
                  BlocConsumer<LMChatParticipantsBloc, LMChatParticipantsState>(
                bloc: participantsBloc,
                listener: _updatePaginationState,
                buildWhen: (previous, current) {
                  if (current is LMChatParticipantsPaginationLoadingState) {
                    return false;
                  }
                  return true;
                },
                builder: (context, state) {
                  if (state is LMChatParticipantsLoadingState) {
                    return LMChatLoader(
                      style: LMChatTheme.theme.loaderStyle,
                    );
                  }
                  return _buildParticipantsList();
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  LMChatAppBar _defAppBar() {
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        height: 72,
        gap: 4,
        backgroundColor: LMChatTheme.theme.container,
        padding: EdgeInsets.symmetric(horizontal: 4.w),
      ),
      title: ValueListenableBuilder(
        valueListenable: _showSearchBarTextField,
        builder: (context, value, __) {
          return Padding(
            padding: EdgeInsets.symmetric(
              horizontal: 4.w,
            ),
            child: _showSearchBarTextField.value
                ? TextField(
                    focusNode: focusNode,
                    keyboardType: TextInputType.text,
                    textCapitalization: TextCapitalization.words,
                    controller: _searchController,
                    onChanged: _onSearchTextChange,
                    decoration: InputDecoration(
                      border: InputBorder.none,
                      hintText: "Search...",
                      hintStyle:
                          Theme.of(context).textTheme.bodyMedium!.copyWith(
                                color: LMChatTheme.theme.onContainer,
                                fontSize: 16,
                              ),
                    ),
                  )
                : Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      LMChatText(
                        "Participants",
                        style: LMChatTextStyle(
                          maxLines: 1,
                          textStyle: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            color: LMChatTheme.theme.onContainer,
                          ),
                        ),
                      ),
                      kVerticalPaddingSmall,
                      Text(
                        _memberCountText,
                        style: TextStyle(
                          fontSize: 14,
                          color: LMChatTheme.theme.onContainer,
                        ),
                      ),
                    ],
                  ),
          );
        },
      ),
      trailing: [
        ValueListenableBuilder(
            valueListenable: _showSearchBarTextField,
            builder: (context, value, __) {
              return GestureDetector(
                onTap: _onSearchTap,
                child: LMChatIcon(
                    type: LMChatIconType.icon,
                    icon: value ? Icons.close : Icons.search,
                    style: LMChatIconStyle(
                      size: 24,
                      color: LMChatTheme.theme.onContainer,
                    )),
              );
            }),
      ],
    );
  }

  void _onSearchTap() {
    if (_showSearchBarTextField.value) {
      searchTerm = null;
      _searchController.clear();
      _pagingController.nextPageKey = 2;
      _pagingController.itemList = <LMChatUserViewData>[];
      participantsBloc!.add(
        LMChatGetParticipantsEvent(
          chatroomId: widget.chatroomViewData.id,
          page: 1,
          pageSize: _pageSize,
          search: searchTerm,
          isSecret: widget.chatroomViewData.isSecret ?? false,
        ),
      );
    } else {
      if (focusNode.canRequestFocus) {
        focusNode.requestFocus();
      }
    }
    _showSearchBarTextField.value = !_showSearchBarTextField.value;
  }

  String get _memberCountText {
    final int count = widget.chatroomViewData.participantCount ?? 0;
    return count == 1 ? "$count Member" : "$count Members";
  }

  void _onSearchTextChange(String value) {
    if (_debounce?.isActive ?? false) {
      _debounce?.cancel();
    }
    _debounce = Timer(
      const Duration(milliseconds: 500),
      () {
        searchTerm = value;
        _pagingController.nextPageKey = 2;
        _pagingController.itemList = <LMChatUserViewData>[];
        participantsBloc!.add(
          LMChatGetParticipantsEvent(
            chatroomId: widget.chatroomViewData.id,
            page: 1,
            pageSize: _pageSize,
            search: searchTerm,
            isSecret: widget.chatroomViewData.isSecret ?? false,
          ),
        );
      },
    );
  }

  void _updatePaginationState(context, state) {
    if (state is LMChatParticipantsLoadedState) {
      if (state.participants.length < _pageSize) {
        _pagingController.appendLastPage(
          state.participants,
        );
      } else {
        _pagingController.appendPage(
          state.participants,
          state.page + 1,
        );
      }
    } else if (state is LMChatParticipantsErrorState) {
      _pagingController.error = state.errorMessage;
    }
  }

  Widget _buildParticipantsList() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: PagedListView(
        padding: EdgeInsets.zero,
        pagingController: _pagingController,
        physics: const ClampingScrollPhysics(),
        builderDelegate: PagedChildBuilderDelegate<LMChatUserViewData>(
          itemBuilder: (context, item, index) {
            LMChatUserTile userTile = LMChatUserTile(
              userViewData: item,
            );
            return _screenBuilder.userTileBuilder(context, item, userTile);
          },
          firstPageErrorIndicatorBuilder:
              _screenBuilder.firstPageErrorIndicatorBuilder,
          newPageErrorIndicatorBuilder:
              _screenBuilder.newPageErrorIndicatorBuilder,
          firstPageProgressIndicatorBuilder:
              _screenBuilder.firstPageProgressIndicatorBuilder,
          newPageProgressIndicatorBuilder:
              _screenBuilder.newPageProgressIndicatorBuilder,
          noItemsFoundIndicatorBuilder:
              _screenBuilder.noItemsFoundIndicatorBuilder,
          noMoreItemsIndicatorBuilder:
              _screenBuilder.noMoreItemsIndicatorBuilder,
        ),
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/views/participants/configurations/builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_participant_builder_delegate}
/// Delegate class for building the participant widget
/// {@endtemplate}
class LMChatParticipantBuilderDelegate {
  /// {@macro lm_chat_participant_builder_delegate}
  const LMChatParticipantBuilderDelegate();
  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Build a [Scaffold] widget with the given parameters
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.home,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds the first page error indicator.
  Widget firstPageErrorIndicatorBuilder(
    BuildContext context,
  ) {
    return const SizedBox();
  }

  /// Builds the new page error indicator.
  Widget newPageErrorIndicatorBuilder(
    BuildContext context,
  ) {
    return const SizedBox();
  }

  /// Builds the first page progress indicator.
  Widget firstPageProgressIndicatorBuilder(
    BuildContext context,
  ) {
    LMChatThemeData chatThemeData = LMChatTheme.instance.themeData;
    return LMChatLoader(
      style: chatThemeData.loaderStyle,
    );
  }

  /// Builds the new page progress indicator.
  Widget newPageProgressIndicatorBuilder(
    BuildContext context,
  ) {
    LMChatThemeData chatThemeData = LMChatTheme.instance.themeData;
    return LMChatLoader(
      style: chatThemeData.loaderStyle,
    );
  }

  /// Builds the no items found indicator.
  Widget noItemsFoundIndicatorBuilder(
    BuildContext context,
  ) {
    return const Center(
      child: LMChatText(
        'No search results found',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
          ),
        ),
      ),
    );
  }

  /// Builds the no more items indicator.
  Widget noMoreItemsIndicatorBuilder(
    BuildContext context,
  ) {
    return const SizedBox();
  }

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    TextEditingController searchController,
    VoidCallback onSearch,
    LMChatAppBar appBar,
  ) {
    return appBar;
  }

  /// Builds the list view.
  Widget userTileBuilder(
    BuildContext context,
    LMChatUserViewData user,
    LMChatUserTile userTile,
  ) {
    return userTile;
  }
}



================================================
File: lib/packages/core/lib/src/views/participants/configurations/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/participants/configurations/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/participants/configurations/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/participants/configurations/style.dart';

// export all the configurations
export 'package:likeminds_chat_flutter_core/src/views/participants/configurations/builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/participants/configurations/setting.dart';
export 'package:likeminds_chat_flutter_core/src/views/participants/configurations/style.dart';

/// {@template lm_chat_participant_config}
/// Configuration class for the Likeminds Chat Participant.
/// {@endtemplate}
class LMChatParticipantConfig {
  /// {@macro lm_chat_participant_builder_delegate}
  final LMChatParticipantBuilderDelegate builder;

  /// {@macro lm_chat_participant_style}
  final LMChatParticipantStyle style;

  /// {@macro lm_chat_participant_setting}
  final LMChatParticipantSetting setting;

  /// {@macro lm_chat_participant_config}
  const LMChatParticipantConfig({
    this.builder = const LMChatParticipantBuilderDelegate(),
    this.style = const LMChatParticipantStyle(),
    this.setting = const LMChatParticipantSetting(),
  });
}



================================================
File: lib/packages/core/lib/src/views/participants/configurations/setting.dart
================================================
/// {@template lm_chat_participant_setting}
/// Setting class for the Likeminds Chat Participant.
/// {@endtemplate}
class LMChatParticipantSetting {
  /// {@macro lm_chat_participant_setting}
  const LMChatParticipantSetting();
}



================================================
File: lib/packages/core/lib/src/views/participants/configurations/style.dart
================================================
/// {@template lm_chat_participant_style}
/// Style class for the Likeminds Chat Participant.
/// {@endtemplate}
class LMChatParticipantStyle {
  /// {@macro lm_chat_participant_style}
  const LMChatParticipantStyle();
}



================================================
File: lib/packages/core/lib/src/views/poll/create_poll.dart
================================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:overlay_support/overlay_support.dart';

/// {@template lm_chat_create_poll_bottom_sheet}
/// Create Poll widget
/// responsible for creating the poll
/// {@endtemplate}
class LMChatCreatePollScreen extends StatefulWidget {
  /// {@macro lm_chat_create_poll_bottom_sheet}
  const LMChatCreatePollScreen({
    super.key,
    required this.chatroomId,
    this.repliedConversationId,
    this.pollQuestionStyle,
    this.optionStyle,
  });

  /// [chatroomId] chatroomId for which poll is created
  final int chatroomId;

  /// [repliedConversationId] repliedConversationId for which poll is created
  final String? repliedConversationId;

  /// [LMChatTextFieldStyle] for poll question
  final LMChatTextFieldStyle? pollQuestionStyle;

  /// [LMChatTextFieldStyle] for poll options
  final LMChatTextFieldStyle? optionStyle;

  /// Creates a copy of this [LMChatCreatePollScreen] but with the given fields replaced with the new values.
  LMChatCreatePollScreen copyWith({
    Key? key,
    int? chatroomId,
    String? repliedConversationId,
    LMChatTextFieldStyle? pollQuestionStyle,
    LMChatTextFieldStyle? optionStyle,
  }) {
    return LMChatCreatePollScreen(
      key: key ?? this.key,
      chatroomId: chatroomId ?? this.chatroomId,
      repliedConversationId:
          repliedConversationId ?? this.repliedConversationId,
      pollQuestionStyle: pollQuestionStyle ?? this.pollQuestionStyle,
    );
  }

  @override
  State<LMChatCreatePollScreen> createState() => _LMChatCreatePollScreenState();
}

class _LMChatCreatePollScreenState extends State<LMChatCreatePollScreen> {
  late Size screenSize;
  LMChatThemeData theme = LMChatTheme.theme;
  LMChatUserViewData? user =
      LMChatLocalPreference.instance.getUser().toUserViewData();
  List<String> options = ["", ""];
  final ValueNotifier<bool> _optionBuilder = ValueNotifier(false);
  String exactlyDialogKey = 'exactly';
  int exactlyValue = 1;
  final TextEditingController _questionController = TextEditingController();
  final ValueNotifier<DateTime?> _expiryDateBuilder = ValueNotifier(null);
  final ValueNotifier<LMChatPollMultiSelectState> _multiSelectStateBuilder =
      ValueNotifier(LMChatPollMultiSelectState.exactly);
  final ValueNotifier<bool> _rebuildMultiSelectStateBuilder =
      ValueNotifier(false);
  final ValueNotifier<int> _multiSelectNoBuilder = ValueNotifier(1);
  final ValueNotifier<bool> _showResultsWithoutVoteBuilder =
      ValueNotifier(false);
  final ValueNotifier<bool> _hideResultsUntilPollEndBuilder =
      ValueNotifier(false);
  final ValueNotifier<bool> _isAnonymousBuilder = ValueNotifier(false);
  final ValueNotifier<bool> _allowAddOptionBuilder = ValueNotifier(false);
  final ValueNotifier<bool> _allowVoteChangeBuilder = ValueNotifier(false);
  final ValueNotifier<bool> _rebuildAdvancedOptionsBuilder =
      ValueNotifier(false);
  final StreamController<bool> _isValidatedController =
      StreamController<bool>.broadcast();
  final CommunityConfigurations? communityConfigurations = LMChatLocalPreference
      .instance
      .fetchCommunityConfiguration("chat_poll")
      ?.data;
  final _screenBuilder = LMChatCore.config.pollConfig.createPollBuilder;
  final _screenStyle = LMChatCore.config.pollConfig.style;
  late LMChatTextFieldStyle? pollQuestionStyle =
      widget.pollQuestionStyle ?? _screenStyle.pollQuestionStyle;
  late LMChatTextFieldStyle? optionStyle =
      widget.optionStyle ?? _screenStyle.optionStyle;

  Future<DateTime?> showDateTimePicker({
    required BuildContext context,
    DateTime? initialDate,
    DateTime? firstDate,
    DateTime? lastDate,
  }) async {
    // unfocus text fields if any and request focus for date picker
    FocusScope.of(context).requestFocus(FocusNode());

    initialDate ??= DateTime.now();
    firstDate ??= DateTime.now();
    lastDate ??= firstDate.add(const Duration(days: 365 * 200));

    final DateTime? selectedDate = await showDatePicker(
        context: context,
        initialDate: initialDate,
        firstDate: firstDate,
        lastDate: lastDate,
        helpText: 'Start date',
        builder: (context, child) {
          return Theme(
              data: LMChatTheme.isThemeDark
                  ? Theme.of(context).copyWith(
                      colorScheme: ColorScheme.dark(
                        primary: theme.primaryColor,
                        onPrimary: theme.onPrimary,
                        secondary: theme.secondaryColor,
                      ),
                    )
                  : Theme.of(context).copyWith(
                      colorScheme: ColorScheme.light(
                        primary: theme.primaryColor,
                        onPrimary: theme.onPrimary,
                        secondary: theme.secondaryColor,
                      ),
                    ),
              child: child!);
        });

    if (selectedDate == null) return null;

    if (!context.mounted) return selectedDate;

    final TimeOfDay? selectedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(initialDate),
      builder: (context, child) {
        return Theme(
            data: Theme.of(context).copyWith(
              colorScheme: LMChatTheme.isThemeDark
                  ? ColorScheme.dark(
                      primary: theme.primaryColor,
                      onPrimary: theme.onPrimary,
                      secondary: theme.secondaryColor,
                    )
                  : ColorScheme.light(
                      primary: theme.primaryColor,
                      onPrimary: theme.onPrimary,
                      secondary: theme.secondaryColor,
                    ),
            ),
            child: child!);
      },
    );
    if (selectedTime == null) return null;
    DateTime selectedDateTime = DateTime(
      selectedDate.year,
      selectedDate.month,
      selectedDate.day,
      selectedTime.hour,
      selectedTime.minute,
    );

    if (selectedDateTime.isBefore(DateTime.now())) {
      showSnackBar('Expiry date cannot be in the past');
      return null;
    }

    return selectedDateTime;
  }

  String getFormattedDate(DateTime date) {
    String day = date.day.toString().padLeft(2, '0');
    String month = date.month.toString().padLeft(2, '0');
    String hour = date.hour.toString().padLeft(2, '0');
    String minute = date.minute.toString().padLeft(2, '0');

    return '$day-$month-${date.year} $hour:$minute';
  }

  void showSnackBar(String message) {
    toast(message);
  }

  bool checkForUniqueOptions(bool showError) {
    Set<String> uniqueOptions = options.toSet();
    if (uniqueOptions.length != options.length) {
      if (showError) showSnackBar('Options should be unique');
      return false;
    }
    return true;
  }

  bool validatePoll({bool showError = true}) {
    // check if question is empty
    if (_questionController.text.trim().isEmpty) {
      if (showError) showSnackBar('Question cannot be empty');
      return false;
    }

    // trim options and check if options are empty
    for (int i = 0; i < options.length; i++) {
      options[i] = options[i].trim();
      if (options[i].isEmpty) {
        if (showError) showSnackBar('Option ${i + 1} cannot be empty');
        return false;
      }
    }

    // check if options are unique
    if (!checkForUniqueOptions(showError)) {
      return false;
    }

    // check if expiry date is empty only when poll type is deferred = {showResultsWithoutVoting == false && hideResultUtilPollEnds == true }
    // in other cases expiry date can be empty and poll expiry will be set to infinite by `no_poll_expiry : true` flag
    // if expiry date is set then it should be in future
    if (_showResultsWithoutVoteBuilder.value == false &&
        _hideResultsUntilPollEndBuilder.value == true &&
        _expiryDateBuilder.value == null) {
      if (showError) showSnackBar('Expiry date cannot be empty');
      return false;
    }

    // check if expiry date is required and expiry date is empty
    if (_isExpiryTimeRequired() && _expiryDateBuilder.value == null) {
      if (showError) showSnackBar('Expiry date cannot be empty');
      return false;
    }

    // check if expiry date is in past
    if (_expiryDateBuilder.value != null &&
        _expiryDateBuilder.value!.isBefore(DateTime.now())) {
      if (showError) showSnackBar('Expiry date cannot be in the past');
      return false;
    }

    // check if multiple select state and number is set accordingly the community configuration
    // if community configuration allow_override is false then only check for multi select state and number
    final isAllowOverride =
        communityConfigurations?.value?['allow_override'] == true;

    if (!isAllowOverride) {
      final multiSelectState =
          communityConfigurations?.value?['multiple_select_state'];
      final multiSelectNo =
          communityConfigurations?.value?['multiple_select_no'];

      // check if multi select state is exactly or at least
      //then options length should be equal to or greater than multi select number
      if (multiSelectState == 'exactly' || multiSelectState == 'at_least') {
        if (options.length < multiSelectNo) {
          if (showError) {
            showSnackBar(
                'There should be minimum $multiSelectNo options as per community configuration');
          }
          return false;
        }
      }
    }

    return true;
  }

  @override
  Widget build(BuildContext context) {
    return _screenBuilder.scaffold(
      backgroundColor: theme.container,
      appBar: _screenBuilder.appBarBuilder(context, _defAppBar(context),
          _isValidatedController, validatePoll, onPollSubmit),
      body: SingleChildScrollView(
        child: Column(
          children: [
            _screenBuilder.userTileBuilder(
              context,
              _defUserTile(),
            ),
            _screenBuilder.pollQuestionContainerBuilder(
              context,
              _questionController,
              _defPollQuestionContainer(),
            ),
            const SizedBox(height: 16),
            _screenBuilder.pollOptionsListBuilder(
              context,
              _defPollOptionList(),
            ),
            const SizedBox(height: 16),
            // Advanced settings
            // if community configuration allow_override is true show advanced settings
            // else, check if community configuration no_poll_expiry is false show expiry time
            // else hide expiry time, it will be set to infinite automatically
            communityConfigurations?.value?['allow_override']
                ? _screenBuilder.advancedOptionBuilder(
                    context, _defAdvancedOptions(context))
                : communityConfigurations?.value?['no_poll_expiry'] == false
                    ? _defExpiryTime(context)
                    : const SizedBox(),
          ],
        ),
      ),
    );
  }

  LMChatAppBar _defAppBar(BuildContext context) {
    return LMChatAppBar(
      title: _defTitleText(),
      trailing: [
        StreamBuilder(
            stream: _isValidatedController.stream,
            builder: (context, snapshot) {
              final bool isValidated = snapshot.data ?? false;
              return _defPostButton(isValidated);
            })
      ],
      style: LMChatAppBarStyle(
        centerTitle: true,
        backgroundColor: LMChatTheme.theme.container,
      ),
    );
  }

  Widget _defAdvancedOptions(BuildContext context) {
    return ValueListenableBuilder(
        valueListenable: _rebuildAdvancedOptionsBuilder,
        builder: (context, _, __) {
          return AnimatedSize(
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeInOut,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ValueListenableBuilder(
                    valueListenable: _showResultsWithoutVoteBuilder,
                    builder: (context, value, child) {
                      return _screenBuilder.showResultsWithoutVotingTileBuilder(
                        context,
                        _defShowResultsTile(value),
                        value,
                      );
                    }),
                // if show results without voting is false only then show poll type switch
                if (_showResultsWithoutVoteBuilder.value == false)
                  ValueListenableBuilder(
                      valueListenable: _hideResultsUntilPollEndBuilder,
                      builder: (context, value, child) {
                        return _screenBuilder.hideResultsTileBuilder(
                          context,
                          _defHideResultsTile(value),
                          value,
                        );
                      }),
                ValueListenableBuilder(
                    valueListenable: _allowAddOptionBuilder,
                    builder: (context, value, child) {
                      return _screenBuilder.allowAddOptionTileBuilder(
                        context,
                        _defAllowVotesTile(value),
                        value,
                      );
                    }),
                ValueListenableBuilder(
                    valueListenable: _allowVoteChangeBuilder,
                    builder: (context, value, child) {
                      return _screenBuilder.allowVoteChangeTileBuilder(
                        context,
                        _defAllowVoteChange(value),
                        value,
                      );
                    }),
                ValueListenableBuilder(
                    valueListenable: _isAnonymousBuilder,
                    builder: (context, value, child) {
                      return _screenBuilder.anonymousPollTileBuilder(
                        context,
                        _defAnonymousTile(value),
                        value,
                      );
                    }),

                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 18,
                    vertical: 12,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      _screenBuilder.multipleSelectTextBuilder(
                        context,
                        _defMultipleSelectText(),
                      ),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          ValueListenableBuilder(
                              valueListenable: _multiSelectStateBuilder,
                              builder: (context, value, child) {
                                return DropdownButtonFormField<
                                    LMChatPollMultiSelectState>(
                                  value: value,
                                  onChanged: (value) {
                                    if (value != null) {
                                      _multiSelectStateBuilder.value = value;
                                    }
                                  },
                                  dropdownColor: theme.container,
                                  iconEnabledColor: theme.onContainer,
                                  style: TextStyle(
                                    color: theme.onContainer,
                                  ),
                                  decoration: InputDecoration(
                                    constraints: BoxConstraints(
                                        minWidth: 40.w, maxWidth: 40.w),
                                  ),
                                  items: [
                                    DropdownMenuItem(
                                      value: LMChatPollMultiSelectState.exactly,
                                      child: LMChatText(
                                        LMChatPollMultiSelectState.exactly.name,
                                      ),
                                    ),
                                    DropdownMenuItem(
                                      value: LMChatPollMultiSelectState.atLeast,
                                      child: LMChatText(
                                        LMChatPollMultiSelectState.atLeast.name,
                                      ),
                                    ),
                                    DropdownMenuItem(
                                      value: LMChatPollMultiSelectState.atMax,
                                      child: LMChatText(
                                        LMChatPollMultiSelectState.atMax.name,
                                      ),
                                    ),
                                  ],
                                );
                              }),
                          LMChatText(
                            '=',
                            style: LMChatTextStyle(
                              textStyle: TextStyle(
                                fontSize: 24,
                                fontWeight: FontWeight.w400,
                                color: theme.inActiveColor,
                              ),
                            ),
                          ),
                          ValueListenableBuilder(
                              valueListenable: _rebuildMultiSelectStateBuilder,
                              builder: (context, _, __) {
                                return ValueListenableBuilder(
                                    valueListenable: _multiSelectNoBuilder,
                                    builder: (context, value, child) {
                                      return DropdownButtonFormField<int>(
                                        value: value,
                                        decoration: InputDecoration(
                                          constraints: BoxConstraints(
                                              minWidth: 40.w, maxWidth: 40.w),
                                        ),
                                        items: [
                                          // create dropdown items based on current options length min 1 and max options.length
                                          for (int i = 1;
                                              i <= options.length;
                                              i++)
                                            DropdownMenuItem(
                                              value: i,
                                              child: LMChatText(
                                                '$i ${i == 1 ? 'option' : 'options'}',
                                              ),
                                            ),
                                        ],
                                        dropdownColor: theme.container,
                                        iconEnabledColor: theme.onContainer,
                                        style: TextStyle(
                                          color: theme.onContainer,
                                        ),
                                        onChanged: (value) {
                                          if (value != null) {
                                            _multiSelectNoBuilder.value = value;
                                          }
                                        },
                                      );
                                    });
                              })
                        ],
                      )
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                _screenBuilder.expiryTimeContainerBuilder(
                  context,
                  _defExpiryTime(context),
                ),
              ],
            ),
          );
        });
  }

  LMChatText _defMultipleSelectText() {
    return LMChatText(
      'Allow users to select:',
      style: LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.w400,
          color: theme.inActiveColor,
        ),
      ),
    );
  }

  LMChatUserTile _defUserTile() {
    return LMChatUserTile(
      userViewData: LMChatLocalPreference.instance.getUser().toUserViewData(),
    );
  }

  SwitchListTile _defShowResultsTile(bool value) {
    return SwitchListTile(
      value: value,
      onChanged: (value) {
        _showResultsWithoutVoteBuilder.value = value;
        if (value == true) {
          _hideResultsUntilPollEndBuilder.value = false;
        }
        _rebuildAdvancedOptionsBuilder.value =
            !_rebuildAdvancedOptionsBuilder.value;
        _isValidatedController.add(validatePoll(showError: false));
      },
      activeColor: theme.primaryColor,
      contentPadding: const EdgeInsets.symmetric(
        horizontal: 18,
      ),
      title: LMChatText(
        'Show results without voting',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.inActiveColor,
          ),
        ),
      ),
    );
  }

  SwitchListTile _defHideResultsTile(bool value) {
    return SwitchListTile(
      value: value,
      onChanged: (value) {
        _hideResultsUntilPollEndBuilder.value = value;
        _rebuildAdvancedOptionsBuilder.value =
            !_rebuildAdvancedOptionsBuilder.value;
        _isValidatedController.add(validatePoll(showError: false));
      },
      activeColor: theme.primaryColor,
      contentPadding: const EdgeInsets.symmetric(
        horizontal: 18,
      ),
      title: LMChatText(
        'Hide results until poll ends',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.inActiveColor,
          ),
        ),
      ),
    );
  }

  SwitchListTile _defAnonymousTile(bool value) {
    return SwitchListTile(
      value: value,
      onChanged: (value) {
        _isAnonymousBuilder.value = value;
      },
      activeColor: theme.primaryColor,
      contentPadding: const EdgeInsets.symmetric(
        horizontal: 18,
      ),
      title: LMChatText(
        'Anonymous poll',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.inActiveColor,
          ),
        ),
      ),
    );
  }

  SwitchListTile _defAllowVoteChange(bool value) {
    return SwitchListTile(
      value: value,
      onChanged: (value) {
        _allowVoteChangeBuilder.value = value;
      },
      activeColor: theme.primaryColor,
      contentPadding: const EdgeInsets.symmetric(
        horizontal: 18,
      ),
      title: LMChatText(
        'Allow users to change their vote',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.inActiveColor,
          ),
        ),
      ),
    );
  }

  SwitchListTile _defAllowVotesTile(bool value) {
    return SwitchListTile(
      value: value,
      onChanged: (value) {
        _allowAddOptionBuilder.value = value;
      },
      activeColor: theme.primaryColor,
      contentPadding: const EdgeInsets.symmetric(
        horizontal: 18,
      ),
      title: LMChatText(
        'Allow voters to add options',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.inActiveColor,
          ),
        ),
      ),
    );
  }

  Container _defExpiryTime(BuildContext context) {
    return Container(
      color: theme.container,
      padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _screenBuilder.expiryTimeTitleBuilder(
            context,
            _defExpiryDateTitle(),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: GestureDetector(
              onTap: () async {
                DateTime? selectedDate = await showDateTimePicker(
                  context: context,
                  initialDate: _expiryDateBuilder.value,
                );
                if (selectedDate != null) {
                  _expiryDateBuilder.value = selectedDate;
                }
                _isValidatedController.add(validatePoll(showError: false));
              },
              child: Row(
                children: [
                  _screenBuilder.expiryTimeIconBuilder(
                    context,
                    _defExpiryDateIcon(),
                  ),
                  Expanded(
                    child: ValueListenableBuilder(
                      valueListenable: _expiryDateBuilder,
                      builder: (context, value, child) {
                        return Row(
                          children: [
                            _screenBuilder.expiryTimeTextBuilder(
                              context,
                              _defExpiryDateText(value),
                            ),
                            if (_expiryDateBuilder.value != null) ...[
                              const Spacer(),
                              _screenBuilder.editExpiryTimeIconBuilder(
                                context,
                                _defEditExpiryIcon(),
                              ),
                              _screenBuilder.expiryDeleteButtonBuilder(
                                context,
                                _defDeleteExpiryTimeButton(),
                              )
                            ]
                          ],
                        );
                      },
                    ),
                  ),
                ],
              ),
            ),
          )
        ],
      ),
    );
  }

  LMChatIcon _defEditExpiryIcon() {
    return LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.mode_edit_outline_outlined,
      style: LMChatIconStyle(
        size: 20,
        color: theme.inActiveColor,
        margin: const EdgeInsets.only(right: 8),
      ),
    );
  }

  LMChatButton _defDeleteExpiryTimeButton() {
    return LMChatButton(
      onTap: () {
        // set expiry date to null
        _expiryDateBuilder.value = null;
      },
      style: LMChatButtonStyle(
        backgroundColor: Colors.transparent,
        icon: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.delete_outline,
          style: LMChatIconStyle(
            size: 20,
            color: theme.errorColor,
            margin: const EdgeInsets.only(right: 8, left: 8),
          ),
        ),
      ),
    );
  }

  LMChatIcon _defExpiryDateIcon() {
    return LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.calendar_today,
      style: LMChatIconStyle(
          size: 15,
          color: theme.primaryColor,
          margin: const EdgeInsets.only(right: 8)),
    );
  }

  LMChatText _defExpiryDateText(DateTime? value) {
    return LMChatText(
      value == null ? 'DD-MM-YYYY hh:mm' : getFormattedDate(value),
      style: LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w400,
          color: value == null ? theme.primaryColor : theme.onContainer,
        ),
      ),
    );
  }

  LMChatText _defExpiryDateTitle() {
    String labelText = 'Set expiration date and time';
    return LMChatText(
      _isExpiryTimeRequired() ? '$labelText*' : labelText,
      style: LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w400,
          color: theme.primaryColor,
        ),
      ),
    );
  }

  bool _isExpiryTimeRequired() {
    final isExpiryTimeRequired =
        (communityConfigurations?.value?['allow_override'] == false &&
            communityConfigurations?.value?['no_poll_expiry'] == false);
    return _hideResultsUntilPollEndBuilder.value || isExpiryTimeRequired;
  }

  Widget _defPollOptionList() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
            padding: const EdgeInsets.symmetric(horizontal: 18),
            child: _screenBuilder.pollOptionTitleBuilder(
              context,
              _defAnswerTitleText(),
            )),
        ValueListenableBuilder(
            valueListenable: _optionBuilder,
            builder: (context, _, __) {
              return AnimatedSize(
                duration: const Duration(milliseconds: 300),
                curve: Curves.easeInOut,
                child: ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: options.length,
                    itemBuilder: (context, index) {
                      return _screenBuilder.pollOptionTileBuilder(
                          context, _defPollOption(index), index);
                    }),
              );
            }),
        _screenBuilder.addOptionTileBuilder(context, _defAddOptionTile())
      ],
    );
  }

  LMChatText _defAnswerTitleText() {
    return LMChatText(
      'Options*',
      style: LMChatTextStyle(
        textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.primaryColor),
      ),
    );
  }

  LMChatTile _defAddOptionTile() {
    return LMChatTile(
      onTap: () {
        if (options.length < 10) {
          options.add('');
          _optionBuilder.value = !_optionBuilder.value;
          _rebuildMultiSelectStateBuilder.value =
              !_rebuildMultiSelectStateBuilder.value;
        } else {
          showSnackBar('You can add at max 10 options');
        }
        _isValidatedController.add(validatePoll(showError: false));
      },
      style: LMChatTileStyle.basic().copyWith(
          padding: const EdgeInsets.symmetric(
        horizontal: 18,
        vertical: 16,
      )),
      leading: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.add,
        style: LMChatIconStyle(
          size: 24,
          color: theme.primaryColor,
        ),
      ),
      title: LMChatText(
        'Add option',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.primaryColor,
          ),
        ),
      ),
    );
  }

  LMChatOptionTile _defPollOption(int index) {
    return LMChatOptionTile(
      index: index,
      isRemovable: options.length > 2,
      option: options[index],
      optionStyle: widget.optionStyle ?? const LMChatTextFieldStyle(),
      onDelete: () {
        if (options.length > 2) {
          options.removeAt(index);
          _optionBuilder.value = !_optionBuilder.value;
          _rebuildMultiSelectStateBuilder.value =
              !_rebuildMultiSelectStateBuilder.value;
          if (_multiSelectNoBuilder.value > options.length) {
            _multiSelectNoBuilder.value = 1;
          }
          _isValidatedController.add(validatePoll(showError: false));
        }
      },
      onChanged: (value) {
        options[index] = value;
        _isValidatedController.add(validatePoll(showError: false));
      },
    );
  }

  Container _defPollQuestionContainer() {
    return Container(
      color: theme.container,
      padding: const EdgeInsets.symmetric(
        horizontal: 16,
        vertical: 12,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _screenBuilder.pollQuestionTitleBuilder(
            context,
            _defPollQuestionTitle(),
          ),
          _screenBuilder.pollQuestionTextFieldBuilder(
            context,
            _questionController,
            _defQuestionTextField(),
          ),
        ],
      ),
    );
  }

  TextField _defQuestionTextField() {
    return TextField(
      controller: _questionController,
      maxLines: 3,
      minLines: 3,
      maxLength: 250,
      buildCounter: (context,
          {required currentLength, required isFocused, required maxLength}) {
        return LMChatText(
          '$currentLength/$maxLength character limit',
          style: LMChatTextStyle(
            padding: EdgeInsets.zero,
            textStyle: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w400,
              color: theme.inActiveColor,
            ),
          ),
        );
      },
      style: TextStyle(
        color: theme.onContainer,
      ),
      onChanged: (value) {
        _isValidatedController.add(validatePoll(showError: false));
      },
      decoration: widget.pollQuestionStyle?.inputDecoration ??
          InputDecoration(
            fillColor: LMChatTheme.isThemeDark
                ? theme.backgroundColor
                : theme.textFieldStyle.inputDecoration?.fillColor,
            filled: true,
            hintText: 'Ask a question',
            hintStyle: TextStyle(
              color: theme.inActiveColor,
            ),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide.none,
            ),
            focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide.none,
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide.none,
            ),
            errorBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide.none,
            ),
            disabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide.none,
            ),
          ),
    );
  }

  LMChatText _defPollQuestionTitle() {
    return LMChatText(
      'Question*',
      style: LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 16,
          fontWeight: FontWeight.w400,
          color: theme.primaryColor,
        ),
        padding: const EdgeInsets.only(bottom: 8),
      ),
    );
  }

  LMChatText _defTitleText() {
    return LMChatText(
      'New Poll',
      style: LMChatTextStyle(
        textStyle: TextStyle(
          color: theme.onContainer,
          fontSize: 17,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }

  LMChatText _defPostButton(bool isValidated) {
    return LMChatText(
      "DONE",
      onTap: onPollSubmit,
      style: LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.w500,
          color: isValidated ? theme.primaryColor : theme.inActiveColor,
        ),
      ),
    );
  }

  int _getPollType() {
    /// instant poll - 0 : {show results without voting == false && hideResultUtilPollEnds == false}
    /// deferred poll - 1 : {show results without voting == false && hideResultUtilPollEnds == true}
    /// open poll - 2 : {show results without voting == true}
    if (_showResultsWithoutVoteBuilder.value) {
      return 2;
    } else if (_hideResultsUntilPollEndBuilder.value) {
      return 1;
    } else {
      return 0;
    }
  }

  void onPollSubmit() {
    if (validatePoll()) {
      final pollType = _getPollType();
      final expiryTime = _expiryDateBuilder.value?.millisecondsSinceEpoch;
      final noPollExpiry = expiryTime == null;

      // create poll
      String pollQuestion = _questionController.text.trim();
      LMChatConversationBloc.instance.add(
        LMChatPostPollConversationEvent(
          chatroomId: widget.chatroomId,
          text: pollQuestion,
          polls: options,
          pollType: pollType,
          multipleSelectState: _multiSelectStateBuilder.value.index,
          multipleSelectNo: _multiSelectNoBuilder.value,
          isAnonymous: _isAnonymousBuilder.value,
          allowAddOption: _allowAddOptionBuilder.value,
          expiryTime: _expiryDateBuilder.value?.millisecondsSinceEpoch,
          temporaryId: DateTime.now().millisecondsSinceEpoch.toString(),
          repliedConversationId: widget.repliedConversationId,
          noPollExpiry: noPollExpiry,
          allowVoteChange: _allowVoteChangeBuilder.value,
        ),
      );

      Navigator.pop(context);
    }
  }
}

/// {@template lm_chat_option_tile}
/// Option tile for poll
/// responsible for creating the poll option
/// {@endtemplate}
class LMChatOptionTile extends StatefulWidget {
  /// {@macro lm_chat_option_tile}
  const LMChatOptionTile({
    super.key,
    required this.index,
    this.option,
    this.onDelete,
    this.onChanged,
    this.isRemovable = true,
    this.optionStyle,
  });
  final int index;
  final String? option;
  final VoidCallback? onDelete;
  final Function(String)? onChanged;
  final bool isRemovable;
  final LMChatTextFieldStyle? optionStyle;

  /// Creates a copy of this [LMChatOptionTile] but with the given fields replaced with the new values.
  /// {@macro lm_chat_option_tile}
  LMChatOptionTile copyWith({
    Key? key,
    int? index,
    String? option,
    VoidCallback? onDelete,
    Function(String)? onChanged,
    bool? isRemovable,
    LMChatTextFieldStyle? optionStyle,
  }) {
    return LMChatOptionTile(
      key: key ?? this.key,
      index: index ?? this.index,
      option: option ?? this.option,
      onDelete: onDelete ?? this.onDelete,
      onChanged: onChanged ?? this.onChanged,
      isRemovable: isRemovable ?? this.isRemovable,
      optionStyle: optionStyle ?? this.optionStyle,
    );
  }

  @override
  State<LMChatOptionTile> createState() => _LMChatOptionTileState();
}

class _LMChatOptionTileState extends State<LMChatOptionTile> {
  final TextEditingController _controller = TextEditingController();
  final LMChatThemeData theme = LMChatTheme.theme;

  @override
  void initState() {
    super.initState();
    _controller.text = widget.option ?? '';
  }

  @override
  void didUpdateWidget(oldWidget) {
    super.didUpdateWidget(oldWidget);
    _controller.text = widget.option ?? '';
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 8),
      child: TextField(
        controller: _controller,
        onChanged: widget.onChanged,
        style: TextStyle(
          color: theme.onContainer,
        ),
        decoration: widget.optionStyle?.inputDecoration ??
            InputDecoration(
              fillColor: LMChatTheme.isThemeDark
                  ? theme.backgroundColor
                  : theme.textFieldStyle.inputDecoration?.fillColor,
              filled: true,
              hintText: 'Option ${widget.index + 1}',
              hintStyle: TextStyle(
                color: theme.inActiveColor,
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
                borderSide: BorderSide.none,
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
                borderSide: BorderSide.none,
              ),
              errorBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
                borderSide: BorderSide.none,
              ),
              disabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
                borderSide: BorderSide.none,
              ),
              suffixIconColor: theme.inActiveColor,
              suffixIcon: widget.isRemovable
                  ? IconButton(
                      isSelected: true,
                      icon: const Icon(Icons.close),
                      onPressed: widget.onDelete,
                    )
                  : null,
            ),
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/views/poll/poll_handler.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/poll/poll_option_convertor.dart';
import 'package:overlay_support/overlay_support.dart';

/// Handles the poll submission logic
Future<void> submitVote(
  BuildContext context,
  LMChatConversationViewData conversationData,
  List<LMChatPollOptionViewData> option,
  Map<String, bool> isVoteEditing,
  LMChatConversationViewData previousValue,
  int chatroomId,
) async {
  try {
    if (option.isEmpty) {
      toast(
        "Please select an option",
      );
      return;
    }
    if (LMChatPollUtils.hasPollEnded(
        conversationData.expiryTime, conversationData.noPollExpiry)) {
      toast(
        "Poll ended. Vote can not be submitted now.",
      );

      return;
    }
    if (LMChatPollUtils.isPollSubmitted(conversationData.poll!) &&
        !(conversationData.allowVoteChange ?? false)) {
      return;
    } else {
      if (LMChatPollUtils.isMultiChoicePoll(conversationData.multipleSelectNo,
          conversationData.multipleSelectState)) {
        if (conversationData.multipleSelectState! ==
                LMChatPollMultiSelectState.exactly &&
            option.length != conversationData.multipleSelectNo) {
          toast(
            "Please select exactly ${conversationData.multipleSelectNo} poll",
          );
          return;
        } else if (conversationData.multipleSelectState! ==
                LMChatPollMultiSelectState.atLeast &&
            option.length < conversationData.multipleSelectNo!) {
          toast(
            "Please select at least ${conversationData.multipleSelectNo} poll",
          );
          return;
        } else if (conversationData.multipleSelectState! ==
                LMChatPollMultiSelectState.atMax &&
            option.length > conversationData.multipleSelectNo!) {
          toast(
            "Please select at most ${conversationData.multipleSelectNo} poll",
          );
          return;
        }
      }
      SubmitPollRequest request = (SubmitPollRequestBuilder()
            ..conversationId(conversationData.id)
            ..polls(option.map((e) => e.toPollOption()).toList()))
          .build();
      final response = await LMChatCore.client.submitPoll(request);
      if (!response.success) {
        toast(
          response.errorMessage ?? "Failed to submit vote",
        );
      } else {
        LMChatConversationBloc.instance.add(
          LMChatUpdateConversationsEvent(
            conversationId: conversationData.id,
            chatroomId: chatroomId,
            shouldUpdate: true,
          ),
        );
        toast(
          "Vote submitted successfully",
        );
      }
    }
  } on Exception catch (e) {
    toast(
      e.toString(),
    );
  }
}

/// Handles the poll option addition logic
Future<void> addOption(
  BuildContext context,
  LMChatConversationViewData conversationData,
  String option,
  LMChatUserViewData? currentUser,
  ValueNotifier<bool> rebuildChatWidget,
  LMChatWidgetSource source,
) async {
  String optionText = option.trim();
  // check if the answer is empty
  if (optionText.isEmpty) {
    toast(
      "Option can not be empty",
    );
    return;
  }
  // check if the option already exists
  if (conversationData.poll!.any((element) => element.text == optionText)) {
    toast('Options should be unique');
    return;
  }

  AddPollOptionRequest request = (AddPollOptionRequestBuilder()
        ..conversationId(conversationData.id)
        ..poll(option))
      .build();

  final response = await LMChatCore.client.addPollOption(request);
  if (response.success) {
    final LMChatPollOptionViewData pollOptionViewData =
        response.data!.poll!.toPollOptionViewData();
    conversationData.poll!.add(pollOptionViewData);
    toast(
      "Option added successfully",
    );
    rebuildChatWidget.value = !rebuildChatWidget.value;
  }
}

/// Handles the poll vote text tap logic
void onVoteTextTap(BuildContext context,
    LMChatConversationViewData conversationData, LMChatWidgetSource source,
    {LMChatPollOptionViewData? option}) {
  if (conversationData.isAnonymous ?? false) {
    showDialog(
      context: context,
      builder: (context) => Theme(
        data: Theme.of(context).copyWith(
          dialogBackgroundColor: LMChatTheme.theme.container,
        ),
        child: SimpleDialog(
          backgroundColor: LMChatTheme.theme.container,
          surfaceTintColor: Colors.transparent,
          contentPadding: const EdgeInsets.symmetric(
            vertical: 30,
            horizontal: 8,
          ),
          children: [
            LMChatText(
              'This being an anonymous poll, the names of the voters can not be disclosed.',
              style: LMChatTextStyle(
                maxLines: 3,
                textAlign: TextAlign.center,
                textStyle: TextStyle(
                  fontSize: 16,
                  color: LMChatTheme.theme.onContainer,
                ),
              ),
            )
          ],
        ),
      ),
    );
  } else if (conversationData.toShowResults! ||
      LMChatPollUtils.hasPollEnded(
          conversationData.expiryTime, conversationData.noPollExpiry)) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LMChatPollResultScreen(
          conversationId: conversationData.id,
          pollTitle: conversationData.answer,
          pollOptions: conversationData.poll ?? [],
          selectedOptionId: option?.id,
        ),
      ),
    );
  } else {
    toast(
      "Results will be shown after the poll ends",
    );
  }
}



================================================
File: lib/packages/core/lib/src/views/poll/poll_result.dart
================================================
import 'package:flutter/material.dart';
import 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/user/user_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';

/// {@template lm_chat_poll_result_screen}
/// A screen to display poll results.
/// {@endtemplate}
class LMChatPollResultScreen extends StatefulWidget {
  /// {@macro lm_chat_poll_result_screen}
  const LMChatPollResultScreen({
    super.key,
    required this.conversationId,
    required this.pollOptions,
    this.pollTitle,
    this.selectedOptionId,
    this.tabWidth,
  });

  /// conversation id
  final int conversationId;

  /// poll title
  final String? pollTitle;

  /// poll options
  final List<LMChatPollOptionViewData> pollOptions;

  /// selected option id
  final int? selectedOptionId;

  /// width for the poll options tab
  final double? tabWidth;

  @override
  State<LMChatPollResultScreen> createState() => _LMChatPollResultScreenState();
}

class _LMChatPollResultScreenState extends State<LMChatPollResultScreen>
    with SingleTickerProviderStateMixin {
  LMChatThemeData theme = LMChatTheme.theme;
  LMChatUserViewData? user =
      LMChatLocalPreference.instance.getUser().toUserViewData();
  int initialIndex = 0;
  late TabController _tabController;
  late PageController _pagingController;
  final LMChatPollResultBuilderDelegate _screenBuilder =
      LMChatCore.config.pollConfig.pollResultBuilder;

  @override
  initState() {
    super.initState();
    setTabController();
  }

  void setTabController() {
    _pagingController = PageController(initialPage: initialIndex);
    _tabController = TabController(
      length: widget.pollOptions.length,
      initialIndex: initialIndex,
      vsync: this,
    );
    if (widget.selectedOptionId != null) {
      int index = widget.pollOptions
          .indexWhere((element) => element.id == widget.selectedOptionId);
      if (index != -1) {
        initialIndex = index;
        if (_tabController.index != initialIndex) {
          _tabController.animateTo(initialIndex);
        }
        WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
          if (_pagingController.page != initialIndex) {
            _pagingController.jumpToPage(initialIndex);
          }
        });
      }
    }
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return _screenBuilder.scaffold(
        backgroundColor: theme.container,
        appBar: _screenBuilder.appBarBuilder(context, _defAppBar()),
        body: Column(
          children: [
            _screenBuilder.tabBarBuilder(
              context,
              _defTabBar(width),
            ),
            Expanded(
              child: SafeArea(
                child: PageView.builder(
                  onPageChanged: (index) {
                    _tabController.animateTo(index);
                  },
                  controller: _pagingController,
                  itemCount: widget.pollOptions.length,
                  itemBuilder: (context, index) {
                    return _defListView(widget.pollOptions[index]);
                  },
                ),
              ),
            )
          ],
        ));
  }

  TabBar _defTabBar(double width) {
    return TabBar(
      onTap: (index) {
        _pagingController.animateToPage(index,
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeInOut);
      },
      controller: _tabController,
      dividerColor: theme.inActiveColor,
      indicatorColor: theme.primaryColor,
      indicatorWeight: 4,
      isScrollable: true,
      labelColor: theme.primaryColor,
      indicatorSize: TabBarIndicatorSize.tab,
      labelStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.w500,
      ),
      unselectedLabelStyle: const TextStyle(
        fontSize: 16,
        fontWeight: FontWeight.w400,
      ),
      unselectedLabelColor: theme.inActiveColor,
      tabs: [
        for (var option in widget.pollOptions)
          Tab(
            child: SizedBox(
              width: widget.tabWidth ??
                  (widget.pollOptions.length == 2 ? width / 3 : width / 4),
              child: Column(
                children: [
                  _screenBuilder.voteCountTextBuilder(
                    context,
                    _defVoteCountText(option),
                  ),
                  _screenBuilder.pollOptionTextBuilder(
                    context,
                    _defOptionText(option),
                  ),
                ],
              ),
            ),
          ),
      ],
    );
  }

  LMChatText _defOptionText(LMChatPollOptionViewData option) {
    return LMChatText(
      option.text,
    );
  }

  LMChatText _defVoteCountText(LMChatPollOptionViewData option) {
    return LMChatText(option.noVotes.toString());
  }

  LMChatAppBar _defAppBar() {
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        centerTitle: true,
        height: 72,
        padding: const EdgeInsets.symmetric(horizontal: 18),
        gap: 3.w,
        backgroundColor: theme.container,
        border: Border.all(
          color: Colors.transparent,
        ),
      ),
      title: LMChatText(
        'Poll Result',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            color: theme.onContainer,
            fontSize: 17,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  Widget _defListView(LMChatPollOptionViewData option) {
    if (option.noVotes != null && option.noVotes! <= 0) {
      return _defNoResponse();
    }
    PagingController<int, LMChatUserViewData> pagingController =
        PagingController(firstPageKey: 1);
    _addPaginationListener(pagingController, option.id!);

    return PagedListView<int, LMChatUserViewData>(
      pagingController: pagingController,
      builderDelegate: PagedChildBuilderDelegate(
        itemBuilder: (context, item, index) {
          return _screenBuilder.userTileBuilder(
            context,
            item,
            _defUserTile(item),
          );
        },
        noItemsFoundIndicatorBuilder: (context) {
          return _screenBuilder.noItemsFoundIndicatorBuilder(
            context,
            _defNoResponse(),
          );
        },
        firstPageProgressIndicatorBuilder: (context) {
          return _screenBuilder.firstPageProgressIndicatorBuilder(
            context,
            const LMChatLoader(),
          );
        },
        firstPageErrorIndicatorBuilder: (context) {
          return _screenBuilder.firstPageErrorIndicatorBuilder(
            context,
            _defNoResponse(),
          );
        },
      ),
    );
  }

  LMChatUserTile _defUserTile(LMChatUserViewData item) {
    return LMChatUserTile(
      userViewData: item,
      style: LMChatTileStyle.basic(),
    );
  }

  Center _defNoResponse() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const LMChatIcon(
            type: LMChatIconType.svg,
            assetPath: emptyPollResult,
            style: LMChatIconStyle(
              size: 40,
              margin: EdgeInsets.only(bottom: 16),
            ),
          ),
          LMChatText(
            'No Response',
            style: LMChatTextStyle(
              textStyle: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.w500,
                color: theme.onContainer,
              ),
            ),
          )
        ],
      ),
    );
  }

  void _addPaginationListener(
    PagingController<int, LMChatUserViewData> _pagingController,
    int pollOptionId,
  ) {
    _pagingController.addPageRequestListener(
      (pageKey) async {
        await _getUserList(
          _pagingController,
          pageKey,
          pollOptionId,
        );
      },
    );
  }

  Future<void> _getUserList(
    PagingController<int, LMChatUserViewData> pagingController,
    int page,
    int pollOptionId,
  ) async {
    GetPollUsersRequest request = (GetPollUsersRequestBuilder()
          ..conversationId(widget.conversationId)
          ..pollId(pollOptionId))
        .build();

    LMResponse<GetPollUsersResponse> response =
        await LMChatCore.instance.lmChatClient.getPollUsers(request);
    if (!response.success) {
      pagingController.error = response.errorMessage;
      return;
    }

    final List<LMChatUserViewData> users =
        response.data!.data!.map((e) => e.toUserViewData()).toList();

    pagingController.appendLastPage(
      users,
    );
  }
}



================================================
File: lib/packages/core/lib/src/views/poll/configurations/config.dart
================================================
// import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/views/poll/configurations/create_poll_builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/poll/configurations/poll_result_builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/poll/configurations/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/poll/configurations/style.dart';


// export all the configurations
export 'package:likeminds_chat_flutter_core/src/views/poll/configurations/create_poll_builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/poll/configurations/poll_result_builder.dart';
export 'package:likeminds_chat_flutter_core/src/views/poll/configurations/setting.dart';
export 'package:likeminds_chat_flutter_core/src/views/poll/configurations/style.dart';

/// {@template lm_chat_poll_config}
/// [LMChatPollConfig] is a class which is used to configure the chatroom
/// screen. It is used to customize the create poll screen.
/// {@endtemplate}
class LMChatPollConfig {
  /// {@macro lm_chat_poll_builder}
  final LMChatPollResultBuilderDelegate pollResultBuilder;

  /// {@macro lm_chat_create_poll_builder}
  final LMChatCreatePollBuilderDelegate createPollBuilder;

  /// {@macro lm_chat_create_poll_setting}
  final LMChatPollSetting setting;

  /// {@macro lm_chat_create_poll_style}
  final LMChatCreatePollStyle style;

  /// {@macro lm_chat_create_poll_config}
  const LMChatPollConfig({
    this.pollResultBuilder = const LMChatPollResultBuilderDelegate(),
    this.createPollBuilder = const LMChatCreatePollBuilderDelegate(),
    this.setting = const LMChatPollSetting(),
    this.style = const LMChatCreatePollStyle(),
  });
}



================================================
File: lib/packages/core/lib/src/views/poll/configurations/create_poll_builder.dart
================================================
import 'dart:async';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// {@template lm_chat_create_poll_builder}
/// [LMChatCreatePollBuilderDelegate] is a class which is used to build the create poll
/// screen. It is used to customize the create poll screen.
/// {@endtemplate}
class LMChatCreatePollBuilderDelegate {
  /// {@macro lm_chat_create_poll_builder}
  const LMChatCreatePollBuilderDelegate();

  /// chatWidgetBuilder
  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Builds the scaffold for the screen
  /// Builds a [Scaffold] widget with the given parameters.
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.createPoll,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds the scroll to bottom button

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatAppBar appBar,
    StreamController<bool> isPollValid,
    bool Function() validatePoll,
    VoidCallback onPollSubmit,
  ) {
    return appBar;
  }

  /// user tile builder
  Widget userTileBuilder(
    BuildContext context,
    LMChatUserTile userTile,
  ) {
    return userTile;
  }

  Widget pollQuestionContainerBuilder(
    BuildContext context,
    TextEditingController controller,
    Container container,
  ) {
    return container;
  }

  Widget pollQuestionTitleBuilder(
    BuildContext context,
    LMChatText title,
  ) {
    return title;
  }

  Widget pollQuestionTextFieldBuilder(
    BuildContext context,
    TextEditingController controller,
    TextField textField,
  ) {
    return textField;
  }

  Widget pollOptionsListBuilder(
    BuildContext context,
    Widget optionList,
  ) {
    return optionList;
  }

  Widget pollOptionTitleBuilder(
    BuildContext context,
    LMChatText title,
  ) {
    return title;
  }

  Widget pollOptionTileBuilder(
    BuildContext context,
    LMChatOptionTile pollOption,
    int index,
  ) {
    return pollOption;
  }

  Widget addOptionTileBuilder(
    BuildContext context,
    LMChatTile addOptionTile,
  ) {
    return addOptionTile;
  }

  Widget advancedOptionBuilder(BuildContext context, Widget advancedOption) {
    return advancedOption;
  }

  Widget showResultsWithoutVotingTileBuilder(
    BuildContext context,
    SwitchListTile showResultsTile,
    bool value,
  ) {
    return showResultsTile;
  }

  Widget hideResultsTileBuilder(
    BuildContext context,
    SwitchListTile hideResultsTile,
    bool value,
  ) {
    return hideResultsTile;
  }

  Widget allowAddOptionTileBuilder(
    BuildContext context,
    SwitchListTile allowAddOptionTile,
    bool value,
  ) {
    return allowAddOptionTile;
  }

  Widget allowVoteChangeTileBuilder(
    BuildContext context,
    SwitchListTile allowVoteChangeTile,
    bool value,
  ) {
    return allowVoteChangeTile;
  }

  Widget anonymousPollTileBuilder(
    BuildContext context,
    SwitchListTile anonymousPollTile,
    bool value,
  ) {
    return anonymousPollTile;
  }

  Widget multipleSelectTextBuilder(
    BuildContext context,
    LMChatText multipleSelectText,
  ) {
    return multipleSelectText;
  }

  Widget expiryTimeContainerBuilder(
    BuildContext context,
    Container container,
  ) {
    return container;
  }

  Widget expiryTimeTitleBuilder(
    BuildContext context,
    LMChatText title,
  ) {
    return title;
  }

  Widget expiryTimeIconBuilder(
    BuildContext context,
    LMChatIcon icon,
  ) {
    return icon;
  }

  Widget editExpiryTimeIconBuilder(
    BuildContext context,
    LMChatIcon icon,
  ) {
    return icon;
  }

  Widget expiryDeleteButtonBuilder(
    BuildContext context,
    LMChatButton button,
  ) {
    return button;
  }

  Widget expiryTimeTextBuilder(
    BuildContext context,
    LMChatText text,
  ) {
    return text;
  }
}



================================================
File: lib/packages/core/lib/src/views/poll/configurations/poll_result_builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// {@template lm_chat_poll_result_builder}
/// [LMChatPollResultBuilderDelegate] is a class which is used to build the chatroom
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatPollResultBuilderDelegate {
  /// {@macro lm_chat_poll_result_builder}
  const LMChatPollResultBuilderDelegate();

  /// chatWidgetBuilder
  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Builds the scaffold for the screen
  /// Builds a [Scaffold] widget with the given parameters.
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.pollResult,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds the scroll to bottom button

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatAppBar appBar,
  ) {
    return appBar;
  }

  /// user tile builder
  Widget userTileBuilder(
    BuildContext context,
    LMChatUserViewData user,
    LMChatUserTile userTile,
  ) {
    return userTile;
  }

  /// no item builder
  Widget noItemsFoundIndicatorBuilder(
    BuildContext context,
    Widget noItemIndicator,
  ) {
    return noItemIndicator;
  }

  /// first page progress indicator builder
  Widget firstPageProgressIndicatorBuilder(
    BuildContext context,
    Widget firstPageProgressIndicator,
  ) {
    return firstPageProgressIndicator;
  }

  /// Error indicator builder
  Widget firstPageErrorIndicatorBuilder(
    BuildContext context,
    Widget firstPageErrorIndicator,
  ) {
    return firstPageErrorIndicator;
  }

  /// Builds the tab bar.
  Widget tabBarBuilder(
    BuildContext context,
    TabBar tabBar,
  ) {
    return tabBar;
  }

  /// Builds the vote count text in TabBar
  Widget voteCountTextBuilder(
    BuildContext context,
    LMChatText voteCountText,
  ) {
    return voteCountText;
  }

  /// Builds the poll option text in TabBar
  Widget pollOptionTextBuilder(
    BuildContext context,
    LMChatText pollOptionText,
  ) {
    return pollOptionText;
  }
}



================================================
File: lib/packages/core/lib/src/views/poll/configurations/setting.dart
================================================
/// {@template lm_chat_poll_setting}
/// [LMChatPollSetting] is a class which is used to configure the create poll
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatPollSetting {
  /// {@macro lm_chat_poll_setting}
  const LMChatPollSetting();
}


================================================
File: lib/packages/core/lib/src/views/poll/configurations/style.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_poll_style}
/// [LMChatCreatePollStyle] is a class which is used to style the create poll
/// screen. It is used to customize the chatroom screen.
/// {@endtemplate}
class LMChatCreatePollStyle {
  /// {@macro lm_chat_poll_style}
  const LMChatCreatePollStyle({
    this.pollQuestionStyle,
    this.optionStyle,
  });

  /// [LMChatTextFieldStyle] for poll question
  final LMChatTextFieldStyle? pollQuestionStyle;

  /// [LMChatTextFieldStyle] for poll options
  final LMChatTextFieldStyle? optionStyle;
}



================================================
File: lib/packages/core/lib/src/views/report/report.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/moderation/moderation_bloc.dart';
import 'package:likeminds_chat_flutter_core/src/views/report/configurations/builder.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:overlay_support/overlay_support.dart';

/// {@template lm_chat_report_screen}
/// Report screen for reporting abuse
/// [reportChipBuilder] - Report chip builder
/// [reportContentBuilder] - Report content builder
/// [entityId] - The id of the entity to report (i.e. conversation)
/// [entityCreatorId] - The id of the entity creator
/// [entityType] - The type of the entity
/// {@endtemplate}
class LMChatReportScreen extends StatefulWidget {
  /// Report chip builder
  final Widget Function(BuildContext, LMChatDeleteReasonViewData)?
      reportChipBuilder;

  /// Report content builder
  final Widget Function(BuildContext, LMReportContentWidget)?
      reportContentBuilder;

  /// The id of the entity to report (i.e. conversation)
  final String entityId;

  /// The id of the entity creator
  final String entityCreatorId;

  /// The type of the entity
  final int? entityType;

  /// {@macro lm_chat_report_screen}
  const LMChatReportScreen({
    Key? key,
    required this.entityId,
    required this.entityCreatorId,
    this.entityType,
    this.reportChipBuilder,
    this.reportContentBuilder,
  }) : super(key: key);

  @override
  State<LMChatReportScreen> createState() => _LMChatReportScreenState();
}

class _LMChatReportScreenState extends State<LMChatReportScreen> {
  late Size screenSize;
  final LMChatWidgetSource _widgetSource = LMChatWidgetSource.report;
  LMChatThemeData theme = LMChatTheme.instance.themeData;
  final TextEditingController _reportReasonController = TextEditingController();
  LMChatReportTagViewData? _selectedReportTag;
  final LMChatReportBuilderDelegate _screenBuilder =
      LMChatCore.config.reportConfig.builder;
  final LMChatModerationBloc _moderationBloc = LMChatModerationBloc();

  @override
  void initState() {
    super.initState();
    _moderationBloc.add(LMChatModerationFetchTagsEvent());
  }

  @override
  void dispose() {
    super.dispose();
    _reportReasonController.dispose();
    _moderationBloc.close();
  }

  @override
  Widget build(BuildContext context) {
    screenSize = MediaQuery.sizeOf(context);
    return _screenBuilder.scaffold(
      backgroundColor: theme.container,
      source: _widgetSource,
      appBar: _screenBuilder.appBarBuilder(context, _defAppBar(context)),
      body: SafeArea(
        top: false,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.start,
          children: [
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    const SizedBox(
                      height: 20,
                    ),
                    widget.reportContentBuilder
                            ?.call(context, _defReportContentWidget()) ??
                        _defReportContentWidget(),
                    const SizedBox(
                      height: 24,
                    ),
                    _defChipListBuilder(),
                    if (_selectedReportTag?.name.toLowerCase() == 'others' ||
                        _selectedReportTag?.name.toLowerCase() == 'other')
                      _screenBuilder.otherReasonTextFieldBuilder(
                        context,
                        _reportReasonController,
                        _defOtherReasonTextField(),
                      )
                  ],
                ),
              ),
            ),
            _screenBuilder.submitButtonBuilder(
              context,
              widget.entityId,
              _selectedReportTag?.id,
              _reportReasonController.text.trim(),
              _defSubmitButton(context),
            ),
          ],
        ),
      ),
    );
  }

  Widget _defOtherReasonTextField() {
    return Padding(
      padding: const EdgeInsets.symmetric(
        vertical: 16,
        horizontal: 16,
      ),
      child: TextField(
        cursorColor: Colors.black,
        style: const TextStyle(
          color: Colors.black,
        ),
        controller: _reportReasonController,
        decoration: theme.textFieldStyle.inputDecoration?.copyWith(
              hintText: 'Reason',
              hintStyle: theme.contentStyle.textStyle,
              border: UnderlineInputBorder(
                borderSide: BorderSide(
                  color: theme.disabledColor,
                  width: 1,
                ),
              ),
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(
                  color: theme.primaryColor,
                  width: 1,
                ),
              ),
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(
                  color: theme.primaryColor,
                  width: 1,
                ),
              ),
            ) ??
            InputDecoration(
              fillColor: theme.primaryColor,
              focusColor: theme.primaryColor,
              labelText: 'Reason',
              labelStyle: theme.contentStyle.textStyle,
              border: UnderlineInputBorder(
                borderSide: BorderSide(
                  color: theme.disabledColor,
                  width: 1,
                ),
              ),
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(
                  color: theme.primaryColor,
                  width: 1,
                ),
              ),
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(
                  color: theme.primaryColor,
                  width: 1,
                ),
              ),
            ),
      ),
    );
  }

  BlocConsumer<LMChatModerationBloc, LMChatModerationState>
      _defChipListBuilder() {
    return BlocConsumer<LMChatModerationBloc, LMChatModerationState>(
        bloc: _moderationBloc,
        listener: (context, state) {
          if (state is LMChatModerationReportPostedState) {
            toast('Reported successfully');
            context.pop();
          }
        },
        buildWhen: (previous, current) {
          if (previous is LMChatModerationTagLoadedState &&
              current is LMChatModerationReportPostedState) {
            return false;
          }
          return true;
        },
        builder: (context, state) {
          if (state is LMChatModerationTagLoadingState) {
            return const LMChatLoader();
          }
          if (state is LMChatModerationTagLoadedState) {
            List<LMChatReportTagViewData> reportTags = state.tags;
            return Padding(
              padding: const EdgeInsets.symmetric(
                vertical: 4,
                horizontal: 16,
              ),
              child: Wrap(
                  spacing: 10.0,
                  runSpacing: 10.0,
                  alignment: WrapAlignment.start,
                  runAlignment: WrapAlignment.start,
                  crossAxisAlignment: WrapCrossAlignment.start,
                  children: reportTags.isNotEmpty
                      ? reportTags
                          .map(
                            (tagViewData) => _screenBuilder.reportChipBuilder(
                              context,
                              tagViewData,
                              _defChip(tagViewData),
                            ),
                          )
                          .toList()
                      : []),
            );
          } else {
            return const SizedBox();
          }
        });
  }

  LMChatChip _defChip(LMChatReportTagViewData tagViewData) {
    return LMChatChip(
      onTap: () {
        setState(() {
          if (_selectedReportTag?.id == tagViewData.id) {
            if (_selectedReportTag?.name.toLowerCase() == 'others' ||
                _selectedReportTag?.name.toLowerCase() == 'other') {
              _reportReasonController.clear();
            }
            _selectedReportTag = null;
          } else {
            _selectedReportTag = tagViewData;
          }
        });
      },
      label: LMChatText(
        tagViewData.name,
        style: LMChatTextStyle(
          textStyle: const TextStyle(
            fontSize: 16,
            fontFamily: 'Inter',
            fontWeight: FontWeight.w400,
          ).copyWith(
            fontSize: 14,
            color: _selectedReportTag?.id == tagViewData.id
                ? Colors.white
                : theme.inActiveColor,
          ),
        ),
      ),
      style: LMChatChipStyle.basic().copyWith(
        backgroundColor: _selectedReportTag?.id == tagViewData.id
            ? theme.primaryColor
            : theme.container,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(50.0),
          side: BorderSide(
            color: _selectedReportTag?.id == tagViewData.id
                ? theme.primaryColor
                : theme.inActiveColor,
          ),
        ),
        padding: const EdgeInsets.symmetric(horizontal: 16.0),
      ),
    );
  }

  LMChatButton _defSubmitButton(BuildContext context) {
    return LMChatButton(
      style: LMChatButtonStyle(
        height: 48,
        padding: const EdgeInsets.symmetric(horizontal: 60.0),
        margin: const EdgeInsets.symmetric(vertical: 24.0),
        backgroundColor: _selectedReportTag == null
            ? theme.errorColor.withOpacity(0.2)
            : theme.errorColor,
        borderRadius: 50,
      ),
      text: LMChatText(
        'Report',
        style: LMChatTextStyle(
          textStyle: TextStyle(
              color: theme.container,
              fontSize: 16,
              fontWeight: FontWeight.w500),
        ),
      ),
      onTap: _onSubmit,
    );
  }

  void _onSubmit() async {
    String? reason = _reportReasonController.text.trim();
    if (_selectedReportTag == null) {
      showReasonNotSelectedSnackbar();
      return;
    }

    String deleteReasonLowerCase = _selectedReportTag!.name.toLowerCase();
    if ((deleteReasonLowerCase == 'others' ||
        deleteReasonLowerCase == 'other')) {
      if (reason.isEmpty) {
        toast('Please enter a reason');
        return;
      }
    }

    if (_selectedReportTag != null) {
      _moderationBloc.add(
        LMChatModerationPostReportEvent(
          entityId: widget.entityId,
          reportTagId: _selectedReportTag!.id,
          reason: reason,
        ),
      );
    } else {
      showReasonNotSelectedSnackbar();
      return;
    }
  }

  LMChatAppBar _defAppBar(BuildContext context) {
    return LMChatAppBar(
      style: LMChatAppBarStyle(
        backgroundColor: theme.container,
        showBackButton: false,
        height: 56,
        border: Border(
          bottom: BorderSide(
            color: theme.disabledColor,
            width: 1,
          ),
        ),
        margin: const EdgeInsets.symmetric(
          horizontal: 8,
        ),
      ),
      trailing: [
        LMChatButton(
          onTap: () {
            context.pop();
          },
          style: LMChatButtonStyle(
            height: 48,
            backgroundColor: Colors.transparent,
            borderRadius: 0,
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.close,
              style: LMChatIconStyle(
                color: theme.onContainer,
              ),
            ),
          ),
        )
      ],
      title: LMChatText(
        'Report',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 20,
            color: theme.errorColor,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  void showReasonNotSelectedSnackbar() {
    toast('Please select a reason');
  }

  LMReportContentWidget _defReportContentWidget() {
    return LMReportContentWidget(
      title: 'Please specify the problem to continue',
      description:
          'You would be able to report this message after selecting a problem.',
      style: LMReportContentWidgetStyle(
        titleStyle: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.w500,
            color: theme.onContainer,
          ),
        ),
        descriptionStyle: LMChatTextStyle(
          textStyle: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w400,
            color: theme.inActiveColor,
            overflow: TextOverflow.visible,
          ),
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16),
      ),
    );
  }
}

/// {@template lm_chat_report_screen_style}
/// Style for the report screen
/// [LMReportContentWidgetStyle] - Style for the report content widget
/// [LMChatButtonStyle] - Style for the submit button
/// {@endtemplate}
class LMReportScreenStyle {
  /// Style for the report content widget
  LMReportContentWidgetStyle? reportContentWidgetStyle;

  /// Style for the submit button
  LMChatButtonStyle? submitButtonStyle;

  /// {@macro lm_chat_report_screen_style}
  LMReportScreenStyle({
    this.reportContentWidgetStyle,
    this.submitButtonStyle,
  });

  /// Copy the current style with the provided values
  /// [reportContentWidgetStyle] - Style for the report content widget
  /// [submitButtonStyle] - Style for the submit button
  LMReportScreenStyle copyWith({
    LMReportContentWidgetStyle? reportContentWidgetStyle,
    LMChatButtonStyle? submitButtonStyle,
  }) {
    return LMReportScreenStyle(
      reportContentWidgetStyle:
          reportContentWidgetStyle ?? this.reportContentWidgetStyle,
      submitButtonStyle: submitButtonStyle ?? this.submitButtonStyle,
    );
  }
}

/// {@template lm_chat_report_content_widget}
/// A widget to display the report content
/// [title] - The title of the report content
/// [description] - The description of the report content
/// [style] - The style of the report content widget
/// {@endtemplate}
class LMReportContentWidget extends StatelessWidget {
  /// The title of the report content
  final String title;

  /// The description of the report content
  final String description;

  /// The style of the report content widget

  final LMReportContentWidgetStyle? style;

  /// {@macro lm_chat_report_content_widget}
  const LMReportContentWidget({
    super.key,
    required this.title,
    required this.description,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: style?.margin,
      padding: style?.padding,
      child: Column(
        crossAxisAlignment:
            style?.crossAxisAlignment ?? CrossAxisAlignment.start,
        mainAxisAlignment: style?.mainAxisAlignment ?? MainAxisAlignment.start,
        children: <Widget>[
          LMChatText(
            title,
            style: style?.titleStyle,
          ),
          SizedBox(
            height: style?.titleDescriptionSpacing ?? 8,
          ),
          LMChatText(
            description,
            style: style?.descriptionStyle,
          ),
        ],
      ),
    );
  }
}

/// {@template lm_chat_report_content_widget_style}
/// Style for the report content widget
/// [LMChatTextStyle] - Style for the title
/// [LMChatTextStyle] - Style for the description
/// [CrossAxisAlignment] - Cross axis alignment
/// [MainAxisAlignment] - Main axis alignment
/// [double] - Spacing between title and description
/// [EdgeInsets] - Padding
/// [EdgeInsets] - Margin
/// {@endtemplate}
class LMReportContentWidgetStyle {
  /// Style for the title
  final LMChatTextStyle? titleStyle;

  /// Style for the description
  final LMChatTextStyle? descriptionStyle;

  /// Cross axis alignment
  final CrossAxisAlignment? crossAxisAlignment;

  /// Main axis alignment
  final MainAxisAlignment? mainAxisAlignment;

  /// Spacing between title and description
  final double? titleDescriptionSpacing;

  /// Padding
  final EdgeInsets? padding;

  /// Margin
  final EdgeInsets? margin;

  /// {@macro lm_chat_report_content_widget_style}
  const LMReportContentWidgetStyle({
    this.titleStyle,
    this.descriptionStyle,
    this.crossAxisAlignment,
    this.mainAxisAlignment,
    this.titleDescriptionSpacing,
    this.padding,
    this.margin,
  });
}



================================================
File: lib/packages/core/lib/src/views/report/configurations/builder.dart
================================================
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/views/report/report.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_report_builder_delegate}
/// Delegate class for building the report widget
/// {@endtemplate}
class LMChatReportBuilderDelegate {
  /// {@macro lm_chat_report_builder_delegate}
  const LMChatReportBuilderDelegate();

  static final LMChatWidgetBuilderDelegate _chatWidgetBuilderDelegate =
      LMChatCore.config.widgetBuilderDelegate;

  /// Build a [Scaffold] widget with the given parameters
  Widget scaffold({
    Key? key,
    bool extendBody = false,
    bool extendBodyBehindAppBar = false,
    PreferredSizeWidget? appBar,
    Widget? body,
    Widget? floatingActionButton,
    FloatingActionButtonLocation? floatingActionButtonLocation,
    FloatingActionButtonAnimator? floatingActionButtonAnimator,
    List<Widget>? persistentFooterButtons,
    AlignmentDirectional persistentFooterAlignment =
        AlignmentDirectional.centerEnd,
    Widget? drawer,
    DrawerCallback? onDrawerChanged,
    Widget? endDrawer,
    DrawerCallback? onEndDrawerChanged,
    Color? drawerScrimColor,
    Color? backgroundColor,
    Widget? bottomNavigationBar,
    Widget? bottomSheet,
    bool? resizeToAvoidBottomInset,
    bool primary = true,
    DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start,
    double? drawerEdgeDragWidth,
    bool drawerEnableOpenDragGesture = true,
    bool endDrawerEnableOpenDragGesture = true,
    String? restorationId,
    LMChatWidgetSource source = LMChatWidgetSource.home,
    bool canPop = true,
    Function(bool)? onPopInvoked,
  }) {
    return _chatWidgetBuilderDelegate.scaffold(
      key: key,
      extendBody: extendBody,
      extendBodyBehindAppBar: extendBodyBehindAppBar,
      appBar: appBar,
      body: body,
      floatingActionButton: floatingActionButton,
      floatingActionButtonLocation: floatingActionButtonLocation,
      floatingActionButtonAnimator: floatingActionButtonAnimator,
      persistentFooterButtons: persistentFooterButtons,
      persistentFooterAlignment: persistentFooterAlignment,
      drawer: drawer,
      onDrawerChanged: onDrawerChanged,
      endDrawer: endDrawer,
      onEndDrawerChanged: onEndDrawerChanged,
      drawerScrimColor: drawerScrimColor,
      backgroundColor: backgroundColor,
      bottomNavigationBar: bottomNavigationBar,
      bottomSheet: bottomSheet,
      resizeToAvoidBottomInset: resizeToAvoidBottomInset,
      primary: primary,
      drawerDragStartBehavior: drawerDragStartBehavior,
      drawerEdgeDragWidth: drawerEdgeDragWidth,
      drawerEnableOpenDragGesture: drawerEnableOpenDragGesture,
      endDrawerEnableOpenDragGesture: endDrawerEnableOpenDragGesture,
      restorationId: restorationId,
    );
  }

  /// Builds the app bar.
  PreferredSizeWidget appBarBuilder(
    BuildContext context,
    LMChatAppBar appBar,
  ) {
    return appBar;
  }

  /// Builds the report chip.
  Widget reportChipBuilder(
    BuildContext context,
    LMChatReportTagViewData data,
    LMChatChip reportChip,
  ) {
    return reportChip;
  }

  /// Builds the report content.
  Widget reportContentBuilder(
    BuildContext context,
    LMReportContentWidget reportContentWidget,
  ) {
    return reportContentWidget;
  }

  /// Builds the other reason text field.
  Widget otherReasonTextFieldBuilder(
    BuildContext context,
    TextEditingController textEditingController,
    Widget otherReasonTextField,
  ) {
    return otherReasonTextField;
  }

  /// Builds the submit button.
  Widget submitButtonBuilder(
    BuildContext context,
    String entityId,
    int? reportTagId,
    String? reason,
    LMChatButton submitButton,
  ) {
    return submitButton;
  }
}



================================================
File: lib/packages/core/lib/src/views/report/configurations/config.dart
================================================
import 'package:likeminds_chat_flutter_core/src/views/report/configurations/builder.dart';
import 'package:likeminds_chat_flutter_core/src/views/report/configurations/setting.dart';
import 'package:likeminds_chat_flutter_core/src/views/report/configurations/style.dart';

/// {@template lm_chat_report_config}
/// [LMChatReportConfig] is a class which is used to configure the chat report
/// screen. It is used to customize the chat report screen.
/// [builder] is used to set builders for the chat report screen.
/// [setting] is used to set the settings for the chat report screen.
/// [style] is used to set the style for the chat report screen.
/// {@endtemplate}
class LMChatReportConfig {
  /// {@macro lm_chat_report_builder_delegate}
  final LMChatReportBuilderDelegate builder;

  /// {@macro lm_chat_report_setting}
  final LMChatReportSetting setting;

  /// {@macro lm_chat_report_style}
  final LMChatReportStyle style;

  /// {@macro lm_chat_report_config}
  const LMChatReportConfig({
    this.builder = const LMChatReportBuilderDelegate(),
    this.style = const LMChatReportStyle(),
    this.setting = const LMChatReportSetting(),
  });
}



================================================
File: lib/packages/core/lib/src/views/report/configurations/setting.dart
================================================
/// {@template lm_chat_report_setting}
/// Setting class for the Chat Report Screen.
/// {@endtemplate}
class LMChatReportSetting {
/// {@macro lm_chat_report_setting}
 const LMChatReportSetting();
}


================================================
File: lib/packages/core/lib/src/views/report/configurations/style.dart
================================================
/// {@template lm_chat_report_style}
/// Style class for the Chat Report Screen.
/// {@endtemplate}
class LMChatReportStyle {
  /// {@macro lm_chat_report_style}
  const LMChatReportStyle();
}



================================================
File: lib/packages/core/lib/src/widgets/widgets.dart
================================================
export 'lists/chatroom/chatroom_list.dart';
export 'lists/chatroom/dm_chatroom_list.dart';

export 'chatroom/chatroom_bar_header.dart';
export 'chatroom/chatroom_bar.dart';
export 'chatroom/chatroom_bar_menu.dart';
export 'chatroom/chatroom_menu.dart';

export 'lists/conversation/conversation_list.dart';
export 'lists/conversation/dm_conversation_list.dart';

export 'explore/explore_tile.dart';
export 'explore/explore_join_button.dart';
export 'text_field/text_field.dart';

export 'button/chatbot_button.dart';



================================================
File: lib/packages/core/lib/src/widgets/button/chatbot_button.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/views/chatbot/init_chatbot.dart';

/// A class that holds the configuration properties for the LMChatAIButton.
/// These properties are used to authenticate and initialize the AI chatbot.
class LMChatAIButtonProps {
  /// The API key used for authentication when not using token-based security.
  /// Required when using the non-token based authentication method.
  final String? apiKey;

  /// The unique identifier for the user.
  /// Required when using the non-token based authentication method.
  final String? uuid;

  /// The display name of the user.
  /// Required when using the non-token based authentication method.
  final String? userName;

  /// The URL of the user's profile image.
  /// Optional parameter for user profile customization.
  final String? imageUrl;

  /// Indicates whether the user is a guest user.
  /// Optional parameter, defaults to false if not provided.
  final bool? isGuest;

  /// The access token for token-based security authentication.
  /// Required when using the token-based authentication method.
  final String? accessToken;

  /// The refresh token for token-based security authentication.
  /// Required when using the token-based authentication method.
  final String? refreshToken;

  /// Creates a new instance of [LMChatAIButtonProps].
  ///
  /// Use either [apiKey], [uuid], and [userName] for non-token based authentication,
  /// or [accessToken] and [refreshToken] for token-based authentication.
  const LMChatAIButtonProps({
    this.apiKey,
    this.uuid,
    this.userName,
    this.imageUrl,
    this.isGuest,
    this.accessToken,
    this.refreshToken,
  });

  /// Checks if the props are empty.
  bool isEmpty() {
    return (apiKey == null || apiKey!.isEmpty) &&
        (uuid == null || uuid!.isEmpty) &&
        (userName == null || userName!.isEmpty) &&
        (imageUrl == null || imageUrl!.isEmpty) &&
        isGuest == null;
  }
}

/// Style class for customizing the appearance of [LMChatAIButton]
class LMChatAIButtonStyle {
  /// The text to be displayed on the button.
  /// Defaults to 'AI Bot' if not provided.
  final String? text;

  /// The size of the button text in logical pixels.
  /// Defaults to 14 if not provided.
  final double? textSize;

  /// The color of the button text.
  /// Defaults to white (0xFFFFFFFF) if not provided.
  final Color? textColor;

  /// The height of the button in logical pixels.
  final double? height;

  /// The width of the button in logical pixels.
  final double? width;

  /// The padding of the button in logical pixels.
  final EdgeInsets? padding;

  /// The background color of the button.
  /// Defaults to dark blue (0xFF020D42) if not provided.
  final Color? backgroundColor;

  /// The border radius of the button in logical pixels.
  /// Defaults to 28 if not provided.
  final double? borderRadius;

  /// The icon to be displayed on the button.
  /// If not provided, defaults to Icons.android.
  final IconData? icon;

  /// The placement of the icon relative to the text (start or end).
  /// Defaults to LMChatIconButtonPlacement.start.
  final LMChatIconButtonPlacement iconPlacement;

  const LMChatAIButtonStyle({
    this.text,
    this.textSize,
    this.textColor,
    this.backgroundColor,
    this.borderRadius,
    this.height,
    this.width,
    this.icon,
    this.iconPlacement = LMChatIconButtonPlacement.start,
    this.padding,
  });

  /// Basic style factory constructor; used as default style
  factory LMChatAIButtonStyle.basic() {
    return const LMChatAIButtonStyle(
      text: 'AI Bot',
      textSize: 16,
      textColor: Color(0xFFFFFFFF),
      backgroundColor: Color(0xFF020D42),
      borderRadius: 28,
      iconPlacement: LMChatIconButtonPlacement.start,
    );
  }

  /// Creates a copy of this style with the given fields replaced with new values
  LMChatAIButtonStyle copyWith({
    String? text,
    double? textSize,
    Color? textColor,
    Color? backgroundColor,
    double? borderRadius,
    IconData? icon,
    LMChatIconButtonPlacement? iconPlacement,
  }) {
    return LMChatAIButtonStyle(
      text: text ?? this.text,
      textSize: textSize ?? this.textSize,
      textColor: textColor ?? this.textColor,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      borderRadius: borderRadius ?? this.borderRadius,
      icon: icon ?? this.icon,
      iconPlacement: iconPlacement ?? this.iconPlacement,
    );
  }
}

/// A button widget that provides direct access to AI chatroom functionality.
///
/// This widget can be configured to use either token-based or API key-based authentication
/// through the [props] parameter.
class LMChatAIButton extends StatelessWidget {
  /// The text widget of the button
  final LMChatText? text;

  /// The icon widget of the button
  final LMChatIcon? icon;

  /// Style configuration for the button's appearance
  final LMChatAIButtonStyle? style;

  /// Configuration properties for the AI chatbot initialization.
  /// Contains authentication and user information.
  final LMChatAIButtonProps? props;

  /// Callback function that is called when the button is tapped.
  final VoidCallback? onTap;

  /// Callback function that is called when the button is long-pressed.
  final VoidCallback? onLongPress;

  const LMChatAIButton({
    super.key,
    this.text,
    this.icon,
    this.style,
    this.props,
    this.onTap,
    this.onLongPress,
  });

  /// Initializes the AI chatbot with token-based security.
  ///
  /// This method handles the authentication process using [accessToken] and [refreshToken],
  /// and navigates to the appropriate screen based on the chatroom state.
  ///
  /// Parameters:
  /// - [accessToken]: The access token for authentication
  /// - [refreshToken]: The refresh token for authentication
  /// - [context]: The build context for navigation
  ///
  /// Shows error message if the initialization fails.
  Future<void> startAIChatbotWithSecurity(
      String accessToken, String refreshToken, BuildContext context) async {
    final response = await LMChatCore.instance.showChatWithoutApiKey(
      accessToken: accessToken,
      refreshToken: refreshToken,
    );

    if (response.success) {
      final chatroomId =
          LMChatLocalPreference.instance.getChatroomIdWithAIChatbot();
      if (chatroomId != null) {
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => LMChatroomScreen(chatroomId: chatroomId)),
        );
      } else {
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => const LMChatAIBotInitiationScreen()),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(response.errorMessage ?? 'An error occurred')),
      );
    }
  }

  /// Initializes the AI chatbot without token-based security.
  ///
  /// This method handles the authentication process using API key and user information,
  /// and navigates to the appropriate screen based on the chatroom state.
  ///
  /// Parameters:
  /// - [apiKey]: The API key for authentication
  /// - [uuid]: The unique identifier of the user
  /// - [userName]: The display name of the user
  /// - [imageUrl]: Optional URL for the user's profile image
  /// - [isGuest]: Whether the user is a guest
  /// - [context]: The build context for navigation
  ///
  /// Shows error message if the initialization fails.
  Future<void> startAIChatbotWithoutSecurity(
      String apiKey,
      String uuid,
      String userName,
      String? imageUrl,
      bool isGuest,
      BuildContext context) async {
    final response = await LMChatCore.instance.showChatWithApiKey(
      apiKey: apiKey,
      uuid: uuid,
      userName: userName,
      imageUrl: imageUrl,
      isGuest: isGuest,
    );

    if (response.success) {
      final chatroomId =
          LMChatLocalPreference.instance.getChatroomIdWithAIChatbot();
      if (chatroomId != null) {
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => LMChatroomScreen(chatroomId: chatroomId)),
        );
      } else {
        Navigator.push(
          context,
          MaterialPageRoute(
              builder: (context) => const LMChatAIBotInitiationScreen()),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(response.errorMessage ?? 'An error occurred')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final inStyle = style ?? LMChatAIButtonStyle.basic();

    return LMChatButton(
      onTap: () async {
        onTap?.call();

        if (props != null) {
          if (props!.accessToken != null && props!.refreshToken != null) {
            // Start with API Key Security
            await startAIChatbotWithSecurity(
              props!.accessToken!,
              props!.refreshToken!,
              context,
            );
          } else if (props!.apiKey != null &&
              props!.uuid != null &&
              props!.userName != null) {
            // Start without API Key Security
            await startAIChatbotWithoutSecurity(
              props!.apiKey!,
              props!.uuid!,
              props!.userName!,
              props!.imageUrl,
              props!.isGuest ?? false,
              context,
            );
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content:
                    LMChatText('Invalid or insufficient credentials provided'),
              ),
            );
          }
        } else {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: LMChatText('No credentials provided'),
            ),
          );
        }
      },
      onLongPress: onLongPress,
      text: text ??
          LMChatText(
            inStyle.text ?? 'AI Bot',
            style: LMChatTextStyle(
              textStyle: TextStyle(
                color: inStyle.textColor,
                fontSize: inStyle.textSize,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
      icon: icon ??
          LMChatIcon(
            type:
                inStyle.icon == null ? LMChatIconType.svg : LMChatIconType.icon,
            icon: inStyle.icon,
            assetPath: kChatbotIcon,
            style: LMChatIconStyle(
              color: inStyle.textColor,
            ),
          ),
      style: LMChatButtonStyle(
        backgroundColor: inStyle.backgroundColor,
        borderRadius: inStyle.borderRadius,
        spacing: 6,
        height: inStyle.height,
        width: inStyle.width,
        padding: inStyle.padding ??
            const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        placement: inStyle.iconPlacement,
      ),
    );
  }
}



================================================
File: lib/packages/core/lib/src/widgets/chatroom/chatroom_bar.dart
================================================
import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/audio_handler.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/member_rights/member_rights.dart';
import 'package:flutter/services.dart';
import 'dart:math' as math;
import 'package:flutter_sound/flutter_sound.dart';

/// {@template lm_chatroom_bar}
/// A widget to display the chatroom bar.
/// It has a text field to type the message and send button.
/// {@endtemplate}
class LMChatroomBar extends StatefulWidget {
  /// [chatroom] is the chatroom for which the bar is to be displayed.
  final LMChatRoomViewData chatroom;

  /// [scrollToBottom] is the function to scroll to the bottom of the chat.
  final void Function(bool) scrollToBottom;

  /// [controller] is an optional [TextEditingController] that can be used to control the text input field.
  /// If provided, it allows external management of the text input, such as setting the text or listening for changes.
  final TextEditingController? controller;

  /// Indicates whether tagging is enabled in the chatroom bar.
  /// If true, users can tag other users in their messages.
  final bool? enableTagging;

  /// {@macro lm_chatroom_bar}
  const LMChatroomBar({
    super.key,
    required this.chatroom,
    required this.scrollToBottom,
    this.controller,
    this.enableTagging,
  });

  /// Creates a copy of this [LMChatroomBar] with the given fields replaced with new values.
  ///
  /// The [chatroom] parameter sets a new chatroom view data.
  /// The [scrollToBottom] parameter sets a new scroll to bottom callback function.
  /// The [controller] parameter sets a new text editing controller.
  /// The [enableTagging] parameter sets whether tagging is enabled.
  ///
  /// Returns a new [LMChatroomBar] instance with the updated values.
  LMChatroomBar copyWith({
    LMChatRoomViewData? chatroom,
    void Function(bool)? scrollToBottom,
    TextEditingController? controller,
    bool? enableTagging,
  }) {
    return LMChatroomBar(
      chatroom: chatroom ?? this.chatroom,
      scrollToBottom: scrollToBottom ?? this.scrollToBottom,
      controller: controller ?? this.controller,
      enableTagging: enableTagging ?? this.enableTagging,
    );
  }

  @override
  State<LMChatroomBar> createState() => _LMChatroomBarState();
}

class _LMChatroomBarState extends State<LMChatroomBar>
    with TickerProviderStateMixin {
  LMChatConversationViewData? replyToConversation;
  List<LMChatAttachmentViewData>? replyConversationAttachments;
  LMChatConversationViewData? editConversation;

  // Flutter and other dependecies needed
  final CustomPopupMenuController _popupMenuController =
      CustomPopupMenuController();
  late final TextEditingController _textEditingController;
  final FocusNode _focusNode = FocusNode();

  // Instances of BLoCs required
  LMChatConversationActionBloc chatActionBloc =
      LMChatConversationActionBloc.instance;
  LMChatConversationBloc conversationBloc = LMChatConversationBloc.instance;

  // Instance of current user and member state
  final LMChatUserViewData currentUser =
      LMChatLocalPreference.instance.getUser().toUserViewData();
  final MemberStateResponse? getMemberState =
      LMChatLocalPreference.instance.getMemberRights();
  final LMChatThemeData _themeData = LMChatTheme.instance.themeData;
  final _screenBuilder = LMChatCore.config.chatRoomConfig.builder;

  String? result;

  String previewLink = '';

  LMChatRoomViewData? chatroom;
  List<LMChatTagViewData> tags = [];
  LMChatMediaModel? linkModel;

  /// if set to false link preview should not be displayed
  bool showLinkPreview = true;

  /// if a message contains a link, this should be set to true
  bool isActiveLink = false;

  /// debounce timer for link preview
  Timer? _debounce;

  /// flag to check if a message is sent before the link preview is fetched
  bool _isSentBeforeLinkFetched = false;

  // Create a ValueNotifier to hold the text input state
  final ValueNotifier<String> _textInputNotifier = ValueNotifier<String>('');

  // Create a ValueNotifier to hold the voice button state
  final ValueNotifier<bool> _isVoiceButtonHeld = ValueNotifier<bool>(false);

  // Add these variables for recording state
  Timer? _recordingTimer;
  final ValueNotifier<Duration> _recordingDuration =
      ValueNotifier(Duration.zero);

  // Add this variable to track the current recording path
  String? _currentRecordingPath;

  // Add these variables for recording state management
  final ValueNotifier<bool> _isReviewingRecording = ValueNotifier<bool>(false);
  final ValueNotifier<PlaybackProgress> _playbackProgress = ValueNotifier(
    const PlaybackProgress(duration: Duration.zero, position: Duration.zero),
  );
  String? _recordedFilePath;

  // Add isPlaying ValueNotifier
  final ValueNotifier<bool> _isPlaying = ValueNotifier<bool>(false);

  // Add this near the top of the _LMChatroomBarState class
  late final AnimationController _breathingController;
  late final Animation<Color?> _breathingAnimation;

  // Add a new ValueNotifier for recording lock state
  final ValueNotifier<bool> _isRecordingLocked = ValueNotifier<bool>(false);

  final OverlayPortalController _overlayPortalController =
      OverlayPortalController();

  late final AnimationController _lockSlideController;
  late final Animation<double> _lockSlideAnimation;

  // Add these new controllers and animations near the other animation declarations
  late final AnimationController _cancelAnimationController;
  late final Animation<double> _micRotationAnimation;
  late final Animation<double> _micPositionAnimation;
  late final Animation<double> _binScaleAnimation;
  late final Animation<double> _binFadeAnimation;
  late final Animation<double> _micFadeAnimation;

  // Add this near other state variables in _LMChatroomBarState
  StreamSubscription<LMChatAudioState>? _audioStateSubscription;

  // Add near the top of _LMChatroomBarState class
  late final FlutterSoundPlayer _localPlayer;
  bool _isLocalPlayerInitialized = false;

  String getText() {
    if (_textEditingController.text.isNotEmpty) {
      return _textEditingController.text;
    } else {
      return "";
    }
  }

  void _onTextChanged(String message) {
    _textInputNotifier.value = message; // Update the ValueNotifier
    if (_debounce?.isActive ?? false) {
      _debounce?.cancel();
    }

    if (!showLinkPreview ||
        replyToConversation != null ||
        editConversation != null) {
      return;
    }

    _debounce = Timer(const Duration(milliseconds: 500), () {
      chatActionBloc.add(LMChatConversationTextChangeEvent(
        text: message,
        previousLink: previewLink,
      ));
    });
  }

  @override
  void initState() {
    super.initState();
    chatroom = widget.chatroom;
    _textEditingController = widget.controller ?? TextEditingController();
    _textEditingController.addListener(() {
      _onTextChanged(_textEditingController.text); // Notify on text change
    });

    // Setup breathing animation with continuous looping
    _breathingController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );

    _breathingAnimation = ColorTween(
      begin: Colors.red,
      end: _themeData.onContainer,
    ).animate(CurvedAnimation(
      parent: _breathingController,
      curve: Curves.easeInOut,
    ));

    // Initialize lock slide animation controller
    _lockSlideController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );

    _lockSlideAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _lockSlideController,
      curve: Curves.easeInOut,
    ));

    // Initialize cancel animation controller
    _cancelAnimationController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );

    // Mic rotation animation
    _micRotationAnimation = Tween<double>(
      begin: 0.0,
      end: 2 * math.pi, // Full 360 rotation
    ).animate(CurvedAnimation(
      parent: _cancelAnimationController,
      curve: const Interval(0.0, 0.5, curve: Curves.easeInOut),
    ));

    // Mic position animation (moving upward then down)
    _micPositionAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 0, end: -50),
        weight: 40,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: -50, end: 0),
        weight: 60,
      ),
    ]).animate(CurvedAnimation(
      parent: _cancelAnimationController,
      curve: Curves.easeInOut,
    ));

    // Bin scale animation
    _binScaleAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 0, end: 1.2),
        weight: 40,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.2, end: 1.0),
        weight: 20,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1.0, end: 0),
        weight: 40,
      ),
    ]).animate(CurvedAnimation(
      parent: _cancelAnimationController,
      curve: Curves.easeInOut,
    ));

    // Bin fade animation
    _binFadeAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween<double>(begin: 0, end: 1),
        weight: 20,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1, end: 1),
        weight: 60,
      ),
      TweenSequenceItem(
        tween: Tween<double>(begin: 1, end: 0),
        weight: 20,
      ),
    ]).animate(CurvedAnimation(
      parent: _cancelAnimationController,
      curve: Curves.easeInOut,
    ));

    // Mic fade animation
    _micFadeAnimation = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _cancelAnimationController,
      curve: const Interval(0.6, 1.0, curve: Curves.easeOut),
    ));

    // Subscribe to audio state changes
    _audioStateSubscription =
        LMChatCoreAudioHandler.instance.audioStateStream.listen((state) {
      if (state == LMChatAudioState.stopped) {
        _resetRecordingState();
      }
    });

    _localPlayer = FlutterSoundPlayer();
    _initLocalPlayer();
  }

  @override
  void dispose() {
    // Clean up recording related resources
    _stopRecordingTimer();
    if (_isRecordingLocked.value || _isReviewingRecording.value) {
      LMChatCoreAudioHandler.instance.cancelRecording();
    }
    if (_isPlaying.value) {
      _stopLocalPlayback();
    }
    if (_isLocalPlayerInitialized) {
      _localPlayer.closePlayer();
    }

    // Clean up all controllers and subscriptions
    _popupMenuController.dispose();
    _textEditingController.dispose();
    _focusNode.dispose();
    _debounce?.cancel();
    _textInputNotifier.dispose();
    _recordingTimer?.cancel();
    _recordingDuration.dispose();
    _isReviewingRecording.dispose();
    _playbackProgress.dispose();
    _isVoiceButtonHeld.dispose();
    _isPlaying.dispose();
    _breathingController.dispose();
    _isRecordingLocked.dispose();
    _lockSlideController.dispose();
    _cancelAnimationController.dispose();
    _audioStateSubscription?.cancel();

    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        BlocConsumer<LMChatConversationActionBloc,
            LMChatConversationActionState>(
          bloc: chatActionBloc,
          listener: _blocListener,
          builder: (context, state) {
            return _screenBuilder.chatroomBottomBarContainer(
              context,
              _defTextFieldContainer(),
              _defSendButton(context),
              _defVoiceOverlayLayout(context),
              _defInnerTextField(context),
              _defAttachmentButton(),
            );
          },
        ),
      ],
    );
  }

  Container _defTextFieldContainer() {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.only(
        left: 2.w,
        right: 2.w,
        top: 1.5.h,
        bottom: (isOtherUserAIChatbot(chatroom!)) ? 0 : 1.5.h,
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: [
          ValueListenableBuilder<bool>(
            valueListenable: _isVoiceButtonHeld,
            builder: (context, isHeld, child) {
              return isHeld || _isReviewingRecording.value
                  ? _defRecordingContainer(context)
                  : _isRespondingAllowed()
                      ? _defTextField(context)
                      : _defDisabledTextField(context);
            },
          ),
          _isRespondingAllowed()
              ? ValueListenableBuilder<bool>(
                  valueListenable: _isRecordingLocked,
                  builder: (context, isLocked, child) {
                    return ValueListenableBuilder<bool>(
                      valueListenable: _isReviewingRecording,
                      builder: (context, isReviewing, child) {
                        return ValueListenableBuilder<String>(
                          valueListenable: _textInputNotifier,
                          builder: (context, text, child) {
                            final shouldShowSendButton =
                                text.trim().isNotEmpty ||
                                    isReviewing ||
                                    isLocked ||
                                    (widget.chatroom.type == 10 &&
                                        isOtherUserAIChatbot(widget.chatroom));

                            return AnimatedSwitcher(
                              duration: const Duration(milliseconds: 200),
                              transitionBuilder: (child, animation) {
                                // combine the scale with a fade
                                return FadeTransition(
                                  opacity: animation,
                                  child: ScaleTransition(
                                    scale: animation,
                                    child: child,
                                  ),
                                );
                              },
                              child: shouldShowSendButton
                                  ? _screenBuilder.sendButton(
                                      context,
                                      _textEditingController,
                                      _onSend,
                                      _defSendButton(context),
                                    )
                                  : _defVoiceOverlayLayout(context),
                            );
                          },
                        );
                      },
                    );
                  },
                )
              : const SizedBox.shrink(),
        ],
      ),
    );
  }

  Widget _defaultLockRecordingOverlay() {
    return ValueListenableBuilder<bool>(
      valueListenable: _isVoiceButtonHeld,
      builder: (context, isHeld, child) {
        return Visibility(
          visible: isHeld,
          child: Positioned(
            bottom: 50,
            child: AnimatedBuilder(
              animation: _lockSlideAnimation,
              builder: (context, child) {
                return Container(
                  height: 100,
                  width: 48,
                  decoration: BoxDecoration(
                    color: _themeData.container,
                    borderRadius: BorderRadius.circular(24),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.1),
                        blurRadius: 8,
                        offset: const Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      AnimatedSwitcher(
                          duration: const Duration(milliseconds: 200),
                          child: _screenBuilder.voiceNotesLockIcon(
                              context,
                              LMChatIcon(
                                type: LMChatIconType.icon,
                                icon: _lockSlideAnimation.value > 0.7
                                    ? Icons.lock_outline
                                    : Icons.lock_open_outlined,
                                key: ValueKey(_lockSlideAnimation.value > 0.7),
                                style: LMChatIconStyle(
                                  color: _themeData.onContainer.withOpacity(
                                    0.3 + (_lockSlideAnimation.value * 0.7),
                                  ),
                                  size: 24,
                                ),
                              ),
                              _lockSlideAnimation.value)),
                      const SizedBox(height: 8),
                      Container(
                        height: 48,
                        width: 2,
                        decoration: BoxDecoration(
                          color: _themeData.onContainer.withOpacity(0.2),
                          borderRadius: BorderRadius.circular(1),
                        ),
                      ),
                    ],
                  ),
                );
              },
            ),
          ),
        );
      },
    );
  }

  Widget _defVoiceOverlayLayout(BuildContext context) {
    if (widget.chatroom.type == 10 && isOtherUserAIChatbot(widget.chatroom)) {
      return const SizedBox.shrink();
    }

    return Stack(
      fit: StackFit.passthrough,
      clipBehavior: Clip.none,
      children: [
        _defaultLockRecordingOverlay(),
        _defVoiceButtonBuilder(context),
      ],
    );
  }

  Widget _defTextField(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (editConversation != null)
          _screenBuilder.editTextTextFieldHeader(
            context,
            _textEditingController,
            _defEditConversationWidget(),
          ),
        if (replyToConversation != null)
          _screenBuilder.replyTextFieldHeader(
            context,
            _textEditingController,
            _defReplyConversationWidget(),
          ),
        if (isActiveLink &&
            replyToConversation == null &&
            editConversation == null &&
            !_isSentBeforeLinkFetched)
          _screenBuilder.linkPreviewBar(
            context,
            _defLinkPreview(linkModel!.ogTags!),
          ),
        Container(
          width: 80.w,
          constraints: BoxConstraints(
            minHeight: 5.2.h,
            maxHeight: 24.h,
          ),
          child: _screenBuilder.chatroomTextField(
            context,
            _textEditingController,
            _defInnerTextField(context),
            _defAttachmentButton(),
          ),
        ),
      ],
    );
  }

  // Widget functions for the default widgets of LMChatroomBar
  Widget _defDisabledTextField(BuildContext context) {
    return Container(
      width: 90.w,
      constraints: BoxConstraints(
        minHeight: 4.h,
        maxHeight: 6.h,
      ),
      decoration: BoxDecoration(
        color: _themeData.container,
        borderRadius: BorderRadius.circular(24),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(
          horizontal: kPaddingSmall,
          vertical: kPaddingSmall,
        ),
        child: LMChatTextField(
          isDown: false,
          enabled: false,
          isSecret: widget.chatroom.isSecret ?? false,
          chatroomId: widget.chatroom.id,
          style: Theme.of(context).textTheme.bodyMedium!.copyWith(fontSize: 14),
          onTagSelected: (tag) {},
          onChange: (value) {},
          controller: _textEditingController,
          decoration: InputDecoration(
            border: InputBorder.none,
            enabled: false,
            hintMaxLines: 1,
            hintStyle:
                Theme.of(context).textTheme.bodyMedium!.copyWith(fontSize: 14),
            hintText: _getChatBarHintText(),
          ),
          focusNode: FocusNode(),
        ),
      ),
    );
  }

  LMChatTextField _defInnerTextField(BuildContext context) {
    return LMChatTextField(
      key: const ObjectKey('chatTextField'),
      isDown: false,
      enabled: widget.enableTagging ?? true,
      scrollPhysics: const AlwaysScrollableScrollPhysics(),
      isSecret: widget.chatroom.isSecret ?? false,
      chatroomId: widget.chatroom.id,
      onKeyboardFocusChange: (bool val) {
        if (!val) {
          // keyboard has been closed
          _popupMenuController.hideMenu();
        }
      },
      style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            fontSize: 14,
            color: LMChatTheme.theme.onContainer,
          ),
      onTagSelected: (tag) {
        tags.add(tag);
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.userTagsSomeone,
            eventProperties: {
              'community_id': widget.chatroom.id,
              'chatroom_name': widget.chatroom.header,
              'tagged_user_id': tag.sdkClientInfoViewData?.uuid,
              'tagged_user_name': tag.name,
            },
          ),
        );
      },
      onChange: _onTextChanged,
      controller: _textEditingController,
      decoration: InputDecoration(
        border: OutlineInputBorder(
          borderRadius: editConversation == null &&
                  replyToConversation == null &&
                  !isActiveLink
              ? BorderRadius.circular(24)
              : const BorderRadius.vertical(
                  bottom: Radius.circular(24),
                ),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: editConversation == null &&
                  replyToConversation == null &&
                  !isActiveLink
              ? BorderRadius.circular(24)
              : const BorderRadius.vertical(
                  bottom: Radius.circular(24),
                ),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: editConversation == null &&
                  replyToConversation == null &&
                  !isActiveLink
              ? BorderRadius.circular(24)
              : const BorderRadius.vertical(
                  bottom: Radius.circular(24),
                ),
          borderSide: BorderSide.none,
        ),
        enabled: true,
        hintMaxLines: 1,
        hintStyle: TextStyle(
          fontSize: 14,
          color: _themeData.inActiveColor,
        ),
        hintText: _getChatBarHintText(),
        suffixIcon: _defAttachmentButton(),
        fillColor: _themeData.container,
        filled: true,
      ),
      focusNode: _focusNode,
    );
  }

  Widget _defRecordingContainer(BuildContext context) {
    return ValueListenableBuilder<bool>(
      valueListenable: _isReviewingRecording,
      builder: (context, isReviewing, child) {
        return isReviewing
            ? _buildReviewContainer(context)
            : _buildRecordingContainer(context);
      },
    );
  }

  Widget _buildRecordingContainer(BuildContext context) {
    return ValueListenableBuilder<bool>(
      valueListenable: _isRecordingLocked,
      builder: (context, isLocked, child) {
        return Stack(
          clipBehavior: Clip.none,
          children: [
            Container(
              width: 80.w,
              height: 6.2.h,
              decoration: BoxDecoration(
                color: _themeData.container,
                borderRadius: BorderRadius.circular(24),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: Row(
                      children: [
                        AnimatedBuilder(
                          animation: _cancelAnimationController,
                          builder: (context, child) {
                            return Opacity(
                              opacity: _micFadeAnimation.value,
                              child: Transform.translate(
                                offset: Offset(0, _micPositionAnimation.value),
                                child: Transform.rotate(
                                  angle: _micRotationAnimation.value,
                                  child: Padding(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 16),
                                    child: _buildRecordingIndicator(),
                                  ),
                                ),
                              ),
                            );
                          },
                        ),
                        ValueListenableBuilder<Duration>(
                          valueListenable: _recordingDuration,
                          builder: (context, duration, child) {
                            return Text(
                              "${duration.inMinutes.toString().padLeft(2, '0')}:${(duration.inSeconds % 60).toString().padLeft(2, '0')}",
                              style: TextStyle(
                                fontSize: 14,
                                fontWeight: FontWeight.w500,
                                color: LMChatTheme.theme.onContainer,
                              ),
                            );
                          },
                        ),
                      ],
                    ),
                  ),
                  if (isLocked)
                    Row(
                      children: [
                        LMChatButton(
                          onTap: () async {
                            final audioHandler =
                                LMChatCoreAudioHandler.instance;
                            final recordedDuration = _recordingDuration.value;
                            _stopRecordingTimer();

                            final recordingPath =
                                await audioHandler.stopRecording(
                              recordedDuration: recordedDuration,
                            );

                            if (recordingPath != null) {
                              if (recordedDuration.inSeconds < 1) {
                                toast("Voice recording too short");
                                _handleDeleteRecording();
                                return;
                              }

                              _recordedFilePath = recordingPath;
                              _isReviewingRecording.value = true;
                              _isVoiceButtonHeld.value = false;
                              _isRecordingLocked.value = false;

                              _playbackProgress.value = PlaybackProgress(
                                duration: recordedDuration,
                                position: Duration.zero,
                              );

                              // Setup playback progress listener
                              audioHandler
                                  .getProgressStream(recordingPath)
                                  .listen(
                                (progress) {
                                  _playbackProgress.value = PlaybackProgress(
                                    duration: recordedDuration,
                                    position: progress.position,
                                    isCompleted: progress.isCompleted,
                                  );
                                  if (progress.isCompleted == true) {
                                    _isPlaying.value = false;
                                  }
                                },
                                onError: (error) {
                                  debugPrint('Playback error: $error');
                                  _handleRecordingError();
                                },
                              );
                            }
                          },
                          style: LMChatButtonStyle(
                            height: 28,
                            width: 28,
                            backgroundColor: _themeData.container,
                          ),
                          icon: const LMChatIcon(
                            type: LMChatIconType.icon,
                            icon: Icons.stop_circle,
                            style: LMChatIconStyle(
                              size: 28,
                              color: Colors.red,
                            ),
                          ),
                        ),
                        const SizedBox(width: 8),
                        LMChatButton(
                          onTap: () {
                            _handleDeleteRecording();
                            _isRecordingLocked.value = false;
                            toast("Voice recording cancelled");
                          },
                          style: LMChatButtonStyle(
                            height: 28,
                            width: 28,
                            backgroundColor: _themeData.container,
                          ),
                          icon: LMChatIcon(
                            type: LMChatIconType.icon,
                            icon: Icons.cancel_outlined,
                            style: LMChatIconStyle(
                              size: 28,
                              color: _themeData.inActiveColor,
                            ),
                          ),
                        ),
                        const SizedBox(width: 16),
                      ],
                    )
                  else
                    Padding(
                      padding: const EdgeInsets.only(right: 16),
                      child: AnimatedBuilder(
                        animation: _cancelAnimationController,
                        builder: (context, child) {
                          return Opacity(
                            opacity: 1 - _cancelAnimationController.value,
                            child: Row(
                              children: [
                                Icon(
                                  Icons.arrow_back,
                                  size: 16,
                                  color: _themeData.inActiveColor,
                                ),
                                const SizedBox(width: 4),
                                Text(
                                  "Slide to cancel",
                                  style: TextStyle(
                                    fontSize: 12,
                                    color: _themeData.inActiveColor,
                                  ),
                                ),
                              ],
                            ),
                          );
                        },
                      ),
                    ),
                ],
              ),
            ),
            // Move bin animation overlay to align with mic
            Positioned(
              left: 16, // Keep aligned with mic horizontally
              bottom: 8, // Adjust to better align with mic's resting position
              child: AnimatedBuilder(
                animation: _cancelAnimationController,
                builder: (context, child) {
                  return Opacity(
                    opacity: _binFadeAnimation.value,
                    child: Transform.scale(
                      scale: _binScaleAnimation.value,
                      child: Icon(
                        Icons.delete_outline,
                        size: 28, // Match mic icon size
                        color: _themeData.onContainer,
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildReviewContainer(BuildContext context) {
    return Container(
      width: 80.w,
      height: 6.2.h,
      padding: const EdgeInsets.symmetric(horizontal: 12),
      decoration: BoxDecoration(
        color: _themeData.container,
        borderRadius: BorderRadius.circular(24),
      ),
      child: Row(
        children: [
          ValueListenableBuilder<bool>(
            valueListenable: _isPlaying,
            builder: (context, isPlaying, child) {
              return LMChatButton(
                onTap: () => _handlePlayPause(),
                style: LMChatButtonStyle(
                  height: 28,
                  width: 28,
                  backgroundColor: _themeData.container,
                ),
                icon: LMChatIcon(
                  type: LMChatIconType.icon,
                  icon: isPlaying ? Icons.pause : Icons.play_arrow_rounded,
                  style: LMChatIconStyle(
                    color: _themeData.onContainer,
                    size: 28,
                  ),
                ),
              );
            },
          ),
          const SizedBox(width: 8),
          ValueListenableBuilder<PlaybackProgress>(
            valueListenable: _playbackProgress,
            builder: (context, progress, child) {
              final position = progress.position;
              final duration = progress.duration;
              return Text(
                "${position.inMinutes.toString().padLeft(2, '0')}:${(position.inSeconds % 60).toString().padLeft(2, '0')} / "
                "${duration.inMinutes.toString().padLeft(2, '0')}:${(duration.inSeconds % 60).toString().padLeft(2, '0')}",
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w400,
                  color: LMChatTheme.theme.onContainer,
                ),
              );
            },
          ),
          const Spacer(),
          LMChatButton(
            onTap: () => _handleDeleteRecording(),
            style: LMChatButtonStyle(
              height: 28,
              width: 28,
              backgroundColor: _themeData.container,
            ),
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.cancel_outlined,
              style: LMChatIconStyle(
                size: 28,
                color: _themeData.inActiveColor,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecordingIndicator() {
    return AnimatedBuilder(
      animation: _breathingAnimation,
      builder: (context, child) {
        return Container(
          height: 28, // Increased container size
          width: 28, // Increased container size
          decoration: BoxDecoration(
            color: _themeData.container,
            borderRadius: BorderRadius.circular(12),
          ),
          child: LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.mic,
            style: LMChatIconStyle(
              size: 18, // Increased icon size
              color: _breathingAnimation.value,
            ),
          ),
        );
      },
    );
  }

  // Add these methods to handle the review actions
  void _handlePlayPause() async {
    if (_recordedFilePath == null) return;

    try {
      if (_isPlaying.value) {
        await _stopLocalPlayback();
      } else {
        await _handleLocalPlayback();
      }
    } catch (e) {
      debugPrint('Error handling play/pause: $e');
      _isPlaying.value = false;
    }
  }

  void _handleDeleteRecording() async {
    try {
      // Stop recording timer first
      _stopRecordingTimer();

      // Stop any ongoing playback
      if (_isPlaying.value) {
        await _stopLocalPlayback();
      }

      // Cancel any ongoing recording
      if (_isVoiceButtonHeld.value) {
        await LMChatCoreAudioHandler.instance.cancelRecording();
      }
      // Delete the recorded file if it exists
      else if (_recordedFilePath != null) {
        final file = File(_recordedFilePath!);
        if (await file.exists()) {
          await file.delete();
        }
      }

      _resetRecordingState();
    } catch (e) {
      debugPrint('Error handling recording deletion: $e');
      _resetRecordingState(); // Ensure state is reset even if error occurs
    }
  }

  void _resetRecordingState() {
    if (!mounted) return;

    _stopRecordingTimer();
    _isReviewingRecording.value = false;
    _isVoiceButtonHeld.value = false;
    _isRecordingLocked.value = false;
    _isReviewingRecording.value = false;
    _isPlaying.value = false;
    _recordedFilePath = null;
    _currentRecordingPath = null;
    _playbackProgress.value = const PlaybackProgress(
      duration: Duration.zero,
      position: Duration.zero,
    );
    _recordingDuration.value = Duration.zero;
    _lockSlideController.value = 0.0;
    _cancelAnimationController.reset();

    // Reset breathing animation
    _breathingController.stop();
    _breathingController.reset();

    if (mounted) {
      setState(() {});
    }
  }

  LMChatButton _defSendButton(BuildContext context) {
    return LMChatButton(
      onTap: _onSend,
      style: LMChatButtonStyle(
        backgroundColor: _themeData.primaryColor,
        borderRadius: 100,
        height: 50,
        width: 50,
      ),
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.send,
        style: LMChatIconStyle(
          size: 26,
          boxSize: 26,
          boxPadding: const EdgeInsets.only(left: 2),
          color: _themeData.container,
        ),
      ),
    );
  }

  Widget _defVoiceButtonBuilder(BuildContext context) {
    return ValueListenableBuilder<bool>(
      valueListenable: _isVoiceButtonHeld,
      builder: (context, isHeld, child) {
        return _screenBuilder.voiceNotesButton(context, _defVoiceNoteButton());
      },
    );
  }

  LMChatButton _defVoiceNoteButton() {
    return LMChatButton(
      gesturesEnabled: true,
      onTap: () {
        HapticFeedback.lightImpact();
        toast(
          "Hold to start recording",
          duration: const Duration(milliseconds: 300),
        );
      },
      onLongPress: () {
        // Set held state before starting recording
        _isVoiceButtonHeld.value = true;
        _startRecording();
      },
      onHorizontalDragUpdate: (details) {
        if (_isVoiceButtonHeld.value) {
          if (details.delta.dx < -120) {
            if (!_cancelAnimationController.isAnimating) {
              // Let the voice button return to original position immediately
              // but keep recording container visible until animation completes
              _cancelAnimationController.forward().then((_) {
                // Only update voice button held state after animation
                _isVoiceButtonHeld.value = false;
                HapticFeedback.lightImpact();
                _stopRecordingTimer();
                _handleDeleteRecording();
                _cancelAnimationController.reset();
                toast(
                  "Voice recording cancelled",
                  duration: const Duration(milliseconds: 300),
                );
              });
            }
          }
        }
      },
      onVerticalDragUpdate: (details) {
        if (_isVoiceButtonHeld.value) {
          // Calculate the progress based on drag distance
          // Assuming 75 is the threshold for locking
          final progress = math.min(1.0, -details.delta.dy / 75);
          _lockSlideController.value = progress;

          if (details.delta.dy < -75) {
            HapticFeedback.lightImpact();
            _isRecordingLocked.value = true;
            toast(
              "Voice recording locked",
              duration: const Duration(milliseconds: 300),
            );
            _overlayPortalController.hide();
          }
        }
      },
      onLongPressEnd: (details) async {
        _overlayPortalController.hide();
        _lockSlideController.value = 0.0; // Reset the animation

        // If recording is locked or animation is playing, don't stop recording
        if (_isRecordingLocked.value ||
            _cancelAnimationController.isAnimating) {
          return;
        }

        if (!_isVoiceButtonHeld.value) return;

        try {
          final audioHandler = LMChatCoreAudioHandler.instance;
          HapticFeedback.mediumImpact();

          final recordedDuration = _recordingDuration.value;
          _stopRecordingTimer();

          final recordingPath = await audioHandler.stopRecording(
            recordedDuration: recordedDuration,
          );

          if (recordingPath != null) {
            if (recordedDuration.inSeconds < 1) {
              toast("Voice recording too short");
              _handleDeleteRecording();
              return;
            }

            _recordedFilePath = recordingPath;
            _isReviewingRecording.value = true;
            _isVoiceButtonHeld.value = false;

            _playbackProgress.value = PlaybackProgress(
              duration: recordedDuration,
              position: Duration.zero,
            );

            audioHandler.getProgressStream(recordingPath).listen(
              (progress) {
                _playbackProgress.value = PlaybackProgress(
                  duration: recordedDuration,
                  position: progress.position,
                  isCompleted: progress.isCompleted,
                );
                if (progress.isCompleted == true) {
                  _isPlaying.value = false;
                }
              },
              onError: (error) {
                debugPrint('Playback error: $error');
                _handleRecordingError();
              },
            );
          } else {
            _resetRecordingState();
          }
        } catch (e) {
          debugPrint('Voice recording error: $e');
          _handleRecordingError();
        }
      },
      style: LMChatButtonStyle(
        backgroundColor: _themeData.primaryColor,
        borderRadius: 100,
        height: 50,
        width: 50,
        scaleOnLongPress: 1.6,
      ),
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.mic,
        style: LMChatIconStyle(
          size: 26,
          boxSize: 26,
          color: _themeData.container,
        ),
      ),
    );
  }

  CustomPopupMenu? _defAttachmentButton() {
    return _isRespondingAllowed()
        ? CustomPopupMenu(
            controller: _popupMenuController,
            enablePassEvent: false,
            arrowColor: Colors.white,
            showArrow: false,
            menuBuilder: () => _defAttachmentMenu(),
            pressType: PressType.singleClick,
            child: _defAttachmentIcon(),
          )
        : null;
  }

  Widget _defAttachmentMenu() {
    // First determine which buttons should be visible based on conditions
    final List<LMAttachmentMenuItemData> menuItems = _getVisibleMenuItems();

    return LMChatCore.config.chatRoomConfig.builder.attachmentMenuBuilder(
      context,
      menuItems,
      LMAttachmentMenu(
        items: menuItems,
        style: LMAttachmentMenuStyle(
          backgroundColor: _themeData.container,
          menuItemStyle: LMAttachmentMenuItemStyle(
            iconColor: _themeData.container,
            backgroundColor: _themeData.primaryColor,
            labelTextStyle: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: _themeData.onContainer,
                    ) ??
                const TextStyle(),
          ),
        ),
      ),
    );
  }

  List<LMAttachmentMenuItemData> _getVisibleMenuItems() {
    final bool isAIChatbot =
        widget.chatroom.type == 10 && isOtherUserAIChatbot(widget.chatroom);
    final bool showDocuments = !isAIChatbot;
    final bool showPoll = widget.chatroom.type != 10;
    final bool showGIF = !isAIChatbot;

    final List<LMAttachmentMenuItemData> items = [
      LMAttachmentMenuItemData(
        icon: Icons.camera_alt_outlined,
        label: 'Camera',
        onTap: () async {
          _popupMenuController.hideMenu();
          final res = await LMChatMediaHandler.instance.pickSingleImage();
          if (res.data != null) {
            _navigateToForwarding();
          } else if (res.errorMessage != null) {
            toast(res.errorMessage!);
          }
        },
      ),
      LMAttachmentMenuItemData(
        icon: Icons.photo_outlined,
        label: 'Gallery',
        onTap: () async {
          _popupMenuController.hideMenu();
          final res = await LMChatMediaHandler.instance.pickMedia(
            mediaCount: isAIChatbot ? 1 : 10,
          );
          if (res.data != null) {
            _navigateToForwarding();
          } else if (res.errorMessage != null) {
            toast(res.errorMessage!);
          }
        },
      ),
      if (showDocuments)
        LMAttachmentMenuItemData(
          icon: Icons.insert_drive_file_outlined,
          label: 'Documents',
          onTap: () async {
            _popupMenuController.hideMenu();
            final res = await LMChatMediaHandler.instance.pickDocuments();
            if (res.data != null) {
              _navigateToForwarding();
            } else if (res.errorMessage != null) {
              toast(res.errorMessage!);
            }
          },
        ),
      if (showGIF)
        LMAttachmentMenuItemData(
          icon: Icons.gif_box_outlined,
          label: 'GIF',
          onTap: () async {
            _popupMenuController.hideMenu();
            final res = await LMChatMediaHandler.instance.pickGIF(context);
            if (res.data != null) {
              _navigateToForwarding();
            } else if (res.errorMessage != null) {
              toast(res.errorMessage!);
            }
          },
        ),
      if (showPoll)
        LMAttachmentMenuItemData(
          iconType: LMChatIconType.svg,
          assetPath: kPollIcon,
          label: 'Poll',
          onTap: () async {
            // hide pop up menu
            _popupMenuController.hideMenu();
            // close keyboard if opened
            _focusNode.unfocus();
            // navigate to create poll screen
            context.push(
              LMChatCreatePollScreen(
                chatroomId: widget.chatroom.id,
              ),
            );
          },
        ),
    ];

    return items;
  }

  LMChatIcon _defAttachmentIcon() {
    return LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.attachment,
      style: LMChatIconStyle(
        size: 24,
        boxSize: 48,
        color: _themeData.inActiveColor,
      ),
    );
  }

  LMChatBarHeader _defReplyConversationWidget() {
    String message = getGIFText(replyToConversation!);
    String userText = replyToConversation?.member?.name ?? '';
    if (replyToConversation?.memberId == currentUser.id) {
      userText = 'You';
    }
    return LMChatBarHeader(
      style: LMChatBarHeaderStyle.basic().copyWith(height: 8.h),
      titleText: userText,
      onCanceled: () {
        chatActionBloc.add(LMChatReplyRemoveEvent());
      },
      subtitle: ((replyToConversation?.attachmentsUploaded ?? false) &&
              replyToConversation?.deletedByUserId == null)
          ? getChatItemAttachmentTile(
              message, replyConversationAttachments ?? [], replyToConversation!)
          : LMChatText(
              replyToConversation!.state != 0
                  ? LMChatTaggingHelper.extractStateMessage(message)
                  : LMChatTaggingHelper.convertRouteToTag(
                        message,
                        withTilde: false,
                      ) ??
                      "Replying to Conversation",
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  fontSize: 14,
                  color: LMChatTheme.theme.onContainer,
                  fontWeight: FontWeight.w400,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
    );
  }

  LMChatBarHeader _defEditConversationWidget() {
    return LMChatBarHeader(
      style: LMChatBarHeaderStyle.basic(),
      title: LMChatText(
        "Edit message",
        style: LMChatTextStyle(
          textStyle: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: LMChatTheme.theme.onContainer,
              ),
          maxLines: 1,
        ),
      ),
      onCanceled: () {
        chatActionBloc.add(LMChatEditRemoveEvent());
        _textEditingController.clear();
      },
      subtitle: LMChatText(
        LMChatTaggingHelper.convertRouteToTag(
              editConversation?.answer,
              withTilde: false,
            ) ??
            "",
        style: LMChatTextStyle(
          textStyle: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: LMChatTheme.theme.onContainer,
              ),
        ),
      ),
    );
  }

  LMChatLinkPreviewBar _defLinkPreview(LMChatOGTagsViewData ogTags) {
    return LMChatLinkPreviewBar(
      ogTags: ogTags,
      style: LMChatLinkPreviewBarStyle.basic(
        inActiveColor: _themeData.inActiveColor,
        containerColor: _themeData.onContainer,
      ),
      onCanceled: () {
        chatActionBloc.add(
          LMChatLinkPreviewRemovedEvent(
            isPermanentlyRemoved: true,
          ),
        );
      },
    );
  }

  void _blocListener(context, state) {
    if (state is LMChatEditConversationState) {
      replyToConversation = null;
      editConversation = state.editConversation;
      _setupEditText();
    } else if (state is LMChatEditRemoveState) {
      editConversation = null;
      _setupEditText();
    } else if (state is LMChatReplyConversationState) {
      editConversation = null;
      _setupEditText();
      replyToConversation = state.conversation;
      replyConversationAttachments = state.attachments;
      _focusNode.requestFocus();
    } else if (state is LMChatReplyRemoveState) {
      replyToConversation = null;
      _focusNode.requestFocus();
    } else if (state is LMChatRefreshBarState) {
      chatroom = state.chatroom;
    } else if (state is LMChatLinkAttachedState) {
      // to prevent the link preview from being displayed if the message is sent before the link preview is fetched
      if (_isSentBeforeLinkFetched) {
        _isSentBeforeLinkFetched = false;
        bool isCurrentTextHasLink =
            LMChatTaggingHelper.getFirstValidLinkFromString(
                    _textEditingController.text)
                .isNotEmpty;
        if (!isCurrentTextHasLink) {
          return;
        }
      }
      linkModel = LMChatMediaModel(
        mediaType: LMChatMediaType.link,
        ogTags: state.ogTags,
        link: state.link,
      );
      previewLink = state.link;
      isActiveLink = true;
    } else if (state is LMChatLinkRemovedState) {
      linkModel = null;
      previewLink = '';
      isActiveLink = false;
      showLinkPreview = !state.isPermanentlyRemoved;
    }
  }

  // Handler functions of the LMChatroomBar
  void _onSend() async {
    final message = _textEditingController.text.trim();

    // If recording is locked, stop recording first and then send
    if (_isRecordingLocked.value) {
      try {
        final audioHandler = LMChatCoreAudioHandler.instance;
        final recordedDuration = _recordingDuration.value;
        _stopRecordingTimer();

        final recordingPath = await audioHandler.stopRecording(
          recordedDuration: recordedDuration,
        );

        if (recordingPath != null) {
          if (recordedDuration.inSeconds < 1) {
            toast("Voice recording too short");
            _handleDeleteRecording();
            return;
          }
          _recordedFilePath = recordingPath;
          _isReviewingRecording.value = true;
          _isVoiceButtonHeld.value = false;
          _isRecordingLocked.value = false;
        }
      } catch (e) {
        debugPrint('Error stopping recording: $e');
        toast("Error stopping recording");
        _resetRecordingState();
        return;
      }
    }

    if (message.isEmpty &&
        !_isReviewingRecording.value &&
        !_isRecordingLocked.value) {
      toast("Text can't be empty");
      return;
    }

    _isSentBeforeLinkFetched = true;
    tags = LMChatTaggingHelper.matchTags(message, tags);
    result = LMChatTaggingHelper.encodeString(message, tags).trim();

    _logAnalyticsEvent();

    if (editConversation != null) {
      _handleEditConversation();
    } else if (_isReviewingRecording.value) {
      _handleSendVoiceNote();
    } else {
      _handleNewMessage();
    }

    _handleChatroomStatus();
    _resetMessageInput();
  }

  void _logAnalyticsEvent() {
    if (replyToConversation != null) {
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.messageReply,
          eventProperties: {
            'type': 'text',
            'chatroom_id': chatroom?.id,
            'replied_to_member_id': replyToConversation!.memberId ??
                replyToConversation?.member?.id,
            'replied_to_member_state': replyToConversation!.member?.state,
            'replied_to_message_id': replyToConversation!.id,
          },
        ),
      );
    }
  }

  void _handleEditConversation() {
    linkModel = null;
    LMChatAnalyticsBloc.instance.add(
      LMChatFireAnalyticsEvent(
        eventName: LMChatAnalyticsKeys.messageEdited,
        eventProperties: {
          'type': 'text',
          'chatroom_id': chatroom?.id,
        },
      ),
    );
    chatActionBloc.add(LMChatEditConversationEvent(
      (EditConversationRequestBuilder()
            ..conversationId(editConversation!.id)
            ..text(result!))
          .build(),
      replyConversation:
          editConversation!.replyConversationObject?.toConversation(),
    ));
    _updateLinkPreviewState();
    widget.scrollToBottom(true);
  }

  void _handleNewMessage() {
    if (isActiveLink && linkModel != null) {
      final extractedLink =
          LMChatTaggingHelper.getFirstValidLinkFromString(result!);
      if (extractedLink.isEmpty) return;

      conversationBloc.add(
        LMChatPostMultiMediaConversationEvent(
          (PostConversationRequestBuilder()
                ..chatroomId(widget.chatroom.id)
                ..temporaryId(DateTime.now().millisecondsSinceEpoch.toString())
                ..text(result!)
                ..triggerBot(widget.chatroom.type == 10 &&
                    isOtherUserAIChatbot(widget.chatroom))
                ..replyId(replyToConversation?.id)
                ..ogTags(linkModel!.ogTags!.toOGTag())
                ..shareLink(linkModel!.link!))
              .build(),
          [
            LMChatMediaModel(
              mediaType: LMChatMediaType.link,
              ogTags: linkModel!.ogTags,
            ),
          ],
        ),
      );
      _updateLinkPreviewState();
      widget.scrollToBottom(true);
      chatActionBloc.add(LMChatLinkPreviewRemovedEvent());
    } else {
      String? extractedLink = showLinkPreview
          ? LMChatTaggingHelper.getFirstValidLinkFromString(result!)
          : null;
      conversationBloc.add(
        LMChatPostConversationEvent(
          text: result ?? '',
          chatroomId: widget.chatroom.id,
          replyId: replyToConversation?.id,
          repliedTo: replyToConversation,
          shareLink: extractedLink,
          triggerBot: widget.chatroom.type == 10 &&
              isOtherUserAIChatbot(widget.chatroom),
        ),
      );
      _updateLinkPreviewState();
      widget.scrollToBottom(true);
      chatActionBloc.add(LMChatLinkPreviewRemovedEvent());
    }
  }

  void _updateLinkPreviewState() {
    if (!showLinkPreview) {
      showLinkPreview = true;
    }
  }

  void _handleChatroomStatus() {
    if (widget.chatroom.isGuest ?? false) {
      toast("Chatroom joined");
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.chatroomFollowed,
          eventProperties: {
            'chatroom_name ': widget.chatroom.header,
            'chatroom_id': widget.chatroom.id,
            'chatroom_type': 'normal',
          },
        ),
      );
      widget.chatroom.isGuest = false;
    }
    if (widget.chatroom.followStatus == false) {
      toast("Chatroom joined");
      widget.chatroom.isGuest = false;
    }
  }

  void _resetMessageInput() {
    _textEditingController.clear();
    tags = [];
    result = "";
    if (editConversation == null) {
      widget.scrollToBottom(true);
    }
    if (replyToConversation != null) {
      chatActionBloc.add(LMChatReplyRemoveEvent());
    }
    editConversation = null;
    replyToConversation = null;
  }

  bool _isRespondingAllowed() {
    if (getMemberState!.member!.state != 1 && widget.chatroom.type == 7) {
      return false;
    } else if (!LMChatMemberRightUtil.checkRespondRights(getMemberState)) {
      return false;
    } else if (chatroom!.chatRequestState == 2) {
      return false;
    } else {
      return true;
    }
  }

  String _getChatBarHintText() {
    if (getMemberState!.member!.state != 1 && widget.chatroom.type == 7) {
      return 'Only Community Managers can respond here';
    } else if (!LMChatMemberRightUtil.checkRespondRights(getMemberState)) {
      return 'The community managers have restricted you from responding here';
    } else if (chatroom!.chatRequestState == 2) {
      return "You can not respond to a rejected connection.";
    } else {
      return "Type your response";
    }
  }

  void _setupEditText() {
    // if the edit conversation is null, return
    if (editConversation == null) {
      return;
    }
    // remove GIF message in the text
    String message = getGIFText(editConversation!);

    // Check for user tags in the message
    String? convertedMsgText = LMChatTaggingHelper.convertRouteToTag(message);
    // set the text in the text field
    _textEditingController.value = TextEditingValue(
      text: '$convertedMsgText ',
      selection: TextSelection.fromPosition(
        TextPosition(
          offset: _textEditingController.text.length - 1,
        ),
      ),
    );
    _focusNode.requestFocus();
    tags = LMChatTaggingHelper.addUserTagsIfMatched(
        editConversation?.answer ?? '');
  }

  void _navigateToForwarding() async {
    _popupMenuController.hideMenu();
    LMChatCoreAudioHandler.instance.stopAudio();
    LMChatCoreAudioHandler.instance.stopRecording();
    final result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LMChatMediaForwardingScreen(
          chatroomId: widget.chatroom.id,
          chatroomName: widget.chatroom.header,
          replyConversation: replyToConversation,
          textFieldText: _textEditingController.text,
          triggerBot: widget.chatroom.type == 10 &&
              isOtherUserAIChatbot(widget.chatroom),
        ),
      ),
    );

    // Clear replying or editing state after returning from the forwarding screen
    if (result == true) {
      if (replyToConversation != null) {
        chatActionBloc.add(LMChatReplyRemoveEvent());
      }
      if (editConversation != null) {
        chatActionBloc.add(LMChatEditRemoveEvent());
        _textEditingController.clear();
      }
      if (linkModel != null) {
        chatActionBloc.add(LMChatLinkPreviewRemovedEvent());
      }
      _textEditingController.clear();
    }
  }

  // Add this method to start recording timer
  void _startRecordingTimer() {
    _stopRecordingTimer(); // Ensure any existing timer is stopped
    _recordingDuration.value = Duration.zero;
    _recordingTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_isVoiceButtonHeld.value || _isRecordingLocked.value) {
        _recordingDuration.value = Duration(seconds: timer.tick);
      } else {
        _stopRecordingTimer();
      }
    });
    _breathingController.repeat(reverse: true);
  }

  // Add this method to stop recording timer
  void _stopRecordingTimer() {
    _recordingTimer?.cancel();
    _recordingTimer = null;
    _breathingController.stop();
    _breathingController.reset();
  }

  // Add method to handle sending voice note
  void _handleSendVoiceNote() async {
    if (_recordedFilePath == null) return;

    try {
      // Stop any ongoing playback
      if (_isPlaying.value) {
        await LMChatCoreAudioHandler.instance.stopAudio();
        _isPlaying.value = false;
      }

      final File audioFile = File(_recordedFilePath!);
      if (!await audioFile.exists()) {
        toast("Error: Recording file not found");
        _resetRecordingState();
        return;
      }

      // Store duration before resetting state
      final duration = _playbackProgress.value.duration;

      conversationBloc.add(
        LMChatPostMultiMediaConversationEvent(
          (PostConversationRequestBuilder()
                ..chatroomId(widget.chatroom.id)
                ..temporaryId(DateTime.now().millisecondsSinceEpoch.toString())
                ..replyId(replyToConversation?.id)
                ..hasFiles(true)
                ..text(result ?? ''))
              .build(),
          [
            LMChatMediaModel(
              mediaType: LMChatMediaType.voiceNote,
              mediaFile: audioFile,
              duration: duration.inSeconds.toDouble(),
              size: audioFile.lengthSync(),
              meta: {
                'duration': duration.inSeconds.toDouble(),
                'file_name': audioFile.path.split('/').last,
              },
            ),
          ],
        ),
      );

      _resetRecordingState();
      if (replyToConversation != null) {
        chatActionBloc.add(LMChatReplyRemoveEvent());
      }
      widget.scrollToBottom(true);
    } catch (e) {
      debugPrint('Error sending voice note: $e');
      toast("Error sending voice note");
      _resetRecordingState();
    }
  }

  // Add error recovery method
  void _handleRecordingError() {
    // Current implementation only calls _resetRecordingState()
    // We should properly cleanup audio resources first
    if (_isPlaying.value) {
      LMChatCoreAudioHandler.instance.stopAudio();
    }
    if (_isVoiceButtonHeld.value || _isRecordingLocked.value) {
      LMChatCoreAudioHandler.instance.cancelRecording();
    }
    _resetRecordingState();
    toast("Error recording audio");
  }

  // Add permission check before starting recording
  Future<void> _startRecording() async {
    _overlayPortalController.show();
    try {
      final audioHandler = LMChatCoreAudioHandler.instance;

      // Reset any existing recording state first
      if (_isPlaying.value || _isReviewingRecording.value) {
        await audioHandler.stopAudio();
        _resetRecordingState();
      }

      // Request permissions before setting button state
      final hasPermission = await handlePermissions(3);
      if (!hasPermission) {
        toast(
          "Microphone permission is required for voice recording",
          duration: const Duration(milliseconds: 1500),
        );
        return;
      }

      // Check if the button is still being held after permission check
      if (!_isVoiceButtonHeld.value) {
        return; // Exit if button is not held anymore
      }

      toast(
        "Swipe up to lock recording",
        duration: const Duration(milliseconds: 300),
      );

      _currentRecordingPath = await audioHandler.startRecording();
      if (_currentRecordingPath != null) {
        _startRecordingTimer();
      } else {
        toast(
          "Couldn't start recording",
          duration: const Duration(milliseconds: 300),
        );
        _resetRecordingState();
      }
    } catch (e) {
      if (e.toString().contains('permission')) {
        toast(
          "Please grant microphone permission in settings to record voice notes",
          duration: const Duration(milliseconds: 1500),
        );
      } else {
        toast(
          "Error starting recording",
          duration: const Duration(milliseconds: 300),
        );
      }
      debugPrint('Voice recording error: $e');
      _resetRecordingState();
    }
  }

  // Add method to initialize local player
  Future<void> _initLocalPlayer() async {
    if (!_isLocalPlayerInitialized) {
      try {
        await _localPlayer.openPlayer();
        _isLocalPlayerInitialized = true;
      } catch (e) {
        debugPrint('Error initializing local player: $e');
      }
    }
  }

  // Add method to handle local playback
  Future<void> _handleLocalPlayback() async {
    if (_recordedFilePath == null) return;

    try {
      if (_isPlaying.value) {
        await _stopLocalPlayback();
      } else {
        if (!_isLocalPlayerInitialized) {
          await _initLocalPlayer();
        }

        await _localPlayer.startPlayer(
          fromURI: _recordedFilePath!,
          codec: Codec.defaultCodec,
          whenFinished: () {
            _isPlaying.value = false;
            _playbackProgress.value = PlaybackProgress(
              duration: _playbackProgress.value.duration,
              position: _playbackProgress.value.duration,
              isCompleted: true,
            );
          },
        );

        _isPlaying.value = true;

        // Setup progress tracking
        _localPlayer.setSubscriptionDuration(const Duration(milliseconds: 100));
        _localPlayer.onProgress!.listen(
          (e) {
            if (_isPlaying.value) {
              _playbackProgress.value = PlaybackProgress(
                duration: e.duration,
                position: e.position,
              );
            }
          },
          onError: (error) {
            debugPrint('Local playback error: $error');
            _stopLocalPlayback();
          },
        );
      }
    } catch (e) {
      debugPrint('Error in local playback: $e');
      _stopLocalPlayback();
    }
  }

  // Add method to stop local playback
  Future<void> _stopLocalPlayback() async {
    if (_isLocalPlayerInitialized &&
        (_localPlayer.isPlaying || _localPlayer.isPaused)) {
      await _localPlayer.stopPlayer();
      _isPlaying.value = false;
    }
  }
}



================================================
File: lib/packages/core/lib/src/widgets/chatroom/chatroom_bar_header.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_bar_header}
/// A widget to display the chat bar header.
/// used in the chatroom bar.
/// to display the user name and the message to be replied.
/// or the message to be edited.
/// {@endtemplate}
class LMChatBarHeader extends StatelessWidget {
  /// {@macro lm_chat_bar_header}
  const LMChatBarHeader({
    super.key,
    this.title,
    this.titleText,
    this.subtitle,
    this.trailing,
    this.onCanceled,
    this.titleBuilder,
    this.subtitleBuilder,
    this.trailingBuilder,
    this.style,
  });

  /// The title of the chat bar header.
  final LMChatText? title;

  /// The title text of the chat bar header.
  final String? titleText;

  /// The subtitle of the chat bar header.
  final Widget? subtitle;

  /// The trailing icon of the chat bar header.
  final LMChatIcon? trailing;

  /// The onCanceled function of the chat bar header.
  final VoidCallback? onCanceled;

  /// The title builder of the chat bar header.
  final Widget Function(LMChatText title)? titleBuilder;

  /// The subtitle builder of the chat bar header.
  final Widget Function(LMChatText subtitle)? subtitleBuilder;

  /// The trailing builder of the chat bar header.
  final Widget Function(LMChatIcon trailing)? trailingBuilder;

  final LMChatBarHeaderStyle? style;

  /// Creates a copy of this [LMChatBarHeader] but with the given fields replaced with the new values.
  LMChatBarHeader copyWith({
    LMChatText? title,
    String? titleText,
    LMChatText? subtitle,
    LMChatIcon? trailing,
    VoidCallback? onCanceled,
    Widget Function(LMChatText title)? titleBuilder,
    Widget Function(LMChatText subtitle)? subtitleBuilder,
    Widget Function(LMChatIcon trailing)? trailingBuilder,
    LMChatBarHeaderStyle? style,
  }) {
    return LMChatBarHeader(
      title: title ?? this.title,
      titleText: titleText ?? this.titleText,
      subtitle: subtitle ?? this.subtitle,
      trailing: trailing ?? this.trailing,
      onCanceled: onCanceled ?? this.onCanceled,
      titleBuilder: titleBuilder ?? this.titleBuilder,
      subtitleBuilder: subtitleBuilder ?? this.subtitleBuilder,
      trailingBuilder: trailingBuilder ?? this.trailingBuilder,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    final LMChatThemeData themeData = LMChatTheme.theme;

    return Container(
      height: style?.height ?? 8.h,
      width: style?.width ?? 80.w,
      padding: style?.padding ?? const EdgeInsets.all(8),
      decoration: style?.decoration ??
          BoxDecoration(
              color: themeData.container,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(8),
              )),
      child: Stack(
        alignment: Alignment.topRight,
        children: [
          Container(
            clipBehavior: Clip.hardEdge,
            decoration: BoxDecoration(
              borderRadius: const BorderRadius.all(Radius.circular(6)),
              color:
                  LMChatTheme.instance.themeData.disabledColor.withOpacity(0.2),
            ),
            child: Row(
              children: [
                Container(
                  width: 1.w,
                  color: LMChatTheme.instance.themeData.primaryColor,
                  padding: const EdgeInsets.all(4),
                ),
                kHorizontalPaddingMedium,
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    titleBuilder?.call(
                          _defTitleBuilder(themeData),
                        ) ??
                        _defTitleBuilder(themeData),
                    kVerticalPaddingSmall,
                    SizedBox(
                      width: 55.w,
                      height: 2.h,
                      child: subtitle,
                    ),
                  ],
                ),
              ],
            ),
          ),
          IconButton(
            onPressed: onCanceled,
            icon: trailingBuilder?.call(
                  _defTrailing(themeData),
                ) ??
                _defTrailing(themeData),
          ),
        ],
      ),
    );
  }

  LMChatIcon _defTrailing(LMChatThemeData themeData) {
    return trailing ??
        LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.close,
          style: LMChatIconStyle.basic().copyWith(
            color: themeData.inActiveColor,
            backgroundColor: themeData.container,
            boxBorderRadius: 100,
            size: 20,
            boxSize: 28,
          ),
        );
  }

  LMChatText _defTitleBuilder(LMChatThemeData themeData) {
    return title ??
        LMChatText(
          titleText ?? '',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              color: themeData.primaryColor,
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
          ),
        );
  }
}

/// {@template lm_chat_bar_header_style}
/// A class to style the chat bar header.
/// {@endtemplate}
class LMChatBarHeaderStyle {
  /// [height] of the chat bar header.
  final double? height;

  /// [width] of the chat bar header.
  final double? width;

  /// [padding] of the chat bar header.
  final EdgeInsetsGeometry? padding;

  /// [decoration] of the chat bar header.
  final BoxDecoration? decoration;

  /// {@macro lm_chat_bar_header_style}
  const LMChatBarHeaderStyle({
    this.height,
    this.width,
    this.padding,
    this.decoration,
  });

  /// A basic style for the chat bar header.
  factory LMChatBarHeaderStyle.basic() {
    return LMChatBarHeaderStyle(
      height: 8.h,
      width: 80.w,
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: LMChatTheme.theme.container,
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(12),
        ),
      ),
    );
  }

  /// Creates a copy of this [LMChatBarHeaderStyle] but with the given fields replaced with the new values.
  LMChatBarHeaderStyle copyWith({
    double? height,
    double? width,
    EdgeInsetsGeometry? padding,
    BoxDecoration? decoration,
  }) {
    return LMChatBarHeaderStyle(
      height: height ?? this.height,
      width: width ?? this.width,
      padding: padding ?? this.padding,
      decoration: decoration ?? this.decoration,
    );
  }
}



================================================
File: lib/packages/core/lib/src/widgets/chatroom/chatroom_bar_menu.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';

/// {@template lm_attachment_menu}
/// A widget that displays a menu of attachment options in the chatroom bar.
/// This menu is shown when the attachment button is tapped.
/// {@endtemplate}
class LMAttachmentMenu extends StatelessWidget {
  /// The list of menu items to display
  final List<LMAttachmentMenuItemData> items;

  /// The style configuration for the menu
  final LMAttachmentMenuStyle style;

  /// {@macro lm_attachment_menu}
  const LMAttachmentMenu({
    super.key,
    required this.items,
    this.style = const LMAttachmentMenuStyle(),
  });

  /// Creates a copy of this [LMAttachmentMenu] with the given fields replaced with new values.
  ///
  /// The [items] parameter sets a new list of menu items.
  /// The [style] parameter sets a new style configuration.
  ///
  /// Returns a new [LMAttachmentMenu] instance with the updated values.
  LMAttachmentMenu copyWith({
    List<LMAttachmentMenuItemData>? items,
    LMAttachmentMenuStyle? style,
  }) {
    return LMAttachmentMenu(
      items: items ?? this.items,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    return _defaultAttachmentMenu(context);
  }

  Widget _defaultAttachmentMenu(BuildContext context) {
    // Calculate grid layout
    final int itemCount = items.length;
    // Use 3 columns for both 3 items and 5 items cases
    final int columns = (itemCount == 3 || itemCount == 5) ? 3 : 2;
    final int rows = (itemCount / columns).ceil();

    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      child: ClipRRect(
        borderRadius: style.borderRadius,
        child: Container(
          width: MediaQuery.of(context).size.width,
          color: style.backgroundColor,
          child: Padding(
            padding: style.padding,
            child: Column(
              children: List.generate(rows, (rowIndex) {
                // Calculate items for this row
                final int startIndex = rowIndex * columns;
                final int endIndex = startIndex + columns > itemCount
                    ? itemCount
                    : startIndex + columns;
                final int itemsInRow = endIndex - startIndex;

                return Padding(
                  padding: EdgeInsets.only(
                    bottom: rowIndex < rows - 1 ? 16 : 0,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      ...List.generate(itemsInRow, (index) {
                        final item = items[startIndex + index];
                        return Expanded(
                          child: LMChatCore.config.chatRoomConfig.builder
                              .attachmentMenuItemBuilder(
                            context,
                            item,
                            LMAttachmentMenuItem(
                              item: item,
                              style: style.menuItemStyle,
                            ),
                          ),
                        );
                      }),
                      // Add spacers if needed to maintain grid alignment
                      if (itemsInRow < columns)
                        ...List.generate(
                          columns - itemsInRow,
                          (index) => const Spacer(),
                        ),
                    ],
                  ),
                );
              }),
            ),
          ),
        ),
      ),
    );
  }
}

/// {@template lm_attachment_menu_item}
/// A widget that displays a single item in the attachment menu.
/// {@endtemplate}
class LMAttachmentMenuItem extends StatelessWidget {
  /// The menu item data
  final LMAttachmentMenuItemData item;

  /// The style configuration for the menu item
  final LMAttachmentMenuItemStyle style;

  /// {@macro lm_attachment_menu_item}
  const LMAttachmentMenuItem({
    super.key,
    required this.item,
    this.style = const LMAttachmentMenuItemStyle(),
  });

  /// Creates a copy of this [LMAttachmentMenuItem] with the given fields replaced with new values.
  ///
  /// The [item] parameter sets a new menu item data.
  /// The [style] parameter sets a new style configuration.
  ///
  /// Returns a new [LMAttachmentMenuItem] instance with the updated values.
  LMAttachmentMenuItem copyWith({
    LMAttachmentMenuItemData? item,
    LMAttachmentMenuItemStyle? style,
  }) {
    return LMAttachmentMenuItem(
      item: item ?? this.item,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    return _defaultMenuItem(context);
  }

  Widget _defaultMenuItem(BuildContext context) {
    return Column(
      children: [
        LMChatButton(
          onTap: item.onTap,
          icon: LMChatIcon(
            type: item.iconType ?? LMChatIconType.icon,
            icon: item.icon,
            assetPath: item.assetPath,
            style: LMChatIconStyle(
              color: style.iconColor,
              size: item.iconType == LMChatIconType.svg ? 38 : 30,
              boxSize: style.iconBoxSize,
              boxBorderRadius: item.iconType == LMChatIconType.svg ? 100 : 0,
              boxPadding: item.iconType == LMChatIconType.svg
                  ? const EdgeInsets.all(12)
                  : EdgeInsets.zero,
              backgroundColor: item.iconType == LMChatIconType.svg
                  ? style.backgroundColor
                  : null,
            ),
          ),
          style: LMChatButtonStyle(
            height: style.buttonHeight,
            width: style.buttonWidth,
            borderRadius: style.buttonBorderRadius,
            backgroundColor: style.backgroundColor,
          ),
        ),
        const SizedBox(height: 4),
        LMChatText(
          item.label,
          style: LMChatTextStyle(
            textStyle: style.labelTextStyle,
          ),
        ),
      ],
    );
  }
}

/// {@template lm_attachment_menu_item_data}
/// Data class for attachment menu items
/// {@endtemplate}
class LMAttachmentMenuItemData {
  /// The icon to display
  final IconData? icon;

  /// The label text to display
  final String label;

  /// The callback when item is tapped
  final VoidCallback onTap;

  /// The type of icon (material icon or svg)
  final LMChatIconType? iconType;

  /// The asset path for svg icons
  final String? assetPath;

  /// {@macro lm_attachment_menu_item_data}
  const LMAttachmentMenuItemData({
    this.icon,
    required this.label,
    required this.onTap,
    this.iconType,
    this.assetPath,
  });
}

/// {@template lm_attachment_menu_style}
/// Style configuration for the attachment menu
/// {@endtemplate}
class LMAttachmentMenuStyle {
  /// Background color of the menu
  final Color backgroundColor;

  /// Border radius of the menu
  final BorderRadius borderRadius;

  /// Padding around the menu content
  final EdgeInsets padding;

  /// Style for menu items
  final LMAttachmentMenuItemStyle menuItemStyle;

  /// {@macro lm_attachment_menu_style}
  const LMAttachmentMenuStyle({
    this.backgroundColor = Colors.white,
    this.borderRadius = const BorderRadius.all(Radius.circular(8)),
    this.padding = const EdgeInsets.symmetric(
      vertical: 16,
      horizontal: 48,
    ),
    this.menuItemStyle = const LMAttachmentMenuItemStyle(),
  });

  /// Creates a copy of this style with the given fields replaced with new values
  LMAttachmentMenuStyle copyWith({
    Color? backgroundColor,
    BorderRadius? borderRadius,
    EdgeInsets? padding,
    LMAttachmentMenuItemStyle? menuItemStyle,
  }) {
    return LMAttachmentMenuStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      borderRadius: borderRadius ?? this.borderRadius,
      padding: padding ?? this.padding,
      menuItemStyle: menuItemStyle ?? this.menuItemStyle,
    );
  }
}

/// {@template lm_attachment_menu_item_style}
/// Style configuration for attachment menu items
/// {@endtemplate}
class LMAttachmentMenuItemStyle {
  /// Color of the icon
  final Color iconColor;

  /// Background color for both icon and button
  final Color backgroundColor;

  /// Size of the icon box
  final double iconBoxSize;

  /// Height of the button
  final double buttonHeight;

  /// Width of the button
  final double buttonWidth;

  /// Border radius of the button
  final double buttonBorderRadius;

  /// Text style for the label
  final TextStyle labelTextStyle;

  /// {@macro lm_attachment_menu_item_style}
  const LMAttachmentMenuItemStyle({
    this.iconColor = Colors.white,
    this.backgroundColor = Colors.blue,
    this.iconBoxSize = 48,
    this.buttonHeight = 48,
    this.buttonWidth = 48,
    this.buttonBorderRadius = 24,
    this.labelTextStyle = const TextStyle(
      fontSize: 12,
      color: Colors.black,
    ),
  });

  /// Creates a copy of this style with the given fields replaced with new values
  LMAttachmentMenuItemStyle copyWith({
    Color? iconColor,
    Color? backgroundColor,
    double? iconBoxSize,
    double? buttonHeight,
    double? buttonWidth,
    double? buttonBorderRadius,
    TextStyle? labelTextStyle,
  }) {
    return LMAttachmentMenuItemStyle(
      iconColor: iconColor ?? this.iconColor,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      iconBoxSize: iconBoxSize ?? this.iconBoxSize,
      buttonHeight: buttonHeight ?? this.buttonHeight,
      buttonWidth: buttonWidth ?? this.buttonWidth,
      buttonBorderRadius: buttonBorderRadius ?? this.buttonBorderRadius,
      labelTextStyle: labelTextStyle ?? this.labelTextStyle,
    );
  }
}



================================================
File: lib/packages/core/lib/src/widgets/chatroom/chatroom_menu.dart
================================================
import 'package:flutter/material.dart';
import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/blocs.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/audio_handler.dart';
import 'package:likeminds_chat_flutter_core/src/views/participants/participants.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';

class LMChatroomMenu extends StatefulWidget {
  final ChatRoom chatroom;
  final List<ChatroomAction> chatroomActions;
  final CustomPopupMenuController? controller;
  final LMChatCustomPopupMenuStyle? style;
  final LMChatIconBuilder? iconBuilder;

  const LMChatroomMenu({
    super.key,
    required this.controller,
    required this.chatroom,
    required this.chatroomActions,
    this.style,
    this.iconBuilder,
  });
  LMChatroomMenu copyWith({
    CustomPopupMenuController? controller,
    LMChatCustomPopupMenuStyle? style,
    List<ChatroomAction>? chatroomActions,
    LMChatIconBuilder? iconBuilder,
  }) {
    return LMChatroomMenu(
      chatroom: chatroom,
      controller: controller ?? this.controller,
      style: style ?? this.style,
      chatroomActions: chatroomActions ?? this.chatroomActions,
      iconBuilder: iconBuilder ?? this.iconBuilder,
    );
  }

  @override
  State<LMChatroomMenu> createState() => _ChatroomMenuState();
}

class _ChatroomMenuState extends State<LMChatroomMenu> {
  late List<ChatroomAction> chatroomActions;

  ValueNotifier<bool> rebuildChatroomMenu = ValueNotifier(false);

  final LMChatHomeFeedBloc homeBloc = LMChatHomeFeedBloc.instance;
  final LMChatConversationBloc conversationBloc =
      LMChatConversationBloc.instance;
  final LMChatConversationActionBloc conversationActionBloc =
      LMChatConversationActionBloc.instance;
  @override
  void initState() {
    super.initState();
    chatroomActions = widget.chatroomActions;
  }

  @override
  void didUpdateWidget(LMChatroomMenu old) {
    super.didUpdateWidget(old);
    chatroomActions = widget.chatroomActions;
  }

  @override
  Widget build(BuildContext context) {
    return CustomPopupMenu(
      pressType: PressType.singleClick,
      showArrow: false,
      controller: widget.controller,
      enablePassEvent: false,
      menuBuilder: () => ClipRRect(
        borderRadius: BorderRadius.circular(8),
        child: Container(
          width: widget.style?.menuBoxWidth,
          height: widget.style?.menuBoxHeight,
          constraints: BoxConstraints(
            minWidth: 12.w,
            maxWidth: 60.w,
          ),
          decoration: widget.style?.menuBoxDecoration ??
              BoxDecoration(
                color: LMChatTheme.theme.container,
              ),
          child: ListView.builder(
            padding: EdgeInsets.zero,
            shrinkWrap: true,
            itemCount: chatroomActions.length,
            itemBuilder: (BuildContext context, int index) {
              return getListTile(chatroomActions[index]);
            },
          ),
        ),
      ),
      child: widget.iconBuilder?.call(
            context,
            _defIcon(),
          ) ??
          _defIcon(),
    );
  }

  LMChatIcon _defIcon() {
    return LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.more_vert_rounded,
      style: LMChatIconStyle(
        size: 28,
        color: LMChatTheme.theme.onContainer,
      ),
    );
  }

  Widget? getListTile(ChatroomAction action) {
    return ListTile(
      style: ListTileStyle.list,
      onTap: () {
        performAction(action);
      },
      tileColor: Colors.transparent,
      title: AbsorbPointer(
        absorbing: true,
        child: LMChatText(
          action.title,
          style: LMChatTextStyle(
            maxLines: 1,
            padding: EdgeInsets.zero,
            textStyle: widget.style?.menuTextStyle ??
                TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w400,
                  color: LMChatTheme.theme.onContainer,
                  overflow: TextOverflow.ellipsis,
                ),
          ),
        ),
      ),
    );
  }

  void performAction(ChatroomAction action) {
    switch (action.id) {
      case 2:
        viewParticipants();
        break;
      case 6:
        muteChatroom(action);
        break;
      case 8:
        muteChatroom(action);
        break;
      case 9:
        showLeaveDialog();
        break;
      case 15:
        showLeaveDialog();
        break;
      case 27:
        showBlockDialog(action);
        break;
      case 28:
        blockDM(action);
        break;
      default:
        unimplemented();
    }
    widget.controller!.hideMenu();
  }

  void unimplemented() {
    toast("Coming Soon");
  }

  void viewParticipants() {
    widget.controller!.hideMenu();
    LMChatAnalyticsBloc.instance.add(
      LMChatFireAnalyticsEvent(
        eventName: LMChatAnalyticsKeys.viewChatroomParticipants,
        eventProperties: {
          'chatroom_id': widget.chatroom.id,
          'community_id': LMChatLocalPreference.instance.getCommunityData()?.id,
          'source': 'chatroom_overflow_menu',
        },
      ),
    );
    LMChatCoreAudioHandler.instance.stopAudio();
    LMChatCoreAudioHandler.instance.stopRecording();
    Navigator.push(context, MaterialPageRoute(builder: (context) {
      return LMChatroomParticipantsPage(
        chatroomViewData: widget.chatroom.toChatRoomViewData(),
      );
    }));
  }

  void muteChatroom(ChatroomAction action) async {
    final response =
        await LMChatCore.client.muteChatroom((MuteChatroomRequestBuilder()
              ..chatroomId(widget.chatroom.id)
              ..value(!widget.chatroom.muteStatus!))
            .build());
    if (response.success) {
      // widget.controller.hideMenu();
      // rebuildChatroomMenu.value = !rebuildChatroomMenu.value;
      if (action.title.toLowerCase() == "mute notifications") {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomMuted,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
            },
          ),
        );
      } else {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomUnMuted,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
            },
          ),
        );
      }
      toast((action.title.toLowerCase() == "mute notifications")
          ? "Notifications muted for this space!"
          : "Notifications unmuted for this space!");
      chatroomActions = chatroomActions.map((element) {
        if (element.title.toLowerCase() == "mute notifications") {
          element.title = "Unmute notifications";
        } else if (element.title.toLowerCase() == "unmute notifications") {
          element.title = "Mute notifications";
        }

        return element;
      }).toList();
      rebuildChatroomMenu.value = !rebuildChatroomMenu.value;
      widget.controller!.hideMenu();
      homeBloc.add(LMChatRefreshHomeFeedEvent());
    } else {
      toast(response.errorMessage!);
    }
  }

  void leaveChatroom() async {
    final User user = LMChatLocalPreference.instance.getUser();

    if (!(widget.chatroom.isSecret ?? false)) {
      final response =
          await LMChatCore.client.followChatroom((FollowChatroomRequestBuilder()
                ..chatroomId(widget.chatroom.id)
                ..memberId(user.id)
                ..value(false))
              .build());
      if (response.success) {
        widget.chatroom.isGuest = true;
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomUnfollowed,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
              'chatroom_id': widget.chatroom.id,
              'chatroom_type': 'normal',
              'source': 'overflow_menu',
            },
          ),
        );
        toast("Chatroom left");
        widget.controller!.hideMenu();
        homeBloc.add(LMChatRefreshHomeFeedEvent());
        Navigator.pop(context);
      } else {
        toast(response.errorMessage!);
      }
    } else {
      final response = await LMChatCore.client
          .deleteParticipant((DeleteParticipantRequestBuilder()
                ..chatroomId(widget.chatroom.id)
                ..isSecret(true))
              .build());
      if (response.success) {
        widget.chatroom.isGuest = true;
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomLeft,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
              'chatroom_id': widget.chatroom.id,
              'chatroom_type': 'secret',
            },
          ),
        );
        toast("Chatroom left");
        widget.controller!.hideMenu();
        homeBloc.add(LMChatRefreshHomeFeedEvent());
        Navigator.pop(context);
      } else {
        toast(response.errorMessage!);
      }
    }
  }

  void showLeaveDialog() {
    showDialog(
        context: context,
        builder: (context) => LMChatDialog(
              style: LMChatDialogStyle(
                backgroundColor: LMChatTheme.theme.container,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              title: LMChatText(
                "Leave Chatroom?",
                style: LMChatTextStyle(
                  textStyle: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                    color: LMChatTheme.theme.onContainer,
                  ),
                ),
              ),
              content: LMChatText(
                widget.chatroom.isSecret != null && widget.chatroom.isSecret!
                    ? 'Are you sure you want to leave this private group? To join back, you\'ll need to reach out to the admin'
                    : 'Are you sure you want to leave this group?',
                style: const LMChatTextStyle(),
              ),
              actions: [
                Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 2.0),
                  child: LMChatText(
                    "CANCEL",
                    style: LMChatTextStyle(
                      textStyle: TextStyle(
                        fontWeight: FontWeight.w600,
                        color: LMChatTheme.theme.onContainer,
                      ),
                    ),
                    onTap: () {
                      Navigator.of(context).pop();
                    },
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8.0),
                  child: LMChatText("CONFIRM",
                      style: LMChatTextStyle(
                        textStyle: TextStyle(
                          fontWeight: FontWeight.w600,
                          color: LMChatTheme.theme.primaryColor,
                        ),
                      ), onTap: () {
                    leaveChatroom();
                    Navigator.pop(context);
                  }),
                ),
              ],
            ));
  }

  void showBlockDialog(ChatroomAction action) {
    showDialog(
      context: context,
      builder: (context) => LMChatDialog(
        style: LMChatDialogStyle(
          backgroundColor: LMChatTheme.theme.container,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
        title: LMChatText(
          "Block Direct Messaging?",
          style: LMChatTextStyle(
            textStyle: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w500,
              color: LMChatTheme.theme.onContainer,
            ),
          ),
        ),
        content: const LMChatText(
          'Are you sure you do not want to receive new messages from this user?',
          style: LMChatTextStyle(),
        ),
        actions: [
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 2.0),
            child: LMChatText(
              "CANCEL",
              style: LMChatTextStyle(
                textStyle: TextStyle(
                  fontWeight: FontWeight.w600,
                  color: LMChatTheme.theme.onContainer,
                ),
              ),
              onTap: () {
                Navigator.of(context).pop();
              },
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: LMChatText("CONFIRM",
                style: LMChatTextStyle(
                  textStyle: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: LMChatTheme.theme.primaryColor,
                  ),
                ), onTap: () {
              blockDM(action);
              Navigator.pop(context);
            }),
          ),
        ],
      ),
    );
  }

  void blockDM(ChatroomAction action) async {
    final request = (BlockMemberRequestBuilder()
          ..chatroomId(widget.chatroom.id)
          ..status(action.id == 27 ? 0 : 1))
        .build();
    final response = await LMChatCore.client.blockMember(request);
    if (response.success) {
      toast(action.id == 27 ? "Member blocked" : "Member unblocked");

      final conversation = response.data!.conversation!;

      conversationBloc.add(LMChatLocalConversationEvent(
        conversation: conversation.toConversationViewData(),
      ));

      conversationActionBloc.add(LMChatRefreshBarEvent(
        chatroom: widget.chatroom.toChatRoomViewData().copyWith(
              chatRequestState: action.id == 27 ? 2 : 1,
            ),
      ));

      chatroomActions = chatroomActions.map((element) {
        if (element.title.toLowerCase() == "block") {
          element.id = 28;
          element.title = "Unblock";
        } else if (element.title.toLowerCase() == "unblock") {
          element.id = 27;
          element.title = "Block";
        }

        return element;
      }).toList();
      rebuildChatroomMenu.value = !rebuildChatroomMenu.value;
      widget.controller!.hideMenu();
      // Navigator.pop(context);
    } else {
      toast(response.errorMessage!);
    }
  }
}



================================================
File: lib/packages/core/lib/src/widgets/explore/explore_join_button.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

class LMChatJoinButton extends StatelessWidget {
  final VoidCallback onTap;
  final LMChatRoomViewData chatroom;

  const LMChatJoinButton({
    super.key,
    required this.onTap,
    required this.chatroom,
  });

  @override
  Widget build(BuildContext context) {
    bool isJoined = chatroom.followStatus!;
    return chatroom.isSecret != null && chatroom.isSecret!
        ? const SizedBox()
        : GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: () {
              isJoined
                  ? showDialog(
                      context: context,
                      builder: (context) => LMChatDialog(
                        style: LMChatDialogStyle(
                          backgroundColor: LMChatTheme.theme.container,
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8),
                          ),
                        ),
                        title: LMChatText(
                          "Leave Chatroom?",
                          style: LMChatTextStyle(
                            textStyle: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.w500,
                              color: LMChatTheme.theme.onContainer,
                            ),
                          ),
                        ),
                        content: LMChatText(
                          chatroom.isSecret != null && chatroom.isSecret!
                              ? 'Are you sure you want to leave this private chatroom? To join back, you\'ll need to reach out to the admin'
                              : 'Are you sure you want to leave this chatroom?',
                          style: LMChatTextStyle(
                            textStyle: TextStyle(
                              fontSize: 14,
                              color: LMChatTheme.theme.onContainer,
                            ),
                          ),
                        ),
                        actions: [
                          Padding(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 8.0,
                              vertical: 2.0,
                            ),
                            child: LMChatText(
                              "CANCEL",
                              style: LMChatTextStyle(
                                textStyle: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  color: LMChatTheme.theme.onContainer,
                                ),
                              ),
                              onTap: () {
                                Navigator.of(context).pop();
                              },
                            ),
                          ),
                          Padding(
                            padding:
                                const EdgeInsets.symmetric(horizontal: 8.0),
                            child: LMChatText(
                              "CONFIRM",
                              style: LMChatTextStyle(
                                backgroundColor: LMChatTheme.theme.primaryColor,
                                padding: const EdgeInsets.all(6),
                                textStyle: TextStyle(
                                  fontWeight: FontWeight.w600,
                                  color: LMChatTheme.theme.onPrimary,
                                ),
                              ),
                              onTap: () {
                                onTap();
                                Navigator.pop(context);
                              },
                            ),
                          ),
                        ],
                      ),
                    )
                  : onTap();
            },
            child: AbsorbPointer(
              child: Container(
                decoration: BoxDecoration(
                  color: isJoined
                      ? LMChatTheme.theme.disabledColor.withOpacity(0.5)
                      : LMChatTheme.theme.primaryColor,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(8),
                  child: Row(
                    children: [
                      isJoined
                          ? LMChatIcon(
                              type: LMChatIconType.svg,
                              assetPath: exploreJoinnedIcon,
                              style: LMChatIconStyle(
                                size: 24,
                                color: LMChatTheme.theme.primaryColor,
                              ),
                            )
                          : LMChatIcon(
                              type: LMChatIconType.svg,
                              assetPath: exploreJoinIcon,
                              style: LMChatIconStyle(
                                size: 24,
                                color: LMChatTheme.theme.container,
                              ),
                            ),
                      const SizedBox(width: 6),
                      LMChatText(
                        isJoined ? "Joined" : "Join",
                        style: LMChatTextStyle.basic().copyWith(
                          textStyle: TextStyle(
                            color: !isJoined
                                ? LMChatTheme.theme.container
                                : LMChatTheme.theme.primaryColor,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          );
  }
}



================================================
File: lib/packages/core/lib/src/widgets/explore/explore_tile.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_fl/likeminds_chat_fl.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/blocs.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_core/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_core/src/widgets/widgets.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:overlay_support/overlay_support.dart';

///{@template lm_chat_explore_tile}
/// Core widget to represent an Explore chatroom tile
///
/// Uses [LMChatTile] internally, so can be styled with [LMChatTileStyle]
///
/// Requires a chatroom model [LMChatRoomViewData]
/// {@endtemplate}
class LMChatExploreTile extends StatefulWidget {
  /// Style class used to customise look and feel of widget
  final LMChatTileStyle? style;

  /// Chatroom view model required to render the widget
  final LMChatRoomViewData chatroom;

  /// Callback function to handle tap event
  final VoidCallback? onTap;

  /// Flag to absorb touch events
  final bool? absorbTouch;

  /// Widget to display on the left side of the tile
  final Widget? leading;

  /// Widget to display as title
  final Widget? title;

  /// Widget to display as subtitle
  final Widget? subtitle;

  /// Widget to display on the right side of the tile
  final Widget? trailing;

  ///{@macro lm_chat_explore_tile}
  const LMChatExploreTile({
    super.key,
    this.style,
    this.onTap,
    this.absorbTouch,
    this.leading,
    this.title,
    this.subtitle,
    this.trailing,
    required this.chatroom,
  });

  /// CopyWith method to update the widget with new values
  /// Returns a new instance of the widget with updated values
  LMChatExploreTile copyWith({
    LMChatTileStyle? style,
    VoidCallback? onTap,
    bool? absorbTouch,
    Widget? leading,
    Widget? title,
    Widget? subtitle,
    Widget? trailing,
    LMChatRoomViewData? chatroom,
  }) {
    return LMChatExploreTile(
      style: style ?? this.style,
      onTap: onTap ?? this.onTap,
      absorbTouch: absorbTouch ?? this.absorbTouch,
      leading: leading ?? this.leading,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      trailing: trailing ?? this.trailing,
      chatroom: chatroom ?? this.chatroom,
    );
  }

  @override
  State<LMChatExploreTile> createState() => _LMChatExploreTileState();
}

class _LMChatExploreTileState extends State<LMChatExploreTile> {
  late LMChatRoomViewData chatroom;
  final User user = LMChatLocalPreference.instance.getUser();
  ValueNotifier<bool> isJoinedNotifier = ValueNotifier(false);
  final _screenBuilder = LMChatCore.config.exploreConfig.builder;
  @override
  void initState() {
    super.initState();
    chatroom = widget.chatroom;
  }

  @override
  Widget build(BuildContext context) {
    return LMChatTile(
      onTap: widget.onTap,
      absorbTouch: widget.absorbTouch ?? false,
      style: widget.style ??
          LMChatTheme.theme.chatTileStyle.copyWith(
            gap: 6,
          ),
      leading: widget.leading ??
          LMChatProfilePicture(
            fallbackText: chatroom.header,
            overlay: chatroom.externalSeen != null &&
                    chatroom.externalSeen! == false
                ? _defaultNewText()
                : Positioned(
                    bottom: 0,
                    right: 0,
                    child:
                        chatroom.isPinned != null && chatroom.isPinned! == true
                            ? _screenBuilder.pinIconBuilder(
                                context,
                                _defaultPinnedIcon(),
                              )
                            : const SizedBox.shrink(),
                  ),
            imageUrl: chatroom.chatroomImageUrl,
            style: LMChatProfilePictureStyle.basic().copyWith(
              size: 56,
              textPadding: const EdgeInsets.symmetric(
                horizontal: 8,
                vertical: 9,
              ),
            ),
          ),
      title: widget.title ?? _defaulltExploreTitle(),
      subtitle: widget.subtitle ??
          _screenBuilder.subtitleBuilder(
            context,
            LMChatText(
              chatroom.title,
              style: LMChatTextStyle(
                textAlign: TextAlign.left,
                maxLines: 2,
                minLines: 1,
                textStyle: TextStyle(
                  overflow: TextOverflow.ellipsis,
                  color: LMChatTheme.theme.onContainer,
                ),
              ),
            ),
          ),
    );
  }

  Row _defaulltExploreTitle() {
    return Row(
      children: [
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  chatroom.isSecret ?? false
                      ? LMChatText(
                          chatroom.header,
                          style: LMChatTextStyle(
                            maxLines: 1,
                            textStyle: TextStyle(
                              overflow: TextOverflow.ellipsis,
                              fontSize: 16,
                              fontWeight: FontWeight.w500,
                              color: LMChatTheme.theme.onContainer,
                            ),
                          ),
                        )
                      : Expanded(
                          child: _screenBuilder.headerBuilder(
                            context,
                            LMChatText(
                              chatroom.header,
                              style: LMChatTextStyle(
                                maxLines: 1,
                                textStyle: TextStyle(
                                  overflow: TextOverflow.ellipsis,
                                  fontSize: 16,
                                  color: LMChatTheme.theme.onContainer,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ),
                          ),
                        ),
                  const SizedBox(width: 4),
                  if (chatroom.isSecret ?? false)
                    _screenBuilder.lockIconBuilder(
                      context,
                      LMChatIcon(
                        type: LMChatIconType.svg,
                        assetPath: secretLockIcon,
                        style: LMChatIconStyle(
                          size: 18,
                          color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                        ),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 4),
              _defaultSpaceStats(),
            ],
          ),
        ),
        const SizedBox(width: 12),
        _defaultJoinButton(),
      ],
    );
  }

  LMChatIcon _defaultPinnedIcon() {
    return LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.push_pin,
      style: LMChatIconStyle(
        size: 18,
        boxSize: 24,
        boxBorder: 2,
        boxPadding: const EdgeInsets.all(4),
        boxBorderRadius: 12,
        color: LMChatTheme.theme.onContainer,
        backgroundColor: LMChatTheme.theme.container,
      ),
    );
  }

  Row _defaultSpaceStats() {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _screenBuilder.memberCountIconBuilder(
          context,
          LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.people_outline,
            style: LMChatIconStyle(
              size: 20,
              color: LMChatTheme.theme.onContainer.withOpacity(0.6),
            ),
          ),
        ),
        const SizedBox(width: 4),
        _screenBuilder.memberCountBuilder(
          context,
          chatroom.participantCount ?? 0,
          LMChatText(
            chatroom.participantCount.toString(),
            style: LMChatTextStyle(
              maxLines: 1,
              textStyle: TextStyle(
                overflow: TextOverflow.ellipsis,
                fontSize: 14,
                color: LMChatTheme.theme.onContainer.withOpacity(0.6),
              ),
            ),
          ),
        ),
        const SizedBox(width: 10),
        _screenBuilder.totalResponseCountIconBuilder(
          context,
          LMChatIcon(
            type: LMChatIconType.icon,
            icon: CupertinoIcons.chat_bubble,
            style: LMChatIconStyle(
              size: 20,
              color: LMChatTheme.theme.onContainer.withOpacity(0.6),
            ),
          ),
        ),
        const SizedBox(width: 4),
        _screenBuilder.totalResponseCountBuilder(
          context,
          chatroom.totalResponseCount ?? 0,
          LMChatText(
            chatroom.totalResponseCount.toString(),
            style: LMChatTextStyle(
              maxLines: 1,
              textStyle: TextStyle(
                overflow: TextOverflow.ellipsis,
                fontSize: 14,
                color: LMChatTheme.theme.onContainer.withOpacity(0.6),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _defaultJoinButton() {
    return ValueListenableBuilder(
        valueListenable: isJoinedNotifier,
        builder: (context, _, __) {
          return LMChatJoinButton(
            chatroom: chatroom,
            onTap: () async {
              debugPrint("Chat tile tapped");
              _onTapJoinButton();
            },
          );
        });
  }

  Widget _defaultNewText() {
    return Positioned(
      bottom: 0,
      child: LMChatText(
        'NEW',
        style: LMChatTextStyle(
          padding: const EdgeInsets.symmetric(
            vertical: 2.0,
            horizontal: 2.0,
          ),
          backgroundColor: LMChatTheme.theme.errorColor,
          textStyle: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.w600,
            color: LMChatTheme.theme.onPrimary,
          ),
        ),
      ),
    );
  }

  void _onTapJoinButton() async {
    if (chatroom.followStatus == true) {
      LMResponse response;
      if (chatroom.isSecret == null || chatroom.isSecret! == false) {
        final request = (FollowChatroomRequestBuilder()
              ..chatroomId(chatroom.id)
              ..memberId(user.id)
              ..value(false))
            .build();
        response =
            await LMChatCore.instance.lmChatClient.followChatroom(request);
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomUnfollowed,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
              'chatroom_id': widget.chatroom.id,
              'chatroom_type': 'normal',
              'source': 'overflow_menu',
            },
          ),
        );
      } else {
        final request = (DeleteParticipantRequestBuilder()
              ..chatroomId(chatroom.id)
              ..memberId(user.userUniqueId!)
              ..isSecret(true))
            .build();
        response =
            await LMChatCore.instance.lmChatClient.deleteParticipant(request);
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomLeft,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
              'chatroom_id': widget.chatroom.id,
              'chatroom_type': 'normal',
              'source': 'overflow_menu',
            },
          ),
        );
      }
      chatroom = chatroom.copyWith(followStatus: false);
      isJoinedNotifier.value = !isJoinedNotifier.value;
      if (!response.success) {
        chatroom = chatroom.copyWith(followStatus: true);
        isJoinedNotifier.value = !isJoinedNotifier.value;
        toast(response.errorMessage ?? 'An error occurred');
      } else {
        toast("Chatroom left");
        LMChatHomeFeedBloc.instance.add(LMChatRefreshHomeFeedEvent());
      }
    } else {
      final request = (FollowChatroomRequestBuilder()
            ..chatroomId(chatroom.id)
            ..memberId(user.id)
            ..value(true))
          .build();
      LMResponse response =
          await LMChatCore.instance.lmChatClient.followChatroom(request);
      chatroom = chatroom.copyWith(followStatus: true);
      isJoinedNotifier.value = !isJoinedNotifier.value;
      if (!response.success) {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.chatroomFollowed,
            eventProperties: {
              'chatroom_name ': widget.chatroom.header,
              'chatroom_id': widget.chatroom.id,
              'chatroom_type': 'normal',
              'source': 'overflow_menu',
            },
          ),
        );
        chatroom = chatroom.copyWith(followStatus: false);
        isJoinedNotifier.value = !isJoinedNotifier.value;
        toast(response.errorMessage ?? 'An error occurred');
      } else {
        toast("Chatroom joined");
        LMChatHomeFeedBloc.instance.add(LMChatRefreshHomeFeedEvent());
      }
    }
  }
}



================================================
File: lib/packages/core/lib/src/widgets/lists/chatroom/chatroom_list.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';

/// {@template lm_chat_home_feed_list}
/// A widget that represents a List of Group Chatrooms on home
/// Talks to an instance of LMChatHomeFeedBloc, and updates accordingly
/// Allows for customizations to change the look and feel.
/// {@endtemplate}
class LMChatHomeFeedList extends StatefulWidget {
  /// {@macro lm_chat_home_feed_list}
  const LMChatHomeFeedList({
    super.key,
    this.chatroomTag,
  });

  /// Tag to filter chatrooms, takes priority over the tag from config
  final String? chatroomTag;

  /// Creates a copy of this [LMChatHomeFeedList] but with the given fields replaced with the new values.
  LMChatHomeFeedList copyWith({
    String? chatroomTag,
  }) {
    return LMChatHomeFeedList(
      chatroomTag: chatroomTag ?? this.chatroomTag,
    );
  }

  @override
  State<LMChatHomeFeedList> createState() => _LMChatHomeFeedListState();
}

class _LMChatHomeFeedListState extends State<LMChatHomeFeedList>
    with AutomaticKeepAliveClientMixin<LMChatHomeFeedList> {
  // Widget level track of page key for pagination
  int _page = 1;

  // BLoC needed for list's state management
  late LMChatHomeFeedBloc feedBloc;

  // ValueNotifier to rebuild the list based on an update
  ValueNotifier<bool> rebuildFeedList = ValueNotifier(false);

  // Paging controller to handle pagination, and list updation
  late PagingController<int, LMChatRoomViewData> homeFeedPagingController;

  final LMChatHomeBuilderDelegate _screenBuilder =
      LMChatCore.config.homeConfig.builder;
  final _homeScreenSettings = LMChatCore.config.homeConfig.setting;
  final LMChatHomeFeedListStyle _style =
      LMChatCore.config.homeConfig.style.homeFeedListStyle?.call(
            LMChatHomeFeedListStyle.basic(LMChatTheme.theme.scaffold),
          ) ??
          LMChatHomeFeedListStyle.basic(LMChatTheme.theme.scaffold);

  String get _tag => widget.chatroomTag ?? _homeScreenSettings.tag ?? '';

  @override
  void initState() {
    super.initState();
    feedBloc = LMChatHomeFeedBloc.instance;
    homeFeedPagingController = PagingController(firstPageKey: 1);
    _addPaginationListener();
  }

  @override
  void didUpdateWidget(covariant LMChatHomeFeedList oldWidget) {
    super.didUpdateWidget(oldWidget);
    feedBloc = LMChatHomeFeedBloc.instance;
    homeFeedPagingController = PagingController(firstPageKey: 1);
    _addPaginationListener();
  }

  @override
  void dispose() {
    feedBloc.close();
    homeFeedPagingController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return Scaffold(
      backgroundColor: _style.backgroundColor ?? LMChatTheme.theme.scaffold,
      body: SafeArea(
        top: false,
        child: Column(
          children: [
            _screenBuilder.homeFeedExploreTileBuilder(
              context,
              _defaultExploreTile(),
            ),
            Expanded(
              child: BlocListener<LMChatHomeFeedBloc, LMChatHomeFeedState>(
                bloc: feedBloc,
                listener: (_, state) {
                  _updatePagingControllers(state);
                },
                child: ValueListenableBuilder(
                    valueListenable: rebuildFeedList,
                    builder: (context, _, __) {
                      return PagedListView<int, LMChatRoomViewData>(
                        pagingController: homeFeedPagingController,
                        padding: _style.padding ??
                            const EdgeInsets.symmetric(
                              horizontal: 8,
                            ),
                        physics: const ClampingScrollPhysics(),
                        builderDelegate:
                            PagedChildBuilderDelegate<LMChatRoomViewData>(
                          firstPageErrorIndicatorBuilder: (context) =>
                              _screenBuilder
                                  .homeFeedFirstPageErrorIndicatorBuilder(
                            context,
                            _defaultErrorView(),
                          ),
                          newPageErrorIndicatorBuilder: (context) =>
                              _screenBuilder
                                  .homeFeedNewPageErrorIndicatorBuilder(
                            context,
                            _defaultErrorView(),
                          ),
                          firstPageProgressIndicatorBuilder: (context) =>
                              _screenBuilder
                                  .homeFeedFirstPageProgressIndicatorBuilder(
                            context,
                            const LMChatSkeletonChatroomList(),
                          ),
                          newPageProgressIndicatorBuilder: (context) =>
                              _screenBuilder
                                  .homeFeedNewPageProgressIndicatorBuilder(
                            context,
                            const LMChatLoader(),
                          ),
                          noItemsFoundIndicatorBuilder: (context) =>
                              _screenBuilder
                                  .homeFeedNoItemsFoundIndicatorBuilder(
                            context,
                            _defaultEmptyView(),
                          ),
                          noMoreItemsIndicatorBuilder: (context) =>
                              _screenBuilder
                                  .homeFeedNoMoreItemsIndicatorBuilder(
                            context,
                            const SizedBox(),
                          ),
                          itemBuilder: (context, item, index) {
                            return _screenBuilder.homeFeedTileBuilder(
                              context,
                              item,
                              _defaultHomeChatRoomTile(item),
                            );
                          },
                        ),
                      );
                    }),
              ),
            ),
          ],
        ),
      ),
    );
  }

  LMChatTile _defaultExploreTile() {
    return LMChatTile(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => const LMChatExplorePage(),
          ),
        ).then((val) {
          feedBloc.add(LMChatRefreshHomeFeedEvent(tag: _tag));
        });
      },
      style: LMChatTileStyle.basic().copyWith(
        margin: EdgeInsets.only(
          top: 2.h,
          bottom: 2.h,
        ),
        padding: EdgeInsets.symmetric(horizontal: 6.w),
        height: 4.5.h,
      ),
      leading: LMChatIcon(
        type: LMChatIconType.svg,
        assetPath: exploreIcon,
        style: LMChatIconStyle(
          color: LMChatTheme.theme.primaryColor,
          size: 18,
          boxSize: 32,
        ),
      ),
      title: Padding(
        padding: EdgeInsets.only(
          left: 4.w,
          right: 4,
        ),
        child: LMChatText(
          'Explore Chatrooms',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              fontSize: 16,
              color: LMChatTheme.theme.onContainer,
              fontWeight: FontWeight.w500,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
      ),
      trailing: FutureBuilder(
        future: LMChatCore.client.getExploreTabCount(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Container();
          }
          if (snapshot.connectionState == ConnectionState.done &&
              snapshot.hasData) {
            if (snapshot.data!.success) {
              GetExploreTabCountResponse response = snapshot.data!.data!;
              return _screenBuilder.homeFeedExploreChipBuilder(
                context,
                _defExploreChip(response),
              );
            } else {
              const SizedBox();
            }
          }
          return const SizedBox();
        },
      ),
    );
  }

  LMChatChip _defExploreChip(GetExploreTabCountResponse response) {
    return LMChatChip(
      style: LMChatChipStyle.basic().copyWith(
        backgroundColor: LMChatTheme.theme.primaryColor,
        padding: EdgeInsets.zero,
        labelPadding: EdgeInsets.only(
          left: 2.w,
          right: 2.w,
        ),
        side: BorderSide.none,
      ),
      label: LMChatText(
        response.unseenChannelCount == null || response.unseenChannelCount == 0
            ? '${response.totalChannelCount} Chatrooms'
            : '${response.unseenChannelCount} NEW',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            color: LMChatTheme.theme.onPrimary,
            fontWeight: FontWeight.w400,
            fontSize: 12,
          ),
        ),
      ),
    );
  }

  _addPaginationListener() {
    homeFeedPagingController.addPageRequestListener(
      (pageKey) {
        feedBloc.add(LMChatFetchHomeFeedEvent(
          page: pageKey,
          tag: _tag,
        ));
      },
    );
  }

  _updatePagingControllers(LMChatHomeFeedState state) {
    if (state is LMChatHomeFeedError) {
      homeFeedPagingController.error = state.errorMessage;
      return;
    }
    if (state is LMChatHomeFeedLoaded) {
      _page++;
      homeFeedPagingController.itemList?.clear();
      homeFeedPagingController.nextPageKey = _page;
      if (state.chatrooms.isEmpty || state.chatrooms.length < 50) {
        homeFeedPagingController.appendLastPage(state.chatrooms);
      } else {
        homeFeedPagingController.appendPage(state.chatrooms, _page);
      }
    } else if (state is LMChatHomeFeedUpdated) {
      _page = 2;
      homeFeedPagingController.itemList?.clear();
      homeFeedPagingController.nextPageKey = _page;
      if (state.chatrooms.isEmpty || state.chatrooms.length < 50) {
        homeFeedPagingController.appendLastPage(state.chatrooms);
      } else {
        homeFeedPagingController.appendPage(state.chatrooms, _page);
      }
    }
  }

  Widget _defaultEmptyView() {
    return Center(
        child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const LMChatIcon(
          type: LMChatIconType.png,
          assetPath: emptyViewImage,
          style: LMChatIconStyle(
            size: 100,
          ),
        ),
        const SizedBox(height: 12),
        LMChatText(
          'Oops! No chatrooms found.',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              color: LMChatTheme.theme.inActiveColor,
            ),
          ),
        )
      ],
    ));
  }

  Widget _defaultErrorView() {
    return Container();
  }

  LMChatTile _defaultHomeChatRoomTile(LMChatRoomViewData chatroom) {
    String message = getHomeChatroomPreviewMessage(chatroom.lastConversation!);
    return LMChatTile(
      style: LMChatTileStyle.basic().copyWith(
        backgroundColor: LMChatTheme.theme.scaffold,
      ),
      onTap: () {
        LMChatRealtime.instance.chatroomId = chatroom.id;
        final route = MaterialPageRoute(
          builder: (context) {
            return LMChatroomScreen(
              chatroomId: chatroom.id,
            );
          },
        );
        Navigator.of(context).push(route).whenComplete(
              () => feedBloc.add(LMChatRefreshHomeFeedEvent(tag: _tag)),
            );
      },
      leading: LMChatProfilePicture(
        fallbackText: chatroom.header,
        imageUrl: chatroom.chatroomImageUrl,
        style: _style.profilePictureStyle ??
            LMChatProfilePictureStyle.basic().copyWith(size: 48),
      ),
      title: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Flexible(
            child: LMChatText(
              chatroom.header,
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  overflow: TextOverflow.ellipsis,
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                  color: LMChatTheme.theme.onContainer,
                ),
              ),
            ),
          ),
          const SizedBox(width: 2),
          if (chatroom.isSecret == true)
            _screenBuilder.homeFeedSecretChatroomIconBuilder(
              _defSecretChatroomIcon(),
            ),
        ],
      ),
      subtitle: (((chatroom.lastConversation?.attachmentsUploaded ?? false) ||
                      (chatroom.lastConversation?.hasFiles ?? false)) &&
                  chatroom.lastConversation?.deletedByUserId == null) ||
              (chatroom.lastConversation?.state == 10 &&
                  chatroom.lastConversation?.deletedByUserId == null)
          ? getChatItemAttachmentTile(
              message,
              prefix:
                  getUserHomePrefixPreviewMessage(chatroom.lastConversation!),
              chatroom.attachments,
              chatroom.lastConversation!)
          : LMChatText(
              chatroom.lastConversation!.state != 0
                  ? LMChatTaggingHelper.extractStateMessage(message)
                  : message,
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  fontSize: 14,
                  color: LMChatTheme.theme.onContainer,
                  fontWeight: FontWeight.w400,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
      trailing: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          chatroom.muteStatus != null && chatroom.muteStatus!
              ? _screenBuilder.homeFeedMuteIconBuilder(
                  _defMuteIcon(),
                )
              : const SizedBox.shrink(),
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              LMChatText(
                getTime(chatroom.lastConversation!.createdEpoch!.toString()),
                style: LMChatTextStyle(
                  textStyle: TextStyle(
                    fontSize: 12,
                    color: LMChatTheme.theme.onContainer,
                    fontWeight: FontWeight.w400,
                  ),
                ),
              ),
              const SizedBox(height: 6),
              Visibility(
                visible: chatroom.unseenCount! > 0,
                child: LMChatText(
                  chatroom.unseenCount! > 99
                      ? "99+"
                      : chatroom.unseenCount.toString(),
                  style: _style.unReadCountTextStyle,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  LMChatIcon _defSecretChatroomIcon() {
    return const LMChatIcon(
      type: LMChatIconType.svg,
      assetPath: secretLockIcon,
      style: LMChatIconStyle(
        size: 20,
      ),
    );
  }

  LMChatIcon _defMuteIcon() {
    return LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.volume_off_outlined,
      style: LMChatIconStyle(
        backgroundColor: LMChatTheme.theme.container,
        color: LMChatTheme.theme.onContainer,
        boxSize: 36,
        boxPadding: const EdgeInsets.only(
          left: 6,
          right: 4,
        ),
        fit: BoxFit.contain,
      ),
    );
  }

  @override
  bool get wantKeepAlive => true;
}

/// {@template lm_chat_home_feed_list_style}
/// A style object to customize the look and feel of the home feed list
/// {@endtemplate}
class LMChatHomeFeedListStyle {
  /// [backgroundColor] is the background color of the list
  final Color? backgroundColor;

  /// [padding] is the padding of the list
  final EdgeInsets? padding;

  /// [profilePictureStyle] is the style of the profile picture
  final LMChatProfilePictureStyle? profilePictureStyle;

  /// [unReadCountTextStyle] is the style of the unread count
  final LMChatTextStyle? unReadCountTextStyle;

  static final LMChatThemeData _themeData = LMChatTheme.theme;

  /// {@macro lm_chat_home_feed_list_style}
  const LMChatHomeFeedListStyle({
    this.backgroundColor,
    this.padding,
    this.profilePictureStyle,
    this.unReadCountTextStyle,
  });

  /// Default style for the home feed list
  factory LMChatHomeFeedListStyle.basic(Color? scaffold) {
    return LMChatHomeFeedListStyle(
        backgroundColor: scaffold,
        padding: const EdgeInsets.only(
          right: 8,
          left: 4,
        ),
        profilePictureStyle:
            LMChatProfilePictureStyle.basic().copyWith(size: 48),
        unReadCountTextStyle: LMChatTextStyle(
          maxLines: 1,
          backgroundColor: LMChatTheme.theme.primaryColor,
          borderRadius: 24,
          padding: const EdgeInsets.only(
            left: 7,
            right: 7,
            top: 2,
            bottom: 2,
          ),
          textStyle: TextStyle(
            fontSize: 12,
            color: LMChatTheme.theme.onPrimary,
            fontWeight: FontWeight.w500,
          ),
        ));
  }

  /// Creates a copy of this [LMChatHomeFeedListStyle] but with the given fields replaced with the new values.
  /// If the fields are null, the original values are retained.
  LMChatHomeFeedListStyle copyWith({
    Color? backgroundColor,
    EdgeInsets? padding,
    LMChatProfilePictureStyle? profilePictureStyle,
    LMChatTextStyle? unReadCountTextStyle,
  }) {
    return LMChatHomeFeedListStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      padding: padding ?? this.padding,
      profilePictureStyle: profilePictureStyle ?? this.profilePictureStyle,
      unReadCountTextStyle: unReadCountTextStyle ?? this.unReadCountTextStyle,
    );
  }
}



================================================
File: lib/packages/core/lib/src/widgets/lists/chatroom/dm_chatroom_list.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_core/src/utils/realtime/realtime.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_dm_feed_list}
/// A widget that represents a List of DM Chatrooms
/// Talks to an instance of LMChatDMFeedBloc, and updates accordingly
/// Allows for customizations to change the look and feel.
/// {@endtemplate}
class LMChatDMFeedList extends StatefulWidget {
  /// {@macro lm_chat_dm_feed_list}
  const LMChatDMFeedList({
    super.key,
  });

  /// Creates a copy of this [LMChatDMFeedList] but with the given fields replaced with the new values.
  LMChatDMFeedList copyWith() {
    return const LMChatDMFeedList();
  }

  @override
  State<LMChatDMFeedList> createState() => _LMChatDMFeedListState();
}

class _LMChatDMFeedListState extends State<LMChatDMFeedList>
    with AutomaticKeepAliveClientMixin<LMChatDMFeedList> {
  // Widget level track of page key for pagination
  int _page = 1;

  // BLoC needed for list's state management
  late LMChatDMFeedBloc feedBloc;

  // ValueNotifier to rebuild the list based on an update
  ValueNotifier<bool> rebuildFeedList = ValueNotifier(false);

  // Paging controller to handle pagination, and list updation
  late PagingController<int, LMChatRoomViewData> homeFeedPagingController;

  final LMChatHomeBuilderDelegate _screenBuilder =
      LMChatCore.config.homeConfig.builder;

  /// [_style] is a style object to customize the look and feel of the list
  final LMChatDMFeedListStyle _style =
      LMChatCore.config.homeConfig.style.dmFeedListStyle?.call(
            LMChatDMFeedListStyle.basic(),
          ) ??
          LMChatDMFeedListStyle.basic();

  @override
  void initState() {
    feedBloc = LMChatDMFeedBloc.instance;
    homeFeedPagingController = PagingController(firstPageKey: 1);
    _addPaginationListener();
    LMChatAnalyticsBloc.instance.add(
      const LMChatFireAnalyticsEvent(
        eventName: LMChatAnalyticsKeys.dmScreenOpened,
        eventProperties: {'source': 'home_feed'},
      ),
    );
    super.initState();
  }

  @override
  void didUpdateWidget(covariant LMChatDMFeedList oldWidget) {
    feedBloc = LMChatDMFeedBloc.instance;
    homeFeedPagingController = PagingController(firstPageKey: 1);
    _addPaginationListener();
    super.didUpdateWidget(oldWidget);
  }

  @override
  void dispose() {
    feedBloc.close();
    homeFeedPagingController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return Scaffold(
      backgroundColor: _style.backgroundColor ?? LMChatTheme.theme.scaffold,
      body: SafeArea(
        top: false,
        child: BlocListener<LMChatDMFeedBloc, LMChatDMFeedState>(
          bloc: feedBloc,
          listener: (_, state) {
            _updatePagingControllers(state);
          },
          child: ValueListenableBuilder(
              valueListenable: rebuildFeedList,
              builder: (context, _, __) {
                return PagedListView<int, LMChatRoomViewData>(
                  pagingController: homeFeedPagingController,
                  padding: _style.padding ??
                      const EdgeInsets.symmetric(
                        vertical: 8,
                        horizontal: 4,
                      ),
                  physics: const ClampingScrollPhysics(),
                  builderDelegate:
                      PagedChildBuilderDelegate<LMChatRoomViewData>(
                    itemBuilder: (context, chatroom, index) {
                      return _screenBuilder.dmFeedTileBuilder(
                        context,
                        chatroom,
                        _defaultDMChatRoomTile(chatroom),
                      );
                    },
                    firstPageErrorIndicatorBuilder: (context) =>
                        _screenBuilder.dmFeedFirstPageErrorIndicatorBuilder(
                      context,
                      _defaultErrorView(),
                    ),
                    newPageErrorIndicatorBuilder: (context) =>
                        _screenBuilder.dmFeedNewPageErrorIndicatorBuilder(
                      context,
                      _defaultErrorView(),
                    ),
                    firstPageProgressIndicatorBuilder: (context) =>
                        _screenBuilder.dmFeedFirstPageProgressIndicatorBuilder(
                      context,
                      const LMChatSkeletonChatroomList(),
                    ),
                    newPageProgressIndicatorBuilder: (context) =>
                        _screenBuilder.dmFeedNewPageProgressIndicatorBuilder(
                      context,
                      const LMChatLoader(),
                    ),
                    noItemsFoundIndicatorBuilder: (context) =>
                        _screenBuilder.dmFeedNoItemsFoundIndicatorBuilder(
                      context,
                      _defaultEmptyView(),
                    ),
                    noMoreItemsIndicatorBuilder: (context) =>
                        _screenBuilder.dmFeedNoMoreItemsIndicatorBuilder(
                      context,
                      const SizedBox(),
                    ),
                  ),
                );
              }),
        ),
      ),
    );
  }

  _addPaginationListener() {
    homeFeedPagingController.addPageRequestListener(
      (pageKey) {
        feedBloc.add(
          LMChatFetchDMFeedEvent(
            page: pageKey,
          ),
        );
      },
    );
  }

  _updatePagingControllers(LMChatDMFeedState state) {
    if (state is LMChatDMFeedLoaded) {
      _page++;
      homeFeedPagingController.itemList?.clear();
      homeFeedPagingController.nextPageKey = _page;
      if (state.chatrooms.isEmpty || state.chatrooms.length < 50) {
        homeFeedPagingController.appendLastPage(state.chatrooms);
      } else {
        homeFeedPagingController.appendPage(state.chatrooms, _page);
      }
    } else if (state is LMChatDMFeedUpdated) {
      _page = 2;
      homeFeedPagingController.itemList?.clear();
      homeFeedPagingController.nextPageKey = _page;
      if (state.chatrooms.isEmpty || state.chatrooms.length < 50) {
        homeFeedPagingController.appendLastPage(state.chatrooms);
      } else {
        homeFeedPagingController.appendPage(state.chatrooms, _page);
      }
    }
  }

  Widget _defaultErrorView() {
    return Container();
  }

  Widget _defaultEmptyView() {
    return Center(
        child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const LMChatIcon(
          type: LMChatIconType.png,
          assetPath: emptyViewImage,
          style: LMChatIconStyle(
            size: 100,
          ),
        ),
        const SizedBox(height: 12),
        LMChatText(
          'Oops! No direct messages.',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              color: LMChatTheme.theme.inActiveColor,
            ),
          ),
        )
      ],
    ));
  }

  LMChatTile _defaultDMChatRoomTile(LMChatRoomViewData chatroom) {
    final user = LMChatLocalPreference.instance.getUser();
    bool whichUser = user.id != chatroom.chatroomWithUserId;
    final chatroomUser =
        whichUser ? chatroom.chatroomWithUser! : chatroom.member!;
    String message = getDMChatroomPreviewMessage(
      chatroom.lastConversation!,
      chatroom.lastConversation!.member!,
      chatroom.member!,
      chatroom.chatroomWithUser!,
    );
    return LMChatTile(
      style: LMChatTileStyle.basic().copyWith(
        backgroundColor: LMChatTheme.theme.scaffold,
      ),
      onTap: () {
        LMChatRealtime.instance.chatroomId = chatroom.id;
        final route = MaterialPageRoute(
          builder: (context) {
            return LMChatroomScreen(
              chatroomId: chatroom.id,
            );
          },
        );
        Navigator.of(context).push(route).then(
              (val) => feedBloc.add(LMChatRefreshDMFeedEvent()),
            );
      },
      leading: LMChatProfilePicture(
        fallbackText: chatroomUser.name,
        imageUrl: chatroomUser.imageUrl,
        style: _style.profilePictureStyle ??
            LMChatProfilePictureStyle.basic().copyWith(size: 48),
      ),
      title: LMChatText(
        chatroomUser.name,
        style: LMChatTextStyle(
          maxLines: 1,
          textStyle: TextStyle(
            fontSize: 16,
            color: LMChatTheme.theme.onContainer,
            fontWeight: FontWeight.w500,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ),
      subtitle: ((chatroom.lastConversation?.attachmentsUploaded ?? false) &&
              chatroom.lastConversation?.deletedByUserId == null)
          ? getChatItemAttachmentTile(
              message, chatroom.attachments, chatroom.lastConversation!)
          : LMChatText(
              chatroom.lastConversation!.state != 0
                  ? LMChatTaggingHelper.extractStateMessage(message)
                  : message,
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  fontSize: 14,
                  color: LMChatTheme.theme.onContainer,
                  fontWeight: FontWeight.w400,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
      trailing: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          chatroom.muteStatus != null && chatroom.muteStatus!
              ? _screenBuilder.dmFeedMuteIconBuilder(
                  _defMuteButton(),
                )
              : const SizedBox.shrink(),
          const SizedBox(width: 8),
          Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              LMChatText(
                getTime(chatroom.lastConversation!.createdEpoch!.toString()),
                style: LMChatTextStyle(
                  textStyle: TextStyle(
                    fontSize: 12,
                    color: LMChatTheme.theme.onContainer,
                    fontWeight: FontWeight.w400,
                  ),
                ),
              ),
              const SizedBox(height: 6),
              Visibility(
                visible: chatroom.unseenCount! > 0,
                child: Container(
                  constraints: const BoxConstraints(
                    minHeight: 24,
                    maxHeight: 24,
                  ),
                  width: 24,
                  decoration: BoxDecoration(
                    borderRadius: const BorderRadius.all(Radius.circular(14)),
                    color: LMChatTheme.theme.primaryColor,
                  ),
                  child: Center(
                    child: LMChatText(
                      chatroom.unseenCount! > 99
                          ? "99+"
                          : chatroom.unseenCount.toString(),
                      style: _style.unreadCountTextStyle,
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  LMChatButton _floatingActionButton() {
    return LMChatButton(
      onTap: () {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => const LMChatExplorePage(),
          ),
        );
      },
      style: LMChatButtonStyle(
        backgroundColor: LMChatTheme.theme.backgroundColor,
        height: 48,
        width: 48,
        borderRadius: 12,
      ),
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.message,
        style: LMChatIconStyle(
          color: LMChatTheme.theme.primaryColor,
        ),
      ),
    );
  }

  LMChatIcon _defMuteButton() {
    return const LMChatIcon(
      type: LMChatIconType.icon,
      icon: Icons.volume_off_outlined,
    );
  }

  @override
  bool get wantKeepAlive => true;
}

/// {@template lm_chat_dm_feed_list_style}
/// A style object to customize the look and feel of the DM Feed List
/// {@endtemplate}
class LMChatDMFeedListStyle {
  /// [backgroundColor] is the background color of the list
  final Color? backgroundColor;

  /// [padding] is the padding of the list
  final EdgeInsets? padding;

  /// [profilePictureStyle] is the style of the profile picture
  final LMChatProfilePictureStyle? profilePictureStyle;

  /// [unreadCountTextStyle] is the style of the unread count text
  final LMChatTextStyle? unreadCountTextStyle;

  static final LMChatThemeData _themeData = LMChatTheme.theme;

  /// {@macro lm_chat_dm_feed_list_style}
  const LMChatDMFeedListStyle({
    this.backgroundColor,
    this.padding,
    this.profilePictureStyle,
    this.unreadCountTextStyle,
  });

  /// {@macro lm_chat_dm_feed_list_style}
  factory LMChatDMFeedListStyle.basic() {
    return LMChatDMFeedListStyle(
      backgroundColor: _themeData.scaffold,
      padding: const EdgeInsets.only(
        left: 4,
        right: 8,
      ),
      profilePictureStyle: LMChatProfilePictureStyle.basic().copyWith(size: 48),
      unreadCountTextStyle: LMChatTextStyle(
        padding: const EdgeInsets.only(
          left: 7,
          right: 7,
          top: 2,
          bottom: 2,
        ),
        textStyle: TextStyle(
          fontSize: 12,
          color: LMChatTheme.theme.onPrimary,
          fontWeight: FontWeight.w400,
        ),
      ),
    );
  }

  /// Creates a copy of this [LMChatDMFeedListStyle] but with the given fields replaced with the new values.
  /// If the new values are null, the old values are retained.
  LMChatDMFeedListStyle copyWith({
    Color? backgroundColor,
    EdgeInsets? padding,
    LMChatProfilePictureStyle? profilePictureStyle,
    LMChatTextStyle? unreadCountTextStyle,
  }) {
    return LMChatDMFeedListStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      padding: padding ?? this.padding,
      profilePictureStyle: profilePictureStyle ?? this.profilePictureStyle,
      unreadCountTextStyle: unreadCountTextStyle ?? this.unreadCountTextStyle,
    );
  }
}



================================================
File: lib/packages/core/lib/src/widgets/lists/conversation/conversation_list.dart
================================================
// ignore_for_file: unused_import

import 'dart:async';

import 'package:date_format/date_format.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
// import 'package:infinite_scroll_pagination/infinite_scroll_pagination.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/audio_handler.dart';
import 'package:likeminds_chat_flutter_core/src/views/poll/poll_handler.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:intl/intl.dart';
import 'package:super_sliver_list/super_sliver_list.dart';

/// {@template lm_chat_conversation_list}
/// A widget that displays a list of conversations.
/// {@endtemplate}
class LMChatConversationList extends StatefulWidget {
  /// The chatroom id.
  final int chatroomId;

  /// The selected conversations.
  final List<int>? selectedConversations;

  /// The conversation helper.
  final LMChatConversationActionInterface? conversationHelper;

  /// The app bar notifier.
  final ValueNotifier<bool>? appBarNotifier;

  /// The paginated list controller.
  final LMDualSidePaginationController<LMChatConversationViewData>?
      paginatedListController;

  /// Creates a new instance of LMChatConversationList
  const LMChatConversationList({
    super.key,
    required this.chatroomId,
    this.selectedConversations,
    this.conversationHelper,
    this.appBarNotifier,
    this.paginatedListController,
  });

  @override
  State<LMChatConversationList> createState() => _LMChatConversationListState();
}

class _LMChatConversationListState extends State<LMChatConversationList> {
  late LMChatConversationBloc _conversationBloc;
  late LMChatConversationActionBloc _convActionBloc;

  late User user;
  int _topPage = 1;
  int _bottomPage = 1;
  final int _pageSize = 200;
  int lastConversationId = 0;

  ValueNotifier showConversationActions = ValueNotifier(false);
  ValueNotifier rebuildConversationList = ValueNotifier(false);
  late ValueNotifier<bool> rebuildAppBar;

  Map<String, Conversation> conversationMeta = <String, Conversation>{};
  Map<String, List<LMChatAttachmentViewData>> conversationAttachmentsMeta =
      <String, List<LMChatAttachmentViewData>>{};
  Map<String, List<LMChatReactionViewData>> conversationReactionsMeta =
      <String, List<LMChatReactionViewData>>{};
  Map<int, User?> userMeta = <int, User?>{};
  List<int> _selectedIds = [];
  int? _animateToChatId;

  late ScrollController scrollController;
  final LMChatroomBuilderDelegate _screenBuilder =
      LMChatCore.config.chatRoomConfig.builder;
  late LMDualSidePaginationController<LMChatConversationViewData>
      pagedListController = widget.paginatedListController ??
          LMDualSidePaginationController(
            listController: ListController(),
            scrollController: ScrollController(),
          );
  final LMChatThemeData theme = LMChatTheme.theme;
  int? replyId;
  LMChatConversationViewData? localConversation;

  @override
  void initState() {
    super.initState();
    user = LMChatLocalPreference.instance.getUser();
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    _selectedIds = widget.selectedConversations ?? [];
    rebuildAppBar = widget.appBarNotifier ?? ValueNotifier(false);
    // setting the reply conversation to null
  }

  @override
  void didUpdateWidget(covariant LMChatConversationList oldWidget) {
    super.didUpdateWidget(oldWidget);
    user = LMChatLocalPreference.instance.getUser();
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    _selectedIds = widget.selectedConversations ?? [];
    rebuildAppBar = widget.appBarNotifier ?? ValueNotifier(false);
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocListener(
      listeners: [
        BlocListener<LMChatConversationActionBloc,
            LMChatConversationActionState>(
          bloc: _convActionBloc,
          listener: (context, state) {
            if (state is LMChatConversationDelete) {
              for (LMChatConversationViewData conversation
                  in state.conversations) {
                _updateDeletedConversation(conversation);
              }
            }
            if (state is LMChatConversationEdited) {
              _updateEditedConversation(state.conversationViewData);
            }
            if (state is LMChatPutReactionState ||
                state is LMChatPutReactionError ||
                state is LMChatDeleteReactionState ||
                state is LMChatDeleteReactionError) {
              _updateReactions(state);
            }
          },
        ),
        BlocListener<LMChatConversationBloc, LMChatConversationState>(
          bloc: _conversationBloc,
          listener: (context, state) {
            updatePagingControllers(state);
          },
        )
      ],
      child: ValueListenableBuilder(
        valueListenable: rebuildConversationList,
        builder: (context, value, child) {
          return LMDualSidePagedList<LMChatConversationViewData>(
            paginationType: LMChatConversationBloc.replyConversation == null
                ? LMPaginationType.top
                : LMPaginationType.both,
            initialPage: 1,
            onPaginationTriggered: _onPaginationTriggered,
            paginationController: pagedListController,
            padding: const EdgeInsets.symmetric(
              vertical: 10,
            ),
            reverse: true,
            firstPageProgressIndicatorBuilder: (context) =>
                _screenBuilder.loadingListWidgetBuilder(
              context,
              const LMChatSkeletonChatList(),
            ),
            newPageProgressIndicatorBuilder: (context) =>
                _screenBuilder.paginatedLoadingWidgetBuilder(
              context,
              const LMChatLoader(),
            ),
            noItemsFoundIndicatorBuilder: (context) {
              return _defaultEmptyView();
            },
            itemBuilder: (context, item, index) {
              if (item.isTimeStamp != null && item.isTimeStamp! ||
                  item.state != 0 && item.state != 10 && item.state != null) {
                final stateMessage =
                    LMChatTaggingHelper.extractStateMessage(item.answer);
                return _screenBuilder.stateBubbleBuilder(
                  context,
                  stateMessage,
                  _defaultStateBubble(stateMessage),
                );
              }
              return conversationWithCustomWidget(item)
                  ? _screenBuilder.customChatBubbleBuilder(
                      context, item, widget.chatroomId)
                  : item.memberId == user.id
                      ? _screenBuilder.sentChatBubbleBuilder(
                          context, item, _defaultSentChatBubble(item))
                      : _screenBuilder.receivedChatBubbleBuilder(
                          context, item, _defaultReceivedChatBubble(item));
            },
          );
        },
      ),
    );
  }

  Future<void> _onPaginationTriggered(pageKey, direction, conversation) async {
    LMChatConversationViewData? replyConversation =
        LMChatConversationBloc.replyConversation;
    _conversationBloc.add(
      LMChatFetchConversationsEvent(
        minTimestamp: replyConversation == null
            ? null
            : direction == LMPaginationDirection.bottom
                ? replyConversation.createdEpoch
                : null,
        maxTimestamp: replyConversation == null
            ? null
            : direction == LMPaginationDirection.top
                ? replyConversation.createdEpoch
                : null,
        chatroomId: widget.chatroomId,
        page: pageKey,
        pageSize: _pageSize,
        direction: direction,
        lastConversationId: lastConversationId,
        replyId: replyId,
        orderBy: direction == LMPaginationDirection.bottom
            ? OrderBy.ascending
            : OrderBy.descending,
      ),
    );
  }

  LMChatStateBubble _defaultStateBubble(String message) {
    return LMChatStateBubble(
      message: message,
      style: LMChatTheme.theme.stateBubbleStyle.copyWith(
        backgroundColor: const Color(0xffacb7c0),
        messageStyle: LMChatTextStyle.basic().copyWith(
          maxLines: 2,
          textStyle: TextStyle(
            fontSize: 12,
            color: LMChatTheme.theme.container,
          ),
          textAlign: TextAlign.center,
        ),
      ),
    );
  }

  LMChatBubble _defaultSentChatBubble(LMChatConversationViewData conversation) {
    return LMChatBubble(
      actionHelper: widget.conversationHelper,
      onReplyTap: () {
        _onReplyTap(conversation, pagedListController, widget.chatroomId);
      },
      conversation: conversation,
      attachments:
          conversationAttachmentsMeta[conversation.temporaryId.toString()] ??
              conversationAttachmentsMeta[conversation.id.toString()],
      currentUser: LMChatLocalPreference.instance.getUser().toUserViewData(),
      conversationUser: conversation.member!,
      poll: _defPoll(conversation),
      userMeta: userMeta.map((id, user) {
        return MapEntry(id, user!.toUserViewData());
      }),
      audioHandler: LMChatCoreAudioHandler.instance,
      onTagTap: (tag) {},
      reactions:
          conversationReactionsMeta[conversation.temporaryId.toString()] ??
              conversationReactionsMeta[conversation.id.toString()],
      onReaction: (r) {
        onReaction(r, conversation.id);
        setState(() {});
      },
      onRemoveReaction: (r) {
        onRemoveReaction(r, conversation.id);
        setState(() {});
      },
      onReactionsTap: () {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.reactionListOpened,
            eventProperties: {
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      onReply: (conversation) {
        _convActionBloc.add(
          LMChatReplyConversationEvent(
            chatroomId: widget.chatroomId,
            conversationId: conversation.id,
            replyConversation: conversation,
            attachments: conversationAttachmentsMeta[
                    conversation.temporaryId.toString()] ??
                conversationAttachmentsMeta[conversation.id.toString()],
          ),
        );
      },
      isSent: true,
      style: LMChatBubbleStyle.basic().copyWith(
        showHeader: false,
      ),
      isSelected: _selectedIds.contains(conversation.id) ||
          _animateToChatId == conversation.id,
      onLongPress: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.messageSelected,
            eventProperties: {
              'type': 'text',
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.emoticonTrayOpened,
            eventProperties: {
              'from': 'long press',
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      isSelectableOnTap: () {
        return _selectedIds.isNotEmpty;
      },
      onTap: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
          LMChatAnalyticsBloc.instance.add(
            LMChatFireAnalyticsEvent(
              eventName: LMChatAnalyticsKeys.messageSelected,
              eventProperties: {
                'type': 'text',
                'chatroom_id': widget.chatroomId,
              },
            ),
          );
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
      },
      onMediaTap: () {
        LMChatMediaHandler.instance.addPickedMedia(
            conversationAttachmentsMeta[conversation.id.toString()]);
        LMChatCoreAudioHandler.instance.stopAudio();
        LMChatCoreAudioHandler.instance.stopRecording();
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => LMChatMediaPreviewScreen(
              conversation: conversation,
            ),
          ),
        );
      },
      replyBuilder: (reply, oldWidget) {
        String message = getGIFText(reply);
        return oldWidget.copyWith(
          subtitle: ((reply.attachmentsUploaded ?? false) &&
                  reply.deletedByUserId == null)
              ? getChatItemAttachmentTile(message,
                  conversationAttachmentsMeta[reply.id.toString()] ?? [], reply)
              : LMChatText(
                  reply.state != 0
                      ? LMChatTaggingHelper.extractStateMessage(message)
                      : LMChatTaggingHelper.convertRouteToTag(
                            message,
                            withTilde: false,
                          ) ??
                          "Replying to Conversation",
                  style: LMChatTextStyle(
                    maxLines: 1,
                    textStyle: TextStyle(
                      fontSize: 12,
                      color: LMChatTheme.theme.onContainer,
                      fontWeight: FontWeight.w400,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
        );
      },
    );
  }

  LMChatPoll _defPoll(LMChatConversationViewData conversation) {
    ValueNotifier<bool> rebuildPoll = ValueNotifier(false);
    final List<int> selectedOptions = [];
    bool isVoteEditing = false;

    return LMChatPoll(
      style: theme.pollStyle,
      rebuildPollWidget: rebuildPoll,
      pollData: conversation,
      selectedOption: selectedOptions,
      onEditVote: (pollData) {
        isVoteEditing = true;
        selectedOptions.clear();
        pollData.poll?.forEach((element) {
          if ((element.isSelected ?? false)) {
            selectedOptions.add(element.id!);
          }
        });
        rebuildPoll.value = !rebuildPoll.value;
      },
      onSubmit: (options) {
        submitVote(
          context,
          conversation,
          options,
          {},
          conversation.copyWith(),
          widget.chatroomId,
        );
      },
      onOptionSelect: (option) {
        // if poll has ended, then do not allow to vote
        if (LMChatPollUtils.hasPollEnded(
            conversation.expiryTime, conversation.noPollExpiry)) {
          return;
        }
        // if poll is submitted and not editing votes, then do not allow to vote
        if (LMChatPollUtils.isPollSubmitted(conversation.poll ?? []) &&
            !isVoteEditing) {
          return;
        }
        // if multiple select is enabled, then add the option to the selected options
        // else submit the vote
        if (LMChatPollUtils.isMultiChoicePoll(
            conversation.multipleSelectNo, conversation.multipleSelectState)) {
          if (selectedOptions.contains(option.id)) {
            selectedOptions.remove(option.id);
          } else {
            if (option.id != null) {
              selectedOptions.add(option.id!);
            }
          }
          rebuildPoll.value = !rebuildPoll.value;
        } else {
          submitVote(
            context,
            conversation,
            [option],
            {},
            conversation.copyWith(),
            widget.chatroomId,
          );
        }
      },
      onAddOptionSubmit: (optionText) async {
        await addOption(
          context,
          conversation,
          optionText,
          user.toUserViewData(),
          rebuildPoll,
          LMChatWidgetSource.chatroom,
        );
        rebuildConversationList.value = !rebuildConversationList.value;
      },
      onVoteClick: (option) {
        onVoteTextTap(
          context,
          conversation,
          LMChatWidgetSource.chatroom,
          option: option,
        );
      },
      onAnswerTextTap: () {
        onVoteTextTap(
          context,
          conversation,
          LMChatWidgetSource.chatroom,
        );
      },
    );
  }

  LMChatBubble _defaultReceivedChatBubble(
      LMChatConversationViewData conversation) {
    return LMChatBubble(
      actionHelper: widget.conversationHelper,
      onReplyTap: () {
        _onReplyTap(conversation, pagedListController, widget.chatroomId);
      },
      conversation: conversation,
      attachments: conversationAttachmentsMeta[conversation.id.toString()],
      currentUser: LMChatLocalPreference.instance.getUser().toUserViewData(),
      poll: _defPoll(conversation),
      conversationUser: conversation.member!,
      userMeta: userMeta.map((id, user) {
        return MapEntry(id, user!.toUserViewData());
      }),
      audioHandler: LMChatCoreAudioHandler.instance,
      reactions:
          conversationReactionsMeta[conversation.temporaryId.toString()] ??
              conversationReactionsMeta[conversation.id.toString()],
      onReaction: (r) {
        onReaction(r, conversation.id);
        setState(() {});
      },
      onRemoveReaction: (r) {
        onRemoveReaction(r, conversation.id);
        setState(() {});
      },
      onReactionsTap: () {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.reactionListOpened,
            eventProperties: {
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      onTagTap: (tag) {},
      onReply: (conversation) {
        _convActionBloc.add(
          LMChatReplyConversationEvent(
            chatroomId: widget.chatroomId,
            conversationId: conversation.id,
            replyConversation: conversation,
            attachments:
                conversationAttachmentsMeta[conversation.id.toString()],
          ),
        );
      },
      replyBuilder: (reply, oldWidget) {
        String message = getGIFText(reply);
        return oldWidget.copyWith(
          subtitle: ((reply.attachmentsUploaded ?? false) &&
                  reply.deletedByUserId == null)
              ? getChatItemAttachmentTile(message,
                  conversationAttachmentsMeta[reply.id.toString()] ?? [], reply)
              : LMChatText(
                  reply.state != 0
                      ? LMChatTaggingHelper.extractStateMessage(message)
                      : LMChatTaggingHelper.convertRouteToTag(
                            message,
                            withTilde: false,
                          ) ??
                          "Replying to Conversation",
                  style: LMChatTextStyle(
                    maxLines: 1,
                    textStyle: TextStyle(
                      fontSize: 12,
                      color: LMChatTheme.theme.onContainer,
                      fontWeight: FontWeight.w400,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
        );
      },
      isSent: false,
      style: LMChatBubbleStyle.basic().copyWith(
        showHeader: conversation.conversationViewType !=
            LMChatConversationViewType.bottom,
      ),
      avatar: LMChatProfilePicture(
        fallbackText: conversation.member!.name,
        imageUrl: conversation.member!.imageUrl,
        style: const LMChatProfilePictureStyle(
          size: 39,
          boxShape: BoxShape.circle,
        ),
      ),
      avatarBuilder: (context, avatar) {
        if (conversation.conversationViewType ==
            LMChatConversationViewType.bottom) {
          return const SizedBox(
            width: 39,
          );
        }
        return avatar;
      },
      isSelected: _selectedIds.contains(conversation.id) ||
          _animateToChatId == conversation.id,
      onLongPress: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.messageSelected,
            eventProperties: {
              'type': 'text',
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.emoticonTrayOpened,
            eventProperties: {
              'from': 'long press',
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      isSelectableOnTap: () {
        return _selectedIds.isNotEmpty;
      },
      onTap: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
          LMChatAnalyticsBloc.instance.add(
            LMChatFireAnalyticsEvent(
              eventName: LMChatAnalyticsKeys.messageSelected,
              eventProperties: {
                'type': 'text',
                'chatroom_id': widget.chatroomId,
              },
            ),
          );
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
      },
      onMediaTap: () {
        LMChatMediaHandler.instance.addPickedMedia(
            conversationAttachmentsMeta[conversation.id.toString()]);
        LMChatCoreAudioHandler.instance.stopAudio();
        LMChatCoreAudioHandler.instance.stopRecording();
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => LMChatMediaPreviewScreen(
              conversation: conversation,
            ),
          ),
        );
      },
    );
  }

  Widget _defaultEmptyView() {
    return Center(
        child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const LMChatIcon(
          type: LMChatIconType.png,
          assetPath: emptyViewImage,
          style: LMChatIconStyle(
            size: 100,
          ),
        ),
        const SizedBox(height: 12),
        LMChatText(
          'Oops! No conversations found.',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              color: LMChatTheme.theme.inActiveColor,
            ),
          ),
        )
      ],
    ));
  }

  Future<void> updatePagingControllers(LMChatConversationState state) async {
    if (state is LMChatConversationLoadedState) {
      if (state.getConversationResponse.conversationMeta != null &&
          state.getConversationResponse.conversationMeta!.isNotEmpty) {
        conversationMeta
            .addAll(state.getConversationResponse.conversationMeta!);
      }
      if (state.getConversationResponse.conversationAttachmentsMeta != null &&
          state.getConversationResponse.conversationAttachmentsMeta!
              .isNotEmpty) {
        Map<String, List<LMChatAttachmentViewData>>
            getConversationAttachmentData = state
                .getConversationResponse.conversationAttachmentsMeta!
                .map((key, value) {
          return MapEntry(
            key,
            (value as List<Attachment>?)
                    ?.map((e) => e.toAttachmentViewData())
                    .toList() ??
                [],
          );
        });
        conversationAttachmentsMeta.addAll(getConversationAttachmentData);
      }
      if (state.getConversationResponse.conversationReactionMeta != null &&
          state.getConversationResponse.conversationReactionMeta!.isNotEmpty) {
        Map<String, List<LMChatReactionViewData>> getConversationReactionsData =
            state.getConversationResponse.conversationReactionMeta!
                .map((key, value) {
          return MapEntry(
            key,
            (value as List<Reaction>?)
                    ?.map((e) => e.toReactionViewData())
                    .toList() ??
                [],
          );
        });
        conversationReactionsMeta.addAll(getConversationReactionsData);
      }

      if (state.getConversationResponse.userMeta != null) {
        userMeta.addAll(state.getConversationResponse.userMeta!);
      }
      List<LMChatConversationViewData>? conversationData =
          state.getConversationResponse.conversationData?.map((e) {
        final conv = e.toConversationViewData(
          conversationPollsMeta:
              state.getConversationResponse.conversationPollsMeta,
          userMeta: state.getConversationResponse.userMeta,
          attachmentMeta:
              state.getConversationResponse.conversationAttachmentsMeta,
          reactionMeta: state.getConversationResponse.conversationReactionMeta,
          conversationMeta: state.getConversationResponse.conversationMeta,
          widgets: state.getConversationResponse.widgets,
        );
        // Add attachments to the conversation object explicitly
        if (conversationAttachmentsMeta.containsKey(conv.id.toString())) {
          return conv.copyWith(
            attachments: conversationAttachmentsMeta[conv.id.toString()],
          );
        }
        return conv;
      }).toList();

      if (state.direction == LMPaginationDirection.bottom) {
        conversationData = conversationData?.reversed.toList();
      }
      if (state.reInitialize) {
        pagedListController.clear();
        _topPage = 1;
        if (localConversation != null) {
          conversationData?.insert(0, localConversation!);
          localConversation = null;
        }
      }
      if (state.page == 1) {
        conversationData =
            groupConversationsAndAddDates(conversationData ?? []);
      } else {
        conversationData = updatePaginationConversationsViewType(
            pagedListController.itemList, conversationData ?? []);
      }
      if (state.getConversationResponse.conversationData == null ||
          state.getConversationResponse.conversationData!.isEmpty ||
          state.getConversationResponse.conversationData!.length < _pageSize) {
        if (state.direction == LMPaginationDirection.top) {
          _bottomPage++;
          pagedListController.appendLastPageToEnd(conversationData);
        } else {
          _topPage++;
          pagedListController
              .appendFirstPageToStart(conversationData.reversed.toList());
        }
      } else {
        if (state.direction == LMPaginationDirection.top) {
          _bottomPage++;
          pagedListController.appendPageToEnd(conversationData, _bottomPage);
        } else {
          _topPage++;
          pagedListController.appendPageToStart(
              conversationData.toList(), _topPage);
        }
      }
      rebuildConversationList.value = !rebuildConversationList.value;
    }
    if (state is LMChatConversationPostedState) {
      if (LMChatConversationBloc.replyConversation != null) {
        localConversation = state.conversationViewData;
        return;
      }
      addConversationToPagedList(
        state.conversationViewData,
      );
    } else if (state is LMChatLocalConversationState) {
      if (LMChatConversationBloc.replyConversation != null) {
        localConversation = state.conversationViewData;
        return;
      }
      addLocalConversationToPagedList(state.conversationViewData);
    } else if (state is LMChatConversationErrorState) {
      toast(state.message);
    }

    if (state is LMChatMultiMediaConversationLoadingState) {
      LMChatConversationViewData conv =
          state.postConversation.toConversationViewData();

      // Add reply conversation object if exists
      conv = conv.copyWith(
          replyConversationObject: conversationMeta[conv.replyId.toString()]
              ?.toConversationViewData());

      if (!userMeta.containsKey(user.id)) {
        userMeta[user.id] = user;
      }
      conversationAttachmentsMeta[conv.temporaryId!] =
          state.mediaFiles.map((e) => e.toAttachmentViewData()).toList();

      addLocalConversationToPagedList(conv);
    }
    if (state is LMChatMultiMediaConversationPostedState) {
      final conv = state.postConversationResponse.conversation;

      conversationAttachmentsMeta[conv!.id.toString()] =
          state.putMediaResponse.map((e) => e.toAttachmentViewData()).toList();

      addConversationToPagedList(
        state.postConversationResponse.conversation!.toConversationViewData(),
      );
    }
    if (state is LMChatConversationUpdatedState) {
      if (state.conversationViewData.id != lastConversationId ||
          state.shouldUpdate) {
        conversationAttachmentsMeta.addAll(state.attachments);
        addConversationToPagedList(
          state.conversationViewData,
        );
        lastConversationId = state.conversationViewData.id;
        LMChatroomActionBloc.instance.add(
          LMChatMarkReadChatroomEvent(
            chatroomId: widget.chatroomId,
          ),
        );
      }
    }
  }

  // This function adds local conversation to the paging controller
  // and rebuilds the list to reflect UI changes
  void addLocalConversationToPagedList(
      LMChatConversationViewData conversation) {
    LMChatConversationViewData? result;
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;

    // Handle reply conversation logic
    if (conversation.replyId != null &&
        !conversationMeta.containsKey(conversation.replyId.toString())) {
      LMChatConversationViewData? replyConversation =
          pagedListController.itemList.firstWhere((element) =>
              element.id ==
              (conversation.replyId ?? conversation.replyConversation));
      conversationMeta[conversation.replyId.toString()] =
          replyConversation.toConversation();

      result = conversation.copyWith(
        replyConversationObject: replyConversation,
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    } else {
      result = conversation.copyWith(
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    }

    // Check if we need to add a timestamp message
    if (conversationList.isNotEmpty &&
        conversationList.first.date != conversation.date) {
      // Add timestamp message before the new conversation
      conversationList.insert(
        0,
        Conversation(
          isTimeStamp: true,
          id: 1,
          hasFiles: false,
          attachmentCount: 0,
          attachmentsUploaded: false,
          createdEpoch: conversation.createdEpoch,
          chatroomId: widget.chatroomId,
          date: conversation.date,
          memberId: conversation.memberId,
          temporaryId: conversation.temporaryId,
          answer: DateFormat('dd MMM yyyy').format(
              DateTime.fromMillisecondsSinceEpoch(
                  conversation.createdEpoch ?? 0)),
          communityId: LMChatLocalPreference.instance.getCommunityData()!.id,
          createdAt: conversation.createdAt,
          header: conversation.header,
        ).toConversationViewData(),
      );
    }

    // check if the new conversation is by the same user as last conversation
    // if yes, then add the conversation to the same group by assigning view type - bottom
    if (conversationList.isNotEmpty &&
        conversationList.first.memberId == conversation.memberId) {
      result = result.copyWith(
          conversationViewType: LMChatConversationViewType.bottom);
    }

    // Add the actual conversation
    conversationList.insert(0, result);
    if (conversationList.length >= _pageSize) {
      conversationList.removeLast();
    }
    if (!userMeta.containsKey(user.id)) {
      userMeta[user.id] = user;
    }
    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void addConversationToPagedList(LMChatConversationViewData conversation) {
    LMChatConversationViewData? result;
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;

    int index = conversationList.indexWhere((element) {
      if (conversation.temporaryId == null || element.temporaryId == null) {
        return element.id == conversation.id;
      }
      return element.temporaryId == conversation.temporaryId;
    });
    if ((conversation.replyId != null ||
            conversation.replyConversation != null) &&
        !conversationMeta.containsKey(conversation.replyId.toString())) {
      LMChatConversationViewData? replyConversation =
          pagedListController.itemList.firstWhere((element) =>
              element.id ==
              (conversation.replyId ?? conversation.replyConversation));
      conversationMeta[conversation.replyId.toString()] =
          replyConversation.toConversation();

      result = conversation.copyWith(
        replyConversationObject: replyConversation,
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    } else {
      result = conversation.copyWith(
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    }
    // check if the new conversation is by the same user as last conversation
    // if yes, then add the conversation to the same group by assigning view type - bottom
    if (conversationList.isNotEmpty &&
        conversationList.first.memberId == conversation.memberId) {
      result = result.copyWith(
          conversationViewType: LMChatConversationViewType.bottom);
    }
    if (index != -1) {
      conversationList[index] = result;
    } else if (conversationList.isNotEmpty) {
      if (conversationList.first.date != conversation.date) {
        conversationList.insert(
          0,
          Conversation(
            isTimeStamp: true,
            id: 1,
            hasFiles: false,
            attachmentCount: 0,
            attachmentsUploaded: false,
            createdEpoch: conversation.createdEpoch,
            chatroomId: widget.chatroomId,
            date: conversation.date,
            memberId: conversation.memberId,
            temporaryId: conversation.temporaryId,
            answer: DateFormat('dd MMM yyyy').format(
                DateTime.fromMillisecondsSinceEpoch(
                    conversation.createdEpoch ?? 0)),
            communityId: LMChatLocalPreference.instance.getCommunityData()!.id,
            createdAt: conversation.createdAt,
            header: conversation.header,
          ).toConversationViewData(),
        );
      }
      // add the actual conversation
      conversationList.insert(0, result);
      if (conversationList.length >= _pageSize) {
        conversationList.removeLast();
      }
      if (!userMeta.containsKey(user.id)) {
        userMeta[user.id] = user;
      }
    }
    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _updateDeletedConversation(LMChatConversationViewData conversation) {
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;

    // Update the deleted conversation
    int index =
        conversationList.indexWhere((element) => element.id == conversation.id);
    if (index != -1) {
      conversationList[index] = conversationList[index].copyWith(
        deletedByUserId: user.id,
      );
    }

    // Update conversations replying to the deleted conversation
    for (int i = 0; i < conversationList.length; i++) {
      if (conversationList[i].replyId == conversation.id ||
          conversationList[i].replyConversation == conversation.id) {
        conversationList[i] = conversationList[i].copyWith(
          replyConversationObject: conversation.copyWith(
            deletedByUserId: user.id,
          ),
        );
      }
    }

    if (conversationMeta.isNotEmpty &&
        conversationMeta.containsKey(conversation.id.toString())) {
      conversationMeta[conversation.id.toString()]!.deletedByUserId = user.id;
    }

    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _updateEditedConversation(
      LMChatConversationViewData editedConversation) {
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;
    int index = conversationList
        .indexWhere((element) => element.id == editedConversation.id);
    if (index != -1) {
      conversationList[index] = editedConversation;
    }

    if (conversationMeta.isNotEmpty &&
        conversationMeta.containsKey(editedConversation.id.toString())) {
      conversationMeta[editedConversation.id.toString()] =
          editedConversation.toConversation();
    }
    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  onReaction(
    String reaction,
    int conversationId,
  ) {
    if (reaction == 'Add') {
      LMChatroomActionBloc.instance.add(
        LMChatShowEmojiKeyboardEvent(
          conversationId: conversationId,
        ),
      );
    } else {
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.reactionAdded,
          eventProperties: {
            'reaction': reaction,
            'from': 'long_press',
            'message_id': conversationId,
            'chatroom_id': widget.chatroomId,
          },
        ),
      );
      _convActionBloc.add(LMChatPutReaction(
        conversationId: conversationId,
        reaction: reaction,
      ));
      _selectedIds.remove(conversationId);
      rebuildAppBar.value = !rebuildAppBar.value;
    }
  }

  onRemoveReaction(String reaction, int conversationId) {
    LMChatAnalyticsBloc.instance.add(
      LMChatFireAnalyticsEvent(
        eventName: LMChatAnalyticsKeys.reactionRemoved,
        eventProperties: {
          'message_id': conversationId,
          'chatroom_id': widget.chatroomId,
        },
      ),
    );
    _convActionBloc.add(LMChatDeleteReaction(
      conversationId: conversationId,
      reaction: reaction,
    ));
    Navigator.pop(context);
  }

  void _updateReactions(LMChatConversationActionState state) {
    if (state is LMChatPutReactionState) {
      LMChatReactionViewData addedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      if (!userMeta.containsKey(user.id)) {
        userMeta[user.id] = user;
      }
      _addReaction(addedReaction, state.conversationId);
    }
    if (state is LMChatPutReactionError) {
      toast(state.errorMessage);
      LMChatReactionViewData addedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      _removeReaction(addedReaction);
    }
    if (state is LMChatDeleteReactionState) {
      LMChatReactionViewData deletedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      _removeReaction(deletedReaction);
    }
    if (state is LMChatDeleteReactionError) {
      toast(state.errorMessage);
      LMChatReactionViewData deletedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      _addReaction(deletedReaction, state.conversationId);
    }
  }

  void _addReaction(LMChatReactionViewData reaction, int conversationId) {
    String conversationIdStr = conversationId.toString();
    if (conversationReactionsMeta.containsKey(conversationIdStr)) {
      final existingReactions = conversationReactionsMeta[conversationIdStr]!;
      final existingReactionIndex =
          existingReactions.indexWhere((r) => r.userId == reaction.userId);
      if (existingReactionIndex != -1) {
        existingReactions[existingReactionIndex] =
            reaction; // Update existing reaction
      } else {
        existingReactions.add(reaction); // Add new reaction
      }
    } else {
      conversationReactionsMeta[conversationIdStr] = [reaction];
    }
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;
    int index =
        conversationList.indexWhere((element) => element.id == conversationId);
    if (index != -1) {
      conversationList[index] =
          conversationList[index].copyWith(hasReactions: true);
    }
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _removeReaction(LMChatReactionViewData reaction) {
    String conversationIdStr = reaction.conversationId.toString();
    if (conversationReactionsMeta.containsKey(conversationIdStr)) {
      final existingReactions = conversationReactionsMeta[conversationIdStr]!;
      final existingReactionIndex =
          existingReactions.indexWhere((r) => r.userId == reaction.userId);
      if (existingReactionIndex != -1) {
        existingReactions
            .removeAt(existingReactionIndex); // Remove existing reaction
      }
    }
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;
    int index = conversationList
        .indexWhere((element) => element.id == reaction.conversationId);
    if (index != -1) {
      conversationList[index] = conversationList[index].copyWith(
          hasReactions:
              conversationReactionsMeta[conversationIdStr]!.isNotEmpty);
    }
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _onReplyTap(
    LMChatConversationViewData conversation,
    LMDualSidePaginationController pagedListController,
    int chatroomId,
  ) async {
    // find index of the conversation in the list
    final int? replyId = conversation.replyId ??
        conversation.replyConversation ??
        conversation.replyConversationObject?.id;
    // if not able to find replyId in conversation return
    if (replyId == null) {
      return;
    }
    // find index of reply in conversation list
    int index = pagedListController.itemList
        .indexWhere((element) => element.id == replyId);
    if (index != -1) {
      // scroll and highlight the conversation
      _scrollToConversation(index, replyId, pagedListController);
    } else {
      // handle if index is -1
      final currentTime = DateTime.now().millisecondsSinceEpoch;
      // fetch reply conversation
      final GetConversationRequestBuilder replyConversationBuilder =
          GetConversationRequestBuilder()
            ..chatroomId(chatroomId)
            ..page(1)
            ..pageSize(1)
            ..isLocalDB(false)
            ..minTimestamp(0)
            ..maxTimestamp(currentTime)
            ..conversationId(replyId);

      // [Data Layer] function call
      final replyConversationResponse = await LMChatCore.client
          .getConversation(replyConversationBuilder.build());
      // convert [Conversation] list to [LMChatConversationViewData] list
      final replyConversationsVewData =
          replyConversationResponse.data!.conversationData!.map((e) {
        return e.toConversationViewData(
          conversationPollsMeta:
              replyConversationResponse.data!.conversationPollsMeta,
          userMeta: replyConversationResponse.data!.userMeta,
          attachmentMeta:
              replyConversationResponse.data!.conversationAttachmentsMeta,
          reactionMeta:
              replyConversationResponse.data!.conversationReactionMeta,
          conversationMeta: replyConversationResponse.data!.conversationMeta,
        );
      }).toList();

      // assign replyViewData to Global replyConversation
      if (replyConversationsVewData.isNotEmpty) {
        LMChatConversationBloc.replyConversation =
            replyConversationsVewData.first;
      }

      // fetch 100 conversations from the bottom of the list
      final GetConversationRequestBuilder bottomToReplyConversationBuilder =
          GetConversationRequestBuilder()
            ..chatroomId(chatroomId)
            ..page(1)
            ..pageSize(_pageSize)
            ..isLocalDB(false)
            ..minTimestamp(replyConversationsVewData.first.createdEpoch!)
            ..maxTimestamp(currentTime)
            ..orderBy(OrderBy.ascending);

      // [Data Layer] function call
      final bottomToReplyResponse = await LMChatCore.client
          .getConversation(bottomToReplyConversationBuilder.build());

      // convert [Conversation] list to [LMChatConversationViewData] list
      final bottomConversationsVewData =
          bottomToReplyResponse.data!.conversationData!.map((e) {
        return e.toConversationViewData(
          conversationPollsMeta:
              bottomToReplyResponse.data!.conversationPollsMeta,
          userMeta: bottomToReplyResponse.data!.userMeta,
          attachmentMeta:
              bottomToReplyResponse.data!.conversationAttachmentsMeta,
          reactionMeta: bottomToReplyResponse.data!.conversationReactionMeta,
          conversationMeta: bottomToReplyResponse.data!.conversationMeta,
        );
      }).toList();

      // fetch 100 conversations from the top of the list
      final GetConversationRequestBuilder topToReplyConversationBuilder =
          GetConversationRequestBuilder()
            ..chatroomId(chatroomId)
            ..page(1)
            ..pageSize(_pageSize)
            ..isLocalDB(true)
            ..minTimestamp(0)
            ..maxTimestamp(replyConversationsVewData.first.createdEpoch!);

      // [Data Layer] function call
      final topToReplyResponse = await LMChatCore.client
          .getConversation(topToReplyConversationBuilder.build());

      // convert [Conversation] list to [LMChatConversationViewData] list
      final topConversationsViewData =
          topToReplyResponse.data!.conversationData!.map((e) {
        return e.toConversationViewData(
          conversationPollsMeta: topToReplyResponse.data!.conversationPollsMeta,
          userMeta: topToReplyResponse.data!.userMeta,
          attachmentMeta: topToReplyResponse.data!.conversationAttachmentsMeta,
          reactionMeta: topToReplyResponse.data!.conversationReactionMeta,
          conversationMeta: topToReplyResponse.data!.conversationMeta,
        );
      }).toList();

      // clear page list and fetch the conversation
      // with the reply id
      pagedListController.clear();
      // add all the conversations to the list
      List<LMChatConversationViewData> allConversations = [];
      // add bottom conversation in reversed order
      allConversations.addAll(bottomConversationsVewData.reversed);
      // add top conversation
      allConversations.addAll(topConversationsViewData);
      // update conversation view type
      allConversations = groupConversationsAndAddDates(allConversations);
      // add the new conversation to pagedList
      pagedListController.addAll(allConversations);
      // reset the pages
      _topPage = 2;
      _bottomPage = 2;
      // set last page reached to true in case of no more data
      if (bottomConversationsVewData.length < _pageSize) {
        pagedListController.isLastPageToTopReached = true;
      }
      if (topConversationsViewData.length < _pageSize) {
        pagedListController.isLastPageToBottomReached = true;
      }
      rebuildConversationList.value = !rebuildConversationList.value;
      // find index of the conversation in the list and scroll to it
      int index = pagedListController.itemList
          .indexWhere((element) => element.id == replyId);
      if (index != -1) {
        // scroll and highlight the conversation
        _scrollToConversation(index, replyId, pagedListController);
      }
    }
  }

  void _scrollToConversation(int index, int replyId,
      LMDualSidePaginationController pagedListController) {
    pagedListController.listController.animateToItem(
      index: index,
      scrollController: pagedListController.scrollController,
      alignment: 0.5,
      duration: (estimatedDuration) {
        return const Duration(milliseconds: 200);
      },
      curve: (estimatedDuration) {
        return Curves.easeInOut;
      },
    );
    // highlight the reply message
    _highLightConversation(replyId);
  }

  Future<void> _highLightConversation(int replyId) async {
    // highlight the reply message
    // set replyId to [_animateToChatId] flag
    // used to detect if we have to show a selection animation
    // with the help of AnimatedContainer in [LMChatBubble]
    _animateToChatId = replyId;
    rebuildConversationList.value = !rebuildConversationList.value;
    // it is essential for showing an animation with better visibility
    await Future.delayed(const Duration(milliseconds: 1500));
    // again setting [_animateToChatId] to null for removing selection state
    _animateToChatId = null;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  /// This function checks if the conversation
  /// has custom widget or not
  bool conversationWithCustomWidget(LMChatConversationViewData conversation) {
    return conversation.widgetId != null && conversation.widget != null;
  }
}



================================================
File: lib/packages/core/lib/src/widgets/lists/conversation/dm_conversation_list.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:likeminds_chat_flutter_core/likeminds_chat_flutter_core.dart';
import 'package:likeminds_chat_flutter_core/src/blocs/observer.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/convertors.dart';
import 'package:likeminds_chat_flutter_core/src/utils/constants/assets.dart';
import 'package:likeminds_chat_flutter_core/src/utils/media/audio_handler.dart';
import 'package:overlay_support/overlay_support.dart';
import 'package:intl/intl.dart';
import 'package:super_sliver_list/super_sliver_list.dart';

/// {@template lm_chat_dm_conversation_list}
/// A widget that displays a list of direct messages.
/// {@endtemplate}
class LMChatDMConversationList extends StatefulWidget {
  /// The chatroom id.
  final int chatroomId;

  /// The selected conversations.
  final List<int>? selectedConversations;

  /// The app bar notifier.
  final ValueNotifier<bool>? appBarNotifier;

  /// The flag to check if the other user is an AI chatbot.
  final bool? isOtherUserAIChatbot;

  /// The paginated list controller.
  final LMDualSidePaginationController<LMChatConversationViewData>?
      paginatedListController;

  /// The conversation helper.
  final LMChatConversationActionInterface? conversationHelper;

  /// Creates a new instance of LMChatDMConversationList
  const LMChatDMConversationList({
    super.key,
    required this.chatroomId,
    this.selectedConversations,
    this.appBarNotifier,
    this.paginatedListController,
    this.isOtherUserAIChatbot,
    this.conversationHelper,
  });

  @override
  State<LMChatDMConversationList> createState() =>
      _LMChatDMConversationListState();
}

class _LMChatDMConversationListState extends State<LMChatDMConversationList> {
  late LMChatConversationBloc _conversationBloc;
  late LMChatConversationActionBloc _convActionBloc;

  late User user;
  int _topPage = 1;
  int _bottomPage = 1;
  final int _pageSize = 200;
  int lastConversationId = 0;
  bool isOtherUserChatbot = false;

  ValueNotifier showConversationActions = ValueNotifier(false);
  ValueNotifier rebuildConversationList = ValueNotifier(false);
  late ValueNotifier<bool> rebuildAppBar;

  Map<String, Conversation> conversationMeta = <String, Conversation>{};
  Map<String, List<LMChatAttachmentViewData>> conversationAttachmentsMeta =
      <String, List<LMChatAttachmentViewData>>{};
  Map<String, List<LMChatReactionViewData>> conversationReactionsMeta =
      <String, List<LMChatReactionViewData>>{};
  Map<int, User?> userMeta = <int, User?>{};
  List<int> _selectedIds = [];
  int? replyId;
  LMChatConversationViewData? replyConversation;
  int? _animateToChatId;

  late ScrollController scrollController;
  final LMChatroomBuilderDelegate _screenBuilder =
      LMChatCore.config.chatRoomConfig.builder;

  late LMDualSidePaginationController<LMChatConversationViewData>
      pagedListController = widget.paginatedListController ??
          LMDualSidePaginationController(
            listController: ListController(),
            scrollController: ScrollController(),
          );
  LMChatConversationViewData? localConversation;

  @override
  void initState() {
    super.initState();
    user = LMChatLocalPreference.instance.getUser();
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    _selectedIds = widget.selectedConversations ?? [];
    rebuildAppBar = widget.appBarNotifier ?? ValueNotifier(false);
    isOtherUserChatbot = widget.isOtherUserAIChatbot ??
        widget.chatroomId ==
            LMChatLocalPreference.instance.getChatroomIdWithAIChatbot();
  }

  @override
  void didUpdateWidget(covariant LMChatDMConversationList oldWidget) {
    super.didUpdateWidget(oldWidget);
    Bloc.observer = LMChatBlocObserver();
    user = LMChatLocalPreference.instance.getUser();
    _conversationBloc = LMChatConversationBloc.instance;
    _convActionBloc = LMChatConversationActionBloc.instance;
    _selectedIds = widget.selectedConversations ?? [];
    rebuildAppBar = widget.appBarNotifier ?? ValueNotifier(false);
  }

  @override
  void dispose() {
    _convActionBloc.close();
    _conversationBloc.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MultiBlocListener(
      listeners: [
        BlocListener<LMChatConversationActionBloc,
            LMChatConversationActionState>(
          bloc: _convActionBloc,
          listener: (context, state) {
            if (state is LMChatConversationDelete) {
              for (LMChatConversationViewData conversation
                  in state.conversations) {
                _updateDeletedConversation(conversation);
              }
            }
            if (state is LMChatConversationEdited) {
              updateEditedConversation(state.conversationViewData);
            }
            if (state is LMChatPutReactionState ||
                state is LMChatPutReactionError ||
                state is LMChatDeleteReactionState ||
                state is LMChatDeleteReactionError) {
              _updateReactions(state);
            }
          },
        ),
        BlocListener<LMChatConversationBloc, LMChatConversationState>(
          bloc: _conversationBloc,
          listener: (context, state) {
            updatePagingControllers(state);
          },
        ),
      ],
      child: ValueListenableBuilder(
        valueListenable: rebuildConversationList,
        builder: (context, value, child) {
          return LMDualSidePagedList(
            paginationType: replyConversation == null
                ? LMPaginationType.top
                : LMPaginationType.both,
            initialPage: 1,
            onPaginationTriggered: _onPaginationTriggered,
            paginationController: pagedListController,
            padding: const EdgeInsets.symmetric(
              vertical: 10,
            ),
            reverse: true,
            noItemsFoundIndicatorBuilder: (context) =>
                _screenBuilder.noItemInListWidgetBuilder(
              context,
              _defaultEmptyView(),
            ),
            firstPageProgressIndicatorBuilder: (context) =>
                _screenBuilder.loadingListWidgetBuilder(
              context,
              const LMChatSkeletonChatList(),
            ),
            newPageProgressIndicatorBuilder: (context) =>
                _screenBuilder.paginatedLoadingWidgetBuilder(
              context,
              const LMChatLoader(),
            ),
            itemBuilder: (context, item, index) {
              if (item.id == -1) {
                return _getChatBotShimmer();
              }
              if (item.isTimeStamp != null && item.isTimeStamp! ||
                  item.state != 0 && item.state != null) {
                final stateMessage = item.state == 1
                    ? LMChatTaggingHelper.extractFirstDMStateMessage(
                        item,
                        user.toUserViewData(),
                      )
                    : LMChatTaggingHelper.extractStateMessage(item.answer);
                return _screenBuilder.stateBubbleBuilder(
                  context,
                  stateMessage,
                  _defaultStateBubble(stateMessage),
                );
              }
              return item.memberId == user.id
                  ? _screenBuilder.sentChatBubbleBuilder(
                      context, item, _defaultSentChatBubble(item))
                  : _screenBuilder.receivedChatBubbleBuilder(
                      context, item, _defaultReceivedChatBubble(item));
            },
          );
        },
      ),
    );
  }

  Future<void> _onPaginationTriggered(pageKey, direction, conversation) async {
    _conversationBloc.add(
      LMChatFetchConversationsEvent(
        minTimestamp: replyConversation == null
            ? null
            : direction == LMPaginationDirection.bottom
                ? replyConversation!.createdEpoch
                : null,
        maxTimestamp: replyConversation == null
            ? null
            : direction == LMPaginationDirection.top
                ? replyConversation!.createdEpoch
                : null,
        chatroomId: widget.chatroomId,
        page: pageKey,
        pageSize: _pageSize,
        direction: direction,
        lastConversationId: lastConversationId,
        replyId: replyId,
        orderBy: direction == LMPaginationDirection.bottom
            ? OrderBy.ascending
            : OrderBy.descending,
      ),
    );
  }

  LMChatStateBubble _defaultStateBubble(String message) {
    return LMChatStateBubble(
      message: message,
      style: LMChatTheme.theme.stateBubbleStyle.copyWith(
        backgroundColor: const Color(0xffacb7c0),
        messageStyle: LMChatTextStyle.basic().copyWith(
          maxLines: 2,
          textStyle: TextStyle(
            fontSize: 12,
            color: LMChatTheme.theme.container,
          ),
          textAlign: TextAlign.center,
        ),
      ),
    );
  }

  LMChatBubble _defaultSentChatBubble(LMChatConversationViewData conversation) {
    return LMChatBubble(
      actionHelper: widget.conversationHelper,
      onReplyTap: () {
        _onReplyTap(conversation, pagedListController, widget.chatroomId);
      },
      conversation: conversation,
      attachments:
          conversationAttachmentsMeta[conversation.temporaryId.toString()] ??
              conversationAttachmentsMeta[conversation.id.toString()],
      currentUser: LMChatLocalPreference.instance.getUser().toUserViewData(),
      conversationUser: conversation.member!,
      userMeta: userMeta.map((id, user) {
        return MapEntry(id, user!.toUserViewData());
      }),
      audioHandler: LMChatCoreAudioHandler.instance,
      reactions:
          conversationReactionsMeta[conversation.temporaryId.toString()] ??
              conversationReactionsMeta[conversation.id.toString()],
      onReaction: (r) {
        onReaction(r, conversation.id);
        setState(() {});
      },
      onRemoveReaction: (r) {
        onRemoveReaction(r, conversation.id);
        setState(() {});
      },
      replyBuilder: (reply, oldWidget) {
        String message = getGIFText(reply);
        return oldWidget.copyWith(
          subtitle: ((reply.attachmentsUploaded ?? false) &&
                  reply.deletedByUserId == null)
              ? getChatItemAttachmentTile(message,
                  conversationAttachmentsMeta[reply.id.toString()] ?? [], reply)
              : LMChatText(
                  reply.state != 0
                      ? LMChatTaggingHelper.extractStateMessage(message)
                      : LMChatTaggingHelper.convertRouteToTag(
                            message,
                            withTilde: false,
                          ) ??
                          "Replying to Conversation",
                  style: LMChatTextStyle(
                    maxLines: 1,
                    textStyle: TextStyle(
                      fontSize: 12,
                      color: LMChatTheme.theme.onContainer,
                      fontWeight: FontWeight.w400,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
        );
      },
      onTagTap: (tag) {},
      onReply: (conversation) {
        _convActionBloc.add(
          LMChatReplyConversationEvent(
            chatroomId: widget.chatroomId,
            conversationId: conversation.id,
            replyConversation: conversation,
            attachments: conversationAttachmentsMeta[
                    conversation.temporaryId.toString()] ??
                conversationAttachmentsMeta[conversation.id.toString()],
          ),
        );
      },
      isSent: true,
      isDM: true,
      isSelected: _selectedIds.contains(conversation.id) ||
          _animateToChatId == conversation.id,
      style: LMChatBubbleStyle.basic().copyWith(showHeader: false),
      onLongPress: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.messageSelected,
            eventProperties: {
              'type': 'text',
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.emoticonTrayOpened,
            eventProperties: {
              'from': 'long press',
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      isSelectableOnTap: () {
        return _selectedIds.isNotEmpty;
      },
      onReactionsTap: () {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.reactionListOpened,
            eventProperties: {
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      onTap: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
          LMChatAnalyticsBloc.instance.add(
            LMChatFireAnalyticsEvent(
              eventName: LMChatAnalyticsKeys.messageSelected,
              eventProperties: {
                'type': 'text',
                'chatroom_id': widget.chatroomId,
              },
            ),
          );
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
      },
      onMediaTap: () {
        LMChatMediaHandler.instance.addPickedMedia(
            conversationAttachmentsMeta[conversation.id.toString()]);
        LMChatCoreAudioHandler.instance.stopAudio();
        LMChatCoreAudioHandler.instance.stopRecording();
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => LMChatMediaPreviewScreen(
              conversation: conversation,
            ),
          ),
        );
      },
    );
  }

  LMChatBubble _defaultReceivedChatBubble(
      LMChatConversationViewData conversation) {
    return LMChatBubble(
      actionHelper: widget.conversationHelper,
      onReplyTap: () {
        _onReplyTap(conversation, pagedListController, widget.chatroomId);
      },
      conversation: conversation,
      attachments: conversationAttachmentsMeta[conversation.id.toString()],
      currentUser: LMChatLocalPreference.instance.getUser().toUserViewData(),
      conversationUser: conversation.member!,
      userMeta: userMeta.map((id, user) {
        return MapEntry(id, user!.toUserViewData());
      }),
      audioHandler: LMChatCoreAudioHandler.instance,
      reactions:
          conversationReactionsMeta[conversation.temporaryId.toString()] ??
              conversationReactionsMeta[conversation.id.toString()],
      onReaction: (r) {
        onReaction(r, conversation.id);
        setState(() {});
      },
      onRemoveReaction: (r) {
        onRemoveReaction(r, conversation.id);
        setState(() {});
      },
      onTagTap: (tag) {},
      onReply: (conversation) {
        _convActionBloc.add(
          LMChatReplyConversationEvent(
            chatroomId: widget.chatroomId,
            conversationId: conversation.id,
            replyConversation: conversation,
            attachments:
                conversationAttachmentsMeta[conversation.id.toString()],
          ),
        );
      },
      replyBuilder: (reply, oldWidget) {
        String message = getGIFText(reply);
        return oldWidget.copyWith(
          subtitle: ((reply.attachmentsUploaded ?? false) &&
                  reply.deletedByUserId == null)
              ? getChatItemAttachmentTile(message,
                  conversationAttachmentsMeta[reply.id.toString()] ?? [], reply)
              : LMChatText(
                  reply.state != 0
                      ? LMChatTaggingHelper.extractStateMessage(message)
                      : LMChatTaggingHelper.convertRouteToTag(
                            message,
                            withTilde: false,
                          ) ??
                          "Replying to Conversation",
                  style: LMChatTextStyle(
                    maxLines: 1,
                    textStyle: TextStyle(
                      fontSize: 12,
                      color: LMChatTheme.theme.onContainer,
                      fontWeight: FontWeight.w400,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ),
        );
      },
      isSent: false,
      isDM: true,
      avatar: isOtherUserChatbot
          ? LMChatProfilePicture(
              fallbackText: conversation.member!.name,
              imageUrl: conversation.member!.imageUrl,
              style: const LMChatProfilePictureStyle(
                size: 39,
                boxShape: BoxShape.circle,
              ),
            )
          : null,
      style: LMChatBubbleStyle.basic().copyWith(showHeader: false),
      isSelected: _selectedIds.contains(conversation.id) ||
          _animateToChatId == conversation.id,
      onReactionsTap: () {
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.reactionListOpened,
            eventProperties: {
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      onLongPress: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.messageSelected,
            eventProperties: {
              'type': 'text',
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
        LMChatAnalyticsBloc.instance.add(
          LMChatFireAnalyticsEvent(
            eventName: LMChatAnalyticsKeys.emoticonTrayOpened,
            eventProperties: {
              'from': 'long press',
              'message_id': conversation.id,
              'chatroom_id': widget.chatroomId,
            },
          ),
        );
      },
      isSelectableOnTap: () {
        return _selectedIds.isNotEmpty;
      },
      onTap: (value, state) {
        if (value) {
          _selectedIds.add(conversation.id);
          LMChatAnalyticsBloc.instance.add(
            LMChatFireAnalyticsEvent(
              eventName: LMChatAnalyticsKeys.messageSelected,
              eventProperties: {
                'type': 'text',
                'chatroom_id': widget.chatroomId,
              },
            ),
          );
        } else {
          _selectedIds.remove(conversation.id);
        }
        rebuildAppBar.value = !rebuildAppBar.value;
        state.setState(() {});
      },
      onMediaTap: () {
        LMChatMediaHandler.instance.addPickedMedia(
            conversationAttachmentsMeta[conversation.id.toString()]);
        LMChatCoreAudioHandler.instance.stopAudio();
        LMChatCoreAudioHandler.instance.stopRecording();
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => LMChatMediaPreviewScreen(
              conversation: conversation,
            ),
          ),
        );
      },
    );
  }

  Widget _defaultEmptyView() {
    return Center(
        child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        const LMChatIcon(
          type: LMChatIconType.png,
          assetPath: emptyViewImage,
          style: LMChatIconStyle(
            size: 100,
          ),
        ),
        const SizedBox(height: 12),
        LMChatText(
          'Oops! No conversations found.',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              color: LMChatTheme.theme.inActiveColor,
            ),
          ),
        )
      ],
    ));
  }

  Widget _getChatBotShimmer() {
    return const Padding(
      padding: EdgeInsets.only(left: 12.0),
      child: LMChatSkeletonChatBubble(
        isSent: false,
      ),
    );
  }

  LMChatConversationViewData _getChatBotShimmerConversation() {
    return (LMChatConversationViewDataBuilder()
          ..id(-1)
          ..answer('invisible')
          ..createdAt(DateFormat('dd MMM yyyy').format(DateTime.now())))
        .build();
  }

  void updatePagingControllers(LMChatConversationState state) {
    if (state is LMChatConversationLoadedState) {
      if (state.getConversationResponse.conversationMeta != null &&
          state.getConversationResponse.conversationMeta!.isNotEmpty) {
        conversationMeta
            .addAll(state.getConversationResponse.conversationMeta!);
      }
      if (state.getConversationResponse.conversationAttachmentsMeta != null &&
          state.getConversationResponse.conversationAttachmentsMeta!
              .isNotEmpty) {
        Map<String, List<LMChatAttachmentViewData>>
            getConversationAttachmentData = state
                .getConversationResponse.conversationAttachmentsMeta!
                .map((key, value) {
          return MapEntry(
            key,
            (value as List<Attachment>?)
                    ?.map((e) => e.toAttachmentViewData())
                    .toList() ??
                [],
          );
        });
        conversationAttachmentsMeta.addAll(getConversationAttachmentData);
      }
      if (state.getConversationResponse.conversationReactionMeta != null &&
          state.getConversationResponse.conversationReactionMeta!.isNotEmpty) {
        Map<String, List<LMChatReactionViewData>> getConversationReactionsData =
            state.getConversationResponse.conversationReactionMeta!
                .map((key, value) {
          return MapEntry(
            key,
            (value as List<Reaction>?)
                    ?.map((e) => e.toReactionViewData())
                    .toList() ??
                [],
          );
        });
        conversationReactionsMeta.addAll(getConversationReactionsData);
      }
      if (state.getConversationResponse.userMeta != null) {
        userMeta.addAll(state.getConversationResponse.userMeta!);
      }
      List<LMChatConversationViewData>? conversationData = state
              .getConversationResponse.conversationData
              ?.map((e) {
            final conv = e.toConversationViewData(
              conversationPollsMeta:
                  state.getConversationResponse.conversationPollsMeta,
              userMeta: state.getConversationResponse.userMeta,
            );
            // Add attachments to the conversation object explicitly
            if (conversationAttachmentsMeta.containsKey(conv.id.toString())) {
              return conv.copyWith(
                attachments: conversationAttachmentsMeta[conv.id.toString()],
              );
            }
            return conv;
          }).toList() ??
          [];
      if (state.reInitialize) {
        pagedListController.clear();
        _topPage = 1;
        if (localConversation != null) {
          conversationData?.insert(0, localConversation!);
          localConversation = null;
        }
      }
      if (state.page == 1) {
        conversationData = groupConversationsAndAddDates(conversationData);
      } else {
        conversationData = updatePaginationConversationsViewType(
            pagedListController.itemList, conversationData);
      }
      if (state.getConversationResponse.conversationData == null ||
          state.getConversationResponse.conversationData!.isEmpty ||
          state.getConversationResponse.conversationData!.length < _pageSize) {
        if (state.direction == LMPaginationDirection.top) {
          _bottomPage++;
          pagedListController.appendLastPageToEnd(conversationData);
        } else {
          _topPage++;
          pagedListController
              .appendFirstPageToStart(conversationData.reversed.toList());
        }
      } else {
        if (state.direction == LMPaginationDirection.top) {
          _bottomPage++;
          pagedListController.appendPageToEnd(conversationData, _bottomPage);
        } else {
          _topPage++;
          pagedListController.appendPageToStart(
              conversationData.reversed.toList(), _topPage);
        }
      }
      rebuildConversationList.value = !rebuildConversationList.value;
    }
    if (state is LMChatConversationPostedState) {
      if (LMChatConversationBloc.replyConversation != null) {
        localConversation = state.conversationViewData;
        return;
      }
      addConversationToPagedList(
        state.conversationViewData,
      );
    } else if (state is LMChatLocalConversationState) {
      if (LMChatConversationBloc.replyConversation != null) {
        localConversation = state.conversationViewData;
        return;
      }
      addLocalConversationToPagedList(state.conversationViewData);
    } else if (state is LMChatConversationErrorState) {
      toast(state.message);
    }
    if (state is LMChatMultiMediaConversationLoadingState) {
      LMChatConversationViewData conv =
          state.postConversation.toConversationViewData();

      conv = conv.copyWith(
          replyConversationObject: conversationMeta[conv.replyId.toString()]
              ?.toConversationViewData());

      if (!userMeta.containsKey(user.id)) {
        userMeta[user.id] = user;
      }
      conversationAttachmentsMeta[conv.temporaryId!] =
          state.mediaFiles.map((e) => e.toAttachmentViewData()).toList();

      addLocalConversationToPagedList(conv);
    }
    if (state is LMChatMultiMediaConversationPostedState) {
      final conv = state.postConversationResponse.conversation;

      conversationAttachmentsMeta[conv!.id.toString()] =
          state.putMediaResponse.map((e) => e.toAttachmentViewData()).toList();

      addConversationToPagedList(
        state.postConversationResponse.conversation!.toConversationViewData(),
      );
    }
    if (state is LMChatConversationUpdatedState) {
      if (state.conversationViewData.id != lastConversationId ||
          state.shouldUpdate) {
        conversationAttachmentsMeta.addAll(state.attachments);
        addConversationToPagedList(
          state.conversationViewData,
        );
        lastConversationId = state.conversationViewData.id;
        LMChatroomActionBloc.instance.add(
          LMChatMarkReadChatroomEvent(
            chatroomId: widget.chatroomId,
          ),
        );
      }
    }
  }

  void addLocalConversationToPagedList(
      LMChatConversationViewData conversation) {
    LMChatConversationViewData? result;
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;

    if (conversation.replyId != null &&
        !conversationMeta.containsKey(conversation.replyId.toString())) {
      LMChatConversationViewData? replyConversation =
          pagedListController.itemList.firstWhere((element) =>
              element.id ==
              (conversation.replyId ?? conversation.replyConversation));
      conversationMeta[conversation.replyId.toString()] =
          replyConversation.toConversation();

      result = conversation.copyWith(
        replyConversationObject: replyConversation,
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    } else {
      result = conversation.copyWith(
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    }

    if (conversationList.isNotEmpty &&
        conversationList.first.date != conversation.date &&
        conversationList.first.id != -1) {
      conversationList.insert(
        0,
        Conversation(
          isTimeStamp: true,
          id: 1,
          hasFiles: false,
          attachmentCount: 0,
          attachmentsUploaded: false,
          createdEpoch: conversation.createdEpoch,
          chatroomId: widget.chatroomId,
          date: conversation.date,
          memberId: conversation.memberId,
          temporaryId: conversation.temporaryId,
          answer: DateFormat('dd MMM yyyy').format(
              DateTime.fromMillisecondsSinceEpoch(
                  conversation.createdEpoch ?? 0)),
          communityId: LMChatLocalPreference.instance.getCommunityData()!.id,
          createdAt: conversation.createdAt,
          header: conversation.header,
        ).toConversationViewData(),
      );
    }

    // check if the new conversation is by the same user as last conversation
    // if yes, then add the conversation to the same group by assigning view type - bottom
    if (conversationList.isNotEmpty &&
        conversationList.first.memberId == conversation.memberId) {
      result = result.copyWith(
          conversationViewType: LMChatConversationViewType.bottom);
    }

    conversationList.insert(0, result);
    if (isOtherUserChatbot) {
      conversationList.removeWhere((element) => element.id == -1);
      conversationList.insert(0, _getChatBotShimmerConversation());
    }
    if (conversationList.length >= _pageSize) {
      conversationList.removeLast();
    }
    if (!userMeta.containsKey(user.id)) {
      userMeta[user.id] = user;
    }

    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void addConversationToPagedList(LMChatConversationViewData conversation) {
    LMChatConversationViewData? result;
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;

    bool isSelf = conversation.memberId == user.id;
    if (conversationList.first.id == -1 && !isSelf && isOtherUserChatbot) {
      conversationList.removeAt(0);
    }

    int index = conversationList.indexWhere((element) {
      if (conversation.temporaryId == null || element.temporaryId == null) {
        return element.id == conversation.id;
      }
      return element.temporaryId == conversation.temporaryId;
    });
    if ((conversation.replyId != null ||
            conversation.replyConversation != null) &&
        !conversationMeta.containsKey(conversation.replyId.toString())) {
      LMChatConversationViewData? replyConversation =
          pagedListController.itemList.firstWhere((element) =>
              element.id ==
              (conversation.replyId ?? conversation.replyConversation));
      conversationMeta[conversation.replyId.toString()] =
          replyConversation.toConversation();

      result = conversation.copyWith(
        replyConversationObject: replyConversation,
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    } else {
      result = conversation.copyWith(
        attachments: conversationAttachmentsMeta[conversation.temporaryId] ??
            conversationAttachmentsMeta[conversation.id.toString()],
      );
    }

    // check if the new conversation is by the same user as last conversation
    // if yes, then add the conversation to the same group by assigning view type - bottom
    if (conversationList.isNotEmpty &&
        conversationList.first.memberId == conversation.memberId) {
      conversation = result.copyWith(
          conversationViewType: LMChatConversationViewType.bottom);
    }

    if (index != -1) {
      conversationList[index] = conversation;
    } else if (conversationList.isNotEmpty) {
      if (conversationList.first.date != conversation.date) {
        conversationList.insert(
          0,
          Conversation(
            isTimeStamp: true,
            id: 1,
            hasFiles: false,
            attachmentCount: 0,
            attachmentsUploaded: false,
            createdEpoch: conversation.createdEpoch,
            chatroomId: widget.chatroomId,
            date: conversation.date,
            memberId: conversation.memberId,
            temporaryId: conversation.temporaryId,
            answer: DateFormat('dd MMM yyyy').format(
                DateTime.fromMillisecondsSinceEpoch(
                    conversation.createdEpoch ?? 0)),
            communityId: LMChatLocalPreference.instance.getCommunityData()!.id,
            createdAt: conversation.createdAt,
            header: conversation.header,
          ).toConversationViewData(),
        );
      }
      conversationList.insert(0, result);
      if (conversationList.length >= _pageSize) {
        conversationList.removeLast();
      }
      if (!userMeta.containsKey(user.id)) {
        userMeta[user.id] = user;
      }
    }
    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _updateDeletedConversation(LMChatConversationViewData conversation) {
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;

    // Update the deleted conversation
    int index =
        conversationList.indexWhere((element) => element.id == conversation.id);
    if (index != -1) {
      conversationList[index] = conversationList[index].copyWith(
        deletedByUserId: user.id,
      );
    }

    // Update conversations replying to the deleted conversation
    for (int i = 0; i < conversationList.length; i++) {
      if (conversationList[i].replyId == conversation.id ||
          conversationList[i].replyConversation == conversation.id) {
        conversationList[i] = conversationList[i].copyWith(
          replyConversationObject: conversation.copyWith(
            deletedByUserId: user.id,
          ),
        );
      }
    }

    if (conversationMeta.isNotEmpty &&
        conversationMeta.containsKey(conversation.id.toString())) {
      conversationMeta[conversation.id.toString()]!.deletedByUserId = user.id;
    }

    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void updateEditedConversation(LMChatConversationViewData editedConversation) {
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;
    int index = conversationList
        .indexWhere((element) => element.id == editedConversation.id);
    if (index != -1) {
      conversationList[index] = editedConversation;
    }

    if (conversationMeta.isNotEmpty &&
        conversationMeta.containsKey(editedConversation.id.toString())) {
      conversationMeta[editedConversation.id.toString()] =
          editedConversation.toConversation();
    }
    pagedListController.itemList = conversationList;
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  onReaction(
    String reaction,
    int conversationId,
  ) {
    if (reaction == 'Add') {
      LMChatroomActionBloc.instance.add(
        LMChatShowEmojiKeyboardEvent(
          conversationId: conversationId,
        ),
      );
    } else {
      LMChatAnalyticsBloc.instance.add(
        LMChatFireAnalyticsEvent(
          eventName: LMChatAnalyticsKeys.reactionAdded,
          eventProperties: {
            'reaction': reaction,
            'from': 'long_press',
            'message_id': conversationId,
            'chatroom_id': widget.chatroomId,
          },
        ),
      );
      _convActionBloc.add(LMChatPutReaction(
        conversationId: conversationId,
        reaction: reaction,
      ));
      _selectedIds.remove(conversationId);
      rebuildAppBar.value = !rebuildAppBar.value;
    }
  }

  onRemoveReaction(String reaction, int conversationId) {
    LMChatAnalyticsBloc.instance.add(
      LMChatFireAnalyticsEvent(
        eventName: LMChatAnalyticsKeys.reactionRemoved,
        eventProperties: {
          'message_id': conversationId,
          'chatroom_id': widget.chatroomId,
        },
      ),
    );
    _convActionBloc.add(LMChatDeleteReaction(
      conversationId: conversationId,
      reaction: reaction,
    ));
    Navigator.pop(context);
  }

  void _updateReactions(LMChatConversationActionState state) {
    if (state is LMChatPutReactionState) {
      LMChatReactionViewData addedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      if (!userMeta.containsKey(user.id)) {
        userMeta[user.id] = user;
      }
      _addReaction(addedReaction, state.conversationId);
    }
    if (state is LMChatPutReactionError) {
      toast(state.errorMessage);
      LMChatReactionViewData addedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      _removeReaction(addedReaction);
    }
    if (state is LMChatDeleteReactionState) {
      LMChatReactionViewData deletedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      _removeReaction(deletedReaction);
    }
    if (state is LMChatDeleteReactionError) {
      toast(state.errorMessage);
      LMChatReactionViewData deletedReaction = Reaction(
        chatroomId: widget.chatroomId,
        conversationId: state.conversationId,
        reaction: state.reaction,
        userId: user.id,
      ).toReactionViewData();
      _addReaction(deletedReaction, state.conversationId);
    }
  }

  void _addReaction(LMChatReactionViewData reaction, int conversationId) {
    String conversationIdStr = conversationId.toString();
    if (conversationReactionsMeta.containsKey(conversationIdStr)) {
      final existingReactions = conversationReactionsMeta[conversationIdStr]!;
      final existingReactionIndex =
          existingReactions.indexWhere((r) => r.userId == reaction.userId);
      if (existingReactionIndex != -1) {
        existingReactions[existingReactionIndex] =
            reaction; // Update existing reaction
      } else {
        existingReactions.add(reaction); // Add new reaction
      }
    } else {
      conversationReactionsMeta[conversationIdStr] = [reaction];
    }
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;
    int index =
        conversationList.indexWhere((element) => element.id == conversationId);
    if (index != -1) {
      conversationList[index] =
          conversationList[index].copyWith(hasReactions: true);
    }
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _removeReaction(LMChatReactionViewData reaction) {
    String conversationIdStr = reaction.conversationId.toString();
    if (conversationReactionsMeta.containsKey(conversationIdStr)) {
      final existingReactions = conversationReactionsMeta[conversationIdStr]!;
      final existingReactionIndex =
          existingReactions.indexWhere((r) => r.userId == reaction.userId);
      if (existingReactionIndex != -1) {
        existingReactions
            .removeAt(existingReactionIndex); // Remove existing reaction
      }
    }
    List<LMChatConversationViewData> conversationList =
        pagedListController.itemList;
    int index = conversationList
        .indexWhere((element) => element.id == reaction.conversationId);
    if (index != -1) {
      conversationList[index] = conversationList[index].copyWith(
          hasReactions:
              conversationReactionsMeta[conversationIdStr]!.isNotEmpty);
    }
    rebuildConversationList.value = !rebuildConversationList.value;
  }

  void _onReplyTap(
    LMChatConversationViewData conversation,
    LMDualSidePaginationController pagedListController,
    int chatroomId,
  ) async {
    // find index of the conversation in the list
    final int? replyId = conversation.replyId ??
        conversation.replyConversation ??
        conversation.replyConversationObject?.id;
    // if not able to find replyId in conversation return
    if (replyId == null) {
      return;
    }
    // find index of reply in conversation list
    int index = pagedListController.itemList
        .indexWhere((element) => element.id == replyId);
    if (index != -1) {
      // scroll and highlight the conversation
      _scrollToConversation(index, replyId, pagedListController);
    } else {
      // handle if index is -1
      // clear page list and fetch the conversation
      // with the reply id
      pagedListController.clear();
      final currentTime = DateTime.now().millisecondsSinceEpoch;
      // fetch reply conversation
      final GetConversationRequestBuilder replyConversationBuilder =
          GetConversationRequestBuilder()
            ..chatroomId(chatroomId)
            ..page(1)
            ..pageSize(1)
            ..isLocalDB(false)
            ..minTimestamp(0)
            ..maxTimestamp(currentTime)
            ..conversationId(replyId);

      // [Data Layer] function call
      final replyConversationResponse = await LMChatCore.client
          .getConversation(replyConversationBuilder.build());

      // convert [Conversation] list to [LMChatConversationViewData] list
      final replyConversationsVewData =
          replyConversationResponse.data!.conversationData!.map((e) {
        return e.toConversationViewData(
          conversationPollsMeta:
              replyConversationResponse.data!.conversationPollsMeta,
          userMeta: replyConversationResponse.data!.userMeta,
          attachmentMeta:
              replyConversationResponse.data!.conversationAttachmentsMeta,
          reactionMeta:
              replyConversationResponse.data!.conversationReactionMeta,
          conversationMeta: replyConversationResponse.data!.conversationMeta,
        );
      }).toList();

      // assign replyViewData to Global replyConversation
      if (replyConversationsVewData.isNotEmpty) {
        replyConversation = replyConversationsVewData.first;
      }

      // fetch 100 conversations from the bottom of the list
      final GetConversationRequestBuilder bottomToReplyConversationBuilder =
          GetConversationRequestBuilder()
            ..chatroomId(chatroomId)
            ..page(1)
            ..pageSize(_pageSize)
            ..isLocalDB(false)
            ..minTimestamp(replyConversationsVewData.first.createdEpoch!)
            ..maxTimestamp(currentTime)
            ..orderBy(OrderBy.ascending);

      // [Data Layer] function call
      final bottomToReplyResponse = await LMChatCore.client
          .getConversation(bottomToReplyConversationBuilder.build());

      // convert [Conversation] list to [LMChatConversationViewData] list
      final bottomConversationsVewData =
          bottomToReplyResponse.data!.conversationData!.map((e) {
        return e.toConversationViewData(
          conversationPollsMeta:
              bottomToReplyResponse.data!.conversationPollsMeta,
          userMeta: bottomToReplyResponse.data!.userMeta,
          attachmentMeta:
              bottomToReplyResponse.data!.conversationAttachmentsMeta,
          reactionMeta: bottomToReplyResponse.data!.conversationReactionMeta,
          conversationMeta: bottomToReplyResponse.data!.conversationMeta,
        );
      }).toList();

      // fetch 100 conversations from the top of the list
      final GetConversationRequestBuilder topToReplyConversationBuilder =
          GetConversationRequestBuilder()
            ..chatroomId(chatroomId)
            ..page(1)
            ..pageSize(_pageSize)
            ..isLocalDB(true)
            ..minTimestamp(0)
            ..maxTimestamp(replyConversationsVewData.first.createdEpoch!);

      // [Data Layer] function call
      final topToReplyResponse = await LMChatCore.client
          .getConversation(topToReplyConversationBuilder.build());

      // convert [Conversation] list to [LMChatConversationViewData] list
      final topConversationsViewData =
          topToReplyResponse.data!.conversationData!.map((e) {
        return e.toConversationViewData(
          conversationPollsMeta: topToReplyResponse.data!.conversationPollsMeta,
          userMeta: topToReplyResponse.data!.userMeta,
          attachmentMeta: topToReplyResponse.data!.conversationAttachmentsMeta,
          reactionMeta: topToReplyResponse.data!.conversationReactionMeta,
          conversationMeta: topToReplyResponse.data!.conversationMeta,
        );
      }).toList();

      // add all the conversations to the list
      List<LMChatConversationViewData> allConversations = [];

      // add bottom conversation in reversed order
      allConversations.addAll(bottomConversationsVewData.reversed);
      // add top conversation
      allConversations.addAll(topConversationsViewData);
      // update conversation view type
      allConversations = groupConversationsAndAddDates(allConversations);
      // add the new conversation to pagedList
      pagedListController.addAll(allConversations);
      // reset the pages
      _topPage = 2;
      _bottomPage = 2;
      // set last page reached to true in case of no more data
      if (bottomConversationsVewData.length < _pageSize) {
        pagedListController.isLastPageToTopReached = true;
      }
      if (topConversationsViewData.length < _pageSize) {
        pagedListController.isLastPageToBottomReached = true;
      }
      rebuildConversationList.value = !rebuildConversationList.value;
      // find index of the conversation in the list and scroll to it
      int index = pagedListController.itemList
          .indexWhere((element) => element.id == replyId);
      if (index != -1) {
        // scroll and highlight the conversation
        _scrollToConversation(index, replyId, pagedListController);
      }
    }
  }

  void _scrollToConversation(int index, int replyId,
      LMDualSidePaginationController pagedListController) {
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      pagedListController.listController.animateToItem(
        index: index,
        scrollController: pagedListController.scrollController,
        alignment: 0.5,
        duration: (estimatedDuration) {
          return const Duration(milliseconds: 200);
        },
        curve: (estimatedDuration) {
          return Curves.easeInOut;
        },
      );
      // highlight the reply message
      _highLightConversation(replyId);
    });
  }

  Future<void> _highLightConversation(int replyId) async {
    // highlight the reply message
    // set replyId to [_animateToChatId] flag
    // used to detect if we have to show a selection animation
    // with the help of AnimatedContainer in [LMChatBubble]
    _animateToChatId = replyId;
    rebuildConversationList.value = !rebuildConversationList.value;
    // it is essential for showing an animation with better visibility
    await Future.delayed(const Duration(milliseconds: 1500));
    // again setting [_animateToChatId] to null for removing selection state
    _animateToChatId = null;
    rebuildConversationList.value = !rebuildConversationList.value;
  }
}



================================================
File: lib/packages/core/lib/src/widgets/text_field/text_field.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_core/packages/flutter_typeahead/lib/flutter_typeahead.dart';
import 'package:likeminds_chat_flutter_core/src/convertors/tag/tag_convertor.dart';
import 'package:likeminds_chat_flutter_core/src/core/core.dart';

/// A custom text field widget for chat applications with tagging functionality.
class LMChatTextField extends StatefulWidget {
  /// Determines if suggestions should appear below the text field.
  final bool isDown;

  /// The focus node for the text field.
  final FocusNode focusNode;

  /// Callback function when a tag is selected.
  final Function(LMChatTagViewData) onTagSelected;

  /// The text editing controller for the text field.
  final TextEditingController? controller;

  /// Custom decoration for the text field.
  final InputDecoration? decoration;

  /// Custom text style for the text field.
  final TextStyle? style;

  /// Callback function when the text changes.
  final Function(String)? onChange;

  /// The ID of the chatroom.
  final int chatroomId;

  /// Determines if the chatroom is secret.
  final bool isSecret;

  /// Determines if the text field is enabled.
  final bool enabled;

  /// Custom scroll physics for the suggestions list.
  final ScrollPhysics? scrollPhysics;

  /// Custom styling for the text field.
  final LMChatTextFieldStyle? textFieldStyle;

  ///Keyboard visibility
  final void Function(bool)? onKeyboardFocusChange;

  const LMChatTextField(
      {super.key,
      required this.isDown,
      required this.chatroomId,
      required this.onTagSelected,
      required this.controller,
      required this.focusNode,
      this.enabled = true,
      this.isSecret = false,
      this.style,
      this.decoration,
      this.onChange,
      this.scrollPhysics,
      this.textFieldStyle,
      this.onKeyboardFocusChange});

  /// Creates a copy of this widget with the given fields replaced with new values.
  LMChatTextField copyWith({
    bool? isDown,
    FocusNode? focusNode,
    Function(LMChatTagViewData)? onTagSelected,
    TextEditingController? controller,
    InputDecoration? decoration,
    TextStyle? style,
    Function(String)? onChange,
    int? chatroomId,
    bool? isSecret,
    bool? enabled,
    ScrollPhysics? scrollPhysics,
    LMChatTextFieldStyle? textFieldStyle,
    void Function(bool)? onKeyboardFocusChange,
  }) {
    return LMChatTextField(
      isDown: isDown ?? this.isDown,
      focusNode: focusNode ?? this.focusNode,
      onTagSelected: onTagSelected ?? this.onTagSelected,
      controller: controller ?? this.controller,
      decoration: decoration ?? this.decoration,
      style: style ?? this.style,
      onChange: onChange ?? this.onChange,
      chatroomId: chatroomId ?? this.chatroomId,
      isSecret: isSecret ?? this.isSecret,
      enabled: enabled ?? this.enabled,
      scrollPhysics: scrollPhysics ?? this.scrollPhysics,
      textFieldStyle: textFieldStyle ?? this.textFieldStyle,
      onKeyboardFocusChange:
          onKeyboardFocusChange ?? this.onKeyboardFocusChange,
    );
  }

  @override
  State<LMChatTextField> createState() => _LMChatTextFieldState();
}

class _LMChatTextFieldState extends State<LMChatTextField> {
  late final TextEditingController _controller;
  late final FocusNode _focusNode;
  final ScrollController _scrollController = ScrollController();
  final SuggestionsBoxController _suggestionsBoxController =
      SuggestionsBoxController();

  List<LMChatTagViewData> _tagViewData = [];

  int _page = 1;
  final ValueNotifier<bool> _tagComplete = ValueNotifier(false);
  String _textValue = "";
  String _tagValue = "";
  static const int _fixedSize = 50;
  late LMChatTextFieldStyle effectiveStyle;

  @override
  void initState() {
    super.initState();
    _focusNode = widget.focusNode;
    _controller = widget.controller!;
    _setupScrollListener();
    effectiveStyle = widget.textFieldStyle ?? LMChatTheme.theme.textFieldStyle;
  }

  void _setupScrollListener() {
    _scrollController.addListener(() {
      if (_scrollController.position.pixels ==
          _scrollController.position.maxScrollExtent) {
        _loadMoreTags();
      }
    });
  }

  Future<void> _loadMoreTags() async {
    _page++;
    final taggingData = await _fetchTaggingData(_page);
    if (taggingData.members?.isNotEmpty == true) {
      setState(() {
        _tagViewData
            .addAll(taggingData.members!.map((e) => e.toLMChatTagViewData()));
      });
    }
  }

  Future<TagResponseModel> _fetchTaggingData(int page,
      {String? searchQuery}) async {
    final response = await LMChatCore.client.getTaggingList(
      (TagRequestModelBuilder()
            ..chatroomId(widget.chatroomId)
            ..page(page)
            ..searchQuery(searchQuery ?? '')
            ..pageSize(_fixedSize))
          .build(),
    );
    return response.data!;
  }

  Future<Iterable<LMChatTagViewData>> _getSuggestions(String query) async {
    if (query.isEmpty) {
      return const Iterable.empty();
    }

    if (query.contains('@') && !_tagComplete.value) {
      String tag = _tagValue.substring(1).split(' ').first;
      final taggingData = await _fetchTaggingData(1, searchQuery: tag);

      _tagViewData = _processTaggingData(taggingData);
      return _tagViewData;
    }
    return const Iterable.empty();
  }

  List<LMChatTagViewData> _processTaggingData(TagResponseModel taggingData) {
    List<LMChatTagViewData> result = [];

    if (!widget.isSecret) {
      if (taggingData.groupTags != null && taggingData.groupTags!.isNotEmpty) {
        result
            .addAll(taggingData.groupTags!.map((e) => e.toLMChatTagViewData()));
      }
    }

    if (taggingData.members != null && taggingData.members!.isNotEmpty) {
      result.addAll(taggingData.members!.map((e) => e.toLMChatTagViewData()));
    }

    return result;
  }

  void _handleTextChange(String value) {
    widget.onChange?.call(value);
    _updateTaggingState(value);
  }

  void _updateTaggingState(String value) {
    final int newTagCount = '@'.allMatches(value).length;
    final int completeCount = '~'.allMatches(value).length;

    if (newTagCount == completeCount) {
      _textValue = _controller.text;
      _tagComplete.value = true;
    } else if (newTagCount > completeCount) {
      _tagComplete.value = false;
      _tagValue = value.substring(value.lastIndexOf('@'));
      _textValue = value.substring(0, value.lastIndexOf('@'));
    } else {
      _removeExtraTildeIfNeeded();
    }
  }

  void _removeExtraTildeIfNeeded() {
    int currentPosition = _controller.selection.base.offset;
    if (currentPosition > 0 && _controller.text[currentPosition - 1] == '~') {
      _controller.text = _controller.text
          .replaceRange(currentPosition - 1, currentPosition, "");
      _controller.selection =
          TextSelection.fromPosition(TextPosition(offset: currentPosition - 1));
    }
  }

  void _handleSuggestionSelected(LMChatTagViewData suggestion) {
    widget.onTagSelected.call(suggestion);
    int currentPosition = _controller.selection.base.offset;
    String suffix = _controller.text.substring(currentPosition);

    _textValue = _buildTaggedText(suggestion);
    _controller.text = '$_textValue $suffix';
    _controller.selection = TextSelection.fromPosition(
        TextPosition(offset: _controller.text.length - suffix.length));

    _tagValue = '';
    _textValue = _controller.text;
    _page = 1;
    _tagComplete.value = true;
  }

  String _buildTaggedText(LMChatTagViewData suggestion) {
    String prefix = _textValue.endsWith('~') ? ' ' : '';
    String tagPrefix = suggestion.tagType == LMTagType.groupTag ? '' : '@';
    return '$_textValue$prefix$tagPrefix${suggestion.name}~';
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: effectiveStyle.margin ?? EdgeInsets.zero,
      child: ValueListenableBuilder(
        valueListenable: _tagComplete,
        builder: (context, value, child) {
          return TypeAheadField<LMChatTagViewData>(
            scrollPhysics:
                widget.scrollPhysics ?? const AlwaysScrollableScrollPhysics(),
            tagColor: effectiveStyle.tagColor ?? LMChatTheme.theme.linkColor,
            onTagTap: (p) {
              print(p);
            },
            onKeyboardFocusChange: (bool change) {
              widget.onKeyboardFocusChange?.call(change);
            },
            autoFlipListDirection: false,
            autoFlipDirection: true,
            suggestionsBoxController: _suggestionsBoxController,
            suggestionsBoxDecoration: _buildSuggestionsBoxDecoration(),
            noItemsFoundBuilder: (context) => const SizedBox.shrink(),
            hideOnEmpty: true,
            hideOnLoading: true,
            debounceDuration: const Duration(milliseconds: 500),
            scrollController: _scrollController,
            textFieldConfiguration: _buildTextFieldConfiguration(),
            direction: AxisDirection.down,
            suggestionsCallback: widget.enabled
                ? (suggestion) => _getSuggestions(suggestion)
                : (s) => Future.value(const Iterable.empty()),
            keepSuggestionsOnSuggestionSelected: true,
            itemBuilder: _buildSuggestionItem,
            onSuggestionSelected: _handleSuggestionSelected,
          );
        },
      ),
    );
  }

  SuggestionsBoxDecoration _buildSuggestionsBoxDecoration() {
    return SuggestionsBoxDecoration(
      offsetX: -4.w,
      elevation: effectiveStyle.suggestionsBoxElevation ?? 2,
      color: effectiveStyle.suggestionsBoxColor ?? LMChatTheme.theme.container,
      clipBehavior: Clip.hardEdge,
      borderRadius: effectiveStyle.suggestionsBoxBorderRadius ??
          const BorderRadius.all(Radius.circular(12.0)),
      hasScrollbar: false,
      constraints: effectiveStyle.suggestionsBoxConstraints ??
          BoxConstraints(maxHeight: 24.h, minWidth: 80.w),
    );
  }

  TextFieldConfiguration _buildTextFieldConfiguration() {
    return TextFieldConfiguration(
      textInputAction: TextInputAction.newline,
      keyboardType: TextInputType.multiline,
      controller: _controller,
      style: effectiveStyle.textStyle ??
          widget.style ??
          const TextStyle(fontSize: 14),
      textCapitalization: TextCapitalization.sentences,
      focusNode: _focusNode,
      minLines: 1,
      maxLines: 200,
      scrollPadding: const EdgeInsets.all(2),
      enabled: widget.decoration?.enabled ?? true,
      decoration: effectiveStyle.inputDecoration ??
          widget.decoration ??
          InputDecoration(
            hintText: 'Type something...',
            hintStyle: widget.style,
            border: InputBorder.none,
            focusColor: LMChatTheme.theme.linkColor,
          ),
      onChanged: _handleTextChange,
    );
  }

  Widget _buildSuggestionItem(BuildContext context, LMChatTagViewData opt) {
    return Container(
      decoration: BoxDecoration(
        color:
            effectiveStyle.suggestionItemColor ?? LMChatTheme.theme.container,
        border: Border(
          bottom: BorderSide(
            color: effectiveStyle.suggestionItemColor ??
                LMChatTheme.theme.container,
            width: 0.2,
          ),
        ),
      ),
      child: Padding(
        padding: effectiveStyle.suggestionItemPadding ??
            const EdgeInsets.symmetric(horizontal: 4),
        child: Container(
          width: double.infinity,
          color:
              effectiveStyle.suggestionsBoxColor ?? LMChatTheme.theme.container,
          padding: const EdgeInsets.all(12),
          child: Row(
            children: [
              LMChatProfilePicture(
                fallbackText: opt.name,
                imageUrl: opt.imageUrl,
                style: effectiveStyle.suggestionItemAvatarStyle ??
                    LMChatProfilePictureStyle(
                      size: 36,
                      backgroundColor: LMChatTheme.theme.backgroundColor,
                    ),
              ),
              const SizedBox(width: 12),
              LMChatText(
                opt.name,
                style: effectiveStyle.suggestionItemTextStyle ??
                    LMChatTextStyle(
                      textStyle: TextStyle(
                        fontSize: 14,
                        color: LMChatTheme.theme.onContainer,
                      ),
                    ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
File: lib/packages/core/test/likeminds_chat_flutter_core_test.dart
================================================




================================================
File: lib/packages/ui/README.md
================================================
# LikeMinds Chat Flutter UI

LikeMinds Chat Flutter UI is the layer of SDK that allows you to use our premade widgets for building full-blown Chat experiences within your own app using our Data layer (preferrably)



================================================
File: lib/packages/ui/CHANGELOG.md
================================================
## 0.5.0

- Initial release of DM widgets
- v2 architecture of Chat SDK

## 0.5.1

- Fixed a bug in Core package

## 0.6.0

- Added Support for chatroom
- Added conversation lists and actions
- enhancements and minor feature additions

## 0.6.1

- Added Support for block member
- Support for targetSDK v34 out of the box
- Updating dependencies to support Flutter `v3.22.0`

## 0.7.0

- Added multimedia support
- Added multimedia utils and handler functions

## 0.7.5

- Added support for Link Preview

## 0.8.0

- Added support for Tagging
- Added support for Reactions
- Added retry mechanism
- Added Analytics support

### 0.9.0

- Added support for poll
- Fixed Deleted text and link preview ui

### 0.10.0

- Added support for voice notes

### 0.11.0

- Added support for chatbot
- Added support for custom user roles

### 0.12.0

- Added support for poll configuration
- Added support for dark theme
- Added loads of UI/UX improvements

### 0.12.1

- Replaced `open_filex` with `open_file` plugin
- Removed `flutter_keyboard_visibility` plugin

### 0.13.0

- Added Custom Widget support in Chatroom

### 0.14.0

- Fixed Customization misses across the SDK
- Added support for .svg `fileUrl` in `LMChatImage`

## 0.14.1

- Patch update for `likeminds_chat_fl: ^1.12.1`

## 0.15.0

- Fixed attachment menubar hanging issue
- Fixed link preview bug


================================================
File: lib/packages/ui/LICENSE
================================================
Copyright [2024] [Collabmates Private Limited]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



================================================
File: lib/packages/ui/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
linter:
  rules:
    - public_member_api_docs



================================================
File: lib/packages/ui/devtools_options.yaml
================================================
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:



================================================
File: lib/packages/ui/pubspec.yaml
================================================
name: likeminds_chat_flutter_ui
description: UI package for LikeMinds Chat SDK, build your own Chat experiences using our widgets.
version: 0.15.0
homepage: https://likemind.community

environment:
  sdk: ">=3.1.0 <4.0.0"
  flutter: ">=3.10.2"

dependencies:
  flutter:
    sdk: flutter
  flutter_svg: ^2.0.10+1
  media_kit: ^1.1.11
  media_kit_video: ^1.2.5
  media_kit_libs_video: ^1.0.5 # Native video dependencies.
  shimmer: ^3.0.0
  swipe_to_action: ^0.2.0
  cached_network_image: ^3.3.1
  url_launcher: ^6.3.0
  collection: ^1.18.0
  video_thumbnail: ^0.5.3
  pdf_render: ^1.4.12
  open_file: ^3.5.10
  giphy_get: ^3.5.6
  gif: ^2.3.0
  path: ^1.9.0
  flutter_cache_manager: ^3.4.1
  custom_pop_up_menu: ^1.2.4
  emoji_picker_flutter: ^3.0.0
  flutter_sound: ^9.16.3
  super_sliver_list: ^0.4.1
  photo_view: ^0.15.0
  http: ^1.1.0
  path_provider: ^2.1.1

dependency_overrides:
  js: ^0.7.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0

flutter:
  assets:
    - assets/icons/



================================================
File: lib/packages/ui/pubspec_overrides.yaml
================================================
# melos_managed_dependency_overrides: super_sliver_list,js
{dependency_overrides: {js: ^0.7.1}}



================================================
File: lib/packages/ui/.flutter-plugins
================================================
# This is a generated file; do not edit or check into version control.
emoji_picker_flutter=/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/
flutter_sound=/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound-9.17.0/
flutter_sound_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound_web-9.17.0/
media_kit_libs_android_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_android_video-1.3.6/
media_kit_libs_ios_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_ios_video-1.1.4/
media_kit_libs_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_linux-1.1.3/
media_kit_libs_macos_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_macos_video-1.1.4/
media_kit_libs_windows_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_windows_video-1.0.10/
media_kit_native_event_loop=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/
media_kit_video=/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/
open_file=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file-3.5.10/
open_file_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_android-1.0.6/
open_file_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_ios-1.0.3/
open_file_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_linux-0.0.5/
open_file_mac=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_mac-1.0.3/
open_file_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_web-0.0.4/
open_file_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_windows-0.0.3/
package_info_plus=/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/
path_provider=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider-2.1.4/
path_provider_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_android-2.2.4/
path_provider_foundation=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/
path_provider_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_linux-2.2.1/
path_provider_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_windows-2.2.1/
pdf_render=/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/
screen_brightness=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness-0.2.2+1/
screen_brightness_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_android-0.1.0+2/
screen_brightness_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_ios-0.1.0/
screen_brightness_macos=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_macos-0.1.0+1/
screen_brightness_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_windows-0.1.3/
shared_preferences=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences-2.3.2/
shared_preferences_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_android-2.3.3/
shared_preferences_foundation=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/
shared_preferences_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_linux-2.4.1/
shared_preferences_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_web-2.4.2/
shared_preferences_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_windows-2.4.1/
sqflite=/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/
url_launcher=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher-6.3.1/
url_launcher_android=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_android-6.3.2/
url_launcher_ios=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_ios-6.3.0/
url_launcher_linux=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_linux-3.1.1/
url_launcher_macos=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_macos-3.2.0/
url_launcher_web=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_web-2.3.3/
url_launcher_windows=/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_windows-3.1.1/
video_thumbnail=/Users/anujkumar/.pub-cache/hosted/pub.dev/video_thumbnail-0.5.3/
volume_controller=/Users/anujkumar/.pub-cache/hosted/pub.dev/volume_controller-2.0.7/
wakelock_plus=/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/



================================================
File: lib/packages/ui/.flutter-plugins-dependencies
================================================
{"info":"This is a generated file; do not edit or check into version control.","plugins":{"ios":[{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"flutter_sound","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound-9.17.0/","native_build":true,"dependencies":[]},{"name":"media_kit_libs_ios_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_ios_video-1.1.4/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus","volume_controller"]},{"name":"open_file_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_ios-1.0.3/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":true,"dependencies":[]},{"name":"path_provider_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","native_build":true,"dependencies":[]},{"name":"screen_brightness_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_ios-0.1.0/","native_build":true,"dependencies":[]},{"name":"shared_preferences_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"sqflite","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"url_launcher_ios","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_ios-6.3.0/","native_build":true,"dependencies":[]},{"name":"video_thumbnail","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/video_thumbnail-0.5.3/","native_build":true,"dependencies":[]},{"name":"volume_controller","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/volume_controller-2.0.7/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":true,"dependencies":["package_info_plus"]}],"android":[{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"flutter_sound","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound-9.17.0/","native_build":true,"dependencies":[]},{"name":"media_kit_libs_android_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_android_video-1.3.6/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus","volume_controller"]},{"name":"open_file_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_android-1.0.6/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":true,"dependencies":[]},{"name":"path_provider_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_android-2.2.4/","native_build":true,"dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","native_build":true,"dependencies":[]},{"name":"screen_brightness_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_android-0.1.0+2/","native_build":true,"dependencies":[]},{"name":"shared_preferences_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_android-2.3.3/","native_build":true,"dependencies":[]},{"name":"sqflite","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/","native_build":true,"dependencies":[]},{"name":"url_launcher_android","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_android-6.3.2/","native_build":true,"dependencies":[]},{"name":"video_thumbnail","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/video_thumbnail-0.5.3/","native_build":true,"dependencies":[]},{"name":"volume_controller","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/volume_controller-2.0.7/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":true,"dependencies":["package_info_plus"]}],"macos":[{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"media_kit_libs_macos_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_macos_video-1.1.4/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus"]},{"name":"open_file_mac","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_mac-1.0.3/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":true,"dependencies":[]},{"name":"path_provider_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_foundation-2.4.0/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","native_build":true,"dependencies":[]},{"name":"screen_brightness_macos","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_macos-0.1.0+1/","native_build":true,"dependencies":[]},{"name":"shared_preferences_foundation","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_foundation-2.5.3/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"sqflite","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/sqflite-2.3.3+1/","shared_darwin_source":true,"native_build":true,"dependencies":[]},{"name":"url_launcher_macos","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_macos-3.2.0/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":true,"dependencies":["package_info_plus"]}],"linux":[{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"media_kit_libs_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_linux-1.1.3/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus"]},{"name":"open_file_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_linux-0.0.5/","native_build":true,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":false,"dependencies":[]},{"name":"path_provider_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_linux-2.2.1/","native_build":false,"dependencies":[]},{"name":"shared_preferences_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_linux-2.4.1/","native_build":false,"dependencies":["path_provider_linux"]},{"name":"url_launcher_linux","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_linux-3.1.1/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":false,"dependencies":["package_info_plus"]}],"windows":[{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","native_build":true,"dependencies":[]},{"name":"media_kit_libs_windows_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_libs_windows_video-1.0.10/","native_build":true,"dependencies":[]},{"name":"media_kit_native_event_loop","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_native_event_loop-1.0.9/","native_build":true,"dependencies":[]},{"name":"media_kit_video","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/media_kit_video-1.2.5/","native_build":true,"dependencies":["wakelock_plus"]},{"name":"open_file_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_windows-0.0.3/","native_build":false,"dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","native_build":false,"dependencies":[]},{"name":"path_provider_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/path_provider_windows-2.2.1/","native_build":false,"dependencies":[]},{"name":"screen_brightness_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/screen_brightness_windows-0.1.3/","native_build":true,"dependencies":[]},{"name":"shared_preferences_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_windows-2.4.1/","native_build":false,"dependencies":["path_provider_windows"]},{"name":"url_launcher_windows","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_windows-3.1.1/","native_build":true,"dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","native_build":false,"dependencies":["package_info_plus"]}],"web":[{"name":"emoji_picker_flutter","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/emoji_picker_flutter-3.1.0/","dependencies":[]},{"name":"flutter_sound_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/flutter_sound_web-9.17.0/","dependencies":[]},{"name":"open_file_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/open_file_web-0.0.4/","dependencies":[]},{"name":"package_info_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/package_info_plus-8.0.2/","dependencies":[]},{"name":"pdf_render","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/pdf_render-1.4.12/","dependencies":[]},{"name":"shared_preferences_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/shared_preferences_web-2.4.2/","dependencies":[]},{"name":"url_launcher_web","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/url_launcher_web-2.3.3/","dependencies":[]},{"name":"wakelock_plus","path":"/Users/anujkumar/.pub-cache/hosted/pub.dev/wakelock_plus-1.2.8/","dependencies":["package_info_plus"]}]},"dependencyGraph":[{"name":"emoji_picker_flutter","dependencies":["shared_preferences"]},{"name":"flutter_sound","dependencies":["path_provider","flutter_sound_web"]},{"name":"flutter_sound_web","dependencies":[]},{"name":"media_kit_libs_android_video","dependencies":[]},{"name":"media_kit_libs_ios_video","dependencies":[]},{"name":"media_kit_libs_linux","dependencies":[]},{"name":"media_kit_libs_macos_video","dependencies":[]},{"name":"media_kit_libs_windows_video","dependencies":[]},{"name":"media_kit_native_event_loop","dependencies":[]},{"name":"media_kit_video","dependencies":["wakelock_plus","screen_brightness","volume_controller"]},{"name":"open_file","dependencies":["open_file_android","open_file_web","open_file_ios","open_file_mac","open_file_windows","open_file_linux"]},{"name":"open_file_android","dependencies":[]},{"name":"open_file_ios","dependencies":[]},{"name":"open_file_linux","dependencies":[]},{"name":"open_file_mac","dependencies":[]},{"name":"open_file_web","dependencies":[]},{"name":"open_file_windows","dependencies":[]},{"name":"package_info_plus","dependencies":[]},{"name":"path_provider","dependencies":["path_provider_android","path_provider_foundation","path_provider_linux","path_provider_windows"]},{"name":"path_provider_android","dependencies":[]},{"name":"path_provider_foundation","dependencies":[]},{"name":"path_provider_linux","dependencies":[]},{"name":"path_provider_windows","dependencies":[]},{"name":"pdf_render","dependencies":[]},{"name":"screen_brightness","dependencies":["screen_brightness_android","screen_brightness_ios","screen_brightness_macos","screen_brightness_windows"]},{"name":"screen_brightness_android","dependencies":[]},{"name":"screen_brightness_ios","dependencies":[]},{"name":"screen_brightness_macos","dependencies":[]},{"name":"screen_brightness_windows","dependencies":[]},{"name":"shared_preferences","dependencies":["shared_preferences_android","shared_preferences_foundation","shared_preferences_linux","shared_preferences_web","shared_preferences_windows"]},{"name":"shared_preferences_android","dependencies":[]},{"name":"shared_preferences_foundation","dependencies":[]},{"name":"shared_preferences_linux","dependencies":["path_provider_linux"]},{"name":"shared_preferences_web","dependencies":[]},{"name":"shared_preferences_windows","dependencies":["path_provider_windows"]},{"name":"sqflite","dependencies":[]},{"name":"url_launcher","dependencies":["url_launcher_android","url_launcher_ios","url_launcher_linux","url_launcher_macos","url_launcher_web","url_launcher_windows"]},{"name":"url_launcher_android","dependencies":[]},{"name":"url_launcher_ios","dependencies":[]},{"name":"url_launcher_linux","dependencies":[]},{"name":"url_launcher_macos","dependencies":[]},{"name":"url_launcher_web","dependencies":[]},{"name":"url_launcher_windows","dependencies":[]},{"name":"video_thumbnail","dependencies":[]},{"name":"volume_controller","dependencies":[]},{"name":"wakelock_plus","dependencies":["package_info_plus"]}],"date_created":"2025-03-07 19:51:14.005549","version":"3.24.5","swift_package_manager_enabled":false}


================================================
File: lib/packages/ui/.gitignore
================================================
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
# Libraries should not include pubspec.lock, per https://dart.dev/guides/libraries/private-files#pubspeclock.
/pubspec.lock
**/doc/api/
.dart_tool/
.packages
build/



================================================
File: lib/packages/ui/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e1e47221e86272429674bec4f1bd36acc4fc7b77"
  channel: "stable"

project_type: package



================================================
File: lib/packages/ui/.pubignore
================================================
pubspec_overrides.yaml



================================================
File: lib/packages/ui/lib/likeminds_chat_flutter_ui.dart
================================================
library likeminds_chat_flutter_ui;

export 'src/widgets/widgets.dart';
export 'src/utils/utils.dart';
export 'src/models/models.dart';

export 'src/theme/theme.dart';



================================================
File: lib/packages/ui/lib/packages/expandable_text/expandable_text.dart
================================================
library expandable_text;

import 'dart:math';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/packages/linkify/linkify.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';

import './text_parser.dart';

typedef StringCallback = void Function(String value);

class LMChatExpandableText extends StatefulWidget {
  const LMChatExpandableText(
    this.text, {
    Key? key,
    required this.expandText,
    this.collapseText,
    this.expanded = false,
    this.onExpandedChanged,
    this.onLinkTap,
    this.linkColor,
    this.linkEllipsis = true,
    this.linkStyle,
    this.prefixText,
    this.prefixStyle,
    this.onPrefixTap,
    this.urlStyle,
    this.onUrlTap,
    this.hashtagStyle,
    this.onHashtagTap,
    this.mentionStyle,
    this.onMentionTap,
    this.expandOnTextTap = false,
    this.collapseOnTextTap = false,
    this.style,
    this.textDirection,
    this.textAlign,
    this.textScaleFactor,
    this.maxLines = 3,
    this.animation = false,
    this.animationDuration,
    this.animationCurve,
    this.semanticsLabel,
    required this.onTagTap,
    this.enableSelection = true,
  })  : assert(maxLines > 0),
        super(key: key);

  final String text;
  final String expandText;
  final String? collapseText;
  final bool expanded;
  final ValueChanged<bool>? onExpandedChanged;
  final VoidCallback? onLinkTap;
  final Color? linkColor;
  final bool linkEllipsis;
  final TextStyle? linkStyle;
  final String? prefixText;
  final TextStyle? prefixStyle;
  final VoidCallback? onPrefixTap;
  final TextStyle? urlStyle;
  final StringCallback? onUrlTap;
  final TextStyle? hashtagStyle;
  final StringCallback? onHashtagTap;
  final TextStyle? mentionStyle;
  final StringCallback? onMentionTap;
  final bool expandOnTextTap;
  final bool collapseOnTextTap;
  final TextStyle? style;
  final TextDirection? textDirection;
  final TextAlign? textAlign;
  final double? textScaleFactor;
  final int maxLines;
  final bool animation;
  final Duration? animationDuration;
  final Curve? animationCurve;
  final String? semanticsLabel;
  final Function(String) onTagTap;
  final bool enableSelection;

  /// Creates a copy of this [LMChatExpandableText] but with the given fields
  /// updated to the new values.
  LMChatExpandableText copyWith({
    String? text,
    String? expandText,
    String? collapseText,
    bool? expanded,
    ValueChanged<bool>? onExpandedChanged,
    VoidCallback? onLinkTap,
    Color? linkColor,
    bool? linkEllipsis,
    TextStyle? linkStyle,
    String? prefixText,
    TextStyle? prefixStyle,
    VoidCallback? onPrefixTap,
    TextStyle? urlStyle,
    StringCallback? onUrlTap,
    TextStyle? hashtagStyle,
    StringCallback? onHashtagTap,
    TextStyle? mentionStyle,
    StringCallback? onMentionTap,
    bool? expandOnTextTap,
    bool? collapseOnTextTap,
    TextStyle? style,
    TextDirection? textDirection,
    TextAlign? textAlign,
    double? textScaleFactor,
    int? maxLines,
    bool? animation,
    Duration? animationDuration,
    Curve? animationCurve,
    String? semanticsLabel,
    Function(String)? onTagTap,
    bool? enableSelection,
  }) {
    return LMChatExpandableText(
      text ?? this.text,
      expandText: expandText ?? this.expandText,
      collapseText: collapseText ?? this.collapseText,
      expanded: expanded ?? this.expanded,
      onExpandedChanged: onExpandedChanged ?? this.onExpandedChanged,
      onLinkTap: onLinkTap ?? this.onLinkTap,
      linkColor: linkColor ?? this.linkColor,
      linkEllipsis: linkEllipsis ?? this.linkEllipsis,
      linkStyle: linkStyle ?? this.linkStyle,
      prefixText: prefixText ?? this.prefixText,
      prefixStyle: prefixStyle ?? this.prefixStyle,
      onPrefixTap: onPrefixTap ?? this.onPrefixTap,
      urlStyle: urlStyle ?? this.urlStyle,
      onUrlTap: onUrlTap ?? this.onUrlTap,
      hashtagStyle: hashtagStyle ?? this.hashtagStyle,
      onHashtagTap: onHashtagTap ?? this.onHashtagTap,
      mentionStyle: mentionStyle ?? this.mentionStyle,
      onMentionTap: onMentionTap ?? this.onMentionTap,
      expandOnTextTap: expandOnTextTap ?? this.expandOnTextTap,
      collapseOnTextTap: collapseOnTextTap ?? this.collapseOnTextTap,
      style: style ?? this.style,
      textDirection: textDirection ?? this.textDirection,
      textAlign: textAlign ?? this.textAlign,
      textScaleFactor: textScaleFactor ?? this.textScaleFactor,
      maxLines: maxLines ?? this.maxLines,
      animation: animation ?? this.animation,
      animationDuration: animationDuration ?? this.animationDuration,
      animationCurve: animationCurve ?? this.animationCurve,
      semanticsLabel: semanticsLabel ?? this.semanticsLabel,
      onTagTap: onTagTap ?? this.onTagTap,
      enableSelection: enableSelection ?? this.enableSelection,
    );
  }

  @override
  LMChatExpandableTextState createState() => LMChatExpandableTextState();
}

class LMChatExpandableTextState extends State<LMChatExpandableText>
    with TickerProviderStateMixin {
  bool _expanded = false;
  RegExp regExp = RegExp(kRegexLinksAndTags);
  late TapGestureRecognizer _linkTapGestureRecognizer;
  late TapGestureRecognizer _prefixTapGestureRecognizer;

  List<TextSegment> _textSegments = [];
  final List<TapGestureRecognizer> _textSegmentsTapGestureRecognizers = [];

  @override
  void initState() {
    super.initState();
    _expanded = widget.expanded;
    _linkTapGestureRecognizer = TapGestureRecognizer()..onTap = _linkTapped;
    _prefixTapGestureRecognizer = TapGestureRecognizer()..onTap = _prefixTapped;

    _updateText();
  }

  @override
  void didUpdateWidget(LMChatExpandableText oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.text != widget.text ||
        oldWidget.onUrlTap != widget.onUrlTap ||
        oldWidget.onHashtagTap != widget.onHashtagTap ||
        oldWidget.onMentionTap != widget.onMentionTap) {
      _expanded = widget.expanded;
      _updateText();
    }
  }

  @override
  void dispose() {
    _linkTapGestureRecognizer.dispose();
    _prefixTapGestureRecognizer.dispose();
    for (var recognizer in _textSegmentsTapGestureRecognizers) {
      recognizer.dispose();
    }
    super.dispose();
  }

  void _linkTapped() {
    if (widget.onLinkTap != null) {
      widget.onLinkTap!();
      return;
    }

    final toggledExpanded = !_expanded;

    setState(() => _expanded = toggledExpanded);

    widget.onExpandedChanged?.call(toggledExpanded);
  }

  void _prefixTapped() {
    widget.onPrefixTap?.call();
  }

  @override
  Widget build(BuildContext context) {
    final DefaultTextStyle defaultTextStyle = DefaultTextStyle.of(context);
    var effectiveTextStyle = widget.style;
    if (widget.style == null || widget.style!.inherit) {
      effectiveTextStyle = defaultTextStyle.style.merge(widget.style);
    }

    final linkText =
        (_expanded ? widget.collapseText : widget.expandText) ?? '';
    final linkColor = widget.linkColor ??
        widget.prefixStyle?.color ??
        const Color(0xFF4666F6);
    final linkTextStyle = effectiveTextStyle!
        .merge(widget.prefixStyle)
        .copyWith(color: linkColor);

    final prefixText =
        widget.prefixText != null && widget.prefixText!.isNotEmpty
            ? '${widget.prefixText} '
            : '';

    final link = TextSpan(
      children: [
        if (!_expanded)
          TextSpan(
            text: '\u2026 ',
            style: widget.linkEllipsis ? linkTextStyle : effectiveTextStyle,
            recognizer: widget.linkEllipsis ? _linkTapGestureRecognizer : null,
          ),
        if (linkText.isNotEmpty)
          TextSpan(
            style: effectiveTextStyle,
            children: <TextSpan>[
              if (_expanded)
                const TextSpan(
                  text: ' ',
                ),
              TextSpan(
                text: linkText,
                style: linkTextStyle,
                recognizer: _linkTapGestureRecognizer,
              ),
            ],
          ),
      ],
    );

    final prefix = extractLinksAndTags(prefixText);
    final text = extractLinksAndTags(widget.text);

    final content = TextSpan(
      children: <TextSpan>[...prefix, ...text],
      style: effectiveTextStyle,
    );

    Widget result = LayoutBuilder(
      builder: (BuildContext context, BoxConstraints constraints) {
        assert(constraints.hasBoundedWidth);
        final double maxWidth = constraints.maxWidth;

        final textAlign =
            widget.textAlign ?? defaultTextStyle.textAlign ?? TextAlign.start;
        final textDirection =
            widget.textDirection ?? Directionality.of(context);
        final textScaleFactor =
            widget.textScaleFactor ?? MediaQuery.textScaleFactorOf(context);
        final locale = Localizations.maybeLocaleOf(context);

        TextPainter textPainter = TextPainter(
          text: link,
          textAlign: textAlign,
          textDirection: textDirection,
          textScaleFactor: textScaleFactor,
          maxLines: widget.maxLines,
          locale: locale,
        );
        textPainter.layout(minWidth: constraints.minWidth, maxWidth: maxWidth);
        final linkSize = textPainter.size;

        textPainter.text = content;
        textPainter.layout(minWidth: constraints.minWidth, maxWidth: maxWidth);
        final textSize = textPainter.size;

        TextSpan textSpan;
        if (textPainter.didExceedMaxLines) {
          final position = textPainter.getPositionForOffset(Offset(
            textSize.width - linkSize.width,
            textSize.height,
          ));
          final endOffset =
              (textPainter.getOffsetBefore(position.offset) ?? 0) -
                  prefixText.length;

          final recognizer =
              (_expanded ? widget.collapseOnTextTap : widget.expandOnTextTap)
                  ? _linkTapGestureRecognizer
                  : null;
          String resultText;
          if (!_expanded) {
            var response =
                LMChatTaggingHelper.convertRouteToTagAndUserMap(widget.text);
            List<LMChatTagViewData> userTags = response['userTags'];
            resultText = response['text'];
            // final lineCount = textPainter.computeLineMetrics().length;
            final nCount = '\n'.allMatches(resultText).length + 1;
            if (resultText.length > 300 && nCount <= 4) {
              resultText = resultText.substring(0, max(endOffset, 0));
            } else {
              resultText = resultText.substring(0, max(endOffset, 0));
            }

            resultText = LMChatTaggingHelper.encodeString(resultText, userTags);
          } else {
            resultText = widget.text;
          }

          final text = _textSegments.isNotEmpty
              ? TextSpan(
                  children: _buildTextSpans(
                      _expanded ? _textSegments : parseText(resultText),
                      effectiveTextStyle!,
                      recognizer),
                )
              : TextSpan(
                  children: extractLinksAndTags(resultText),
                );

          textSpan = TextSpan(
            style: effectiveTextStyle,
            children: <TextSpan>[
              ...prefix,
              text,
              link,
            ],
          );
        } else {
          textSpan = content;
        }

        final richText = SelectableText.rich(
          textSpan,
          textDirection: textDirection,
          textAlign: textAlign,
          textScaleFactor: textScaleFactor,
          enableInteractiveSelection: widget.enableSelection,
          style: widget.style,
        );

        if (widget.animation) {
          return AnimatedSize(
              duration:
                  widget.animationDuration ?? const Duration(milliseconds: 200),
              curve: widget.animationCurve ?? Curves.fastLinearToSlowEaseIn,
              alignment: Alignment.topLeft,
              child: richText);
        }

        return richText;
      },
    );

    if (widget.semanticsLabel != null) {
      result = Semantics(
        textDirection: widget.textDirection,
        label: widget.semanticsLabel,
        child: ExcludeSemantics(
          child: result,
        ),
      );
    }

    return result;
  }

  void _updateText() {
    for (var recognizer in _textSegmentsTapGestureRecognizers) {
      recognizer.dispose();
    }
    _textSegmentsTapGestureRecognizers.clear();

    if (widget.onUrlTap == null &&
        widget.onHashtagTap == null &&
        widget.onMentionTap == null) {
      _textSegments.clear();
      return;
    }

    _textSegments = parseText(widget.text);

    for (var element in _textSegments) {
      if (element.isUrl && widget.onUrlTap != null) {
        final recognizer = TapGestureRecognizer()
          ..onTap = () {
            widget.onUrlTap!(element.name!);
          };

        _textSegmentsTapGestureRecognizers.add(recognizer);
      } else if (element.isHashtag && widget.onHashtagTap != null) {
        final recognizer = TapGestureRecognizer()
          ..onTap = () {
            widget.onHashtagTap!(element.name!);
          };

        _textSegmentsTapGestureRecognizers.add(recognizer);
      } else if (element.isMention && widget.onMentionTap != null) {
        final recognizer = TapGestureRecognizer()
          ..onTap = () {
            widget.onMentionTap!(element.name!);
          };

        _textSegmentsTapGestureRecognizers.add(recognizer);
      }
    }
  }

  List<TextSpan> _buildTextSpans(List<TextSegment> segments,
      TextStyle textStyle, TapGestureRecognizer? textTapRecognizer) {
    final spans = <TextSpan>[];

    var index = 0;
    for (var segment in segments) {
      TextStyle? style;
      TapGestureRecognizer? recognizer;

      if (segment.isUrl && widget.onUrlTap != null) {
        style = textStyle.merge(widget.urlStyle);
        recognizer = _textSegmentsTapGestureRecognizers[index++];
      } else if (segment.isMention && widget.onMentionTap != null) {
        style = textStyle.merge(widget.mentionStyle);
        recognizer = _textSegmentsTapGestureRecognizers[index++];
      } else if (segment.isHashtag && widget.onHashtagTap != null) {
        style = textStyle.merge(widget.hashtagStyle);
        recognizer = _textSegmentsTapGestureRecognizers[index++];
      }

      final span = TextSpan(
        text: segment.text,
        style: style,
        recognizer: recognizer ?? textTapRecognizer,
      );

      spans.add(span);
    }

    return spans;
  }

  List<TextSpan> extractLinksAndTags(String text) {
    List<TextSpan> textSpans = [];
    int lastIndex = 0;
    for (Match match in regExp.allMatches(text)) {
      int startIndex = match.start;
      int endIndex = match.end;
      String? link = match.group(0);

      if (lastIndex != startIndex) {
        // Add a TextSpan for the preceding text
        textSpans.add(TextSpan(
          text: text.substring(lastIndex, startIndex),
          style: widget.style,
        ));
      }

      // Handle bold text between double asterisks
      if (link != null && link.startsWith('**') && link.endsWith('**')) {
        String boldText =
            link.substring(2, link.length - 2); // Remove ** from both ends
        textSpans.add(TextSpan(
          text: boldText,
          style: widget.style?.copyWith(fontWeight: FontWeight.bold) ??
              const TextStyle(fontWeight: FontWeight.bold),
        ));
      } else if (link != null && link.isNotEmpty && link[0] == '#') {
        textSpans.add(TextSpan(
          text: link,
          style: widget.hashtagStyle ?? const TextStyle(color: Colors.blue),
        ));
      } else {
        bool isTag = link != null && link[0] == '<';

        // if it is a valid link using linkify and
        // if that is not then add normal TextSpan
        if (!isTag && extractLinkAndEmailFromString(link ?? '') == null) {
          textSpans.add(TextSpan(
            text: text.substring(startIndex, endIndex),
            style: widget.style,
          ));
          lastIndex = endIndex;
          continue;
        }
        // Add a TextSpan for the URL
        textSpans.add(TextSpan(
          text:
              isTag ? LMChatTaggingHelper.decodeString(link).keys.first : link,
          style: widget.linkStyle ?? const TextStyle(color: Colors.blue),
          recognizer: TapGestureRecognizer()
            ..onTap = () async {
              if (!isTag) {
                final checkLink = extractLinkAndEmailFromString(link ?? '');
                if (checkLink is UrlElement) {
                  if (Uri.parse(checkLink.url).isAbsolute) {
                    launchUrl(
                      Uri.parse(checkLink.url),
                      mode: LaunchMode.externalApplication,
                    );
                  }
                } else if (checkLink is EmailElement) {
                  launchUrl(
                    Uri.parse('mailto:${checkLink.emailAddress}'),
                    mode: LaunchMode.externalApplication,
                  );
                }
              } else {
                widget.onTagTap(
                  LMChatTaggingHelper.decodeString(link).values.first,
                );
                // LMFeedTaggingHelper.routeToProfile(
                //   LMFeedTaggingHelper.decodeString(link).values.first,
                // );
              }
            },
        ));
      }

      lastIndex = endIndex;
    }

    if (lastIndex != text.length) {
      // Add a TextSpan for the remaining text
      textSpans.add(TextSpan(
        text: text.substring(lastIndex),
        style: widget.style,
      ));
    }

    return textSpans;
  }
}



================================================
File: lib/packages/ui/lib/packages/expandable_text/text_parser.dart
================================================
class TextSegment {
  String text;

  final String? name;
  final bool isHashtag;
  final bool isMention;
  final bool isUrl;

  bool get isText => !isHashtag && !isMention && !isUrl;

  TextSegment(this.text,
      [this.name,
      this.isHashtag = false,
      this.isMention = false,
      this.isUrl = false]);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TextSegment &&
          runtimeType == other.runtimeType &&
          text == other.text &&
          name == other.name &&
          isHashtag == other.isHashtag &&
          isMention == other.isMention &&
          isUrl == other.isUrl;

  @override
  int get hashCode =>
      text.hashCode ^
      name.hashCode ^
      isHashtag.hashCode ^
      isMention.hashCode ^
      isUrl.hashCode;
}

/// Split the string into multiple instances of [TextSegment]
/// for mentions, hashtags, URLs and regular text.
///
/// Mentions are all words that start with @, e.g. @mention.
/// Hashtags are all words that start with #, e.g. #hashtag.
List<TextSegment> parseText(String? text) {
  final segments = <TextSegment>[];

  if (text == null || text.isEmpty) {
    return segments;
  }

  // parse urls and words starting with @ (mention) or # (hashtag)
  RegExp exp = RegExp(
      r'(?<keyword>(#|@)([\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]+)|(?<url>(?:(?:https?|ftp):\/\/)?[-a-z0-9@:%._\+~#=]{1,256}\.[a-z0-9]{1,6}(\/[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)?))',
      unicode: true);
  final matches = exp.allMatches(text);

  var start = 0;
  for (var match in matches) {
    // text before the keyword
    if (match.start > start) {
      if (segments.isNotEmpty && segments.last.isText) {
        segments.last.text += text.substring(start, match.start);
      } else {
        segments.add(TextSegment(text.substring(start, match.start)));
      }
      start = match.start;
    }

    final url = match.namedGroup('url');
    final keyword = match.namedGroup('keyword');

    if (url != null) {
      segments.add(TextSegment(url, url, false, false, true));
    } else if (keyword != null) {
      final isWord = match.start == 0 ||
          [' ', '\n'].contains(text.substring(match.start - 1, start));
      if (!isWord) {
        continue;
      }

      final isHashtag = keyword.startsWith('#');
      final isMention = keyword.startsWith('@');

      segments.add(
          TextSegment(keyword, keyword.substring(1), isHashtag, isMention));
    }

    start = match.end;
  }

  // text after the last keyword or
  // the whole text if it does not contain any keywords
  if (start < text.length) {
    if (segments.isNotEmpty && segments.last.isText) {
      segments.last.text += text.substring(start);
    } else {
      segments.add(TextSegment(text.substring(start)));
    }
  }

  return segments;
}



================================================
File: lib/packages/ui/lib/packages/linkify/linkify.dart
================================================
library linkify;

import 'src/email.dart';
import 'src/url.dart';
export 'src/email.dart' show EmailLinkifier, EmailElement;
export 'src/url.dart' show UrlLinkifier, UrlElement;

abstract class LinkifyElement {
  final String text;
  final String originText;

  LinkifyElement(this.text, [String? originText])
      : originText = originText ?? text;

  @override
  bool operator ==(other) => equals(other);

  @override
  int get hashCode => Object.hash(text, originText);

  bool equals(other) => other is LinkifyElement && other.text == text;
}

class LinkableElement extends LinkifyElement {
  final String url;

  LinkableElement(String? text, this.url, [String? originText])
      : super(text ?? url, originText);

  @override
  bool operator ==(other) => equals(other);

  @override
  int get hashCode => Object.hash(text, originText, url);

  @override
  bool equals(other) =>
      other is LinkableElement && super.equals(other) && other.url == url;
}

/// Represents an element containing text
class TextElement extends LinkifyElement {
  TextElement(String text) : super(text);

  @override
  String toString() {
    return "TextElement: '$text'";
  }

  @override
  bool operator ==(other) => equals(other);

  @override
  int get hashCode => Object.hash(text, originText);

  @override
  bool equals(other) => other is TextElement && super.equals(other);
}

abstract class Linkifier {
  const Linkifier();

  List<LinkifyElement> parse(
      List<LinkifyElement> elements, LinkifyOptions options);
}

class LinkifyOptions {
  /// Removes http/https from shown URLs.
  final bool humanize;

  /// Removes www. from shown URLs.
  final bool removeWww;

  /// Enables loose URL parsing (any string with "." is a URL).
  final bool looseUrl;

  /// When used with [looseUrl], default to `https` instead of `http`.
  final bool defaultToHttps;

  /// Excludes `.` at end of URLs.
  final bool excludeLastPeriod;

  const LinkifyOptions({
    this.humanize = true,
    this.removeWww = false,
    this.looseUrl = false,
    this.defaultToHttps = false,
    this.excludeLastPeriod = true,
  });
}

const _urlLinkifier = UrlLinkifier();
const _emailLinkifier = EmailLinkifier();
const defaultLinkifiers = [_urlLinkifier, _emailLinkifier];

/// Turns [text] into a list of [LinkifyElement]
///
/// Use [humanize] to remove http/https from the start of the URL shown.
/// Will default to `false` (if `null`)
///
/// Uses [linkTypes] to enable some types of links (URL, email).
/// Will default to all (if `null`).
List<LinkifyElement> linkify(
  String text, {
  LinkifyOptions options = const LinkifyOptions(),
  List<Linkifier> linkifiers = defaultLinkifiers,
}) {
  var list = <LinkifyElement>[TextElement(text)];

  if (text.isEmpty) {
    return [];
  }

  if (linkifiers.isEmpty) {
    return list;
  }

  for (var linkifier in linkifiers) {
    list = linkifier.parse(list, options);
  }

  return list;
}



================================================
File: lib/packages/ui/lib/packages/linkify/src/email.dart
================================================
import 'package:likeminds_chat_flutter_ui/packages/linkify/linkify.dart';

final _emailRegex = RegExp(
  r'^(.*?)((mailto:)?[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z][A-Z]+)',
  caseSensitive: false,
  dotAll: true,
);

class EmailLinkifier extends Linkifier {
  const EmailLinkifier();

  @override
  List<LinkifyElement> parse(elements, options) {
    final list = <LinkifyElement>[];

    for (var element in elements) {
      if (element is TextElement) {
        final match = _emailRegex.firstMatch(element.text);

        if (match == null) {
          list.add(element);
        } else {
          final text = element.text.replaceFirst(match.group(0)!, '');

          if (match.group(1)?.isNotEmpty == true) {
            list.add(TextElement(match.group(1)!));
          }

          if (match.group(2)?.isNotEmpty == true) {
            // Always humanize emails
            list.add(EmailElement(
              match.group(2)!.replaceFirst(RegExp(r'mailto:'), ''),
            ));
          }

          if (text.isNotEmpty) {
            list.addAll(parse([TextElement(text)], options));
          }
        }
      } else {
        list.add(element);
      }
    }

    return list;
  }
}

/// Represents an element containing an email address
class EmailElement extends LinkableElement {
  final String emailAddress;

  EmailElement(this.emailAddress) : super(emailAddress, 'mailto:$emailAddress');

  @override
  String toString() {
    return "EmailElement: '$emailAddress' ($text)";
  }

  @override
  bool operator ==(other) => equals(other);

  @override
  int get hashCode => Object.hash(text, originText, url, emailAddress);

  @override
  bool equals(other) =>
      other is EmailElement &&
      super.equals(other) &&
      other.emailAddress == emailAddress;
}



================================================
File: lib/packages/ui/lib/packages/linkify/src/url.dart
================================================
import 'package:likeminds_chat_flutter_ui/packages/linkify/linkify.dart';

final _urlRegex = RegExp(
  r'^(.*?)((?:https?:\/\/|www\.)[^\s/$.?#].[^\s]*)',
  caseSensitive: false,
  dotAll: true,
);

final _looseUrlRegex = RegExp(
  r'''^(.*?)((https?:\/\/)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,4}\b([-a-zA-Z0-9@:%_\+.~#?&//=/'"`]*))''',
  caseSensitive: false,
  dotAll: true,
);

final _protocolIdentifierRegex = RegExp(
  r'^(https?:\/\/)',
  caseSensitive: false,
);

class UrlLinkifier extends Linkifier {
  const UrlLinkifier();

  @override
  List<LinkifyElement> parse(elements, options) {
    final list = <LinkifyElement>[];

    for (var element in elements) {
      if (element is TextElement) {
        var match = options.looseUrl
            ? _looseUrlRegex.firstMatch(element.text)
            : _urlRegex.firstMatch(element.text);

        if (match == null) {
          list.add(element);
        } else {
          final text = element.text.replaceFirst(match.group(0)!, '');

          if (match.group(1)?.isNotEmpty == true) {
            list.add(TextElement(match.group(1)!));
          }

          if (match.group(2)?.isNotEmpty == true) {
            var originalUrl = match.group(2)!;
            var originText = originalUrl;
            String? end;

            if ((options.excludeLastPeriod) &&
                originalUrl[originalUrl.length - 1] == ".") {
              end = ".";
              originText = originText.substring(0, originText.length - 1);
              originalUrl = originalUrl.substring(0, originalUrl.length - 1);
            }

            var url = originalUrl;

            if (!originalUrl.startsWith(_protocolIdentifierRegex)) {
              originalUrl = (options.defaultToHttps ? "https://" : "http://") +
                  originalUrl;
            }

            if ((options.humanize) || (options.removeWww)) {
              if (options.humanize) {
                url = url.replaceFirst(RegExp(r'https?://'), '');
              }
              if (options.removeWww) {
                url = url.replaceFirst(RegExp(r'www\.'), '');
              }

              list.add(UrlElement(
                originalUrl,
                url,
                originText,
              ));
            } else {
              list.add(UrlElement(originalUrl, null, originText));
            }

            if (end != null) {
              list.add(TextElement(end));
            }
          }

          if (text.isNotEmpty) {
            list.addAll(parse([TextElement(text)], options));
          }
        }
      } else {
        list.add(element);
      }
    }

    return list;
  }
}

/// Represents an element containing a link
class UrlElement extends LinkableElement {
  UrlElement(String url, [String? text, String? originText])
      : super(text, url, originText);

  @override
  String toString() {
    return "LinkElement: '$url' ($text)";
  }

  @override
  bool operator ==(other) => equals(other);

  @override
  int get hashCode => Object.hash(text, originText, url);

  @override
  bool equals(other) => other is UrlElement && super.equals(other);
}



================================================
File: lib/packages/ui/lib/src/models/models.dart
================================================
// attachment models
export 'attachment/attachment_view_data.dart';
export 'poll/poll_option_view_data.dart';
export 'poll/poll_enum.dart';

// chatroom models
export 'chatroom/chatroom_view_data.dart';

// conversation models
export 'conversation/conversation_view_data.dart';
export 'conversation/reaction_view_data.dart';

// media models
export 'media/media_model.dart';
export 'media/og_tags_view_data.dart';

// menu models
export 'menu/menu_item_view_data.dart';

// sdk models
export 'sdk/sdk_client_info_view_data.dart';

// tag models
export 'tag/tag_view_data.dart';

// user models
export 'user/user_view_data.dart';

// widget models
export 'widget/widget_view_data.dart';

// delete models
export 'delete/delete_reason_view_data.dart';

// moderation models
export 'moderation/report_tag_view_data.dart';


================================================
File: lib/packages/ui/lib/src/models/attachment/attachment_view_data.dart
================================================
import 'dart:io';

/// `LMChatAttachmentViewData` is a model class that holds the data for the attachment view.
class LMChatAttachmentViewData {
  final int? answerId;
  final int? createdAt;
  final dynamic dimensions;
  final String? fileUrl;
  final String? url;
  final File? attachmentFile;
  final dynamic height;
  final int? id;
  final int? index;
  final dynamic locationLat;
  final dynamic locationLong;
  final dynamic locationName;
  final dynamic meta;
  final String? name;
  final String? thumbnailUrl;
  final File? thumbnailFile;
  final String? type;
  final dynamic width;

  LMChatAttachmentViewData._({
    required this.answerId,
    required this.createdAt,
    required this.dimensions,
    required this.fileUrl,
    required this.url,
    required this.attachmentFile,
    required this.height,
    required this.id,
    required this.index,
    required this.locationLat,
    required this.locationLong,
    required this.locationName,
    required this.meta,
    required this.name,
    required this.thumbnailUrl,
    required this.thumbnailFile,
    required this.type,
    required this.width,
  });

  /// copyWith method is used to create a new instance of `LMChatAttachmentViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatAttachmentViewData copyWith({
    int? answerId,
    int? createdAt,
    dynamic dimensions,
    String? fileUrl,
    String? url,
    File? attachmentFile,
    dynamic height,
    int? id,
    int? index,
    dynamic locationLat,
    dynamic locationLong,
    dynamic locationName,
    dynamic meta,
    String? name,
    String? thumbnailUrl,
    File? thumbnailFile,
    String? type,
    dynamic width,
  }) {
    return LMChatAttachmentViewData._(
      answerId: answerId ?? this.answerId,
      createdAt: createdAt ?? this.createdAt,
      dimensions: dimensions ?? this.dimensions,
      fileUrl: fileUrl ?? this.fileUrl,
      url: url ?? this.url,
      attachmentFile: attachmentFile ?? this.attachmentFile,
      height: height ?? this.height,
      id: id ?? this.id,
      index: index ?? this.index,
      locationLat: locationLat ?? this.locationLat,
      locationLong: locationLong ?? this.locationLong,
      locationName: locationName ?? this.locationName,
      meta: meta ?? this.meta,
      name: name ?? this.name,
      thumbnailUrl: thumbnailUrl ?? this.thumbnailUrl,
      thumbnailFile: thumbnailFile ?? this.thumbnailFile,
      type: type ?? this.type,
      width: width ?? this.width,
    );
  }
}

/// `LMChatAttachmentViewDataBuilder` is a builder class that helps in building the `LMChatAttachmentViewData` object.
class LMChatAttachmentViewDataBuilder {
  int? _answerId;
  int? _createdAt;
  dynamic _dimensions;
  String? _fileUrl;
  String? _url;
  File? _attachmentFile;
  dynamic _height;
  int? _id;
  int? _index;
  dynamic _locationLat;
  dynamic _locationLong;
  dynamic _locationName;
  dynamic _meta;
  String? _name;
  String? _thumbnailUrl;
  File? _thumbnailFile;
  String? _type;
  dynamic _width;

  void answerId(int? answerId) {
    _answerId = answerId;
  }

  void createdAt(int? createdAt) {
    _createdAt = createdAt;
  }

  void dimensions(dynamic dimensions) {
    _dimensions = dimensions;
  }

  void fileUrl(String? fileUrl) {
    _fileUrl = fileUrl;
  }

  void url(String? url) {
    _url = url;
  }

  void attachmentFile(File? attachmentFile) {
    _attachmentFile = attachmentFile;
  }

  void height(dynamic height) {
    _height = height;
  }

  void id(int? id) {
    _id = id;
  }

  void index(int? index) {
    _index = index;
  }

  void locationLat(dynamic locationLat) {
    _locationLat = locationLat;
  }

  void locationLong(dynamic locationLong) {
    _locationLong = locationLong;
  }

  void locationName(dynamic locationName) {
    _locationName = locationName;
  }

  void meta(dynamic meta) {
    _meta = meta;
  }

  void name(String? name) {
    _name = name;
  }

  void thumbnailUrl(String? thumbnailUrl) {
    _thumbnailUrl = thumbnailUrl;
  }

  void thumbnailFile(File? thumbnailFile) {
    _thumbnailFile = thumbnailFile;
  }

  void type(String? type) {
    _type = type;
  }

  void width(dynamic width) {
    _width = width;
  }

  /// build method is used to create a new instance of `LMChatAttachmentViewData` with the provided values.
  LMChatAttachmentViewData build() {
    return LMChatAttachmentViewData._(
      answerId: _answerId,
      createdAt: _createdAt,
      dimensions: _dimensions,
      fileUrl: _fileUrl,
      url: _url,
      attachmentFile: _attachmentFile,
      height: _height,
      id: _id,
      index: _index,
      locationLat: _locationLat,
      locationLong: _locationLong,
      locationName: _locationName,
      meta: _meta,
      name: _name,
      thumbnailUrl: _thumbnailUrl,
      thumbnailFile: _thumbnailFile,
      type: _type,
      width: _width,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/chatroom/chatroom_view_data.dart
================================================
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';

/// `LMChatRoomViewData` is a model class that holds the data for the chat room view.
/// This class is used to display the chat room information in the chat screen.
class LMChatRoomViewData {
  /// [bool] access is used to check if the user has access to the chat room.
  final bool? access;

  /// [String] answerText is used to store the answer text.
  final String? answerText;

  /// [int] answersCount is used to store the count of answers.
  final int? answersCount;

  /// [int] attachmentCount is used to store the count of attachments.
  final int? attachmentCount;

  /// [List<LMChatAttachmentViewData>] attachments is used to store the attachments.
  final List<LMChatAttachmentViewData> attachments;

  /// [bool] attachmentsUploaded is used to check if the attachments are uploaded.
  final bool? attachmentsUploaded;

  /// [int] attendingCount is used to store the count of attendees.
  final int? attendingCount;

  /// [bool] attendingStatus is used to check if the user is attending the event.
  final bool? attendingStatus;

  /// The number of audio files in the chatroom.
  final int? audioCount;

  /// The list of audio files in the chatroom.
  final List<dynamic>? audios;

  /// Indicates if the auto follow action has been completed.
  final bool? autoFollowDone;

  /// The creation time of the chatroom card.
  final String? cardCreationTime;

  /// The ID of the community associated with the chatroom.
  final int? communityId;

  /// The name of the community associated with the chatroom.
  final String? communityName;

  /// The timestamp when the chatroom was created.
  final dynamic createdAt;

  /// The ID of the last conversation in the chatroom.
  final int? lastConversationId;

  /// The date of the chatroom.
  final String? date;

  /// The URL of the chatroom image.
  final String? chatroomImageUrl;

  /// The number of unseen messages in the chatroom.
  final int? unseenCount;

  /// The epoch time of the date.
  final int? dateEpoch;

  /// The timestamp of the date.
  final int? dateTime;

  /// The duration of the chatroom.
  final int? duration;

  /// Indicates the follow status of the chatroom.
  final bool? followStatus;

  /// Indicates if the chatroom has event recordings.
  final bool? hasEventRecording;

  /// The header of the chatroom.
  final String header;

  /// The ID of the chatroom.
  final int id;

  /// The number of image files in the chatroom.
  final int? imageCount;

  /// The list of image files in the chatroom.
  final List<dynamic>? images;

  /// Indicates if members will be included later in the chatroom.
  final bool? includeMembersLater;

  /// Indicates if the chatroom has been edited.
  final bool? isEdited;

  /// Indicates if the user is a guest in the chatroom.
  bool? isGuest;

  /// Indicates if the chatroom is paid.
  final bool? isPaid;

  /// Indicates if the chatroom is pending.
  final bool? isPending;

  /// Indicates if the chatroom is private.
  final bool? isPrivate;

  /// Indicates if the user is a private member of the chatroom.
  final bool? isPrivateMember;

  /// Indicates if the chatroom is secret.
  final bool? isSecret;

  /// Indicates if the chatroom is tagged.
  final bool? isTagged;

  /// Indicates if the chatroom is pinned.
  final bool? isPinned;

  /// The member associated with the chatroom.
  final LMChatUserViewData? member;

  /// The topic of the chatroom.
  final LMChatConversationViewData? topic;

  /// Indicates the mute status of the chatroom.
  final bool? muteStatus;

  /// The number of seconds before the online link is enabled.
  final int? onlineLinkEnableBefore;

  /// The type of online link.
  final dynamic onlineLinkType;

  /// The list of PDF files in the chatroom.
  final List<dynamic>? pdf;

  /// The number of PDF files in the chatroom.
  final int? pdfCount;

  /// The number of polls in the chatroom.
  final int? pollsCount;

  /// The list of reactions in the chatroom.
  final List<dynamic>? reactions;

  /// Indicates if the user has left the secret chatroom.
  final bool? secretChatroomLeft;

  /// The share link of the chatroom.
  final String? shareLink;

  /// The state of the chatroom.
  final int? state;

  /// The title of the chatroom.
  final String title;

  /// The type of the chatroom.
  final int? type;

  /// The number of video files in the chatroom.
  final int? videoCount;

  /// The list of video files in the chatroom.
  final List<dynamic>? videos;

  /// The number of participants in the chatroom.
  final int? participantCount;

  /// The total count of responses in the chatroom.
  final int? totalResponseCount;

  /// Indicates if the external user has seen the chatroom.
  final bool? externalSeen;

  /// Indicates if a member can send messages in the chatroom.
  final bool? memberCanMessage;

  /// The state of the chat request.
  final int? chatRequestState;

  /// The user who requested the chat.
  final LMChatUserViewData? chatRequestedBy;

  /// The ID of the user who requested the chat.
  final int? chatRequestedById;

  /// The user with whom the chatroom is created.
  final LMChatUserViewData? chatroomWithUser;

  /// The ID of the user with whom the chatroom is created.
  final int? chatroomWithUserId;

  /// The ID of the user.
  final int? userId;

  /// The list of members who responded last in the chatroom.
  final List<LMChatUserViewData>? lastResponseMembers;

  final LMChatConversationViewData? lastConversation;

  /// A custom tag for the chatroom.
  final String? customTag;

  LMChatRoomViewData._({
    required this.access,
    required this.answerText,
    required this.answersCount,
    required this.attachmentCount,
    required this.attachments,
    required this.attachmentsUploaded,
    required this.attendingCount,
    required this.attendingStatus,
    required this.audioCount,
    required this.audios,
    required this.autoFollowDone,
    required this.cardCreationTime,
    required this.communityId,
    required this.communityName,
    required this.createdAt,
    required this.lastConversationId,
    required this.date,
    required this.chatroomImageUrl,
    required this.unseenCount,
    required this.dateEpoch,
    required this.dateTime,
    required this.duration,
    required this.hasEventRecording,
    required this.header,
    required this.id,
    required this.imageCount,
    required this.images,
    required this.includeMembersLater,
    required this.isEdited,
    required this.isPaid,
    required this.isPending,
    required this.isPrivate,
    required this.isPrivateMember,
    required this.isSecret,
    required this.isTagged,
    required this.isPinned,
    required this.member,
    required this.topic,
    required this.muteStatus,
    required this.onlineLinkEnableBefore,
    required this.onlineLinkType,
    required this.pdf,
    required this.pdfCount,
    required this.pollsCount,
    required this.reactions,
    required this.secretChatroomLeft,
    required this.shareLink,
    required this.state,
    required this.title,
    required this.type,
    required this.videoCount,
    required this.videos,
    required this.participantCount,
    required this.totalResponseCount,
    required this.memberCanMessage,
    required this.chatRequestState,
    required this.chatRequestedBy,
    required this.chatRequestedById,
    required this.chatroomWithUser,
    required this.chatroomWithUserId,
    required this.userId,
    required this.lastResponseMembers,
    required this.externalSeen,
    required this.isGuest,
    required this.followStatus,
    required this.lastConversation,
    required this.customTag,
  });

  /// copyWith method is used to create a new instance of `LMChatRoomViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatRoomViewData copyWith({
    bool? access,
    String? answerText,
    int? answersCount,
    int? attachmentCount,
    List<LMChatAttachmentViewData>? attachments,
    bool? attachmentsUploaded,
    int? attendingCount,
    bool? attendingStatus,
    int? audioCount,
    List<dynamic>? audios,
    bool? autoFollowDone,
    String? cardCreationTime,
    int? communityId,
    String? communityName,
    dynamic createdAt,
    int? lastConversationId,
    String? date,
    String? chatroomImageUrl,
    int? unseenCount,
    int? dateEpoch,
    int? dateTime,
    int? duration,
    bool? followStatus,
    bool? hasEventRecording,
    String? header,
    int? id,
    int? imageCount,
    List<dynamic>? images,
    bool? includeMembersLater,
    bool? isEdited,
    bool? isGuest,
    bool? isPaid,
    bool? isPending,
    bool? isPrivate,
    bool? isPrivateMember,
    bool? isSecret,
    bool? isTagged,
    bool? isPinned,
    LMChatUserViewData? member,
    LMChatConversationViewData? topic,
    bool? muteStatus,
    int? onlineLinkEnableBefore,
    dynamic onlineLinkType,
    List<dynamic>? pdf,
    int? pdfCount,
    int? pollsCount,
    List<dynamic>? reactions,
    bool? secretChatroomLeft,
    String? shareLink,
    int? state,
    String? title,
    int? type,
    int? videoCount,
    List<dynamic>? videos,
    int? participantCount,
    int? totalResponseCount,
    bool? externalSeen,
    bool? memberCanMessage,
    int? chatRequestState,
    LMChatUserViewData? chatRequestedBy,
    int? chatRequestedById,
    LMChatUserViewData? chatroomWithUser,
    int? chatroomWithUserId,
    int? userId,
    List<LMChatUserViewData>? lastResponseMembers,
    LMChatConversationViewData? lastConversation,
    String? customTag,
  }) {
    return LMChatRoomViewData._(
      followStatus: followStatus ?? this.followStatus,
      access: access ?? this.access,
      answerText: answerText ?? this.answerText,
      answersCount: answersCount ?? this.answersCount,
      attachmentCount: attachmentCount ?? this.attachmentCount,
      attachments: attachments ?? this.attachments,
      attachmentsUploaded: attachmentsUploaded ?? this.attachmentsUploaded,
      attendingCount: attendingCount ?? this.attendingCount,
      attendingStatus: attendingStatus ?? this.attendingStatus,
      audioCount: audioCount ?? this.audioCount,
      audios: audios ?? this.audios,
      autoFollowDone: autoFollowDone ?? this.autoFollowDone,
      cardCreationTime: cardCreationTime ?? this.cardCreationTime,
      communityId: communityId ?? this.communityId,
      communityName: communityName ?? this.communityName,
      createdAt: createdAt ?? this.createdAt,
      lastConversationId: lastConversationId ?? this.lastConversationId,
      date: date ?? this.date,
      chatroomImageUrl: chatroomImageUrl ?? this.chatroomImageUrl,
      unseenCount: unseenCount ?? this.unseenCount,
      dateEpoch: dateEpoch ?? this.dateEpoch,
      dateTime: dateTime ?? this.dateTime,
      duration: duration ?? this.duration,
      hasEventRecording: hasEventRecording ?? this.hasEventRecording,
      header: header ?? this.header,
      id: id ?? this.id,
      imageCount: imageCount ?? this.imageCount,
      images: images ?? this.images,
      includeMembersLater: includeMembersLater ?? this.includeMembersLater,
      isEdited: isEdited ?? this.isEdited,
      isGuest: isGuest ?? this.isGuest,
      isPaid: isPaid ?? this.isPaid,
      isPending: isPending ?? this.isPending,
      isPrivate: isPrivate ?? this.isPrivate,
      isPrivateMember: isPrivateMember ?? this.isPrivateMember,
      isSecret: isSecret ?? this.isSecret,
      isTagged: isTagged ?? this.isTagged,
      isPinned: isPinned ?? this.isPinned,
      member: member ?? this.member,
      topic: topic ?? this.topic,
      muteStatus: muteStatus ?? this.muteStatus,
      onlineLinkEnableBefore:
          onlineLinkEnableBefore ?? this.onlineLinkEnableBefore,
      onlineLinkType: onlineLinkType ?? this.onlineLinkType,
      pdf: pdf ?? this.pdf,
      pdfCount: pdfCount ?? this.pdfCount,
      pollsCount: pollsCount ?? this.pollsCount,
      reactions: reactions ?? this.reactions,
      secretChatroomLeft: secretChatroomLeft ?? this.secretChatroomLeft,
      shareLink: shareLink ?? this.shareLink,
      state: state ?? this.state,
      title: title ?? this.title,
      type: type ?? this.type,
      videoCount: videoCount ?? this.videoCount,
      videos: videos ?? this.videos,
      participantCount: participantCount ?? this.participantCount,
      totalResponseCount: totalResponseCount ?? this.totalResponseCount,
      externalSeen: externalSeen ?? this.externalSeen,
      memberCanMessage: memberCanMessage ?? this.memberCanMessage,
      chatRequestState: chatRequestState ?? this.chatRequestState,
      chatRequestedBy: chatRequestedBy ?? this.chatRequestedBy,
      chatRequestedById: chatRequestedById ?? this.chatRequestedById,
      chatroomWithUser: chatroomWithUser ?? this.chatroomWithUser,
      chatroomWithUserId: chatroomWithUserId ?? this.chatroomWithUserId,
      userId: userId ?? this.userId,
      lastResponseMembers: lastResponseMembers ?? this.lastResponseMembers,
      lastConversation: lastConversation ?? this.lastConversation,
      customTag: customTag ?? this.customTag,
    );
  }
}

/// `LMChatRoomViewDataBuilder` is a builder class that is used to create an instance of `LMChatRoomViewData`.
/// This class is used to create an instance of `LMChatRoomViewData` with the provided values.
class LMChatRoomViewDataBuilder {
  bool? _access;
  String? _answerText;
  int? _answersCount;
  int? _attachmentCount;
  List<LMChatAttachmentViewData> _attachments = [];
  bool? _attachmentsUploaded;
  int? _attendingCount;
  bool? _attendingStatus;
  int? _audioCount;
  List<dynamic>? _audios;
  bool? _autoFollowDone;
  String? _cardCreationTime;
  int? _communityId;
  String? _communityName;
  dynamic _createdAt;
  int? _lastConversationId;
  String? _date;
  String? _chatroomImageUrl;
  int? _unseenCount;
  int? _dateEpoch;
  int? _dateTime;
  int? _duration;
  bool? _followStatus;
  bool? _hasEventRecording;
  String _header = '';
  int _id = 0;
  int? _imageCount;
  List<dynamic>? _images;
  bool? _includeMembersLater;
  bool? _isEdited;
  bool? _isGuest;
  bool? _isPaid;
  bool? _isPending;
  bool? _isPrivate;
  bool? _isPrivateMember;
  bool? _isSecret;
  bool? _isTagged;
  bool? _isPinned;
  LMChatUserViewData? _member;
  LMChatConversationViewData? _topic;
  bool? _muteStatus;
  int? _onlineLinkEnableBefore;
  dynamic _onlineLinkType;
  List<dynamic>? _pdf;
  int? _pdfCount;
  int? _pollsCount;
  List<dynamic>? _reactions;
  bool? _secretChatroomLeft;
  String? _shareLink;
  int? _state;
  String _title = '';
  int? _type;
  int? _videoCount;
  List<dynamic>? _videos;
  int? _participantCount;
  int? _totalResponseCount;
  bool? _externalSeen;
  bool? _memberCanMessage;
  int? _chatRequestState;
  LMChatUserViewData? _chatRequestedBy;
  int? _chatRequestedById;
  LMChatUserViewData? _chatroomWithUser;
  int? _chatroomWithUserId;
  int? _userId;
  List<LMChatUserViewData>? _lastResponseMembers;
  LMChatConversationViewData? _lastConversation;
  String? _customTag;

  /// Sets the access status of the chatroom.
  void access(bool? access) {
    _access = access;
  }

  /// Sets the answer text of the chatroom.
  void answerText(String? answerText) {
    _answerText = answerText;
  }

  /// Sets the count of answers in the chatroom.
  void answersCount(int? answersCount) {
    _answersCount = answersCount;
  }

  /// Sets the count of attachments in the chatroom.
  void attachmentCount(int? attachmentCount) {
    _attachmentCount = attachmentCount;
  }

  /// Sets the attachments of the chatroom.
  void attachment(List<LMChatAttachmentViewData> attachment) {
    _attachments = attachment;
  }

  /// Sets the status of attachments uploaded in the chatroom.
  void attachmentsUploaded(bool? attachmentsUploaded) {
    _attachmentsUploaded = attachmentsUploaded;
  }

  /// Sets the count of attendees in the chatroom.
  void attendingCount(int? attendingCount) {
    _attendingCount = attendingCount;
  }

  /// Sets the attending status of the chatroom.
  void attendingStatus(bool? attendingStatus) {
    _attendingStatus = attendingStatus;
  }

  /// Sets the count of audio files in the chatroom.
  void audioCount(int? audioCount) {
    _audioCount = audioCount;
  }

  /// Sets the audio files of the chatroom.
  void audio(List<dynamic>? audio) {
    _audios = audio;
  }

  /// Sets the status of auto follow done in the chatroom.
  void autoFollowDone(bool? autoFollowDone) {
    _autoFollowDone = autoFollowDone;
  }

  /// Sets the creation time of the chatroom card.
  void cardCreationTime(String? cardCreationTime) {
    _cardCreationTime = cardCreationTime;
  }

  /// Sets the ID of the community associated with the chatroom.
  void communityId(int? communityId) {
    _communityId = communityId;
  }

  /// Sets the name of the community associated with the chatroom.
  void communityName(String? communityName) {
    _communityName = communityName;
  }

  /// Sets the creation date of the chatroom.
  void createdAt(dynamic createdAt) {
    _createdAt = createdAt;
  }

  /// Sets the ID of the last conversation in the chatroom.
  void lastConversationId(int? lastConversationId) {
    _lastConversationId = lastConversationId;
  }

  /// Sets the date of the chatroom.
  void date(String? date) {
    _date = date;
  }

  /// Sets the image URL of the chatroom.
  void chatroomImageUrl(String? chatroomImageUrl) {
    _chatroomImageUrl = chatroomImageUrl;
  }

  /// Sets the count of unseen messages in the chatroom.
  void unseenCount(int? unseenCount) {
    _unseenCount = unseenCount;
  }

  /// Sets the epoch date of the chatroom.
  void dateEpoch(int? dateEpoch) {
    _dateEpoch = dateEpoch;
  }

  /// Sets the date and time of the chatroom.
  void dateTime(int? dateTime) {
    _dateTime = dateTime;
  }

  /// Sets the duration of the chatroom.
  void duration(int? duration) {
    _duration = duration;
  }

  /// Sets the follow status of the chatroom.
  void followStatus(bool? followStatus) {
    _followStatus = followStatus;
  }

  /// Sets the status of event recording in the chatroom.
  void hasEventRecording(bool? hasEventRecording) {
    _hasEventRecording = hasEventRecording;
  }

  /// Sets the header of the chatroom.
  void header(String header) {
    _header = header;
  }

  /// Sets the ID of the chatroom.
  void id(int id) {
    _id = id;
  }

  /// Sets the count of images in the chatroom.
  void imageCount(int? imageCount) {
    _imageCount = imageCount;
  }

  /// Sets the images of the chatroom.
  void image(List<dynamic>? images) {
    _images = images;
  }

  /// Sets the status of including members later in the chatroom.
  void includeMembersLater(bool? includeMembersLater) {
    _includeMembersLater = includeMembersLater;
  }

  /// Sets the edited status of the chatroom.
  void isEdited(bool? isEdited) {
    _isEdited = isEdited;
  }

  /// Sets the guest status of the chatroom.
  void isGuest(bool? isGuest) {
    _isGuest = isGuest;
  }

  /// Sets the paid status of the chatroom.
  void isPaid(bool? isPaid) {
    _isPaid = isPaid;
  }

  /// Sets the pending status of the chatroom.
  void isPending(bool? isPending) {
    _isPending = isPending;
  }

  /// Sets the private status of the chatroom.
  void isPrivate(bool? isPrivate) {
    _isPrivate = isPrivate;
  }

  /// Sets the private member status of the chatroom.
  void isPrivateMember(bool? isPrivateMember) {
    _isPrivateMember = isPrivateMember;
  }

  /// Sets the secret status of the chatroom.
  void isSecret(bool? isSecret) {
    _isSecret = isSecret;
  }

  /// Sets the tagged status of the chatroom.
  void isTagged(bool? isTagged) {
    _isTagged = isTagged;
  }

  /// Sets the pinned status of the chatroom.
  void isPinned(bool? isPinned) {
    _isPinned = isPinned;
  }

  /// Sets the member of the chatroom.
  void member(LMChatUserViewData? member) {
    _member = member;
  }

  /// Sets the topic of the chatroom.
  void topic(LMChatConversationViewData? topic) {
    _topic = topic;
  }

  /// Sets the mute status of the chatroom.
  void muteStatus(bool? muteStatus) {
    _muteStatus = muteStatus;
  }

  /// Sets the time before online link enable in the chatroom.
  void onlineLinkEnableBefore(int? onlineLinkEnableBefore) {
    _onlineLinkEnableBefore = onlineLinkEnableBefore;
  }

  /// Sets the type of online link in the chatroom.
  void onlineLinkType(dynamic onlineLinkType) {
    _onlineLinkType = onlineLinkType;
  }

  /// Sets the PDF files of the chatroom.
  void pdf(List<dynamic> pdf) {
    _pdf = pdf;
  }

  /// Sets the count of PDF files in the chatroom.
  void pdfCount(int? pdfCount) {
    _pdfCount = pdfCount;
  }

  /// Sets the count of polls in the chatroom.
  void pollsCount(int? pollsCount) {
    _pollsCount = pollsCount;
  }

  /// Sets the reactions in the chatroom.
  void veaction(List<dynamic>? reactions) {
    _reactions = reactions;
  }

  /// Sets the status of leaving a secret chatroom.
  void secretChatroomLeft(bool? secretChatroomLeft) {
    _secretChatroomLeft = secretChatroomLeft;
  }

  /// Sets the share link of the chatroom.
  void shareLink(String? shareLink) {
    _shareLink = shareLink;
  }

  /// Sets the state of the chatroom.
  void state(int? state) {
    _state = state;
  }

  /// Sets the title of the chatroom.
  void title(String title) {
    _title = title;
  }

  /// Sets the type of the chatroom.
  void type(int? type) {
    _type = type;
  }

  /// Sets the count of videos in the chatroom.
  void videoCount(int? videoCount) {
    _videoCount = videoCount;
  }

  /// Sets the videos of the chatroom.
  void video(List<dynamic>? videos) {
    _videos = videos;
  }

  /// Sets the count of participants in the chatroom.
  void participantCount(int? participantCount) {
    _participantCount = participantCount;
  }

  /// Sets the total count of responses in the chatroom.
  void totalResponseCount(int? totalResponseCount) {
    _totalResponseCount = totalResponseCount;
  }

  /// Sets the external seen status of the chatroom.
  void externalSeen(bool? externalSeen) {
    _externalSeen = externalSeen;
  }

  /// Sets the member can message status of the chatroom.
  void memberCanMessage(bool? memberCanMessage) {
    _memberCanMessage = memberCanMessage;
  }

  /// Sets the state of the chat request in the chatroom.
  void chatRequestState(int? chatRequestState) {
    _chatRequestState = chatRequestState;
  }

  /// Sets the user who requested the chat in the chatroom.
  void chatRequestedBy(LMChatUserViewData? chatRequestedBy) {
    _chatRequestedBy = chatRequestedBy;
  }

  /// Sets the ID of the user who requested the chat in the chatroom.
  void chatRequestedById(int? chatRequestedById) {
    _chatRequestedById = chatRequestedById;
  }

  /// Sets the user with whom the chatroom is associated.
  void chatroomWithUser(LMChatUserViewData? chatroomWithUser) {
    _chatroomWithUser = chatroomWithUser;
  }

  /// Sets the ID of the user with whom the chatroom is associated.
  void chatroomWithUserId(int? chatroomWithUserId) {
    _chatroomWithUserId = chatroomWithUserId;
  }

  /// Sets the ID of the user in the chatroom.
  void userId(int? userId) {
    _userId = userId;
  }

  /// Sets the last response members in the chatroom.
  void lastResponseMember(List<LMChatUserViewData>? members) {
    _lastResponseMembers = members;
  }

  /// Sets the last conversation in the chatroom.
  void lastConversation(LMChatConversationViewData? lastConversation) {
    _lastConversation = lastConversation;
  }

  /// Sets a custom tag for the chatroom.
  void customTag(String? customTag) {
    _customTag = customTag;
  }

  LMChatRoomViewData build() {
    return LMChatRoomViewData._(
      access: _access,
      answerText: _answerText,
      answersCount: _answersCount,
      attachmentCount: _attachmentCount,
      attachments: _attachments,
      attachmentsUploaded: _attachmentsUploaded,
      attendingCount: _attendingCount,
      attendingStatus: _attendingStatus,
      audioCount: _audioCount,
      audios: _audios,
      autoFollowDone: _autoFollowDone,
      cardCreationTime: _cardCreationTime,
      communityId: _communityId,
      communityName: _communityName,
      createdAt: _createdAt,
      lastConversationId: _lastConversationId,
      date: _date,
      chatroomImageUrl: _chatroomImageUrl,
      unseenCount: _unseenCount,
      dateEpoch: _dateEpoch,
      dateTime: _dateTime,
      duration: _duration,
      hasEventRecording: _hasEventRecording,
      header: _header,
      id: _id,
      imageCount: _imageCount,
      images: _images,
      includeMembersLater: _includeMembersLater,
      isEdited: _isEdited,
      isPaid: _isPaid,
      isPending: _isPending,
      isPrivate: _isPrivate,
      isPrivateMember: _isPrivateMember,
      isSecret: _isSecret,
      isTagged: _isTagged,
      isPinned: _isPinned,
      member: _member,
      topic: _topic,
      muteStatus: _muteStatus,
      onlineLinkEnableBefore: _onlineLinkEnableBefore,
      onlineLinkType: _onlineLinkType,
      pdf: _pdf,
      pdfCount: _pdfCount,
      pollsCount: _pollsCount,
      reactions: _reactions,
      secretChatroomLeft: _secretChatroomLeft,
      shareLink: _shareLink,
      state: _state,
      title: _title,
      type: _type,
      videoCount: _videoCount,
      videos: _videos,
      participantCount: _participantCount,
      totalResponseCount: _totalResponseCount,
      memberCanMessage: _memberCanMessage,
      chatRequestState: _chatRequestState,
      chatRequestedBy: _chatRequestedBy,
      chatRequestedById: _chatRequestedById,
      chatroomWithUser: _chatroomWithUser,
      chatroomWithUserId: _chatroomWithUserId,
      userId: _userId,
      lastResponseMembers: _lastResponseMembers,
      externalSeen: _externalSeen,
      isGuest: _isGuest,
      followStatus: _followStatus,
      lastConversation: _lastConversation,
      customTag: _customTag,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/conversation/conversation_view_data.dart
================================================
// ignore_for_file: public_member_api_docs, sort_constructors_first
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';

/// `LMChatConversationViewData` is a model class that holds the data for the conversation view.
/// This class is used to display the conversation information in the chat screen.
class LMChatConversationViewData {
  final bool? allowAddOption;
  final String answer;
  final int? apiVersion;
  final int? attachmentCount;
  final List<LMChatAttachmentViewData>? attachments;
  final bool? attachmentsUploaded;
  final int? chatroomId;
  final int? communityId;
  final String createdAt;
  final int? createdEpoch;
  final String? date;
  final int? deletedByUserId;
  final String? deviceId;
  final int? endTime;
  final int? expiryTime;
  final bool? hasFiles;
  final bool? hasReactions;
  final String? header;
  final int id;
  final String? internalLink;
  final bool? isAnonymous;
  final bool? isEdited;
  final int? lastUpdated;
  final String? location;
  final String? locationLat;
  final String? locationLong;
  final int? multipleSelectNo;
  final LMChatPollMultiSelectState? multipleSelectState;
  final LMChatOGTagsViewData? ogTags;
  final int? onlineLinkEnableBefore;
  final String? pollAnswerText;
  final LMChatPollType? pollType;
  final int? replyChatroomId;
  final int? replyId;
  final int? startTime;
  final int? state;
  final String? temporaryId;
  final int? memberId;
  final bool? toShowResults;
  final String? pollTypeText;
  final String? submitTypeText;
  final bool? isTimeStamp;
  final LMChatUserViewData? member;
  final int? replyConversation;
  final LMChatConversationViewData? replyConversationObject;
  final List<LMChatReactionViewData>? conversationReactions;
  final List<LMChatPollOptionViewData>? poll;
  final bool? isPollSubmitted;
  LMChatConversationViewType? conversationViewType;
  final bool? noPollExpiry;
  final bool? allowVoteChange;
  final String? widgetId;
  final LMChatWidgetViewData? widget;

  LMChatConversationViewData._({
    this.allowAddOption,
    required this.answer,
    this.apiVersion,
    this.attachmentCount,
    this.attachments,
    this.attachmentsUploaded,
    this.chatroomId,
    this.communityId,
    required this.createdAt,
    this.createdEpoch,
    this.date,
    this.deletedByUserId,
    this.deviceId,
    this.endTime,
    this.expiryTime,
    this.hasFiles,
    this.hasReactions,
    this.header,
    required this.id,
    this.internalLink,
    this.isAnonymous,
    this.isEdited,
    this.lastUpdated,
    this.location,
    this.locationLat,
    this.locationLong,
    this.multipleSelectNo,
    this.multipleSelectState,
    required this.ogTags,
    this.onlineLinkEnableBefore,
    this.pollAnswerText,
    this.pollType,
    this.replyChatroomId,
    this.replyId,
    this.startTime,
    this.state,
    this.temporaryId,
    this.memberId,
    this.toShowResults,
    this.pollTypeText,
    this.submitTypeText,
    this.isTimeStamp,
    this.member,
    this.replyConversation,
    this.replyConversationObject,
    this.conversationReactions,
    this.poll,
    this.isPollSubmitted,
    this.conversationViewType,
    this.noPollExpiry,
    this.allowVoteChange,
    this.widgetId,
    this.widget,
  });

  /// copyWith method is used to create a new instance of `LMChatConversationViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatConversationViewData copyWith({
    bool? allowAddOption,
    String? answer,
    int? apiVersion,
    int? attachmentCount,
    List<LMChatAttachmentViewData>? attachments,
    bool? attachmentsUploaded,
    int? chatroomId,
    int? communityId,
    String? createdAt,
    int? createdEpoch,
    String? date,
    int? deletedByUserId,
    String? deviceId,
    int? endTime,
    int? expiryTime,
    bool? hasFiles,
    bool? hasReactions,
    String? header,
    int? id,
    String? internalLink,
    bool? isAnonymous,
    bool? isEdited,
    int? lastUpdated,
    String? location,
    String? locationLat,
    String? locationLong,
    int? multipleSelectNo,
    LMChatPollMultiSelectState? multipleSelectState,
    dynamic ogTags,
    int? onlineLinkEnableBefore,
    String? pollAnswerText,
    LMChatPollType? pollType,
    int? replyChatroomId,
    int? replyId,
    int? startTime,
    int? state,
    String? temporaryId,
    int? memberId,
    bool? toShowResults,
    String? pollTypeText,
    String? submitTypeText,
    bool? isTimeStamp,
    LMChatUserViewData? member,
    int? replyConversation,
    LMChatConversationViewData? replyConversationObject,
    List<LMChatReactionViewData>? conversationReactions,
    List<LMChatPollOptionViewData>? poll,
    bool? isPollSubmitted,
    LMChatConversationViewType? conversationViewType,
    bool? noPollExpiry,
    bool? allowVoteChange,
    String? widgetId,
    LMChatWidgetViewData? widget,
  }) {
    return LMChatConversationViewData._(
      allowAddOption: allowAddOption ?? this.allowAddOption,
      answer: answer ?? this.answer,
      apiVersion: apiVersion ?? this.apiVersion,
      attachmentCount: attachmentCount ?? this.attachmentCount,
      attachments: attachments ?? this.attachments,
      attachmentsUploaded: attachmentsUploaded ?? this.attachmentsUploaded,
      chatroomId: chatroomId ?? this.chatroomId,
      communityId: communityId ?? this.communityId,
      createdAt: createdAt ?? this.createdAt,
      createdEpoch: createdEpoch ?? this.createdEpoch,
      date: date ?? this.date,
      deletedByUserId: deletedByUserId ?? this.deletedByUserId,
      deviceId: deviceId ?? this.deviceId,
      endTime: endTime ?? this.endTime,
      expiryTime: expiryTime ?? this.expiryTime,
      hasFiles: hasFiles ?? this.hasFiles,
      hasReactions: hasReactions ?? this.hasReactions,
      header: header ?? this.header,
      id: id ?? this.id,
      internalLink: internalLink ?? this.internalLink,
      isAnonymous: isAnonymous ?? this.isAnonymous,
      isEdited: isEdited ?? this.isEdited,
      lastUpdated: lastUpdated ?? this.lastUpdated,
      location: location ?? this.location,
      locationLat: locationLat ?? this.locationLat,
      locationLong: locationLong ?? this.locationLong,
      multipleSelectNo: multipleSelectNo ?? this.multipleSelectNo,
      multipleSelectState: multipleSelectState ?? this.multipleSelectState,
      ogTags: ogTags ?? this.ogTags,
      onlineLinkEnableBefore:
          onlineLinkEnableBefore ?? this.onlineLinkEnableBefore,
      pollAnswerText: pollAnswerText ?? this.pollAnswerText,
      pollType: pollType ?? this.pollType,
      replyChatroomId: replyChatroomId ?? this.replyChatroomId,
      replyId: replyId ?? this.replyId,
      startTime: startTime ?? this.startTime,
      state: state ?? this.state,
      temporaryId: temporaryId ?? this.temporaryId,
      memberId: memberId ?? this.memberId,
      toShowResults: toShowResults ?? this.toShowResults,
      pollTypeText: pollTypeText ?? this.pollTypeText,
      submitTypeText: submitTypeText ?? this.submitTypeText,
      isTimeStamp: isTimeStamp ?? this.isTimeStamp,
      member: member ?? this.member,
      replyConversation: replyConversation ?? this.replyConversation,
      replyConversationObject:
          replyConversationObject ?? this.replyConversationObject,
      conversationReactions:
          conversationReactions ?? this.conversationReactions,
      poll: poll ?? this.poll,
      isPollSubmitted: isPollSubmitted ?? this.isPollSubmitted,
      conversationViewType: conversationViewType ?? this.conversationViewType,
      noPollExpiry: noPollExpiry ?? this.noPollExpiry,
      allowVoteChange: allowVoteChange ?? this.allowVoteChange,
      widgetId: widgetId ?? this.widgetId,
      widget: widget ?? this.widget,
    );
  }
}

/// `LMChatConversationViewDataBuilder` is a builder class used to create an instance of `LMChatConversationViewData`.
/// This class is used to create an instance of `LMChatConversationViewData` with the provided values.
class LMChatConversationViewDataBuilder {
  bool? _allowAddOption;
  String? _answer;
  int? _apiVersion;
  int? _attachmentCount;
  List<LMChatAttachmentViewData>? _attachments;
  bool? _attachmentsUploaded;
  int? _chatroomId;
  int? _communityId;
  String? _createdAt;
  int? _createdEpoch;
  String? _date;
  int? _deletedByUserId;
  String? _deviceId;
  int? _endTime;
  int? _expiryTime;
  bool? _hasFiles;
  bool? _hasReactions;
  String? _header;
  int? _id;
  String? _internalLink;
  bool? _isAnonymous;
  bool? _isEdited;
  int? _lastUpdated;
  String? _location;
  String? _locationLat;
  String? _locationLong;
  int? _multipleSelectNo;
  LMChatPollMultiSelectState? _multipleSelectState;
  LMChatOGTagsViewData? _ogTags;
  int? _onlineLinkEnableBefore;
  String? _pollAnswerText;
  LMChatPollType? _pollType;
  int? _replyChatroomId;
  int? _replyId;
  int? _startTime;
  int? _state;
  String? _temporaryId;
  int? _memberId;
  bool? _toShowResults;
  String? _pollTypeText;
  String? _submitTypeText;
  bool? _isTimeStamp;
  LMChatUserViewData? _member;
  int? _replyConversation;
  LMChatConversationViewData? _replyConversationObject;
  List<LMChatReactionViewData>? _conversationReactions;
  List<LMChatPollOptionViewData>? _poll;
  bool? _isPollSubmitted;
  LMChatConversationViewType? _conversationViewType;
  bool? _noPollExpiry;
  bool? _allowVoteChange;
  String? _widgetId;
  LMChatWidgetViewData? _widget;

  void widgetId(String? widgetId) {
    _widgetId = widgetId;
  }

  void widget(LMChatWidgetViewData? widget) {
    _widget = widget;
  }

  void allowAddOption(bool? allowAddOption) {
    _allowAddOption = allowAddOption;
  }

  void answer(String answer) {
    _answer = answer;
  }

  void apiVersion(int? apiVersion) {
    _apiVersion = apiVersion;
  }

  void attachmentCount(int? attachmentCount) {
    _attachmentCount = attachmentCount;
  }

  void attachments(List<LMChatAttachmentViewData>? attachments) {
    _attachments = attachments;
  }

  void attachmentsUploaded(bool? attachmentsUploaded) {
    _attachmentsUploaded = attachmentsUploaded;
  }

  void chatroomId(int? chatroomId) {
    _chatroomId = chatroomId;
  }

  void communityId(int? communityId) {
    _communityId = communityId;
  }

  void createdAt(String? createdAt) {
    _createdAt = createdAt;
  }

  void createdEpoch(int? createdEpoch) {
    _createdEpoch = createdEpoch;
  }

  void date(String? date) {
    _date = date;
  }

  void deletedByUserId(int? deletedByUserId) {
    _deletedByUserId = deletedByUserId;
  }

  void deviceId(String? deviceId) {
    _deviceId = deviceId;
  }

  void endTime(int? endTime) {
    _endTime = endTime;
  }

  void expiryTime(int? expiryTime) {
    _expiryTime = expiryTime;
  }

  void hasFiles(bool? hasFiles) {
    _hasFiles = hasFiles;
  }

  void hasReactions(bool? hasReactions) {
    _hasReactions = hasReactions;
  }

  void header(String? header) {
    _header = header;
  }

  void id(int? id) {
    _id = id;
  }

  void internalLink(String? internalLink) {
    _internalLink = internalLink;
  }

  void isAnonymous(bool? isAnonymous) {
    _isAnonymous = isAnonymous;
  }

  void isEdited(bool? isEdited) {
    _isEdited = isEdited;
  }

  void lastUpdated(int? lastUpdated) {
    _lastUpdated = lastUpdated;
  }

  void location(String? location) {
    _location = location;
  }

  void locationLat(String? locationLat) {
    _locationLat = locationLat;
  }

  void locationLong(String? locationLong) {
    _locationLong = locationLong;
  }

  void multipleSelectNo(int? multipleSelectNo) {
    _multipleSelectNo = multipleSelectNo;
  }

  void multipleSelectState(LMChatPollMultiSelectState? multipleSelectState) {
    _multipleSelectState = multipleSelectState;
  }

  void ogTags(LMChatOGTagsViewData? ogTags) {
    _ogTags = ogTags;
  }

  void onlineLinkEnableBefore(int? onlineLinkEnableBefore) {
    _onlineLinkEnableBefore = onlineLinkEnableBefore;
  }

  void pollAnswerText(String? pollAnswerText) {
    _pollAnswerText = pollAnswerText;
  }

  void pollType(LMChatPollType? pollType) {
    _pollType = pollType;
  }

  void replyChatroomId(int? replyChatroomId) {
    _replyChatroomId = replyChatroomId;
  }

  void replyId(int? replyId) {
    _replyId = replyId;
  }

  void startTime(int? startTime) {
    _startTime = startTime;
  }

  void state(int? state) {
    _state = state;
  }

  void temporaryId(String? temporaryId) {
    _temporaryId = temporaryId;
  }

  void memberId(int? memberId) {
    _memberId = memberId;
  }

  void toShowResults(bool? toShowResults) {
    _toShowResults = toShowResults;
  }

  void pollTypeText(String? pollTypeText) {
    _pollTypeText = pollTypeText;
  }

  void submitTypeText(String? submitTypeText) {
    _submitTypeText = submitTypeText;
  }

  void isTimeStamp(bool? isTimeStamp) {
    _isTimeStamp = isTimeStamp;
  }

  void member(LMChatUserViewData? member) {
    _member = member;
  }

  void replyConversation(int? replyConversation) {
    _replyConversation = replyConversation;
  }

  void replyConversationObject(
      LMChatConversationViewData? replyConversationObject) {
    _replyConversationObject = replyConversationObject;
  }

  void conversationReactions(
      List<LMChatReactionViewData>? conversationReactions) {
    _conversationReactions = conversationReactions;
  }

  void poll(List<LMChatPollOptionViewData>? poll) {
    _poll = poll;
  }

  void isPollSubmitted(bool? isPollSubmitted) {
    _isPollSubmitted = isPollSubmitted;
  }

  void conversationViewType(LMChatConversationViewType? conversationViewType) {
    _conversationViewType = conversationViewType;
  }

  void noPollExpiry(bool? noPollExpiry) {
    _noPollExpiry = noPollExpiry;
  }

  void allowVoteChange(bool? allowVoteChange) {
    _allowVoteChange = allowVoteChange;
  }

  /// Builds the `LMChatConversationViewData` object using the provided values.
  LMChatConversationViewData build() {
    return LMChatConversationViewData._(
      allowAddOption: _allowAddOption,
      answer: _answer!,
      apiVersion: _apiVersion,
      attachmentCount: _attachmentCount,
      attachments: _attachments,
      attachmentsUploaded: _attachmentsUploaded,
      chatroomId: _chatroomId,
      communityId: _communityId,
      createdAt: _createdAt!,
      createdEpoch: _createdEpoch,
      date: _date,
      deletedByUserId: _deletedByUserId,
      deviceId: _deviceId,
      endTime: _endTime,
      expiryTime: _expiryTime,
      hasFiles: _hasFiles,
      hasReactions: _hasReactions,
      header: _header,
      id: _id!,
      internalLink: _internalLink,
      isAnonymous: _isAnonymous,
      isEdited: _isEdited,
      lastUpdated: _lastUpdated,
      location: _location,
      locationLat: _locationLat,
      locationLong: _locationLong,
      multipleSelectNo: _multipleSelectNo,
      multipleSelectState: _multipleSelectState,
      ogTags: _ogTags,
      onlineLinkEnableBefore: _onlineLinkEnableBefore,
      pollAnswerText: _pollAnswerText,
      pollType: _pollType,
      replyChatroomId: _replyChatroomId,
      replyId: _replyId,
      startTime: _startTime,
      state: _state,
      temporaryId: _temporaryId,
      memberId: _memberId,
      toShowResults: _toShowResults,
      pollTypeText: _pollTypeText,
      submitTypeText: _submitTypeText,
      isTimeStamp: _isTimeStamp,
      member: _member,
      replyConversation: _replyConversation,
      replyConversationObject: _replyConversationObject,
      conversationReactions: _conversationReactions,
      poll: _poll,
      isPollSubmitted: _isPollSubmitted,
      conversationViewType: _conversationViewType,
      noPollExpiry: _noPollExpiry,
      allowVoteChange: _allowVoteChange,
      widgetId: _widgetId,
      widget: _widget,
    );
  }
}

enum LMChatConversationViewType { top, bottom }



================================================
File: lib/packages/ui/lib/src/models/conversation/reaction_view_data.dart
================================================
/// `LMChatReactionViewData` is a model class that contains the data required to render a reaction in the chat.
/// This class is used to display the reactions in the chat screen.
class LMChatReactionViewData {
  int? chatroomId;
  int conversationId;
  int? reactionId;
  int userId;
  String reaction;

  LMChatReactionViewData._({
    required this.chatroomId,
    required this.conversationId,
    required this.reactionId,
    required this.userId,
    required this.reaction,
  });

  /// copyWith method is used to create a new instance of `LMChatReactionViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatReactionViewData copyWith({
    int? chatroomId,
    int? conversationId,
    int? reactionId,
    int? userId,
    String? reaction,
  }) {
    return LMChatReactionViewData._(
      chatroomId: chatroomId ?? this.chatroomId,
      conversationId: conversationId ?? this.conversationId,
      reactionId: reactionId ?? this.reactionId,
      userId: userId ?? this.userId,
      reaction: reaction ?? this.reaction,
    );
  }
}

/// `LMChatReactionViewDataBuilder` is a builder class used to create an instance of `LMChatReactionViewData`.
/// This class is used to create an instance of `LMChatReactionViewData` with the provided values.
class LMChatReactionViewDataBuilder {
  int? _chatroomId;
  int? _conversationId;
  int? _reactionId;
  int? _userId;
  String? _reaction;

  void chatroomId(int? chatroomId) {
    _chatroomId = chatroomId;
  }

  void conversationId(int? conversationId) {
    _conversationId = conversationId;
  }

  void reactionId(int? reactionId) {
    _reactionId = reactionId;
  }

  void userId(int? userId) {
    _userId = userId;
  }

  void reaction(String? reaction) {
    _reaction = reaction;
  }

  LMChatReactionViewData build() {
    return LMChatReactionViewData._(
      chatroomId: _chatroomId!,
      conversationId: _conversationId!,
      reactionId: _reactionId,
      userId: _userId!,
      reaction: _reaction!,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/delete/delete_reason_view_data.dart
================================================
/// {@template lm_chat_delete_reason_view_data}
/// A data class to hold the delete reason data.
/// {@endtemplate}
class LMChatDeleteReasonViewData {
  /// The id of the delete reason.
  final int id;

  /// The reason for the delete.
  final String name;

  /// {@macro lm_chat_delete_reason_view_data}
  const LMChatDeleteReasonViewData._({
    required this.id,
    required this.name,
  });
}

/// {@template lm_delete_reason_view_data_builder}
/// A builder class to build [LMChatDeleteReasonViewData]
/// {@endtemplate}

class LMChatDeleteReasonViewDataBuilder {
  int? _id;
  String? _name;

  /// Set the id of the delete reason.
  void id(int id) {
    _id = id;
  }

  /// Set the name of the delete reason.
  void name(String name) {
    _name = name;
  }

  /// Builds the [LMChatDeleteReasonViewData]
  /// 
  LMChatDeleteReasonViewData build() {
    return LMChatDeleteReasonViewData._(
      id: _id!,
      name: _name!,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/media/media_model.dart
================================================
import 'dart:io';

import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';

/// Enumeration representing the type of media in a conversation
///
/// The supported media types are:
/// - [LMChatMediaType.video]: Represents a video media type.
/// - [LMChatMediaType.image]: Represents an image media type.
/// - [LMChatMediaType.document]: Represents a document media type.
/// - [LMChatMediaType.link]: Represents a link media type.
/// - [LMChatMediaType.audio]: Represents an audio media type.
/// - [LMChatMediaType.gif]: Represents a GIF media type.
/// - [LMChatMediaType.voiceNote]: Represents a voice note media type.
enum LMChatMediaType {
  /// Represents a video media type
  video,

  /// Represents an image media type
  image,

  /// Represents a document media type
  document,

  /// Represents a link media type
  link,

  /// Represents an audio media type
  audio,

  /// Represents a GIF media type
  gif,

  /// Represents a voice note media type
  voiceNote,
}

///{@template lm_chat_media_model}
/// [LMChatMediaModel] is a model class that represents media in a chat conversation.
/// It contains information about the media file, its type, dimensions, and additional metadata.
/// {@endtemplate}
class LMChatMediaModel {
  /// The media file associated with the chat
  File? mediaFile;

  /// The type of media (e.g., image, video)
  LMChatMediaType mediaType;

  /// The URL of the media
  String? mediaUrl;

  /// The width of the media
  int? width;

  /// The height of the media
  int? height;

  /// The URL of the thumbnail image
  String? thumbnailUrl;

  /// The thumbnail file associated with the media
  File? thumbnailFile;

  /// The number of pages (for documents)
  int? pageCount;

  /// The size of the media file in bytes
  int? size;

  /// The duration of the media (for audio/video)
  double? duration;

  /// Open Graph tags associated with the media
  LMChatOGTagsViewData? ogTags;

  /// Additional metadata related to the media
  Map<String, dynamic>? meta;

  /// The link associated with the media
  String? link;

  ///{@macro lm_chat_media_model}
  LMChatMediaModel({
    this.mediaFile,
    required this.mediaType,
    this.mediaUrl,
    this.height,
    this.pageCount,
    this.size,
    this.thumbnailFile,
    this.thumbnailUrl,
    this.width,
    this.duration,
    this.ogTags,
    this.meta,
    this.link,
  });

  /// copyWith method is used to create a new instance of `LMChatMediaModel` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatMediaModel copyWith({
    File? mediaFile,
    LMChatMediaType? mediaType,
    String? mediaUrl,
    int? width,
    int? height,
    String? thumbnailUrl,
    File? thumbnailFile,
    int? pageCount,
    int? size,
    double? duration,
    LMChatOGTagsViewData? ogTags,
    Map<String, dynamic>? meta,
    String? link,
  }) {
    return LMChatMediaModel(
      mediaFile: mediaFile ?? this.mediaFile,
      mediaType: mediaType ?? this.mediaType,
      mediaUrl: mediaUrl ?? this.mediaUrl,
      width: width ?? this.width,
      height: height ?? this.height,
      thumbnailUrl: thumbnailUrl ?? this.thumbnailUrl,
      thumbnailFile: thumbnailFile ?? this.thumbnailFile,
      pageCount: pageCount ?? this.pageCount,
      size: size ?? this.size,
      duration: duration ?? this.duration,
      ogTags: ogTags ?? this.ogTags,
      meta: meta ?? this.meta,
      link: link ?? this.link,
    );
  }
}

/// Maps the [LMChatMediaType] to its corresponding string representation.
///
/// This function takes a [LMChatMediaType] as input and returns the string
/// representation of the media type. The mapping is done using a switch statement.
/// The supported media types are:
/// - [LMChatMediaType.image]: Returns [kAttachmentTypeImage].
/// - [LMChatMediaType.video]: Returns [kAttachmentTypeVideo].
/// - [LMChatMediaType.document]: Returns [kAttachmentTypePDF].
/// - [LMChatMediaType.audio]: Returns [kAttachmentTypeAudio].
/// - [LMChatMediaType.gif]: Returns [kAttachmentTypeGIF].
/// - [LMChatMediaType.voiceNote]: Returns [kAttachmentTypeVoiceNote].
/// - [LMChatMediaType.link]: Returns [kAttachmentTypeLink].
/// If the input [LMChatMediaType] is not one of the supported types, it returns
/// [kAttachmentTypeImage] as the default value.
///
/// Returns:
/// - [String]: The string representation of the media type.
String mapMediaTypeToString(LMChatMediaType mediaType) {
  switch (mediaType) {
    case LMChatMediaType.image:
      return kAttachmentTypeImage;
    case LMChatMediaType.video:
      return kAttachmentTypeVideo;
    case LMChatMediaType.document:
      return kAttachmentTypePDF;
    case LMChatMediaType.audio:
      return kAttachmentTypeAudio;
    case LMChatMediaType.gif:
      return kAttachmentTypeGIF;
    case LMChatMediaType.voiceNote:
      return kAttachmentTypeVoiceNote;
    case LMChatMediaType.link:
      return kAttachmentTypeLink;
    default:
      return kAttachmentTypeImage;
  }
}

/// Maps the string representation of a media type to its corresponding [LMChatMediaType].
///
/// This function takes a [String] as input representing the media type and returns the corresponding [LMChatMediaType].
/// The supported media types are:
/// - [kAttachmentTypeImage]: Returns [LMChatMediaType.image].
/// - [kAttachmentTypeVideo]: Returns [LMChatMediaType.video].
/// - [kAttachmentTypePDF]: Returns [LMChatMediaType.document].
/// - [kAttachmentTypeAudio]: Returns [LMChatMediaType.audio].
/// - [kAttachmentTypeGIF]: Returns [LMChatMediaType.gif].
/// - [kAttachmentTypeVoiceNote]: Returns [LMChatMediaType.voiceNote].
/// - [kAttachmentTypeLink]: Returns [LMChatMediaType.link].
/// If the input [String] is not one of the supported types, it returns [LMChatMediaType.image] as the default value.
///
/// Parameters:
/// - [mediaType] (String): The string representation of the media type.
///
/// Returns:
/// - [LMChatMediaType]: The corresponding media type.
LMChatMediaType mapStringToMediaType(String mediaType) {
  switch (mediaType) {
    case kAttachmentTypeImage:
      return LMChatMediaType.image;
    case kAttachmentTypeVideo:
      return LMChatMediaType.video;
    case kAttachmentTypePDF:
      return LMChatMediaType.document;
    case kAttachmentTypeAudio:
      return LMChatMediaType.audio;
    case kAttachmentTypeGIF:
      return LMChatMediaType.gif;
    case kAttachmentTypeVoiceNote:
      return LMChatMediaType.voiceNote;
    case kAttachmentTypeLink:
      return LMChatMediaType.link;
    default:
      return LMChatMediaType.image;
  }
}



================================================
File: lib/packages/ui/lib/src/models/media/og_tags_view_data.dart
================================================
/// `LMChatOGTagsViewData` is a model class that contains the data required to display the Open Graph tags in the chat.
/// This class is used to display the Open Graph tags in the chat screen.
class LMChatOGTagsViewData {
  String? title;
  String? description;
  String? imageUrl;
  String? url;

  LMChatOGTagsViewData._({
    this.title,
    this.description,
    this.imageUrl,
    this.url,
  });

  /// copyWith method is used to create a new instance of `LMChatOGTagsViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatOGTagsViewData copyWith({
    String? title,
    String? description,
    String? imageUrl,
    String? url,
  }) {
    return LMChatOGTagsViewData._(
      title: title ?? this.title,
      description: description ?? this.description,
      imageUrl: imageUrl ?? this.imageUrl,
      url: url ?? this.url,
    );
  }
}

/// `LMChatOGTagsViewDataBuilder` is a builder class used to create an instance of `LMChatOGTagsViewData`.
/// This class is used to create an instance of `LMChatOGTagsViewData` with the provided values.
class LMChatOGTagsViewDataBuilder {
  String? _title;
  String? _description;
  String? _imageUrl;
  String? _url;

  void title(String? title) {
    _title = title;
  }

  void description(String? description) {
    _description = description;
  }

  void imageUrl(String? imageUrl) {
    _imageUrl = imageUrl;
  }

  void url(String? url) {
    _url = url;
  }

  /// build method is used to create an instance of `LMChatOGTagsViewData` with the provided values.
  LMChatOGTagsViewData build() {
    return LMChatOGTagsViewData._(
      title: _title,
      description: _description,
      imageUrl: _imageUrl,
      url: _url,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/menu/menu_item_view_data.dart
================================================
import 'package:flutter/material.dart';

/// `LMChatMenuItemViewData` is a model class that holds the data for the menu item view.
/// This class is used to display the menu items in the chat screen.
class LMChatMenuItemViewData {
  const LMChatMenuItemViewData._({
    required this.leading,
    required this.title,
    required this.onTap,
  });
  final Widget leading;
  final Widget title;
  final VoidCallback onTap;

  /// copyWith method is used to create a new instance of `LMChatMenuItemViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatMenuItemViewData copyWith({
    Widget? leading,
    Widget? title,
    VoidCallback? onTap,
  }) {
    return LMChatMenuItemViewData._(
      leading: leading ?? this.leading,
      title: title ?? this.title,
      onTap: onTap ?? this.onTap,
    );
  }
}


/// `LMChatMenuItemViewDataBuilder` is a builder class used to create an instance of `LMChatMenuItemViewData`.
class LMChatMenuItemViewDataBuilder {
  Widget? _leading;
  Widget? _title;
  VoidCallback? _onTap;

  void leading(Widget leading) {
    _leading = leading;
  }

  void title(Widget title) {
    _title = title;
  }

  void onTap(VoidCallback onTap) {
    _onTap = onTap;
  }


  /// build method is used to create an instance of `LMChatMenuItemViewData` with the provided values.
  LMChatMenuItemViewData build() {
    return LMChatMenuItemViewData._(
      leading: _leading!,
      title: _title!,
      onTap: _onTap!,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/moderation/report_tag_view_data.dart
================================================
/// {@template lm_chat_report_tag_view_data}
/// A view data class to hold the report tag data.
/// [id] is the id of the report tag.
/// [name] is the name of the report tag.
/// {@endtemplate}
class LMChatReportTagViewData {
  /// The id of the report tag.
  final int id;

  /// The name of the report tag.
  final String name;

  const LMChatReportTagViewData._({
    required this.id,
    required this.name,
  });

  /// copy the [LMChatReportTagViewData] with new values.
  /// [id] is the id of the report tag.
  /// [name] is the name of the report tag.
  LMChatReportTagViewData copyWith({
    int? id,
    String? name,
  }) {
    return LMChatReportTagViewData._(
      id: id ?? this.id,
      name: name ?? this.name,
    );
  }
}

/// {@template lm_chat_report_tag_view_data_builder}
/// A builder class to build [LMChatReportTagViewData]
/// [id] is the id of the report tag.
/// [name] is the name of the report tag.
/// {@endtemplate}
class LMChatReportTagViewDataBuilder {
  int? _id;
  String? _name;

  /// Set the id of the report tag.
  void id(int id) {
    _id = id;
  }

  /// Set the name of the report tag.
  void name(String name) {
    _name = name;
  }

  /// Builds the [LMChatReportTagViewData]
  LMChatReportTagViewData build() {
    return LMChatReportTagViewData._(
      id: _id!,
      name: _name!,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/poll/poll_enum.dart
================================================
/// {@template lm_chat_poll_multi_select_state}
/// Enum to define the multi select state of the poll
/// i.e. exactly, at least, at most
/// {@endtemplate}
enum LMChatPollMultiSelectState {
  /// User can select exactly n options
  exactly(
    value: 0,
    name: 'exactly',
  ),

  /// User can select at most n options
  atMax(
    value: 1,
    name: 'at most',
  ),

  /// User can select at least n options
  atLeast(
    value: 2,
    name: 'at least',
  );

  /// Value of the enum
  final int value;

  /// Display String of the enum
  final String name;

  const LMChatPollMultiSelectState({
    required this.value,
    required this.name,
  });

  factory LMChatPollMultiSelectState.fromValue(int? value) {
    switch (value) {
      case 0:
        return LMChatPollMultiSelectState.exactly;
      case 1:
        return LMChatPollMultiSelectState.atMax;
      case 2:
        return LMChatPollMultiSelectState.atLeast;
      default:
        return LMChatPollMultiSelectState.exactly;
    }
  }
}

/// {@template lm_chat_poll_type}
/// Enum to define the type of poll
/// i.e. instant, deferred and open
/// {@endtemplate}
enum LMChatPollType {
  /// Instant poll
  /// User can see the results as soon as they vote
  instant(
    value: 0,
  ),

  /// Deferred poll
  /// User can see the results only after the poll ends
  deferred(
    value: 1,
  ),

  /// Open poll
  /// User can see the results without voting or waiting for the poll to end
  open(
    value: 2,
  );

  /// Value of the enum
  final int value;

  const LMChatPollType({
    required this.value,
  });

  factory LMChatPollType.fromValue(int? value) {
    switch (value) {
      case 0:
        return LMChatPollType.instant;
      case 1:
        return LMChatPollType.deferred;
      case 2:
        return LMChatPollType.open;
      default:
        return LMChatPollType.instant;
    }
  }
}



================================================
File: lib/packages/ui/lib/src/models/poll/poll_option_view_data.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_poll_option_view_data}
/// `LMChatPollOptionViewData` is a model class used to represent the poll option data in the chat.
/// This class is used to display the poll options in the chat screen.
/// {@endtemplate}

class LMChatPollOptionViewData {
  /// Represents the unique identifier for the poll option.
  final int? id;

  /// The text description of the poll option.
  final String text;

  /// Indicates whether the poll option is selected by the user.
  final bool? isSelected;

  /// The percentage of votes received by the poll option.
  final int? percentage;

  /// The number of votes received by the poll option.
  final int? noVotes;

  /// The identifier for the conversation associated with the poll option.
  final int? conversationId;

  /// The user data of the member who created or is associated with the poll option.
  final LMChatUserViewData? member;

  LMChatPollOptionViewData._({
    required this.id,
    required this.text,
    required this.isSelected,
    required this.percentage,
    required this.noVotes,
    required this.conversationId,
    this.member,
  });

  /// copyWith method is used to create a new instance of `LMChatPollOPtionViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatPollOptionViewData copyWith({
    int? id,
    String? text,
    bool? isSelected,
    int? percentage,
    int? noVotes,
    int? conversationId,
    LMChatUserViewData? member,
  }) {
    return LMChatPollOptionViewData._(
      id: id ?? this.id,
      text: text ?? this.text,
      isSelected: isSelected ?? this.isSelected,
      percentage: percentage ?? this.percentage,
      noVotes: noVotes ?? this.noVotes,
      conversationId: conversationId ?? this.conversationId,
      member: member ?? this.member,
    );
  }
}

/// {@template lm_chat_poll_option_view_data_builder}
/// `LMChatPollOptionViewDataBuilder` is a builder class used to create an instance of `LMChatPollOPtionViewData`.
/// This class is used to create an instance of `LMChatPollOPtionViewData` with the provided values.
/// {@endtemplate}
class LMChatPollOptionViewDataBuilder {
  int? _id;
  String? _text;
  bool? _isSelected;
  int? _percentage;

  int? _noVotes;

  int? _conversationId;

  LMChatUserViewData? _member;

  /// id method is used to set the unique identifier for the poll option.
  void id(int? id) {
    _id = id;
  }

  /// text method is used to set the text description of the poll option.
  void text(String text) {
    _text = text;
  }

  /// isSelected method is used to set whether the poll option is selected by the user.
  void isSelected(bool? isSelected) {
    _isSelected = isSelected;
  }

  /// percentage method is used to set the percentage of votes received by the poll option.
  void percentage(int? percentage) {
    _percentage = percentage;
  }

  /// noVotes method is used to set the number of votes received by the poll option.
  void noVotes(int? noVotes) {
    _noVotes = noVotes;
  }

  /// conversationId method is used to set the identifier for the conversation associated with the poll option.
  void conversationId(int? conversationId) {
    _conversationId = conversationId;
  }

  /// member method is used to set the user data of the member who created or is associated with the poll option.
  void member(LMChatUserViewData? member) {
    _member = member;
  }

  /// build method is used to create an instance of `LMChatPollOPtionViewData` with the provided values.
  LMChatPollOptionViewData build() {
    if (_text == null) throw Exception('text is required');

    return LMChatPollOptionViewData._(
      id: _id,
      text: _text!,
      isSelected: _isSelected,
      percentage: _percentage,
      noVotes: _noVotes,
      conversationId: _conversationId,
      member: _member,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/sdk/sdk_client_info_view_data.dart
================================================
/// `LMChatSDKClientInfoViewData` is a model class that holds the data for the client info view.
/// This class is used to display the client information in the chat screen.
class LMChatSDKClientInfoViewData {
  int community;
  int user;
  String uuid;
  String? widgetId;

  LMChatSDKClientInfoViewData._({
    required this.community,
    required this.user,
    required this.uuid,
    this.widgetId,
  });

  /// copyWith method is used to create a new instance of `LMChatSDKClientInfoViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatSDKClientInfoViewData copyWith({
    int? community,
    int? user,
    String? uuid,
    String? widgetId,
  }) {
    return LMChatSDKClientInfoViewData._(
      community: community ?? this.community,
      user: user ?? this.user,
      uuid: uuid ?? this.uuid,
      widgetId: widgetId ?? this.widgetId,
    );
  }
}

/// `LMChatSDKClientInfoViewDataBuilder` is a builder class used to create an instance of `LMChatSDKClientInfoViewData`.
/// This class is used to create an instance of `LMChatSDKClientInfoViewData` with the provided values.
class LMSDKClientInfoViewDataBuilder {
  int? _community;
  int? _user;
  String? _uuid;
  String? _widgetId;

  void community(int community) {
    _community = community;
  }

  void user(int user) {
    _user = user;
  }

  void uuid(String uuid) {
    _uuid = uuid;
  }

  void widgetId(String widgetId) {
    _widgetId = widgetId;
  }

  LMChatSDKClientInfoViewData build() {
    return LMChatSDKClientInfoViewData._(
      community: _community!,
      user: _user!,
      uuid: _uuid!,
      widgetId: _widgetId,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/tag/tag_view_data.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// `LMTagType` is an enum class that holds the values for the tag type.
/// This class is used to differentiate between the group tag and user tag.
/// The values are `groupTag` and `userTag`.
enum LMTagType { groupTag, userTag }

/// `LMChatTagViewData` is a model class that holds the data for the tag view.
/// This class is used to display the tag information in the chat screen.
class LMChatTagViewData {
  //common values
  final String name;
  final String imageUrl;
  final LMTagType tagType;

  // groupTag specific values
  final String? description;
  final String? route;
  final String? tag;

  // userTag specific values
  final String? customTitle;
  final int? id;
  final bool? isGuest;
  final String? userUniqueId;
  final String? uuid;
  final LMChatSDKClientInfoViewData? sdkClientInfoViewData;

  LMChatTagViewData._({
    required this.name,
    required this.imageUrl,
    required this.tagType,
    this.description,
    this.route,
    this.tag,
    this.customTitle,
    this.id,
    this.isGuest,
    this.userUniqueId,
    this.uuid,
    this.sdkClientInfoViewData,
  });

  /// copyWith method is used to create a new instance of `LMChatTagViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatTagViewData copyWith({
    String? name,
    String? imageUrl,
    LMTagType? tagType,
    String? description,
    String? route,
    String? tag,
    String? customTitle,
    int? id,
    bool? isGuest,
    String? userUniqueId,
    String? uuid,
    LMChatSDKClientInfoViewData? sdkClientInfoViewData,
  }) {
    return LMChatTagViewData._(
      name: name ?? this.name,
      imageUrl: imageUrl ?? this.imageUrl,
      tagType: tagType ?? this.tagType,
      description: description ?? this.description,
      route: route ?? this.route,
      tag: tag ?? this.tag,
      customTitle: customTitle ?? this.customTitle,
      id: id ?? this.id,
      isGuest: isGuest ?? this.isGuest,
      userUniqueId: userUniqueId ?? this.userUniqueId,
      uuid: uuid ?? this.uuid,
      sdkClientInfoViewData:
          sdkClientInfoViewData ?? this.sdkClientInfoViewData,
    );
  }
}

/// `LMChatTagViewDataBuilder` is a builder class used to create an instance of `LMChatTagViewData`.
/// This class is used to create an instance of `LMChatTagViewData` with the provided values.
class LMChatTagViewDataBuilder {
  String? _name;
  String? _imageUrl;
  LMTagType? _tagType;
  String? _description;
  String? _route;
  String? _tag;
  String? _customTitle;
  int? _id;
  bool? _isGuest;
  String? _userUniqueId;
  String? _uuid;
  LMChatSDKClientInfoViewData? _sdkClientInfoViewData;

  void name(String name) {
    _name = name;
  }

  void imageUrl(String imageUrl) {
    _imageUrl = imageUrl;
  }

  void tagType(LMTagType tagType) {
    _tagType = tagType;
  }

  void description(String? description) {
    _description = description;
  }

  void route(String? route) {
    _route = route;
  }

  void tag(String? tag) {
    _tag = tag;
  }

  void customTitle(String? customTitle) {
    _customTitle = customTitle;
  }

  void id(int? id) {
    _id = id;
  }

  void isGuest(bool? isGuest) {
    _isGuest = isGuest;
  }

  void userUniqueId(String? userUniqueId) {
    _userUniqueId = userUniqueId;
  }

  void uuid(String? uuid) {
    _uuid = uuid;
  }

  void sdkClientInfoViewData(
      LMChatSDKClientInfoViewData? sdkClientInfoViewData) {
    _sdkClientInfoViewData = sdkClientInfoViewData;
  }

  /// build method is used to create an instance of `LMChatTagViewData` with the provided values.
  LMChatTagViewData build() {
    if (_name == null) {
      throw StateError("name is required");
    }

    return LMChatTagViewData._(
      name: _name!,
      imageUrl: _imageUrl ?? '',
      tagType: _tagType ?? LMTagType.userTag,
      description: _description,
      route: _route,
      tag: _tag,
      customTitle: _customTitle,
      id: _id,
      isGuest: _isGuest,
      userUniqueId: _userUniqueId,
      uuid: _uuid,
      sdkClientInfoViewData: _sdkClientInfoViewData,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/user/user_view_data.dart
================================================
import 'package:likeminds_chat_flutter_ui/src/models/sdk/sdk_client_info_view_data.dart';
import 'package:likeminds_chat_flutter_ui/src/models/widget/widget_view_data.dart';

/// Enum representing different roles a user can have
enum LMChatUserRole {
  /// Represents a chatbot user role
  chatbot,

  /// Represents a regular member user role
  member,

  /// Represents an administrator user role with elevated privileges
  admin,
}

/// {@template lm_user_view_data}
/// A view data class to hold the user data.
/// {@endtemplate}
class LMChatUserViewData {
  /// unique identifier of the user
  int id;

  /// name of the user
  String name;

  /// image url of the user
  String? imageUrl;

  /// isGuest is a boolean value to check if the user is a guest user
  bool? isGuest;

  /// isDeleted is a boolean value to check if the user is deleted
  bool? isDeleted;

  /// uuid is a unique identifier of the user
  String uuid;

  /// roles is a list of roles assigned to the user
  List<LMChatUserRole>? roles;

  /// organisationName is the name of the organisation to which the user belongs
  String? organisationName;

  /// sdkClientInfo is a view data class to hold the sdk client info data
  LMChatSDKClientInfoViewData? sdkClientInfo;

  /// updatedAt is the timestamp when the user data is updated
  int? updatedAt;

  /// isOwner is a boolean value to check if the user is the owner of the community
  bool? isOwner;

  /// custom title of the user
  /// eg: Community Manager
  String? customTitle;

  /// date since the user is a member of the community
  String? memberSince;

  /// route of the user
  String? route;

  /// state of the user
  int? state;

  /// community id of the community to which the user belongs
  int? communityId;

  /// createdAt is the timestamp when the user is created
  int? createdAt;

  /// customIntroText is the custom intro text of the user
  String? customIntroText;

  /// memberSinceEpoch is the epoch time since the user is a member of the community
  int? memberSinceEpoch;

  /// widget for storing custom data
  LMChatWidgetViewData? widget;

  /// {@macro user_view_data}
  LMChatUserViewData._({
    required this.id,
    required this.name,
    this.imageUrl,
    this.isGuest,
    required this.uuid,
    this.organisationName,
    required this.sdkClientInfo,
    this.updatedAt,
    this.isOwner,
    this.customTitle,
    this.memberSince,
    this.route,
    this.state,
    this.communityId,
    this.createdAt,
    this.isDeleted,
    this.widget,
    this.roles,
  });

  /// copyWith method is used to create a new instance of `LMChatUserViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatUserViewData copyWith({
    int? id,
    String? name,
    String? imageUrl,
    bool? isGuest,
    bool? isDeleted,
    String? uuid,
    String? organisationName,
    LMChatSDKClientInfoViewData? sdkClientInfo,
    int? updatedAt,
    bool? isOwner,
    String? customTitle,
    String? memberSince,
    String? route,
    int? state,
    int? communityId,
    int? createdAt,
    LMChatWidgetViewData? widget,
    List<LMChatUserRole>? roles,
  }) {
    return LMChatUserViewData._(
      id: id ?? this.id,
      name: name ?? this.name,
      imageUrl: imageUrl ?? this.imageUrl,
      isGuest: isGuest ?? this.isGuest,
      uuid: uuid ?? this.uuid,
      organisationName: organisationName ?? this.organisationName,
      sdkClientInfo: sdkClientInfo ?? this.sdkClientInfo,
      updatedAt: updatedAt ?? this.updatedAt,
      isOwner: isOwner ?? this.isOwner,
      customTitle: customTitle ?? this.customTitle,
      memberSince: memberSince ?? this.memberSince,
      route: route ?? this.route,
      state: state ?? this.state,
      communityId: communityId ?? this.communityId,
      createdAt: createdAt ?? this.createdAt,
      isDeleted: isDeleted ?? this.isDeleted,
      widget: widget ?? this.widget,
      roles: roles ?? this.roles,
    );
  }
}

/// {@template user_view_data_builder}
/// A builder class to build [LMUserViewData]
/// {@endtemplate}
class LMChatUserViewDataBuilder {
  int? _id;
  String? _name;
  String? _imageUrl;
  bool? _isGuest;
  bool? _isDeleted;
  String? _uuid;
  String? _organisationName;
  LMChatSDKClientInfoViewData? _sdkClientInfo;
  int? _updatedAt;
  bool? _isOwner;
  String? _customTitle;
  String? _memberSince;
  String? _route;
  int? _state;
  int? _communityId;
  int? _createdAt;
  LMChatWidgetViewData? _widget;
  List<LMChatUserRole>? _roles;

  /// Sets the id of the user
  void id(int? id) {
    _id = id;
  }

  /// Sets the name of the user
  void name(String? name) {
    _name = name;
  }

  /// Sets the image URL of the user
  void imageUrl(String? imageUrl) {
    _imageUrl = imageUrl;
  }

  /// Sets whether the user is a guest
  void isGuest(bool? isGuest) {
    _isGuest = isGuest;
  }

  /// Sets whether the user is deleted
  void isDeleted(bool? isDeleted) {
    _isDeleted = isDeleted;
  }

  /// Sets the UUID of the user
  void uuid(String? uuid) {
    _uuid = uuid;
  }

  /// Sets the organisation name of the user
  void organisationName(String? organisationName) {
    _organisationName = organisationName;
  }

  /// Sets the SDK client info of the user
  void sdkClientInfo(LMChatSDKClientInfoViewData? sdkClientInfo) {
    _sdkClientInfo = sdkClientInfo;
  }

  /// Sets the updated timestamp of the user
  void updatedAt(int? updatedAt) {
    _updatedAt = updatedAt;
  }

  /// Sets whether the user is the owner
  void isOwner(bool? isOwner) {
    _isOwner = isOwner;
  }

  /// Sets the custom title of the user
  void customTitle(String? customTitle) {
    _customTitle = customTitle;
  }

  /// Sets the member since date of the user
  void memberSince(String? memberSince) {
    _memberSince = memberSince;
  }

  /// Sets the route of the user
  void route(String? route) {
    _route = route;
  }

  /// Sets the state of the user
  void state(int? state) {
    _state = state;
  }

  /// Sets the community ID of the user
  void communityId(int? communityId) {
    _communityId = communityId;
  }

  /// Sets the created timestamp of the user
  void createdAt(int? createdAt) {
    _createdAt = createdAt;
  }

  /// Sets the widget data of the user
  void widget(LMChatWidgetViewData? widget) {
    _widget = widget;
  }

  /// Sets the roles of the user
  void roles(List<LMChatUserRole>? roles) {
    _roles = roles;
  }

  /// Builds and returns an instance of [LMChatUserViewData]
  LMChatUserViewData build() {
    if (_id == null) {
      throw Exception('id must not be null');
    }
    if (_name == null) {
      throw Exception('name must not be null');
    }
    if (_uuid == null) {
      throw Exception('uuid must not be null');
    }

    return LMChatUserViewData._(
      id: _id!,
      name: _name!,
      imageUrl: _imageUrl,
      isGuest: _isGuest,
      uuid: _uuid!,
      organisationName: _organisationName,
      sdkClientInfo: _sdkClientInfo,
      updatedAt: _updatedAt,
      isOwner: _isOwner,
      customTitle: _customTitle,
      memberSince: _memberSince,
      route: _route,
      state: _state,
      communityId: _communityId,
      createdAt: _createdAt,
      isDeleted: _isDeleted,
      widget: _widget,
      roles: _roles,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/models/widget/widget_view_data.dart
================================================
/// `LMWidgetViewData` is a data class that represents the data of a widget view.
/// This class is used to display the widget view in the chat screen.
class LMChatWidgetViewData {
  /// Unique identifier for the widget.
  final String id;

  /// Metadata associated with the widget, can be null.
  Map<String, dynamic>? lmMeta;

  /// Timestamp representing when the widget was created.
  int? createdAt;

  /// Additional metadata for the widget.
  Map<String, dynamic> metadata;

  /// Identifier for the parent entity of the widget.
  String? parentEntityId;

  /// Type of the parent entity of the widget.
  String? parentEntityType;

  /// Timestamp representing when the widget was last updated.
  int? updatedAt;

  LMChatWidgetViewData._({
    required this.id,
    this.lmMeta,
    this.createdAt,
    required this.metadata,
    this.parentEntityId,
    this.parentEntityType,
    this.updatedAt,
  });

  /// copyWith method is used to create a new instance of `LMChatWidgetViewData` with the updated values.
  /// If the new values are not provided, the old values are used.
  LMChatWidgetViewData copyWith({
    String? id,
    Map<String, dynamic>? lmMeta,
    int? createdAt,
    Map<String, dynamic>? metadata,
    String? parentEntityId,
    String? parentEntityType,
    int? updatedAt,
  }) {
    return LMChatWidgetViewData._(
      id: id ?? this.id,
      lmMeta: lmMeta ?? this.lmMeta,
      createdAt: createdAt ?? this.createdAt,
      metadata: metadata ?? this.metadata,
      parentEntityId: parentEntityId ?? this.parentEntityId,
      parentEntityType: parentEntityType ?? this.parentEntityType,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

/// `LMWidgetViewDataBuilder` is a builder class used to create an instance of `LMChatWidgetViewData`.
/// This class is used to create an instance of `LMChatWidgetViewData` with the provided values.
class LMWidgetViewDataBuilder {
  String? _id;
  Map<String, dynamic>? _lmMeta;
  int? _createdAt;
  Map<String, dynamic>? _metadata;
  String? _parentEntityId;
  String? _parentEntityType;
  int? _updatedAt;

  /// Sets the ID of the widget.
  ///
  /// [id] The ID to set.
  void id(String? id) {
    _id = id;
  }

  /// Sets the metadata for the widget.
  ///
  /// [lmMeta] The metadata to set.
  void lmMeta(Map<String, dynamic>? lmMeta) {
    _lmMeta = lmMeta;
  }

  /// Sets the creation timestamp of the widget.
  ///
  /// [createdAt] The creation timestamp to set.
  void createdAt(int? createdAt) {
    _createdAt = createdAt;
  }

  /// Sets additional metadata for the widget.
  ///
  /// [metadata] The additional metadata to set.
  void metadata(Map<String, dynamic>? metadata) {
    _metadata = metadata;
  }

  /// Sets the parent entity ID of the widget.
  ///
  /// [parentEntityId] The parent entity ID to set.
  void parentEntityId(String? parentEntityId) {
    _parentEntityId = parentEntityId;
  }

  /// Sets the parent entity type of the widget.
  ///
  /// [parentEntityType] The parent entity type to set.
  void parentEntityType(String? parentEntityType) {
    _parentEntityType = parentEntityType;
  }

  /// Sets the update timestamp of the widget.
  ///
  /// [updatedAt] The update timestamp to set.
  void updatedAt(int? updatedAt) {
    _updatedAt = updatedAt;
  }

  LMChatWidgetViewData build() {
    if (_id == null) {
      throw Exception("Missing required parameter: id");
    }

    return LMChatWidgetViewData._(
      id: _id!,
      lmMeta: _lmMeta,
      createdAt: _createdAt,
      metadata: _metadata ?? {},
      parentEntityId: _parentEntityId,
      parentEntityType: _parentEntityType,
      updatedAt: _updatedAt,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/theme/theme.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

///{@template lm_chat_theme}
///
/// A class for manaing the theme of the entire chat experience
/// Use parameters to style, and custmise each aspect.
///
///{@endtemplate}
class LMChatTheme {
  /// Singleton instance of LMChatTheme
  static LMChatTheme? _instance;

  /// Gets the singleton instance of LMChatTheme
  static LMChatTheme get instance => _instance ??= LMChatTheme._();

  /// Gets the theme data
  static LMChatThemeData get theme => instance.themeData;

  /// Gets the text theme
  static TextTheme get text => instance.textTheme;

  /// Sets the theme data
  static void setTheme(LMChatThemeData theme) {
    final instance = LMChatTheme.instance;
    instance.initialise(
      theme: theme,
      isDark: theme.isDark,
    );
  }

  /// Sets the theme data
  static void setTextTheme(TextTheme theme) {
    instance.textTheme = theme;
  }

  LMChatTheme._();

  /// The theme data for the chat
  late LMChatThemeData themeData;

  /// The text theme for the chat
  late TextTheme textTheme;

  /// Whether the current theme is dark
  bool isDark = false;

  /// Initializes the theme with optional parameters
  void initialise({
    LMChatThemeData? theme,
    TextTheme? textTheme,
    bool? isDark,
  }) {
    // If theme is provided, use its type, otherwise use isDark parameter or default to false
    this.isDark = theme != null ? theme.isDark : (isDark ?? false);

    // Initialize theme based on isDark if not provided
    themeData = theme ??
        (this.isDark ? LMChatThemeData.dark() : LMChatThemeData.light());
    this.textTheme = textTheme ?? ThemeData.light().textTheme;
  }

  /// Static helper to check if current theme is dark
  static bool get isThemeDark => instance.isDark;

  /// Static helper to toggle between light and dark themes
  static void toggleTheme() {
    final instance = LMChatTheme.instance;
    instance.initialise(
      theme: instance.isDark ? LMChatThemeData.light() : LMChatThemeData.dark(),
      isDark: !instance.isDark,
    );
  }
}

class LMChatThemeData {
  /// boolean to figure out which theme we are running
  final bool isDark;

  /// Style for buttons in the chat
  final LMChatButtonStyle buttonStyle;

  /// Style for icons in the chat
  final LMChatIconStyle iconStyle;

  /// Style for loaders in the chat
  final LMChatLoaderStyle loaderStyle;

  /// Style for text fields in the chat
  final LMChatTextFieldStyle textFieldStyle;

  /// Style for dialogs in the chat
  final LMChatDialogStyle dialogStyle;

  /// Style for pop-up menus in the chat
  final LMChatPopUpMenuStyle popUpMenuStyle;

  /// Style for bottom sheets in the chat
  final LMChatBottomSheetStyle bottomSheetStyle;

  /// Style for snack bars in the chat
  final LMChatSnackBarStyle snackBarTheme;

  /// Style for chat tiles
  final LMChatTileStyle chatTileStyle;

  /// Style for app bars in the chat
  final LMChatAppBarStyle appBarStyle;

  /// Style for images in the chat
  final LMChatImageStyle imageStyle;

  /// Style for videos in the chat
  final LMChatVideoStyle videoStyle;

  /// Style for documents in the chat
  final LMChatDocumentStyle documentStyle;

  /// Style for GIFs in the chat
  final LMChatGIFStyle gifStyle;

  /// Style for voice notes in the chat
  final LMChatVoiceNoteStyle voiceNoteStyle;

  /// Style for bubbles in the chat
  final LMChatBubbleStyle bubbleStyle;

  /// Style for state bubbles in the chat
  final LMChatStateBubbleStyle stateBubbleStyle;

  /// Style for reply bubbles in the chat
  final LMChatBubbleReplyStyle replyStyle;

  /// Style for bubble content in the chat
  final LMChatBubbleContentStyle contentStyle;

  /// Style for polls in the chat
  final LMChatPollStyle pollStyle;

  /// Style for bubble reactions in the chat
  final LMChatBubbleReactionsStyle bubbleReactionsStyle;

  /// Style for the reaction bar in the chat
  final LMChatReactionBarStyle reactionBarStyle;

  /// Style for the reaction bottom sheet in the chat
  final LMChatReactionBottomSheetStyle reactionBottomSheetStyle;

  /// Style for the reaction keyboard in the chat
  final LMChatReactionKeyboardStyle reactionKeyboardStyle;

  /// Primary color used in the chat theme
  final Color primaryColor;

  /// Background color used in the chat theme
  final Color backgroundColor;

  /// Secondary color used in the chat theme
  final Color secondaryColor;

  /// Shadow color used in the chat theme
  final Color shadowColor;

  /// Disabled color used in the chat theme
  final Color disabledColor;

  /// Error color used in the chat theme
  final Color errorColor;

  /// Inactive color used in the chat theme
  final Color inActiveColor;

  /// Color for tags in the chat theme
  final Color tagColor;

  /// Color for hashtags in the chat theme
  final Color hashTagColor;

  /// Color for links in the chat theme
  final Color linkColor;

  /// Color for containers in the chat theme
  final Color container;

  /// Color for on-container elements in the chat theme
  final Color onContainer;

  /// Color for on-primary elements in the chat theme
  final Color onPrimary;

  /// Color for the scaffold in the chat theme
  final Color scaffold;

  const LMChatThemeData({
    this.isDark = false,
    required this.primaryColor,
    required this.backgroundColor,
    required this.secondaryColor,
    required this.shadowColor,
    required this.disabledColor,
    required this.errorColor,
    required this.inActiveColor,
    required this.tagColor,
    required this.hashTagColor,
    required this.linkColor,
    required this.container,
    required this.onContainer,
    required this.onPrimary,
    required this.scaffold,
    required this.textFieldStyle,
    required this.dialogStyle,
    required this.popUpMenuStyle,
    required this.loaderStyle,
    required this.buttonStyle,
    required this.iconStyle,
    required this.bottomSheetStyle,
    required this.snackBarTheme,
    required this.imageStyle,
    required this.videoStyle,
    required this.documentStyle,
    required this.gifStyle,
    required this.voiceNoteStyle,
    required this.bubbleStyle,
    required this.replyStyle,
    required this.contentStyle,
    required this.chatTileStyle,
    required this.stateBubbleStyle,
    required this.appBarStyle,
    required this.reactionBarStyle,
    required this.reactionBottomSheetStyle,
    required this.bubbleReactionsStyle,
    required this.reactionKeyboardStyle,
    required this.pollStyle,
  });

  /// Creates a light theme data from the provided ThemeData
  factory LMChatThemeData.fromThemeData(ThemeData theme) {
    return LMChatThemeData.light(
      backgroundColor: theme.colorScheme.surface,
      primaryColor: theme.primaryColor,
      secondaryColor: theme.colorScheme.secondary,
      shadowColor: theme.shadowColor,
      disabledColor: theme.disabledColor,
      errorColor: theme.colorScheme.error,
      inActiveColor: theme.unselectedWidgetColor,
      container: theme.colorScheme.primaryContainer,
      onContainer: theme.colorScheme.onPrimaryContainer,
      onPrimary: theme.colorScheme.onPrimary,
      scaffold: theme.colorScheme.surface,
    );
  }

  /// Creates a light theme data with optional parameters
  factory LMChatThemeData.light({
    Color? primaryColor,
    Color? backgroundColor,
    Color? secondaryColor,
    Color? shadowColor,
    Color? disabledColor,
    Color? errorColor,
    Color? inActiveColor,
    Color? tagColor,
    Color? hashTagColor,
    Color? linkColor,
    Color? scaffold,
    Color? container,
    Color? onContainer,
    Color? onPrimary,
    LMChatButtonStyle? buttonStyle,
    LMChatIconStyle? iconStyle,
    LMChatTextFieldStyle? textFieldStyle,
    LMChatDialogStyle? dialogStyle,
    LMChatPopUpMenuStyle? popUpMenuStyle,
    LMChatLoaderStyle? loaderStyle,
    LMChatBottomSheetStyle? bottomSheetStyle,
    LMChatSnackBarStyle? snackBarTheme,
    LMChatImageStyle? imageStyle,
    LMChatVideoStyle? videoStyle,
    LMChatDocumentStyle? documentStyle,
    LMChatGIFStyle? gifStyle,
    LMChatVoiceNoteStyle? voiceNoteStyle,
    LMChatBubbleReplyStyle? replyStyle,
    LMChatBubbleStyle? bubbleStyle,
    LMChatBubbleContentStyle? contentStyle,
    LMChatTileStyle? chatTileStyle,
    LMChatStateBubbleStyle? stateBubbleStyle,
    LMChatAppBarStyle? appBarStyle,
    LMChatReactionBarStyle? reactionBarStyle,
    LMChatReactionBottomSheetStyle? reactionBottomSheetStyle,
    LMChatBubbleReactionsStyle? bubbleReactionsStyle,
    LMChatReactionKeyboardStyle? reactionKeyboardStyle,
    LMChatPollStyle? pollStyle,
  }) {
    return LMChatThemeData(
        buttonStyle: buttonStyle ?? LMChatButtonStyle.basic(),
        iconStyle: iconStyle ?? LMChatIconStyle.basic(),
        backgroundColor: backgroundColor ?? LMChatDefaultTheme.backgroundColor,
        primaryColor: primaryColor ?? LMChatDefaultTheme.primaryColor,
        secondaryColor: secondaryColor ?? LMChatDefaultTheme.secondaryColor,
        shadowColor: shadowColor ?? LMChatDefaultTheme.shadowColor,
        disabledColor: disabledColor ?? LMChatDefaultTheme.disabledColor,
        errorColor: errorColor ?? LMChatDefaultTheme.errorColor,
        inActiveColor: inActiveColor ?? LMChatDefaultTheme.inactiveColor,
        container: container ?? LMChatDefaultTheme.container,
        scaffold: scaffold ?? LMChatDefaultTheme.container,
        onContainer: onContainer ?? LMChatDefaultTheme.onContainer,
        onPrimary: onPrimary ?? LMChatDefaultTheme.onPrimary,
        hashTagColor: hashTagColor ?? LMChatDefaultTheme.hashTagColor,
        linkColor: linkColor ?? LMChatDefaultTheme.linkColor,
        tagColor: tagColor ?? LMChatDefaultTheme.tagColor,
        textFieldStyle: textFieldStyle ?? LMChatTextFieldStyle.basic(),
        dialogStyle: dialogStyle ?? const LMChatDialogStyle(),
        popUpMenuStyle: popUpMenuStyle ?? const LMChatPopUpMenuStyle(),
        loaderStyle: LMChatLoaderStyle(
          color: primaryColor ?? LMChatDefaultTheme.primaryColor,
        ),
        bottomSheetStyle: bottomSheetStyle ?? const LMChatBottomSheetStyle(),
        snackBarTheme: snackBarTheme ??
            LMChatSnackBarStyle(
              behavior: SnackBarBehavior.floating,
              backgroundColor: primaryColor ?? LMChatDefaultTheme.primaryColor,
            ),
        imageStyle: imageStyle ?? LMChatImageStyle.basic(),
        videoStyle: videoStyle ?? LMChatVideoStyle.basic(),
        documentStyle: documentStyle ?? LMChatDocumentStyle.basic(),
        gifStyle: gifStyle ?? LMChatGIFStyle.basic(),
        voiceNoteStyle: voiceNoteStyle ?? LMChatVoiceNoteStyle.basic(),
        replyStyle: replyStyle ?? const LMChatBubbleReplyStyle(),
        bubbleStyle: bubbleStyle ?? LMChatBubbleStyle(),
        contentStyle: contentStyle ??
            LMChatBubbleContentStyle.basic(
                onContainer: LMChatDefaultTheme.onContainer),
        chatTileStyle: chatTileStyle ?? LMChatTileStyle.basic(),
        stateBubbleStyle:
            stateBubbleStyle ?? LMChatStateBubbleStyle.basic(onContainer),
        appBarStyle: appBarStyle ??
            LMChatAppBarStyle.basic(LMChatDefaultTheme.container),
        pollStyle: pollStyle ??
            LMChatPollStyle.basic(
              primaryColor: primaryColor,
              containerColor: container,
              onContainer: onContainer,
              inActiveColor: inActiveColor,
            ),
        reactionBarStyle: reactionBarStyle ?? LMChatReactionBarStyle.basic(),
        reactionBottomSheetStyle:
            reactionBottomSheetStyle ?? LMChatReactionBottomSheetStyle.basic(),
        bubbleReactionsStyle:
            bubbleReactionsStyle ?? LMChatBubbleReactionsStyle.basic(),
        reactionKeyboardStyle:
            reactionKeyboardStyle ?? LMChatReactionKeyboardStyle.basic());
  }

  /// Creates a dark theme data with optional parameters
  factory LMChatThemeData.dark({
    Color? primaryColor,
    Color? backgroundColor,
    Color? secondaryColor,
    Color? shadowColor,
    Color? disabledColor,
    Color? errorColor,
    Color? inActiveColor,
    Color? tagColor,
    Color? hashTagColor,
    Color? linkColor,
    Color? scaffold,
    Color? container,
    Color? onContainer,
    Color? onPrimary,
    LMChatButtonStyle? buttonStyle,
    LMChatIconStyle? iconStyle,
    LMChatTextFieldStyle? textFieldStyle,
    LMChatDialogStyle? dialogStyle,
    LMChatPopUpMenuStyle? popUpMenuStyle,
    LMChatLoaderStyle? loaderStyle,
    LMChatBottomSheetStyle? bottomSheetStyle,
    LMChatSnackBarStyle? snackBarTheme,
    LMChatImageStyle? imageStyle,
    LMChatVideoStyle? videoStyle,
    LMChatDocumentStyle? documentStyle,
    LMChatGIFStyle? gifStyle,
    LMChatVoiceNoteStyle? voiceNoteStyle,
    LMChatBubbleReplyStyle? replyStyle,
    LMChatBubbleStyle? bubbleStyle,
    LMChatBubbleContentStyle? contentStyle,
    LMChatTileStyle? chatTileStyle,
    LMChatStateBubbleStyle? stateBubbleStyle,
    LMChatAppBarStyle? appBarStyle,
    LMChatReactionBarStyle? reactionBarStyle,
    LMChatReactionBottomSheetStyle? reactionBottomSheetStyle,
    LMChatBubbleReactionsStyle? bubbleReactionsStyle,
    LMChatReactionKeyboardStyle? reactionKeyboardStyle,
    LMChatPollStyle? pollStyle,
  }) {
    return LMChatThemeData(
      isDark: true,
      buttonStyle: buttonStyle ?? LMChatButtonStyle.basic(),
      iconStyle: iconStyle ?? LMChatIconStyle.basic(),
      backgroundColor:
          backgroundColor ?? LMChatDefaultDarkTheme.backgroundColor,
      primaryColor: primaryColor ?? LMChatDefaultDarkTheme.primaryColor,
      secondaryColor: secondaryColor ?? LMChatDefaultDarkTheme.secondaryColor,
      shadowColor: shadowColor ?? LMChatDefaultDarkTheme.shadowColor,
      disabledColor: disabledColor ?? LMChatDefaultDarkTheme.disabledColor,
      errorColor: errorColor ?? LMChatDefaultDarkTheme.errorColor,
      inActiveColor: inActiveColor ?? LMChatDefaultDarkTheme.inactiveColor,
      container: container ?? LMChatDefaultDarkTheme.container,
      scaffold: scaffold ?? LMChatDefaultDarkTheme.container,
      onContainer: onContainer ?? LMChatDefaultDarkTheme.onContainer,
      onPrimary: onPrimary ?? LMChatDefaultDarkTheme.onPrimary,
      hashTagColor: hashTagColor ?? LMChatDefaultDarkTheme.hashTagColor,
      linkColor: linkColor ?? LMChatDefaultDarkTheme.linkColor,
      tagColor: tagColor ?? LMChatDefaultDarkTheme.tagColor,
      textFieldStyle: textFieldStyle ?? LMChatTextFieldStyle.basic(),
      dialogStyle: dialogStyle ?? const LMChatDialogStyle(),
      popUpMenuStyle: popUpMenuStyle ?? const LMChatPopUpMenuStyle(),
      loaderStyle: LMChatLoaderStyle(
        color: primaryColor ?? LMChatDefaultDarkTheme.primaryColor,
      ),
      bottomSheetStyle: bottomSheetStyle ?? const LMChatBottomSheetStyle(),
      snackBarTheme: snackBarTheme ??
          LMChatSnackBarStyle(
            behavior: SnackBarBehavior.floating,
            backgroundColor:
                primaryColor ?? LMChatDefaultDarkTheme.primaryColor,
          ),
      imageStyle: imageStyle ?? LMChatImageStyle.basic(),
      videoStyle: videoStyle ?? LMChatVideoStyle.basic(),
      documentStyle: documentStyle ?? LMChatDocumentStyle.basic(),
      gifStyle: gifStyle ?? LMChatGIFStyle.basic(),
      voiceNoteStyle: voiceNoteStyle ?? LMChatVoiceNoteStyle.basic(),
      replyStyle: replyStyle ?? const LMChatBubbleReplyStyle(),
      bubbleStyle: bubbleStyle ?? LMChatBubbleStyle(),
      contentStyle: contentStyle ??
          LMChatBubbleContentStyle.basic(
              onContainer: LMChatDefaultDarkTheme.onContainer),
      chatTileStyle: chatTileStyle ?? LMChatTileStyle.basic(),
      stateBubbleStyle:
          stateBubbleStyle ?? LMChatStateBubbleStyle.basic(onContainer),
      appBarStyle: appBarStyle ??
          LMChatAppBarStyle.basic(LMChatDefaultDarkTheme.container),
      pollStyle: pollStyle ??
          LMChatPollStyle.basic(
            primaryColor: primaryColor ?? LMChatDefaultDarkTheme.primaryColor,
            containerColor: container ?? LMChatDefaultDarkTheme.container,
            onContainer: onContainer ?? LMChatDefaultDarkTheme.onContainer,
            inActiveColor:
                inActiveColor ?? LMChatDefaultDarkTheme.inactiveColor,
          ),
      reactionBarStyle: reactionBarStyle ?? LMChatReactionBarStyle.basic(),
      reactionBottomSheetStyle:
          reactionBottomSheetStyle ?? LMChatReactionBottomSheetStyle.basic(),
      bubbleReactionsStyle:
          bubbleReactionsStyle ?? LMChatBubbleReactionsStyle.basic(),
      reactionKeyboardStyle:
          reactionKeyboardStyle ?? LMChatReactionKeyboardStyle.basic(),
    );
  }

  /// Creates a copy of the theme data with optional modifications
  LMChatThemeData copyWith({
    Color? primaryColor,
    Color? backgroundColor,
    Color? secondaryColor,
    Color? shadowColor,
    Color? disabledColor,
    Color? errorColor,
    Color? inActiveColor,
    Color? tagColor,
    Color? hashTagColor,
    Color? linkColor,
    Color? container,
    Color? onContainer,
    Color? onPrimary,
    Color? scaffold,
    LMChatButtonStyle? buttonStyle,
    LMChatIconStyle? iconStyle,
    LMChatTextFieldStyle? textFieldStyle,
    LMChatDialogStyle? dialogStyle,
    LMChatPopUpMenuStyle? popUpMenuStyle,
    LMChatLoaderStyle? loaderStyle,
    LMChatBottomSheetStyle? bottomSheetStyle,
    LMChatSnackBarStyle? snackBarTheme,
    LMChatImageStyle? imageStyle,
    LMChatVideoStyle? videoStyle,
    LMChatDocumentStyle? documentStyle,
    LMChatGIFStyle? gifStyle,
    LMChatVoiceNoteStyle? voiceNoteStyle,
    LMChatBubbleReplyStyle? replyStyle,
    LMChatBubbleStyle? bubbleStyle,
    LMChatBubbleContentStyle? contentStyle,
    LMChatTileStyle? chatTileStyle,
    LMChatStateBubbleStyle? stateBubbleStyle,
    LMChatAppBarStyle? appBarStyle,
    LMChatReactionBarStyle? reactionBarStyle,
    LMChatReactionBottomSheetStyle? reactionBottomSheetStyle,
    LMChatBubbleReactionsStyle? bubbleReactionsStyle,
    LMChatReactionKeyboardStyle? reactionKeyboardStyle,
    LMChatPollStyle? pollStyle,
    bool? isDark,
  }) {
    return LMChatThemeData(
      buttonStyle: buttonStyle ?? this.buttonStyle,
      iconStyle: iconStyle ?? this.iconStyle,
      primaryColor: primaryColor ?? this.primaryColor,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      secondaryColor: secondaryColor ?? this.secondaryColor,
      shadowColor: shadowColor ?? this.shadowColor,
      disabledColor: disabledColor ?? this.disabledColor,
      errorColor: errorColor ?? this.errorColor,
      inActiveColor: inActiveColor ?? this.inActiveColor,
      tagColor: tagColor ?? this.tagColor,
      hashTagColor: hashTagColor ?? this.hashTagColor,
      linkColor: linkColor ?? this.linkColor,
      container: container ?? this.container,
      scaffold: scaffold ?? this.scaffold,
      onContainer: onContainer ?? this.onContainer,
      onPrimary: onPrimary ?? this.onPrimary,
      dialogStyle: dialogStyle ?? this.dialogStyle,
      textFieldStyle: textFieldStyle ?? this.textFieldStyle,
      popUpMenuStyle: popUpMenuStyle ?? this.popUpMenuStyle,
      loaderStyle: loaderStyle ?? this.loaderStyle,
      bottomSheetStyle: bottomSheetStyle ?? this.bottomSheetStyle,
      snackBarTheme: snackBarTheme ?? this.snackBarTheme,
      imageStyle: imageStyle ?? this.imageStyle,
      videoStyle: videoStyle ?? this.videoStyle,
      documentStyle: documentStyle ?? this.documentStyle,
      gifStyle: gifStyle ?? this.gifStyle,
      voiceNoteStyle: voiceNoteStyle ?? this.voiceNoteStyle,
      replyStyle: replyStyle ?? this.replyStyle,
      bubbleStyle: bubbleStyle ?? this.bubbleStyle,
      contentStyle: contentStyle ?? this.contentStyle,
      chatTileStyle: chatTileStyle ?? this.chatTileStyle,
      stateBubbleStyle: stateBubbleStyle ?? this.stateBubbleStyle,
      appBarStyle: appBarStyle ?? this.appBarStyle,
      reactionBarStyle: reactionBarStyle ?? this.reactionBarStyle,
      reactionBottomSheetStyle:
          reactionBottomSheetStyle ?? this.reactionBottomSheetStyle,
      bubbleReactionsStyle: bubbleReactionsStyle ?? this.bubbleReactionsStyle,
      reactionKeyboardStyle:
          reactionKeyboardStyle ?? this.reactionKeyboardStyle,
      pollStyle: pollStyle ?? this.pollStyle,
      isDark: isDark ?? this.isDark,
    );
  }
}

class LMChatTextFieldStyle {
  /// Decoration for the input field
  final InputDecoration? inputDecoration;

  /// Text style for the input field
  final TextStyle? textStyle;

  /// Color of the tag in the input field
  final Color? tagColor;

  /// Background color of the suggestions box
  final Color? suggestionsBoxColor;

  /// Elevation of the suggestions box
  final double? suggestionsBoxElevation;

  /// Border radius of the suggestions box
  final BorderRadius? suggestionsBoxBorderRadius;

  /// Constraints for the suggestions box
  final BoxConstraints? suggestionsBoxConstraints;

  /// Padding for the suggestions box
  final EdgeInsets? suggestionsBoxPadding;

  /// Background color of the suggestion item
  final Color? suggestionItemColor;

  /// Padding for the suggestion item
  final EdgeInsets? suggestionItemPadding;

  /// Text style for the suggestion item
  final LMChatTextStyle? suggestionItemTextStyle;

  /// Style for the avatar in the suggestion item
  final LMChatProfilePictureStyle? suggestionItemAvatarStyle;

  /// Whether to show a loading indicator while fetching suggestions
  final bool? showLoadingIndicator;

  /// Custom widget to show when no suggestions are found
  final Widget Function(BuildContext)? noItemsFoundBuilder;

  /// Duration of debounce on the text field
  final Duration? debounceDuration;

  /// margin for the text field
  final EdgeInsets? margin;

  const LMChatTextFieldStyle({
    this.inputDecoration,
    this.textStyle,
    this.tagColor,
    this.suggestionsBoxColor,
    this.suggestionsBoxElevation,
    this.suggestionsBoxBorderRadius,
    this.suggestionsBoxConstraints,
    this.suggestionsBoxPadding,
    this.suggestionItemColor,
    this.suggestionItemPadding,
    this.suggestionItemTextStyle,
    this.suggestionItemAvatarStyle,
    this.noItemsFoundBuilder,
    this.showLoadingIndicator,
    this.debounceDuration,
    this.margin,
  });

  /// Creates a copy of the text field style with optional modifications
  LMChatTextFieldStyle copyWith({
    InputDecoration? inputDecoration,
    TextStyle? textStyle,
    Color? tagColor,
    Color? suggestionsBoxColor,
    double? suggestionsBoxElevation,
    BorderRadius? suggestionsBoxBorderRadius,
    BoxConstraints? suggestionsBoxConstraints,
    EdgeInsets? suggestionsBoxPadding,
    Color? suggestionItemColor,
    Duration? debounceDuration,
    EdgeInsets? suggestionItemPadding,
    LMChatTextStyle? suggestionItemTextStyle,
    LMChatProfilePictureStyle? suggestionItemAvatarStyle,
    EdgeInsets? margin,
  }) {
    return LMChatTextFieldStyle(
      inputDecoration: inputDecoration ?? this.inputDecoration,
      textStyle: textStyle ?? this.textStyle,
      tagColor: tagColor ?? this.tagColor,
      suggestionsBoxColor: suggestionsBoxColor ?? this.suggestionsBoxColor,
      suggestionsBoxElevation:
          suggestionsBoxElevation ?? this.suggestionsBoxElevation,
      suggestionsBoxBorderRadius:
          suggestionsBoxBorderRadius ?? this.suggestionsBoxBorderRadius,
      suggestionsBoxConstraints:
          suggestionsBoxConstraints ?? this.suggestionsBoxConstraints,
      suggestionsBoxPadding:
          suggestionsBoxPadding ?? this.suggestionsBoxPadding,
      suggestionItemColor: suggestionItemColor ?? this.suggestionItemColor,
      suggestionItemPadding:
          suggestionItemPadding ?? this.suggestionItemPadding,
      suggestionItemTextStyle:
          suggestionItemTextStyle ?? this.suggestionItemTextStyle,
      suggestionItemAvatarStyle:
          suggestionItemAvatarStyle ?? this.suggestionItemAvatarStyle,
      debounceDuration: debounceDuration ?? this.debounceDuration,
      margin: margin ?? this.margin,
    );
  }

  /// Creates a basic text field style with default values
  static LMChatTextFieldStyle basic({
    InputDecoration? inputDecoration,
    TextStyle? textStyle,
    Color? tagColor,
    Color? suggestionsBoxColor,
    double? suggestionsBoxElevation,
    BorderRadius? suggestionsBoxBorderRadius,
    BoxConstraints? suggestionsBoxConstraints,
    EdgeInsets? suggestionsBoxPadding,
    Color? suggestionItemColor,
    EdgeInsets? suggestionItemPadding,
    LMChatTextStyle? suggestionItemTextStyle,
    LMChatProfilePictureStyle? suggestionItemAvatarStyle,
  }) {
    return LMChatTextFieldStyle(
      suggestionsBoxElevation: suggestionsBoxElevation ?? 2.0,
      suggestionsBoxBorderRadius:
          suggestionsBoxBorderRadius ?? BorderRadius.circular(8.0),
      suggestionItemAvatarStyle: suggestionItemAvatarStyle,
    );
  }
}

class LMChatPopUpMenuStyle {
  /// Background color of the pop-up menu
  final Color? backgroundColor;

  /// Icon for the pop-up menu
  final LMChatIcon? icon;

  /// Active icon for the pop-up menu
  final LMChatIcon? activeIcon;

  /// Background color when the item is active
  final Color? activeBackgroundColor;

  /// Color of the active item
  final Color? activeColor;

  /// Color of the inactive item
  final Color? inActiveColor;

  /// Width of the pop-up menu
  final double? width;

  /// Height of the pop-up menu
  final double? height;

  /// Border for the pop-up menu
  final Border? border;

  /// Color of the border
  final Color? borderColor;

  /// Width of the border
  final double? borderWidth;

  const LMChatPopUpMenuStyle({
    this.backgroundColor,
    this.icon,
    this.activeIcon,
    this.activeBackgroundColor,
    this.activeColor,
    this.inActiveColor,
    this.width,
    this.height,
    this.border,
    this.borderColor,
    this.borderWidth,
  });

  /// Creates a copy of the pop-up menu style with optional modifications
  LMChatPopUpMenuStyle copyWith({
    Color? backgroundColor,
    LMChatIcon? icon,
    LMChatIcon? activeIcon,
    Color? activeBackgroundColor,
    Color? activeColor,
    Color? inActiveColor,
    double? width,
    double? height,
  }) {
    return LMChatPopUpMenuStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      icon: icon ?? this.icon,
      activeIcon: activeIcon ?? this.activeIcon,
      activeBackgroundColor:
          activeBackgroundColor ?? this.activeBackgroundColor,
      activeColor: activeColor ?? this.activeColor,
      inActiveColor: inActiveColor ?? this.inActiveColor,
      width: width ?? this.width,
      height: height ?? this.height,
    );
  }
}

class LMChatDefaultTheme {
  /// Default background color
  static const Color backgroundColor = Color.fromRGBO(208, 216, 226, 1);

  /// Default primary color
  static const Color primaryColor = Color.fromARGB(255, 50, 105, 200);

  /// Default secondary color
  static const Color secondaryColor = Color.fromARGB(255, 223, 103, 34);

  /// Default shadow color
  static const Color shadowColor = Color.fromRGBO(0, 0, 0, 0.239);

  /// Default disabled color
  static const Color disabledColor = Color.fromRGBO(155, 155, 155, 1);

  /// Default error color
  static const Color errorColor = Color.fromRGBO(251, 22, 9, 1);

  /// Default inactive color
  static const Color inactiveColor = Color.fromRGBO(155, 155, 155, 1);

  /// Default white color
  static const Color whiteColor = Color.fromRGBO(255, 255, 255, 1);

  /// Default grey color
  static const Color greyColor = Color.fromRGBO(102, 102, 102, 1);

  /// Default black color
  static const Color blackColor = Color.fromRGBO(0, 0, 0, 1);

  /// Default tag color
  static const Color tagColor = Color.fromRGBO(0, 122, 255, 1);

  /// Default hashtag color
  static const Color hashTagColor = Color.fromRGBO(0, 122, 255, 1);

  /// Default link color
  static const Color linkColor = Color.fromRGBO(0, 122, 255, 1);

  /// Default heading color
  static const Color headingColor = Color.fromRGBO(51, 51, 51, 1);

  /// Default container color
  static const Color container = whiteColor;

  /// Default on-container color
  static const Color onContainer = blackColor;

  /// Default on-primary color
  static const Color onPrimary = whiteColor;

  /// Default font size for small text
  static const double kFontSmall = 12;

  /// Default font size for buttons
  static const double kButtonFontSize = 12;

  /// Default font size for extra small text
  static const double kFontXSmall = 10;

  /// Default font size for small-medium text
  static const double kFontSmallMed = 14;

  /// Default font size for medium text
  static const double kFontMedium = 16;

  /// Default padding for extra small elements
  static const double kPaddingXSmall = 2;

  /// Default padding for small elements
  static const double kPaddingSmall = 4;

  /// Default padding for medium elements
  static const double kPaddingMedium = 8;

  /// Default padding for large elements
  static const double kPaddingLarge = 16;

  /// Default padding for extra large elements
  static const double kPaddingXLarge = 20;

  /// Default border radius for extra small elements
  static const double kBorderRadiusXSmall = 2;

  /// Default border radius for medium elements
  static const double kBorderRadiusMedium = 8;

  /// Default horizontal padding for extra large elements
  static const SizedBox kHorizontalPaddingXLarge =
      SizedBox(width: kPaddingXLarge);

  /// Default horizontal padding for small elements
  static const SizedBox kHorizontalPaddingSmall =
      SizedBox(width: kPaddingSmall);

  /// Default horizontal padding for extra small elements
  static const SizedBox kHorizontalPaddingXSmall =
      SizedBox(width: kPaddingXSmall);

  /// Default horizontal padding for large elements
  static const SizedBox kHorizontalPaddingLarge =
      SizedBox(width: kPaddingLarge);

  /// Default horizontal padding for medium elements
  static const SizedBox kHorizontalPaddingMedium =
      SizedBox(width: kPaddingMedium);

  /// Default vertical padding for extra large elements
  static const SizedBox kVerticalPaddingXLarge =
      SizedBox(height: kPaddingXLarge);

  /// Default vertical padding for small elements
  static const SizedBox kVerticalPaddingSmall = SizedBox(height: kPaddingSmall);

  /// Default vertical padding for extra small elements
  static const SizedBox kVerticalPaddingXSmall =
      SizedBox(height: kPaddingXSmall);

  /// Default vertical padding for large elements
  static const SizedBox kVerticalPaddingLarge = SizedBox(height: kPaddingLarge);

  /// Default vertical padding for medium elements
  static const SizedBox kVerticalPaddingMedium =
      SizedBox(height: kPaddingMedium);
}

/// Converts a percentage to screen height
extension ScreenHeight on num {
  /// Converts a percentage to screen height
  double get h => (this / 100) * ScreenSize.height;
}

/// Convert integer or double to screen width percentage (w)
extension ScreenWidth on num {
  /// Converts a percentage to screen width
  double get w => (this / 100) * ScreenSize.width;
}

/// Extension to convert double to scaled text size
extension ScreenPoints on double {
  /// Converts a value to scaled text size
  double get sp => ScreenSize.textScale.scale(this);
}

/// Class to initialize the screen size
class ScreenSize {
  /// Width of the screen
  static late double width;

  /// Height of the screen
  static late double height;

  /// Pixel ratio of the screen
  static late double pixelRatio;

  /// Text scaler for the screen
  static late TextScaler textScale;

  /// Block size for horizontal layout
  static late double blockSizeHorizontal;

  /// Block size for vertical layout
  static late double blockSizeVertical;

  /// Safe area horizontal padding
  static late double _safeAreaHorizontal;

  /// Safe area vertical padding
  static late double _safeAreaVertical;

  /// Safe block size for horizontal layout
  static late double safeBlockHorizontal;

  /// Safe block size for vertical layout
  static late double safeBlockVertical;

  /// Initializes the screen size based on the provided context
  static init(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);
    pixelRatio = mediaQuery.devicePixelRatio;
    textScale = mediaQuery.textScaler;
    width = mediaQuery.size.width;
    height = mediaQuery.size.height;
    blockSizeHorizontal = width / 100;
    blockSizeVertical = height / 100;
    _safeAreaHorizontal = mediaQuery.padding.left + mediaQuery.padding.right;
    _safeAreaVertical = mediaQuery.padding.top + mediaQuery.padding.bottom;
    safeBlockHorizontal = (width - _safeAreaHorizontal) / 100;
    safeBlockVertical = (height - _safeAreaVertical) / 100;
  }
}

/// Default dark theme colors and values for the LMChat UI
class LMChatDefaultDarkTheme {
  /// Default background color for dark theme
  static const Color backgroundColor = Color.fromRGBO(18, 18, 18, 1);

  /// Default primary color for dark theme
  static const Color primaryColor = Color.fromARGB(255, 50, 105, 200);

  /// Default secondary color for dark theme
  static const Color secondaryColor = Color.fromARGB(255, 255, 122, 48);

  /// Default shadow color for dark theme
  static const Color shadowColor = Color.fromRGBO(0, 0, 0, 0.5);

  /// Default disabled color for dark theme
  static const Color disabledColor = Color.fromRGBO(128, 128, 128, 1);

  /// Default error color for dark theme
  static const Color errorColor = Color.fromRGBO(255, 82, 82, 1);

  /// Default inactive color for dark theme
  static const Color inactiveColor = Color.fromRGBO(97, 97, 97, 1);

  /// Default white color for dark theme (darker shade for contrast)
  static const Color whiteColor = Color.fromRGBO(242, 242, 242, 1);

  /// Default grey color for dark theme
  static const Color greyColor = Color.fromRGBO(189, 189, 189, 1);

  /// Default black color for dark theme
  static const Color blackColor = Color.fromRGBO(18, 18, 18, 1);

  /// Default tag color for dark theme
  static const Color tagColor = Color.fromRGBO(33, 150, 243, 1);

  /// Default hashtag color for dark theme
  static const Color hashTagColor = Color.fromRGBO(33, 150, 243, 1);

  /// Default link color for dark theme
  static const Color linkColor = Color.fromRGBO(33, 150, 243, 1);

  /// Default heading color for dark theme
  static const Color headingColor = Color.fromRGBO(242, 242, 242, 1);

  /// Default container color for dark theme
  static const Color container = Color.fromRGBO(30, 30, 30, 1);

  /// Default on-container color for dark theme
  static const Color onContainer = whiteColor;

  /// Default on-primary color for dark theme
  static const Color onPrimary = whiteColor;

  // Reuse the same sizing constants from LMChatDefaultTheme
  static const double kFontSmall = LMChatDefaultTheme.kFontSmall;
  static const double kButtonFontSize = LMChatDefaultTheme.kButtonFontSize;
  static const double kFontXSmall = LMChatDefaultTheme.kFontXSmall;
  static const double kFontSmallMed = LMChatDefaultTheme.kFontSmallMed;
  static const double kFontMedium = LMChatDefaultTheme.kFontMedium;
  static const double kPaddingXSmall = LMChatDefaultTheme.kPaddingXSmall;
  static const double kPaddingSmall = LMChatDefaultTheme.kPaddingSmall;
  static const double kPaddingMedium = LMChatDefaultTheme.kPaddingMedium;
  static const double kPaddingLarge = LMChatDefaultTheme.kPaddingLarge;
  static const double kPaddingXLarge = LMChatDefaultTheme.kPaddingXLarge;
  static const double kBorderRadiusXSmall =
      LMChatDefaultTheme.kBorderRadiusXSmall;
  static const double kBorderRadiusMedium =
      LMChatDefaultTheme.kBorderRadiusMedium;

  // Reuse the same spacing widgets from LMChatDefaultTheme
  static const SizedBox kHorizontalPaddingXLarge =
      LMChatDefaultTheme.kHorizontalPaddingXLarge;
  static const SizedBox kHorizontalPaddingSmall =
      LMChatDefaultTheme.kHorizontalPaddingSmall;
  static const SizedBox kHorizontalPaddingXSmall =
      LMChatDefaultTheme.kHorizontalPaddingXSmall;
  static const SizedBox kHorizontalPaddingLarge =
      LMChatDefaultTheme.kHorizontalPaddingLarge;
  static const SizedBox kHorizontalPaddingMedium =
      LMChatDefaultTheme.kHorizontalPaddingMedium;
  static const SizedBox kVerticalPaddingXLarge =
      LMChatDefaultTheme.kVerticalPaddingXLarge;
  static const SizedBox kVerticalPaddingSmall =
      LMChatDefaultTheme.kVerticalPaddingSmall;
  static const SizedBox kVerticalPaddingXSmall =
      LMChatDefaultTheme.kVerticalPaddingXSmall;
  static const SizedBox kVerticalPaddingLarge =
      LMChatDefaultTheme.kVerticalPaddingLarge;
  static const SizedBox kVerticalPaddingMedium =
      LMChatDefaultTheme.kVerticalPaddingMedium;
}



================================================
File: lib/packages/ui/lib/src/utils/enums.dart
================================================
/// Describes the type of icon that can be used in LMChatIcon
///
/// [icon] - For using IconData icons
/// [svg] - For using SVG assets
/// [png] - For using PNG image assets
enum LMChatIconType {
  /// Uses IconData icons from Flutter's icon system
  icon,

  /// Uses SVG asset files
  svg,

  /// Uses PNG image files
  png,
}

/// Specifies the placement position of an icon within a button
///
/// [start] - Icon is placed at the start/beginning of the button
/// [end] - Icon is placed at the end of the button
enum LMChatIconButtonPlacement {
  /// Places icon at the start/beginning of the button
  start,

  /// Places icon at the end of the button
  end,
}

/// Defines different sorting/filtering options for exploring chatrooms
///
/// [newest] - Sort chatrooms by creation date (newest first)
/// [mostMessages] - Sort chatrooms by number of messages (highest first)
/// [mostParticipants] - Sort chatrooms by number of participants (highest first)
/// [active] - Show only active chatrooms
enum LMChatSpace {
  /// Sort chatrooms by creation date (newest first)
  newest,

  /// Sort chatrooms by number of messages (highest first)
  mostMessages,

  /// Sort chatrooms by number of participants (highest first)
  mostParticipants,

  /// Show only active chatrooms
  active,
}

/// Specifies the type of selection for a chatroom
///
/// [appbar] - Selection is done through the app bar
/// [floating] - Selection is done through a floating action button
/// [bottomsheet] - Selection is done through a bottom sheet
enum LMChatSelectionType {
  /// Selection is done through the app bar
  appbar,

  /// Selection is done through a floating action button
  floating,

  /// Selection is done through a bottom sheet
  bottomsheet,
}



================================================
File: lib/packages/ui/lib/src/utils/helpers.dart
================================================



================================================
File: lib/packages/ui/lib/src/utils/typedefs.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

/// {@template lm_context_widget_builder}
/// The context widget builder function for the chat screen.
/// This function is called to build the context widget for the chat screen.
/// The [LMContextWidgetBuilder] function takes one parameter:
/// - [BuildContext] context: The context.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMContextWidgetBuilder = Widget Function(BuildContext context);

/// {@template lm_chat_error_handler}
/// The error handler function for the chat.
/// This function is called when an error occurs in the chat.
/// The [LMChatErrorHandler] function takes two parameters:
/// - [String] errorMessage: The error message.
/// - [StackTrace] stackTrace: The stack
/// {@endtemplate}
typedef LMChatErrorHandler = Function(String, StackTrace);

/// {@template lm_chat_button_builder}
/// The button builder function for the chat.
/// This function is called to build the button for the chat.
/// The [LMChatButtonBuilder] function takes one parameter:
/// - [LMChatButton] olButton: The old button.
/// The function returns a [Widget] widget.
/// {@endtemplate}
typedef LMChatButtonBuilder = Widget Function(LMChatButton olButton);

/// {@template lm_chat_home_app_bar_builder}
/// The app bar builder function for the chat home screen.
/// This function is called to build the app bar for the chat home screen.
/// The [LMChatHomeAppBarBuilder] function takes two parameters:
/// - [LMChatUserViewData] currentUser: The current user.
/// - [LMChatAppBar] oldAppBar: The old app bar.
/// The function returns a [LMChatAppBar] widget.
/// {@endtemplate}
typedef LMChatHomeAppBarBuilder = LMChatAppBar Function(
  LMChatUserViewData currentUser,
  LMChatAppBar oldAppBar,
);

/// {@template lm_chat_home_tile_builder}
/// The tile builder function for the chat home screen.
/// This function is called to build the tile for the chat home screen.
/// The [LMChatHomeTileBuilder] function takes two parameters:
/// - [LMChatUserViewData] user: The user.
/// - [LMChatTile] oldTile: The old tile.
/// The function returns a [LMChatTile] widget.
/// {@endtemplate}

typedef LMChatroomAppBarBuilder = LMChatAppBar Function(
  LMChatRoomViewData chatrooom,
  LMChatAppBar oldAppBar,
);

/// {@template lm_chat_app_bar_builder}
/// The app bar builder function for the any screen.
/// This function is called to build the app bar for the chat screen.
/// The [LMChatAppBarBuilder] function takes one parameter:
/// - [LMChatAppBar] oldAppBar: The old app bar.
/// The function returns a [LMChatAppBar] widget.
/// {@endtemplate}
typedef LMChatAppBarBuilder = LMChatAppBar Function(
  LMChatAppBar oldAppBar,
);

/// {@template lm_chatroom_tile_builder}
/// The tile builder function for the chat room screen.
/// This function is called to build the tile for the chat room screen.
/// The [LMChatroomTileBuilder] function takes two parameters:
/// - [LMChatRoomViewData] chatroom: The chat room.
/// - [LMChatTile] oldTile: The old tile.
/// The function returns a [LMChatTile] widget.
/// {@endtemplate}

typedef LMChatroomTileBuilder = LMChatTile Function(
  LMChatRoomViewData chatroom,
  LMChatTile oldTile,
);

/// {@template lm_chat_bubble_builder}
/// this function is called to build the chat bubble for the chat screen.
/// The [LMChatBubbleBuilder] function takes three parameters:
/// - [LMChatConversationViewData] conversation: The conversation.
/// - [LMChatUserViewData] user: The user.
/// - [LMChatBubble] oldBubble: The old bubble.
/// The function returns a [LMChatBubble] widget.
/// {@endtemplate}
typedef LMChatBubbleBuilder = Widget Function(
  LMChatConversationViewData conversation,
  LMChatUserViewData user,
  LMChatBubble oldBubble,
);

/// {@template lm_chat_state_bubble_builder}
/// The state bubble builder function for the chat screen.
/// This function is called to build the state bubble for the chat screen.
/// The [LMChatStateBubbleBuilder] function takes two parameters:
/// - [String] message: The message.
/// - [LMChatStateBubble] oldStateBubble: The old state bubble.
/// The function returns a [LMChatStateBubble] widget.
/// {@endtemplate}
typedef LMChatStateBubbleBuilder = Widget Function(
  String message,
  LMChatStateBubble oldStateBubble,
);

/// {@template lm_chat_context_widget_builder}
/// The context widget builder function for the chat screen.
/// This function is called to build the context widget for the chat screen.
/// The [LMChatContextWidgetBuilder] function takes one parameter:
/// - [BuildContext] context: The context.
/// The function returns a [Widget].
/// {@endtemplate}

typedef LMChatContextWidgetBuilder = Widget Function(BuildContext context);

/// {@template lm_chatroom_chat_bar_builder}
/// The chat bar builder function for the chat room screen.
/// This function is called to build the chat bar for the chat room screen.
/// The [LMChatroomChatBarBuilder] function takes two parameters:
/// - [LMChatRoomViewData] chatroom: The chat room.
/// - [Function] onMessageSent: The on message sent function.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatroomChatBarBuilder = Widget Function(
  LMChatRoomViewData chatroom,
  Function onMessageSent,
);

/// {@template lm_chat_tile_builder}
/// The tile builder function for the chat screen.
/// This function is called to build the tile for the chat screen.
/// The [LMChatTileBuilder] function takes two parameters:
/// - [LMChatConversationViewData] conversation: The conversation.
/// - [LMChatTile] oldTile: The old tile.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatUserTileBuilder = Widget Function(
  BuildContext context,
  LMChatUserViewData user,
  LMChatUserTile oldUserTile,
);

/// {@template lm_chat_image_widget_builder}
/// The image widget builder function for the chat screen.
/// This function is called to build the image widget for the chat screen.
/// The [LMChatImageBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The image attachment.
/// - [LMChatImage] oldWidget: The old image widget.
/// The function returns an [Widget].
/// {@endtemplate}
typedef LMChatImageBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatImage oldWidget,
);

/// {@template lm_chat_video_widget_builder}
/// The video widget builder function for the chat screen.
/// This function is called to build the video widget for the chat screen.
/// The [LMChatVideoBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The video attachment.
/// - [LMChatVideo] oldWidget: The old video widget.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatVideoBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatVideo oldWidget,
);

/// {@template lm_chat_gif_widget_builder}
/// The gif widget builder function for the chat screen.
/// This function is called to build the gif widget for the chat screen.
/// The [LMChatGIFBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The video attachment.
/// - [LMChatGIF] oldWidget: The old video widget.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatGIFBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatGIF oldWidget,
);

/// {@template lm_chat_voice_note_widget_builder}
/// The voice note widget builder function for the chat screen.
/// This function is called to build the voice note widget for the chat screen.
/// The [LMChatVoiceNoteBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The voice note attachment.
/// - [LMChatVoiceNote] oldWidget: The old audio widget.
/// The function returns an [Widget].
/// {@endtemplate}
typedef LMChatVoiceNoteBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatVoiceNote oldWidget,
);

/// {@template lm_chat_document_widget_builder}
/// The document widget builder function for the chat screen.
/// This function is called to build the document widget for the chat screen.
/// The [LMChatDocumentTilePreviewBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The document attachment.
/// - [LMChatDocumentTilePreview] oldWidget: The old document widget.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatDocumentTilePreviewBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatDocumentTilePreview oldWidget,
);

/// {@template lm_chat_document_widget_builder}
/// The document widget builder function for the chat screen.
/// This function is called to build the document widget for the chat screen.
/// The [LMChatDocumentPreviewBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The document attachment.
/// - [LMChatDocumentPreview] oldWidget: The old document widget.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatDocumentPreviewBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatDocumentPreview oldWidget,
);

/// {@template lm_chat_document_thumbnail_widget_builder}
/// The document thumbnail widget builder function for the chat screen.
/// This function is called to build the document thumbnail widget for the chat screen.
/// The [LMChatDocumentThumbnailBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The document attachment.
/// - [LMChatDocumentThumbnail] oldWidget: The old document thumbnail widget.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatDocumentThumbnailBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatDocumentThumbnail oldWidget,
);

/// {@template lm_chat_document_tile_widget_builder}
/// The document tile widget builder function for the chat screen.
/// This function is called to build the document tile widget for the chat screen.
/// The [LMChatDocumentTileBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatAttachmentViewData] attachment: The document attachment.
/// - [LMChatDocumentTile] oldWidget: The old document tile widget.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatDocumentTileBuilder = Widget Function(
  BuildContext context,
  LMChatAttachmentViewData attachment,
  LMChatDocumentTile oldWidget,
);

/// {@template lm_chat_text_builder}
/// The text builder function for the chat screen.
/// This function is called to build the text for the chat screen.
/// The [LMChatTextBuilder] function takes two parameters:
/// - [BuildContext] context: The context.
/// - [LMChatText] text: The text.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatTextBuilder = Widget Function(
  BuildContext,
  LMChatText,
);

/// {@template lm_chat_poll_builder}
/// The poll builder function for the chat screen.
/// This function is called to build the poll for the chat screen.
/// The [LMChatPollBuilder] function takes three parameters:
/// - [BuildContext] context: The context.
/// - [LMChatPoll] poll: The poll.
/// - [LMChatConversationViewData] conversation: The conversation.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatPollBuilder = Widget Function(
  BuildContext context,
  LMChatPoll poll,
  LMChatConversationViewData conversation,
);

/// {@template lm_chat_icon_builder}
/// The icon builder function for the chat screen.
/// This function is called to build the icon for the chat screen.
/// The [LMChatIconBuilder] function takes two parameters:
/// - [BuildContext] context: The context.
/// - [LMChatIcon] icon: The icon.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatIconBuilder = Widget Function(
  BuildContext context,
  LMChatIcon icon,
);

/// {@template lm_chat_profile_picture_builder}
/// The profile picture builder function for the chat screen.
/// This function is called to build the profile picture for the chat screen.
/// The [LMChatProfilePictureBuilder] function takes two parameters:
/// - [BuildContext] context: The context.
/// - [LMChatProfilePicture] profilePicture: The profile picture.
/// The function returns a [Widget].
/// {@endtemplate}
typedef LMChatProfilePictureBuilder = Widget? Function(
  BuildContext context,
  LMChatProfilePicture? profilePicture,
);



================================================
File: lib/packages/ui/lib/src/utils/utils.dart
================================================
export 'enums.dart';
export 'typedefs.dart';

export 'time_ago/time_ago.dart';
export 'time_ago/time_ago_message.dart';
export 'constants/constants.dart';
export 'constants/assets.dart';

export 'helpers/tagging_helper.dart';
export 'helpers/text_helper.dart';

export 'helpers/conversation_helper.dart';

export 'conversation/conversation_utils.dart';

export 'media/media_utils.dart';
export 'media/audio_handler.dart';

/// Returns the initials of a given name.
///
/// The initials are generated by taking the first character of each word in the name,
/// up to a maximum of two initials.
String getInitials(String name) => name.isNotEmpty
    ? name
        .trim()
        .split(' ')
        .where((element) => element.isNotEmpty)
        .map((l) => l[0])
        .take(2)
        .join()
    : '';



================================================
File: lib/packages/ui/lib/src/utils/constants/assets.dart
================================================
/// poll icon path
const String kPollIcon =
    'packages/likeminds_chat_flutter_ui/assets/icons/poll.svg';

/// tick icon path
const String kTickIcon =
    'packages/likeminds_chat_flutter_ui/assets/icons/tick.svg';

/// document icon path
const String kDocumentIcon =
    'packages/likeminds_chat_flutter_ui/assets/icons/document.svg';

/// chatbot icon path
const String kChatbotIcon =
    'packages/likeminds_chat_flutter_ui/assets/icons/chatbot.svg';



================================================
File: lib/packages/ui/lib/src/utils/constants/constants.dart
================================================
import 'package:flutter/material.dart';

/// Regular expression for links and tags
const String kRegexLinksAndTags =
    r'(?:(?:http|https|ftp|www)\:\/\/)?[a-zA-Z0-9\-\.]+\.[a-zA-Z]{1,}(?::[a-zA-Z0-9]*)?\/?[^\s\n]+|[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}|<<([^<>]+)\|route://member/([a-zA-Z-0-9]+)>>|<<@participants\|route://participants>>|<<([^<>]+)\|route://user_profile/([^<>]+)>>|(\*\*[^*]+\*\*)';

/// Attachment type constant for images
const String kAttachmentTypeImage = "image";

/// Attachment type constant for videos
const String kAttachmentTypeVideo = "video";

/// Attachment type constant for audio files
const String kAttachmentTypeAudio = "audio";

/// Attachment type constant for PDF files
const String kAttachmentTypePDF = "pdf";

/// Attachment type constant for GIFs
const String kAttachmentTypeGIF = "gif";

/// Attachment type constant for links
const String kAttachmentTypeLink = "link";

/// Attachment type constant for voice notes
const String kAttachmentTypeVoiceNote = "voice_note";

/// Font size constant for small text
const double kFontSmall = 12;

/// Font size constant for button text
const double kButtonFontSize = 12;

/// Font size constant for extra small text
const double kFontXSmall = 11;

/// Font size constant for small-medium text
const double kFontSmallMed = 14;

/// Font size constant for medium text
const double kFontMedium = 16;

/// Padding constant for extra small padding
const double kPaddingXSmall = 2;

/// Padding constant for small padding
const double kPaddingSmall = 4;

/// Padding constant for medium padding
const double kPaddingMedium = 8;

/// Padding constant for large padding
const double kPaddingLarge = 16;

/// Padding constant for extra large padding
const double kPaddingXLarge = 20;

/// Border radius constant for extra small radius
const double kBorderRadiusXSmall = 2;

/// Border radius constant for medium radius
const double kBorderRadiusMedium = 8;

/// Horizontal padding constant for extra large padding
const SizedBox kHorizontalPaddingXLarge = SizedBox(width: kPaddingXLarge);

/// Horizontal padding constant for small padding
const SizedBox kHorizontalPaddingSmall = SizedBox(width: kPaddingSmall);

/// Horizontal padding constant for extra small padding
const SizedBox kHorizontalPaddingXSmall = SizedBox(width: kPaddingXSmall);

/// Horizontal padding constant for large padding
const SizedBox kHorizontalPaddingLarge = SizedBox(width: kPaddingLarge);

/// Horizontal padding constant for medium padding
const SizedBox kHorizontalPaddingMedium = SizedBox(width: kPaddingMedium);

/// Vertical padding constant for extra large padding
const SizedBox kVerticalPaddingXLarge = SizedBox(height: kPaddingXLarge);

/// Vertical padding constant for small padding
const SizedBox kVerticalPaddingSmall = SizedBox(height: kPaddingSmall);

/// Vertical padding constant for extra small padding
const SizedBox kVerticalPaddingXSmall = SizedBox(height: kPaddingXSmall);

/// Vertical padding constant for large padding
const SizedBox kVerticalPaddingLarge = SizedBox(height: kPaddingLarge);

/// Vertical padding constant for medium padding
const SizedBox kVerticalPaddingMedium = SizedBox(height: kPaddingMedium);



================================================
File: lib/packages/ui/lib/src/utils/conversation/conversation_utils.dart
================================================
import 'package:flutter/material.dart';

/// Returns the global position of the chat bubble widget.
///
/// Takes a [GlobalKey] as a parameter and returns the [Offset] of the widget's position.
/// If the widget is not found, it returns an offset of (0, 0).
Offset getPositionOfChatBubble(GlobalKey widgetKey) {
  RenderBox? renderBox =
      widgetKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) {
    return const Offset(0, 0);
  }

  final Offset offset = renderBox.localToGlobal(Offset.zero);
  return offset;
}

/// Returns the height of the widget associated with the given [GlobalKey].
///
/// If the widget is not found, it returns null.
double? getHeightOfWidget(GlobalKey widgetKey) {
  RenderBox? renderBox =
      widgetKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) {
    return null;
  }
  return renderBox.size.height;
}

/// Returns the width of the widget associated with the given [GlobalKey].
///
/// If the widget is not found, it returns null.
double? getWidthOfWidget(GlobalKey widgetKey) {
  RenderBox? renderBox =
      widgetKey.currentContext?.findRenderObject() as RenderBox?;
  if (renderBox == null) {
    return null;
  }
  return renderBox.size.width;
}



================================================
File: lib/packages/ui/lib/src/utils/helpers/conversation_helper.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_conversation_action_interface}
/// The interface for the chat conversation actions.
/// {@endtemplate}
abstract class LMChatConversationActionInterface {
  /// The function to call when a reply is made.
  void onReply(LMChatConversationViewData conversation);

  /// The function to call when a copy is made.
  void onCopy(List<LMChatConversationViewData> conversations);

  /// The function to call when an edit is made.
  void onEdit(LMChatConversationViewData conversation);

  /// The function to call when a delete is made.
  void onDelete(BuildContext context, List<int> conversationIds);

  /// The function to call when a report is made.
  void onReport(LMChatConversationViewData conversation, BuildContext context);

  /// The function to call when a reaction is made.
  void onReaction();

  /// The function to call when the menu is shown.
  void showSelectionMenu(BuildContext context, Offset? position);
}



================================================
File: lib/packages/ui/lib/src/utils/helpers/tagging_helper.dart
================================================
// ignore: depend_on_referenced_packages
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';

class LMChatTaggingHelper {
  LMChatTagViewData? userTag;
  static final RegExp tagRegExp = RegExp(r'@([^<>~]+)~');
  static RegExp routeRegExp =
      RegExp(r'<<([^<>]+)\|route://([^<>]+)\/([a-zA-Z0-9]+)>>');
  static const String linkRoute =
      r'(?:(?:https?|ftp):\/\/)?[\w/\-?=%.]+\.[\w/\-?=%.]+|(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b)';

  /// Encodes the string with the user tags and returns the encoded string
  static String encodeString(String string, List<LMChatTagViewData> userTags) {
    final Iterable<RegExpMatch> matches = tagRegExp.allMatches(string);
    for (final match in matches) {
      final String tag = match.group(1)!;
      final LMChatTagViewData? tagData = userTags.firstWhereOrNull(
          (element) => (element.name == tag || element.name == '@$tag'));
      if (tagData != null) {
        if (tagData.tagType == LMTagType.groupTag) {
          string = string.replaceAll('@$tag~', tagData.tag!);
        } else {
          string = string.replaceAll('@$tag~',
              '<<${tagData.name}|route://user_profile/${tagData.sdkClientInfoViewData?.uuid ?? tagData.uuid}>>');
        }
      }
    }
    return string;
  }

  /// Decodes the string with the user tags and returns the decoded string
  static Map<String, String> decodeString(String string) {
    Map<String, String> result = {};
    final RegExp routeRegExp = RegExp(
        r'<<([^<>]+)\|route://(?:member|user_profile|participants)/([^<>]+)>>');
    final Iterable<RegExpMatch> matches = routeRegExp.allMatches(string);

    for (final match in matches) {
      final String tag = match.group(1)!;
      final String id = match.group(2)!;
      string = string.replaceAll('<<$tag|route://member/$id>>', '@$tag');
      string = string.replaceAll('<<$tag|route://user_profile/$id>>', '@$tag');
      result.addAll({'@$tag': id});
    }

    // Handle the participants case
    if (string.contains('participants')) {
      result.addAll({'@participants': 'participants'});
    }

    return result;
  }

  /// Matches the tags in the string and returns the list of matched tags
  static List<LMChatTagViewData> matchTags(
      String text, List<LMChatTagViewData> items) {
    final List<LMChatTagViewData> tags = [];
    final Iterable<RegExpMatch> matches = tagRegExp.allMatches(text);
    for (final match in matches) {
      final String tag = match.group(1)!;
      final LMChatTagViewData? userTag = items.firstWhereOrNull((element) {
        return (element.name == tag || element.name == '@$tag');
      });
      if (userTag != null) {
        tags.add(userTag);
      }
    }
    return tags;
  }

  static void routeToProfile(String userId) {
    debugPrint(userId);
  }

  static String? convertRouteToTag(String? text, {bool withTilde = true}) {
    if (text == null) return "";
    Map<String, String> result = {};
    final RegExp routeRegExp = RegExp(
        r'<<([^<>]+)\|route://(?:member|user_profile|participants)/([^<>]+)>>');
    final Iterable<RegExpMatch> matches = routeRegExp.allMatches(text);

    for (final match in matches) {
      final String tag = match.group(1)!;
      final String id = match.group(2)!;
      text = text!.replaceAll(
          '<<$tag|route://member/$id>>', withTilde ? '@$tag~' : '@$tag');
      text = text.replaceAll(
          '<<$tag|route://user_profile/$id>>', withTilde ? '@$tag~' : '@$tag');
      result.addAll({'@$tag': id});
    }

    // Handle the participants case
    if (text!.contains('participants')) {
      result.addAll({'@participants': 'participants'});
      text = text.replaceAll(
          '<<@participants|route://participants>>', '@participants');
    }

    return text;
  }

  static Map<String, dynamic> convertRouteToTagAndUserMap(String text,
      {bool withTilde = true}) {
    final Iterable<RegExpMatch> matches = routeRegExp.allMatches(text);
    List<LMChatTagViewData> tags = [];
    for (final match in matches) {
      final String tag = match.group(1) ?? match.group(4)!;
      final String? mid = match.group(2);
      final String? id = match.group(3);
      if (id != null) {
        text = text.replaceAll(
            '<<$tag|route://$mid/$id>>', withTilde ? '@$tag~' : '@$tag');
      } else {
        text = text.replaceAll('<<@participants|route://participants>>', tag);
      }
      tags.add(
        (LMChatTagViewDataBuilder()
              ..name(tag)
              ..id(int.tryParse(id ?? '')))
            .build(),
      );
    }
    return {'text': text, 'userTags': tags};
  }

  static List<LMChatTagViewData> addUserTagsIfMatched(String input) {
    final RegExp routeRegExp = RegExp(
        r'<<([^<>]+)\|route://(?:member|user_profile|participants)/([^<>]+)>>');
    final Iterable<RegExpMatch> matches = routeRegExp.allMatches(input);
    List<LMChatTagViewData> userTags = [];

    for (final match in matches) {
      final String tag = match.group(1)!;
      final String id = match.group(2)!;
      userTags.add(
        (LMChatTagViewDataBuilder()
              ..name(tag)
              ..id(int.tryParse(id)))
            .build(),
      );
    }
    return userTags;
  }

  static String extractStateMessage(String input) {
    final RegExp stateRegex = RegExp(r"(?<=\<\<).+?(?=\|)");
    final RegExp tagRegex = RegExp(r"<<(?<=\<\<).+?(?=\>\>)>>");
    final Iterable<RegExpMatch> matches = tagRegex.allMatches(input);
    for (RegExpMatch match in matches) {
      final String? routeTag = match.group(0);
      final String? userName = stateRegex.firstMatch(routeTag!)?.group(0);
      input = input.replaceAll(routeTag, '$userName');
    }
    return input;
  }

  static String extractFirstDMStateMessage(
      LMChatConversationViewData input, LMChatUserViewData user) {
    String result = input.answer;
    final RegExp tagRegex = RegExp(r"<<(?<=\<\<).+?(?=\>\>)>>");
    final Iterable<RegExpMatch> matches = tagRegex.allMatches(input.answer);
    for (RegExpMatch match in matches) {
      final String? routeTag = match.group(0);
      final String? userName = routeRegExp.firstMatch(routeTag!)?.group(1);
      final String? userId = routeRegExp.firstMatch(routeTag)?.group(3);
      if (user.id != int.parse(userId!)) {
        result = result.replaceAll(" $routeTag", ' $userName');
      } else {
        result = result.replaceAll(" $routeTag", '');
      }
    }
    return result;
  }

  static List<String> extractLinkFromString(String text) {
    RegExp exp = RegExp(linkRoute);
    Iterable<RegExpMatch> matches = exp.allMatches(text);
    List<String> links = [];
    for (var match in matches) {
      String link = text.substring(match.start, match.end);
      if (link.isNotEmpty && match.group(1) == null) {
        links.add(link);
      }
    }
    if (links.isNotEmpty) {
      return links;
    } else {
      return [];
    }
  }

  static String getFirstValidLinkFromString(String text) {
    try {
      List<String> links = extractLinkFromString(text);
      List<String> validLinks = [];
      String validLink = '';
      if (links.isNotEmpty) {
        for (String link in links) {
          if (Uri.parse(link).isAbsolute) {
            validLinks.add(link);
          } else {
            link = "https://$link";
            if (Uri.parse(link).isAbsolute) {
              validLinks.add(link);
            }
          }
        }
      }
      if (validLinks.isNotEmpty) {
        validLink = validLinks.first;
      }
      return validLink;
    } catch (e) {
      return '';
    }
  }
}



================================================
File: lib/packages/ui/lib/src/utils/helpers/text_helper.dart
================================================
import 'package:flutter/foundation.dart';
import 'package:likeminds_chat_flutter_ui/packages/linkify/linkify.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/helpers/tagging_helper.dart';

List<String> extractLinkFromString(String text) {
  RegExp exp = RegExp(LMChatTaggingHelper.linkRoute);
  Iterable<RegExpMatch> matches = exp.allMatches(text);
  List<String> links = [];
  for (var match in matches) {
    String link = text.substring(match.start, match.end);
    if (link.isNotEmpty && match.group(1) == null) {
      links.add(link);
    }
  }
  if (links.isNotEmpty) {
    return links;
  } else {
    return [];
  }
}

String getFirstValidLinkFromString(String text) {
  try {
    List<String> links = extractLinkFromString(text);
    List<String> validLinks = [];
    String validLink = '';
    if (links.isNotEmpty) {
      for (String link in links) {
        if (Uri.parse(link).isAbsolute) {
          validLinks.add(link);
        } else {
          link = "https://$link";
          if (Uri.parse(link).isAbsolute) {
            validLinks.add(link);
          }
        }
      }
    }
    if (validLinks.isNotEmpty) {
      validLink = validLinks.first;
    }
    return validLink;
  } on Exception catch (e, stacktrace) {
    debugPrint(e.toString());
    debugPrintStack(stackTrace: stacktrace);
    return '';
  }
}

LinkifyElement? extractLinkAndEmailFromString(String text) {
  final urls = linkify(text, linkifiers: [
    const EmailLinkifier(),
    const UrlLinkifier(),
  ]);
  if (urls.isNotEmpty) {
    if (urls.first is EmailElement || urls.first is UrlElement) {
      return urls.first;
    }
  }
  final links = linkify(text,
      options: const LinkifyOptions(
        looseUrl: true,
      ),
      linkifiers: [
        const EmailLinkifier(),
        const UrlLinkifier(),
      ]);
  if (links.isNotEmpty) {
    if (links.first is EmailElement || links.first is UrlElement) {
      return links.first;
    }
  }
  return null;
}



================================================
File: lib/packages/ui/lib/src/utils/media/attachment_convertor.dart
================================================
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// [MediaConvertor] is an extension on [LMChatAttachmentViewData] class.
/// It converts [LMChatAttachmentViewData] to [LMChatMediaModel].
extension MediaConvertor on LMChatAttachmentViewData {
  /// Converts [LMChatAttachmentViewData] to [LMChatMediaModel]
  LMChatMediaModel toMediaModel() {
    return LMChatMediaModel(
      mediaType: mapStringToMediaType(type!),
      mediaUrl: url ?? fileUrl,
      mediaFile: attachmentFile,
      thumbnailUrl: thumbnailUrl,
      thumbnailFile: thumbnailFile,
      meta: meta,
      height: height,
      width: width,
    );
  }
}

/// [MediaConvertor] is an extension on [LMChatAttachmentViewData] class.
/// It converts [LMChatAttachmentViewData] to [LMChatMediaModel].
extension ViewDataConvertor on LMChatMediaModel {
  /// Converts [LMChatAttachmentViewData] to [LMChatMediaModel]
  LMChatAttachmentViewData toAttachmentViewData() {
    final LMChatAttachmentViewDataBuilder attachmentBuilder =
        LMChatAttachmentViewDataBuilder()
          ..attachmentFile(mediaFile)
          ..fileUrl(mediaUrl)
          ..height(height)
          ..width(width)
          ..meta(meta)
          ..thumbnailFile(thumbnailFile)
          ..thumbnailUrl(thumbnailUrl)
          ..type(mapMediaTypeToString(mediaType))
          ..url(mediaUrl);

    return attachmentBuilder.build();
  }
}



================================================
File: lib/packages/ui/lib/src/utils/media/audio_handler.dart
================================================
import 'dart:async';
import 'package:flutter_sound/flutter_sound.dart';

/// Enum to represent audio states
enum LMChatAudioState { stopped, recording, playing, paused }

/// Class to hold playback progress information
class PlaybackProgress {
  final Duration duration;
  final Duration position;
  final bool isCompleted;

  const PlaybackProgress({
    required this.duration,
    required this.position,
    this.isCompleted = false,
  });
}

/// Abstract class defining the interface for audio handling operations
abstract class LMChatAudioHandler {
  /// Instance of the player
  FlutterSoundPlayer get player;

  /// Instance of the recorder
  FlutterSoundRecorder get recorder;

  /// Stream of currently playing audio URL
  Stream<String> get currentlyPlayingStream;

  /// Currently playing URL
  String? get currentlyPlayingUrl;

  /// Stream of audio state changes
  Stream<LMChatAudioState> get audioStateStream;

  /// Initializes the audio handler
  Future<void> init();

  /// Disposes of audio resources
  Future<void> dispose();

  /// Starts recording audio to the specified path
  Future<String?> startRecording();

  /// Stops the current audio recording and notifies state change
  Future<String?> stopRecording({Duration? recordedDuration});

  /// Cancels the current recording and notifies state change
  Future<void> cancelRecording();

  /// Plays audio from the specified path
  Future<void> playAudio(String path);

  /// Stops the currently playing audio and notifies state change
  Future<void> stopAudio();

  /// Pauses the currently playing audio
  Future<void> pauseAudio();

  /// Resumes the paused audio
  Future<void> resumeAudio();

  /// Seeks to a specific position in the audio
  Future<void> seekTo(Duration position);

  /// Get progress stream for specific audio URL
  Stream<PlaybackProgress> getProgressStream(String audioUrl);

  /// Gets the duration of an audio file without playing it
  Future<Duration?> getDuration(String path);

  /// Get duration updates stream for specific audio path
  Stream<Duration> getDurationStream(String path);
}



================================================
File: lib/packages/ui/lib/src/utils/media/media_utils.dart
================================================
import 'dart:io';
import 'dart:ui' as ui;
import 'dart:math';

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/media/error.dart';
import 'package:video_thumbnail/video_thumbnail.dart';
import 'package:http/http.dart' as http;
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;

const List<String> videoExtentions = [
  'mp4',
  'mov',
  'wmv',
  'avi',
  'mkv',
  'flv',
];

const List<String> photoExtentions = [
  'jpg',
  'jpeg',
  'png',
];

const List<String> mediaExtentions = [
  ...photoExtentions,
  ...videoExtentions,
];

/// Builds a widget to display the attachment tiles for a chat item.
///
/// This function takes a list of media files and a conversation object,
/// and returns a widget that shows the appropriate UI for the attachments.
/// If there are no media files and no answer text, an empty SizedBox is returned.
/// If there are no media files but there is answer text, it displays the answer text.
/// If there are media files, it determines the type of media and displays
/// the corresponding icon and text based on the media type.
///
/// [mediaFiles] - A list of media files associated with the chat item.
/// [conversation] - The conversation data that may contain answer text.
///
/// Returns a [Widget] that represents the attachment tile.
Widget getChatItemAttachmentTile(
  String message,
  List<LMChatAttachmentViewData> mediaFiles,
  LMChatConversationViewData conversation, {
  String? prefix,
}) {
  String answerText = LMChatTaggingHelper.convertRouteToTag(conversation.answer,
          withTilde: false) ??
      '';
  if (conversation.ogTags != null) {
    return Row(
      children: [
        LMChatText(
          prefix ?? '',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              fontSize: 14,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
        LMChatText(
          message,
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              fontSize: 12,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
        LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.link,
          style: LMChatIconStyle(
            color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            size: 16,
          ),
        ),
      ],
    );
  }
  if (conversation.state == 10) {
    return Row(
      children: [
        LMChatText(
          message,
          style: LMChatTextStyle(
            textStyle: TextStyle(
              color: LMChatTheme.theme.onContainer,
            ),
          ),
        ),
        const SizedBox(width: 4),
        LMChatIcon(
          type: LMChatIconType.svg,
          assetPath: kPollIcon,
          style: LMChatIconStyle(
            size: 14,
            color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            boxPadding: const EdgeInsets.only(
              right: 4,
            ),
          ),
        ),
        LMChatText(
          answerText,
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              fontSize: 14,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
      ],
    );
  }
  if (mediaFiles.isEmpty && conversation.answer.isEmpty) {
    return const SizedBox();
  } else if (mediaFiles.isEmpty) {
    return Row(
      children: [
        LMChatText(
          prefix ?? '',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              fontSize: 14,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
        LMChatText(
          answerText,
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              fontSize: 12,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
      ],
    );
  } else {
    IconData iconData = Icons.camera_alt;
    String text = '';
    if (mapStringToMediaType(mediaFiles.first.type!) ==
        LMChatMediaType.voiceNote) {
      return Row(
        children: [
          LMChatText(
            prefix ?? '',
            style: LMChatTextStyle(
              maxLines: 1,
              textStyle: TextStyle(
                overflow: TextOverflow.ellipsis,
                fontSize: 14,
                fontWeight: FontWeight.normal,
                color: LMChatTheme.theme.onContainer.withOpacity(0.8),
              ),
            ),
          ),
          LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.mic,
            style: LMChatIconStyle(
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
              size: 16,
            ),
          ),
          LMChatDefaultTheme.kHorizontalPaddingSmall,
          LMChatText(
            "Voice Message",
            style: LMChatTextStyle(
              maxLines: 1,
              textStyle: TextStyle(
                fontSize: 12,
                fontWeight: FontWeight.normal,
                overflow: TextOverflow.ellipsis,
                color: LMChatTheme.theme.onContainer.withOpacity(0.8),
              ),
            ),
          ),
        ],
      );
    } else if (mapStringToMediaType(mediaFiles.first.type!) ==
        LMChatMediaType.document) {
      iconData = Icons.insert_drive_file;
      if (conversation.answer.isEmpty) {
        text = mediaFiles.length > 1 ? "Documents" : "Document";
      } else {
        text = answerText;
      }
    } else {
      int videoCount = 0;
      int imageCount = 0;
      int gifCount = 0;
      for (LMChatAttachmentViewData media in mediaFiles) {
        if (mapStringToMediaType(media.type!) == LMChatMediaType.video) {
          videoCount++;
        } else if (mapStringToMediaType(media.type!) == LMChatMediaType.gif) {
          gifCount++;
        } else {
          imageCount++;
        }
      }
      if (videoCount != 0 && imageCount != 0) {
        return Row(
          children: <Widget>[
            LMChatText(
              prefix ?? '',
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  overflow: TextOverflow.ellipsis,
                  fontSize: 14,
                  fontWeight: FontWeight.normal,
                  color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                ),
              ),
            ),
            LMChatText(
              videoCount.toString(),
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.normal,
                  overflow: TextOverflow.ellipsis,
                  color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                ),
              ),
            ),
            LMChatDefaultTheme.kHorizontalPaddingSmall,
            LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.video_camera_back,
              style: LMChatIconStyle(
                color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                size: 16,
              ),
            ),
            LMChatDefaultTheme.kHorizontalPaddingMedium,
            LMChatText(
              imageCount.toString(),
              style: LMChatTextStyle(
                maxLines: 1,
                textStyle: TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.normal,
                  overflow: TextOverflow.ellipsis,
                  color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                ),
              ),
            ),
            LMChatDefaultTheme.kHorizontalPaddingSmall,
            LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.image,
              style: LMChatIconStyle(
                color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                size: 16,
              ),
            ),
            LMChatDefaultTheme.kHorizontalPaddingSmall,
            Expanded(
              child: LMChatText(
                answerText,
                style: LMChatTextStyle(
                  maxLines: 1,
                  textStyle: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.normal,
                    overflow: TextOverflow.ellipsis,
                    color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                  ),
                ),
              ),
            )
          ],
        );
      } else if (videoCount == 0 && gifCount == 0) {
        iconData = Icons.image;
        if (conversation.answer.isEmpty) {
          text = mediaFiles.length > 1 ? "Images" : "Image";
        } else {
          text = answerText;
        }
      } else if (imageCount == 0 && gifCount == 0) {
        iconData = Icons.video_camera_back;
        if (conversation.answer.isEmpty) {
          text = mediaFiles.length > 1 ? "Videos" : "Video";
        } else {
          text = answerText;
        }
      } else if (gifCount > 0) {
        iconData = Icons.image;
        text = gifCount > 1 ? "GIFs" : "GIF";
      }
    }
    return Row(
      children: <Widget>[
        LMChatText(
          prefix ?? '',
          style: LMChatTextStyle(
            maxLines: 1,
            textStyle: TextStyle(
              overflow: TextOverflow.ellipsis,
              fontSize: 14,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
        mediaFiles.length > 1
            ? LMChatText(
                '${mediaFiles.length}',
                style: LMChatTextStyle(
                  maxLines: 1,
                  textStyle: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.normal,
                    overflow: TextOverflow.ellipsis,
                    color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                  ),
                ),
              )
            : const SizedBox(),
        mediaFiles.length > 1
            ? LMChatDefaultTheme.kHorizontalPaddingSmall
            : const SizedBox(),
        LMChatIcon(
          type: LMChatIconType.icon,
          icon: iconData,
          style: LMChatIconStyle(
            color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            size: 16,
            boxSize: 16,
          ),
        ),
        LMChatDefaultTheme.kHorizontalPaddingSmall,
        Expanded(
          child: Text(
            text,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.normal,
              color: LMChatTheme.theme.onContainer.withOpacity(0.8),
            ),
          ),
        ),
      ],
    );
  }
}

Future<File?> getVideoThumbnail(LMChatMediaModel media) async {
  String? thumbnailPath = await VideoThumbnail.thumbnailFile(
    video: media.mediaFile!.path,
    imageFormat: ImageFormat.JPEG,
    maxWidth: 300,
    quality: 50,
    timeMs: 100,
  ).onError((error, stackTrace) {
    debugPrint(error.toString());
    return null;
  });

  File? thumbnailFile;
  thumbnailFile = File(thumbnailPath!);
  ui.Image image = await decodeImageFromList(thumbnailFile.readAsBytesSync());
  media.width = image.width;
  media.height = image.height;
  media.thumbnailFile ??= thumbnailFile;

  return thumbnailFile;
}

String getFileSizeString({required int bytes, int decimals = 0}) {
  if (bytes > 0) {
    const suffixes = ["B", "KB", "MB", "GB", "TB"];
    var i = (log(bytes) / log(1000)).floor();
    return "${((bytes / pow(1000, i)).toStringAsFixed(decimals))} ${suffixes[i]}";
  } else {
    return "0";
  }
}

// Returns file size in double in MBs
double getFileSizeInDouble(int bytes) {
  return (bytes / pow(1000, 2));
}

Widget getChatBubbleImage(
  LMChatAttachmentViewData mediaFile, {
  double? width,
  double? height,
  void Function()? onTap,
}) {
  return GestureDetector(
    onTap: onTap,
    child: Container(
      height: height,
      width: width,
      clipBehavior: Clip.hardEdge,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8.0),
      ),
      child: Stack(
        children: [
          CachedNetworkImage(
            imageUrl:
                mapStringToMediaType(mediaFile.type!) == LMChatMediaType.image
                    ? mediaFile.url ?? mediaFile.fileUrl ?? ''
                    : mediaFile.thumbnailUrl ?? '',
            fit: BoxFit.cover,
            height: height,
            width: width,
            errorWidget: (context, url, error) =>
                const LMChatMediaErrorWidget(),
            progressIndicatorBuilder: (context, url, progress) =>
                const LMChatMediaShimmerWidget(),
          ),
          mapStringToMediaType(mediaFile.type!) == LMChatMediaType.video &&
                  mediaFile.thumbnailUrl != null
              ? Column(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    SizedBox(height: 2.h),
                    LMChatIcon(
                      type: LMChatIconType.icon,
                      icon: Icons.play_arrow,
                      style: LMChatIconStyle(
                        color: LMChatDefaultTheme.whiteColor,
                        boxSize: 32,
                        backgroundColor:
                            LMChatDefaultTheme.blackColor.withOpacity(0.3),
                        size: 24,
                        boxBorderRadius: 16,
                        boxPadding: const EdgeInsets.all(2),
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 2.0),
                      child: Row(
                        children: [
                          LMChatIcon(
                            type: LMChatIconType.icon,
                            icon: Icons.video_camera_back_outlined,
                            style: LMChatIconStyle(
                              color: LMChatTheme.theme.onPrimary,
                              boxSize: 20,
                              size: 18,
                              boxPadding: EdgeInsets.zero,
                            ),
                          ),
                          const SizedBox(width: 4),
                          mediaFile.meta?["duration"] != null
                              ? LMChatText(
                                  mediaFile.meta?["duration"].toString() ?? '',
                                  style: LMChatTextStyle.basic().copyWith(
                                    backgroundColor:
                                        LMChatTheme.theme.onPrimary,
                                  ),
                                )
                              : const SizedBox.shrink(),
                        ],
                      ),
                    )
                  ],
                )
              : const SizedBox(),
        ],
      ),
    ),
  );
}

Widget getFileImageTile(LMChatAttachmentViewData mediaFile,
    {double? width, double? height}) {
  if (mediaFile.attachmentFile == null && mediaFile.thumbnailFile == null) {
    return const LMChatMediaErrorWidget();
  }
  return Container(
    height: height,
    width: width,
    clipBehavior: Clip.hardEdge,
    decoration: BoxDecoration(
      borderRadius: BorderRadius.circular(3.0),
    ),
    child: Stack(
      children: [
        Image.file(
          mapStringToMediaType(mediaFile.type!) == LMChatMediaType.image
              ? mediaFile.attachmentFile!
              : mediaFile.thumbnailFile!,
          fit: BoxFit.cover,
          errorBuilder: (context, error, stackTrace) =>
              const LMChatMediaErrorWidget(),
          height: height,
          width: width,
        ),
        mapStringToMediaType(mediaFile.type!) == LMChatMediaType.video &&
                mediaFile.thumbnailFile != null
            ? Center(
                child: LMChatIcon(
                  type: LMChatIconType.icon,
                  icon: Icons.play_arrow,
                  style: LMChatIconStyle(
                    color: LMChatDefaultTheme.blackColor,
                    boxSize: 36,
                    backgroundColor:
                        LMChatDefaultTheme.whiteColor.withOpacity(0.7),
                    size: 24,
                    boxBorderRadius: 18,
                  ),
                ),
              )
            : const SizedBox(),
      ],
    ),
  );
}

Widget getImageMessage(
  BuildContext context,
  List<LMChatAttachmentViewData>? conversationAttachments,
  LMChatImageBuilder? imageBuilder,
) {
  if (conversationAttachments == null || conversationAttachments.isEmpty) {
    return const SizedBox();
  }

  if (conversationAttachments.length == 1) {
    return getChatBubbleImage(
      conversationAttachments.first,
      height: 55.w,
      width: 55.w,
    );
  } else if (conversationAttachments.length == 2) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: <Widget>[
        getChatBubbleImage(
          conversationAttachments[0],
          height: 25.w,
          width: 25.w,
        ),
        kHorizontalPaddingSmall,
        getChatBubbleImage(
          conversationAttachments[1],
          height: 25.w,
          width: 25.w,
        ),
      ],
    );
  } else if (conversationAttachments.length == 3) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: <Widget>[
        getChatBubbleImage(
          conversationAttachments[0],
          height: 25.w,
          width: 25.w,
        ),
        kHorizontalPaddingSmall,
        Container(
          height: 25.w,
          width: 25.w,
          clipBehavior: Clip.hardEdge,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(6.0),
          ),
          child: Stack(
            children: [
              getChatBubbleImage(
                conversationAttachments[1],
                height: 25.w,
                width: 25.w,
              ),
              Positioned(
                child: Container(
                  height: 25.w,
                  width: 25.w,
                  alignment: Alignment.center,
                  color: LMChatTheme.theme.container.withOpacity(0.5),
                  child: LMChatText(
                    '+2',
                    style: LMChatTextStyle(
                      textStyle: TextStyle(
                        color: LMChatTheme.theme.onContainer.withOpacity(0.8),
                        fontSize: 20,
                      ),
                    ),
                  ),
                ),
              )
            ],
          ),
        )
      ],
    );
  } else if (conversationAttachments.length == 4) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            getChatBubbleImage(
              conversationAttachments[0],
              height: 25.w,
              width: 25.w,
            ),
            kHorizontalPaddingSmall,
            getChatBubbleImage(
              conversationAttachments[1],
              height: 25.w,
              width: 25.w,
            ),
          ],
        ),
        kVerticalPaddingSmall,
        Row(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            getChatBubbleImage(
              conversationAttachments[2],
              height: 25.w,
              width: 25.w,
            ),
            kHorizontalPaddingSmall,
            getChatBubbleImage(
              conversationAttachments[3],
              height: 25.w,
              width: 25.w,
            ),
          ],
        ),
      ],
    );
  } else {
    return Column(
      children: [
        Row(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            getChatBubbleImage(
              conversationAttachments[0],
              height: 25.w,
              width: 25.w,
            ),
            kHorizontalPaddingSmall,
            getChatBubbleImage(
              conversationAttachments[1],
              height: 25.w,
              width: 25.w,
            ),
          ],
        ),
        kVerticalPaddingSmall,
        Row(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            getChatBubbleImage(
              conversationAttachments[2],
              height: 25.w,
              width: 25.w,
            ),
            kHorizontalPaddingSmall,
            Container(
              height: 25.w,
              width: 25.w,
              clipBehavior: Clip.hardEdge,
              decoration:
                  BoxDecoration(borderRadius: BorderRadius.circular(6.0)),
              child: Stack(
                children: [
                  getChatBubbleImage(
                    conversationAttachments[3],
                    height: 25.w,
                    width: 25.w,
                  ),
                  Positioned(
                    child: Container(
                      height: 25.w,
                      width: 25.w,
                      alignment: Alignment.center,
                      color: LMChatTheme.theme.container.withOpacity(0.5),
                      child: LMChatText(
                        '+2',
                        style: LMChatTextStyle(
                          textStyle: TextStyle(
                            color:
                                LMChatTheme.theme.onContainer.withOpacity(0.8),
                            fontSize: 20,
                          ),
                        ),
                      ),
                    ),
                  )
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }
}

Widget getImageFileMessage(
  BuildContext context,
  List<LMChatAttachmentViewData> mediaFiles,
  LMChatImageBuilder? imageBuilder,
) {
  if (mediaFiles.length == 1) {
    return GestureDetector(
      child: getFileImageTile(
        mediaFiles.first,
        height: 55.w,
        width: 55.w,
      ),
    );
  } else if (mediaFiles.length == 2) {
    return GestureDetector(
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: <Widget>[
          getFileImageTile(
            mediaFiles[0],
            height: 25.w,
            width: 25.w,
          ),
          LMChatDefaultTheme.kHorizontalPaddingSmall,
          getFileImageTile(
            mediaFiles[1],
            height: 25.w,
            width: 25.w,
          )
        ],
      ),
    );
  } else if (mediaFiles.length == 3) {
    return GestureDetector(
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: <Widget>[
          getFileImageTile(
            mediaFiles[0],
            height: 25.w,
            width: 25.w,
          ),
          LMChatDefaultTheme.kHorizontalPaddingSmall,
          Container(
            height: 25.w,
            width: 25.w,
            clipBehavior: Clip.hardEdge,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(6.0),
            ),
            child: Stack(
              children: [
                getFileImageTile(
                  mediaFiles[1],
                  height: 25.w,
                  width: 25.w,
                ),
                Positioned(
                  child: Container(
                    height: 25.w,
                    width: 25.w,
                    alignment: Alignment.center,
                    color: LMChatDefaultTheme.blackColor.withOpacity(0.5),
                    child: const LMChatText(
                      '+2',
                      style: LMChatTextStyle(
                        textStyle: TextStyle(
                          color: LMChatDefaultTheme.whiteColor,
                          fontSize: 20,
                        ),
                      ),
                    ),
                  ),
                )
              ],
            ),
          )
        ],
      ),
    );
  } else if (mediaFiles.length == 4) {
    return GestureDetector(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              getFileImageTile(
                mediaFiles[0],
                height: 25.w,
                width: 25.w,
              ),
              LMChatDefaultTheme.kHorizontalPaddingSmall,
              getFileImageTile(
                mediaFiles[1],
                height: 25.w,
                width: 25.w,
              ),
            ],
          ),
          LMChatDefaultTheme.kVerticalPaddingSmall,
          Row(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              getFileImageTile(
                mediaFiles[2],
                height: 25.w,
                width: 25.w,
              ),
              LMChatDefaultTheme.kHorizontalPaddingSmall,
              getFileImageTile(
                mediaFiles[3],
                height: 25.w,
                width: 25.w,
              ),
            ],
          ),
        ],
      ),
    );
  } else {
    return GestureDetector(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              getFileImageTile(
                mediaFiles[0],
                height: 25.w,
                width: 25.w,
              ),
              LMChatDefaultTheme.kHorizontalPaddingSmall,
              getFileImageTile(
                mediaFiles[1],
                height: 25.w,
                width: 25.w,
              ),
            ],
          ),
          LMChatDefaultTheme.kVerticalPaddingSmall,
          Row(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              getFileImageTile(
                mediaFiles[2],
                height: 25.w,
                width: 25.w,
              ),
              LMChatDefaultTheme.kHorizontalPaddingSmall,
              Container(
                height: 120,
                width: 120,
                clipBehavior: Clip.hardEdge,
                decoration:
                    BoxDecoration(borderRadius: BorderRadius.circular(6.0)),
                child: Stack(
                  children: [
                    getFileImageTile(
                      mediaFiles[3],
                      height: 25.w,
                      width: 25.w,
                    ),
                    Positioned(
                      child: Container(
                        height: 25.w,
                        width: 25.w,
                        alignment: Alignment.center,
                        color: LMChatDefaultTheme.blackColor.withOpacity(0.5),
                        child: LMChatText(
                          '+${mediaFiles.length - 3}',
                          style: const LMChatTextStyle(
                            textStyle: TextStyle(
                              color: LMChatDefaultTheme.whiteColor,
                              fontSize: 20,
                            ),
                          ),
                        ),
                      ),
                    )
                  ],
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Downloads a file from a URL and saves it locally
///
/// Parameters:
/// - fileUrl: Direct URL to the file on AWS storage
/// - media: Optional media model containing file information
///
/// Returns the local file path where the file was saved
Future<String> downloadFile({String? fileUrl, LMChatMediaModel? media}) async {
  try {
    // Use either direct URL or get URL from media model
    final String url = fileUrl ?? media?.mediaUrl ?? '';
    if (url.isEmpty) {
      throw Exception('No URL provided for download');
    }

    // Get file name from URL
    final String fileName = path.basename(url);

    // Get temporary directory for storing downloaded files
    final Directory tempDir = await getTemporaryDirectory();
    final String localPath = path.join(tempDir.path, fileName);

    // Check if file already exists locally
    if (await File(localPath).exists()) {
      return localPath;
    }

    // Download file
    final response = await http.get(Uri.parse(url));
    if (response.statusCode != 200) {
      throw Exception('Failed to download file: ${response.statusCode}');
    }

    // Save file locally
    final File file = File(localPath);
    await file.writeAsBytes(response.bodyBytes);

    return localPath;
  } catch (e) {
    throw Exception('Error downloading file: $e');
  }
}



================================================
File: lib/packages/ui/lib/src/utils/time_ago/time_ago.dart
================================================
import 'package:likeminds_chat_flutter_ui/src/utils/time_ago/time_ago_message.dart';

class LMChatTimeAgo {
  LMChatTimeAgoMessages? lmChatTimeAgoMessages;

  static LMChatTimeAgo? _instance;

  static LMChatTimeAgo get instance => _instance ??= LMChatTimeAgo._();

  LMChatTimeAgo._();

  void setDefaultTimeFormat(LMChatTimeAgoMessages locale) {
    lmChatTimeAgoMessages = locale;
  }

  String format(DateTime date,
      {String? locale, DateTime? clock, bool allowFromNow = false}) {
    final allowFromNow0 = allowFromNow;

    final messages = lmChatTimeAgoMessages ?? LMChatTimeShortMessages();
    final clock0 = clock ?? DateTime.now();
    var elapsed = clock0.millisecondsSinceEpoch - date.millisecondsSinceEpoch;

    String prefix, suffix;

    if (allowFromNow0 && elapsed < 0) {
      elapsed = date.isBefore(clock0) ? elapsed : elapsed.abs();
      prefix = messages.prefixFromNow();
      suffix = messages.suffixFromNow();
    } else {
      prefix = messages.prefixAgo();
      suffix = messages.suffixAgo();
    }

    final num seconds = elapsed / 1000;
    final num minutes = seconds / 60;
    final num hours = minutes / 60;
    final num days = hours / 24;
    final num months = days / 30;
    final num years = days / 365;

    String result;
    if (seconds < 45) {
      result = messages.lessThanOneMinute(seconds.round(), date);
    } else if (seconds < 90) {
      result = messages.aboutAMinute(date);
    } else if (minutes < 45) {
      result = messages.minutes(minutes.round(), date);
    } else if (minutes < 90) {
      result = messages.aboutAnHour(date);
    } else if (hours < 24) {
      result = messages.hours(hours.round(), date);
    } else if (hours < 48) {
      result = messages.aDay(date);
    } else if (days < 30) {
      result = messages.days(days.round(), date);
    } else if (days < 60) {
      result = messages.aboutAMonth(date);
    } else if (days < 365) {
      result = messages.months(months.round(), date);
    } else if (years < 2) {
      result = messages.aboutAYear(date);
    } else {
      result = messages.years(years.round(), date);
    }

    return [prefix, result, suffix]
        .where((str) => str.isNotEmpty)
        .join(messages.wordSeparator());
  }
}



================================================
File: lib/packages/ui/lib/src/utils/time_ago/time_ago_message.dart
================================================
/// [LookupMessages] template for any language
abstract class LMChatTimeAgoMessages {
  /// Example: `prefixAgo()` 1 min `suffixAgo()`
  String prefixAgo();

  /// Example: `prefixFromNow()` 1 min `suffixFromNow()`
  String prefixFromNow();

  /// Example: `prefixAgo()` 1 min `suffixAgo()`
  String suffixAgo();

  /// Example: `prefixFromNow()` 1 min `suffixFromNow()`
  String suffixFromNow();

  /// Format when time is less than a minute
  String lessThanOneMinute(int seconds, DateTime dateTime);

  /// Format when time is about a minute
  String aboutAMinute(DateTime dateTime);

  /// Format when time is in minutes
  String minutes(int minutes, DateTime dateTime);

  /// Format when time is about an hour
  String aboutAnHour(DateTime dateTime);

  /// Format when time is in hours
  String hours(int hours, DateTime dateTime);

  /// Format when time is a day
  String aDay(DateTime dateTime);

  /// Format when time is in days
  String days(int days, DateTime dateTime);

  /// Format when time is about a month
  String aboutAMonth(DateTime dateTime);

  /// Format when time is in months
  String months(int months, DateTime dateTime);

  /// Format when time is about a year
  String aboutAYear(DateTime dateTime);

  /// Format when time is about a year
  String years(int years, DateTime dateTime);

  /// word separator when words are concatenated
  String wordSeparator() => ' ';
}

/// English Messages
class LMChatTimeMessages implements LMChatTimeAgoMessages {
  @override
  String prefixAgo() => '';
  @override
  String prefixFromNow() => '';
  @override
  String suffixAgo() => 'ago';
  @override
  String suffixFromNow() => 'from now';
  @override
  String lessThanOneMinute(int seconds, DateTime dateTime) => 'a moment';
  @override
  String aboutAMinute(DateTime dateTime) => 'a minute';
  @override
  String minutes(int minutes, DateTime dateTime) => '$minutes minutes';
  @override
  String aboutAnHour(DateTime dateTime) => 'about an hour';
  @override
  String hours(int hours, DateTime dateTime) => '$hours hours';
  @override
  String aDay(DateTime dateTime) => 'a day';
  @override
  String days(int days, DateTime dateTime) => '$days days';
  @override
  String aboutAMonth(DateTime dateTime) => 'about a month';
  @override
  String months(int months, DateTime dateTime) => '$months months';
  @override
  String aboutAYear(DateTime dateTime) => 'about a year';
  @override
  String years(int years, DateTime dateTime) => '$years years';
  @override
  String wordSeparator() => ' ';
}

/// English short Messages
class LMChatTimeShortMessages implements LMChatTimeAgoMessages {
  @override
  String prefixAgo() => '';
  @override
  String prefixFromNow() => '';
  @override
  String suffixAgo() => '';
  @override
  String suffixFromNow() => '';
  @override
  String lessThanOneMinute(int seconds, DateTime dateTime) => 'now';
  @override
  String aboutAMinute(DateTime dateTime) => '1m';
  @override
  String minutes(int minutes, DateTime dateTime) => '${minutes}m';
  @override
  String aboutAnHour(DateTime dateTime) => '~1h';
  @override
  String hours(int hours, DateTime dateTime) => '${hours}h';
  @override
  String aDay(DateTime dateTime) => '~1d';
  @override
  String days(int days, DateTime dateTime) => '${days}d';
  @override
  String aboutAMonth(DateTime dateTime) => '~1mo';
  @override
  String months(int months, DateTime dateTime) => '${months}mo';
  @override
  String aboutAYear(DateTime dateTime) => '~1y';
  @override
  String years(int years, DateTime dateTime) => '${years}y';
  @override
  String wordSeparator() => ' ';
}



================================================
File: lib/packages/ui/lib/src/widgets/widgets.dart
================================================
export 'common/text/text.dart';
export 'common/icon/icon.dart';
export 'common/tile/tile.dart';

export 'common/buttons/button.dart';
export 'common/buttons/floating_action_button.dart';

export 'common/extras/appbar.dart';
export 'common/extras/loader.dart';
export 'common/extras/chip.dart';

export 'common/menu/custom_pop_up_menu_style.dart';

export 'common/snackbar/snackbar.dart';

export 'common/sheets/bottom_sheet.dart';

export 'profile/profile_picture.dart';
export 'profile/user_tile.dart';

export 'shimmers/chatroom_skeleton.dart';
export 'shimmers/document_shimmer.dart';
export 'shimmers/media_shimmer.dart';

export 'media/image.dart';
export 'media/video.dart';
export 'media/document/document.dart';
export 'media/gif.dart';
export 'media/error.dart';
export 'media/link_preview_bar.dart';
export 'media/link_preview.dart';
export 'media/voice_note.dart';

export 'conversation/chat_bubble.dart';

export 'reaction/reaction.dart';

export 'common/menu/menu.dart';
export 'common/menu/menu_item.dart';
export 'common/dialog/dialog.dart';

export 'poll/poll.dart';
export 'poll/poll_style.dart';
export 'poll/poll_option.dart';


export 'paginated_list/dual_side_paginated_list.dart';
export 'paginated_list/pagination_controller.dart';
export 'paginated_list/pagination_utils.dart';



================================================
File: lib/packages/ui/lib/src/widgets/chatroom/chatroom_topic.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/constants/constants.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

class LMChatRoomTopic extends StatelessWidget {
  const LMChatRoomTopic({
    super.key,
    required this.conversation,
    required this.onTap,
    this.leading,
    this.trailing,
    this.title,
    this.subTitle,
    this.date,
    this.backGroundColor,
  });

  final LMChatConversationViewData conversation;
  final VoidCallback onTap;
  final Widget? leading;
  final Widget? trailing;
  final LMChatText? title;
  final LMChatText? subTitle;
  final LMChatText? date;
  final Color? backGroundColor;

  Widget generateIcon(LMChatConversationViewData conversation) {
    Widget? icon;
    if (conversation.attachments == null) {
      if (conversation.ogTags != null) icon = const Icon(Icons.link);
    } else {
      switch (conversation.attachments!.first.type) {
        case kAttachmentTypeImage:
          icon = const Icon(Icons.image);
          break;
        case kAttachmentTypeVideo:
          icon = const Icon(Icons.videocam);
          break;
        case kAttachmentTypePDF:
          icon = const Icon(Icons.insert_drive_file_outlined);
          break;
      }
    }
    if (icon != null) {
      return Row(
        mainAxisAlignment: MainAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          kHorizontalPaddingXSmall,
          icon,
        ],
      );
    } else {
      return const SizedBox.shrink();
    }
  }

  String generateSubtext(LMChatConversationViewData conversation) {
    if (conversation.answer.isNotEmpty) {
      return conversation.answer;
    }

    String subText = "";
    if (conversation.attachments != null) {
      switch (conversation.attachments!.first.type) {
        case kAttachmentTypeImage:
          subText = "Photo";
          break;
        case kAttachmentTypeVideo:
          subText = "Video";
          break;
        case kAttachmentTypePDF:
          subText = conversation.attachments!.first.name ?? "Document";
          break;
      }
    }
    return subText;
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 65,
        decoration: BoxDecoration(
          color: backGroundColor ?? LMChatTheme.theme.backgroundColor,
        ),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
          child: Row(children: [
            leading != null
                ? leading!
                : LMChatProfilePicture(
                    fallbackText: conversation.member != null
                        ? conversation.member!.name
                        : "Chatroom topic",
                    imageUrl: conversation.member?.imageUrl,
                    style: const LMChatProfilePictureStyle(
                      size: 36,
                    ),
                  ),
            Expanded(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 4.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Row(
                      children: [
                        title != null
                            ? title!
                            : LMChatText(
                                conversation.member != null
                                    ? conversation.member!.name
                                    : "Chatroom topic",
                                style: LMChatTextStyle(
                                  textStyle: TextStyle(
                                    fontSize: 14,
                                    fontWeight: FontWeight.bold,
                                    color: LMChatTheme.theme.onContainer,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ),
                        kHorizontalPaddingXSmall,
                        date == null
                            ? Text.rich(
                                TextSpan(children: [
                                  const WidgetSpan(
                                      child: Center(
                                    child: LMChatText(
                                      "\u2022 ",
                                      style: LMChatTextStyle(
                                        textStyle: TextStyle(
                                          fontSize: 12,
                                        ),
                                      ),
                                    ),
                                  )),
                                  WidgetSpan(
                                    child: LMChatText(
                                      "${conversation.date}",
                                      style: const LMChatTextStyle(
                                        textStyle: TextStyle(
                                          color: LMChatDefaultTheme.greyColor,
                                          // fontSize: 16
                                        ),
                                      ),
                                    ),
                                  )
                                ]),
                              )
                            : date!,
                      ],
                    ),
                    subTitle != null
                        ? subTitle!
                        : Text.rich(
                            TextSpan(
                              style: const TextStyle(
                                fontSize: 13,
                              ),
                              children: [
                                TextSpan(
                                  text: generateSubtext(conversation),
                                )
                              ],
                            ),
                            maxLines: 1,
                            style: const TextStyle(
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                  ],
                ),
              ),
            ),
            // trailing != null
            //     ? trailing!
            //     : (((conversation.ogTags != null) ||
            //                 ((conversation.attachments != null &&
            //                         conversation.attachments!.isNotEmpty)) &&
            //                     (conversation.attachments!.first.type !=
            //                         kAttachmentTypePDF)) &&
            //             (conversation.ogTags != null &&
            //                 conversation.ogTags?['image'] != null))
            //         ? Align(
            //             alignment: Alignment.centerRight,
            //             child: LMChatImage(
            //               imageFile:
            //                   conversation.attachments?.first.attachmentFile,
            //               imageUrl:
            //                   conversation.attachments?.first.thumbnailUrl ??
            //                       conversation.attachments?.first.url ??
            //                       conversation.ogTags?['image'],
            //               width: 65,
            //               height: 65,
            //             ),
            //           )
            //         : const SizedBox.shrink()
          ]),
        ),
      ),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/buttons/button.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/enums.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

/// This widget is used to display a text button
/// The [LMChatButton] can be customized by passing in the required parameters
class LMChatButton extends StatefulWidget {
  const LMChatButton({
    super.key,
    this.text,
    required this.onTap,
    this.activeText,
    this.isActive = false,
    this.style,
    this.onTextTap,
    this.icon,
    this.onLongPress,
    this.onLongPressStart,
    this.onLongPressEnd,
    this.onLongPressMoveUpdate,
    this.onVerticalDragUpdate,
    this.onHorizontalDragUpdate,
    this.gesturesEnabled = false,
    this.child,
  });

  /// Required parameter, defines whether the button is active or disabled
  final bool isActive;

  /// Controls whether gestures (long press, drags) are enabled
  final bool gesturesEnabled;

  /// style class to customise the look and feel of the button
  final LMChatButtonStyle? style;

  /// Text to be displayed in the button
  final LMChatText? text;

  /// Icon to be displayed in the button
  final LMChatIcon? icon;

  /// Action to perform after tapping on the button
  final VoidCallback? onTap;

  /// Action to perform after holding the button
  final VoidCallback? onLongPress;

  /// Text to be displayed in the button if the button is active
  final LMChatText? activeText;

  /// Action to perform after text in the button is tapped
  final VoidCallback? onTextTap;

  /// Action to perform after just starting holding the button
  final Function(LongPressStartDetails)? onLongPressStart;

  /// Action to perform after just ending holding the button
  final Function(LongPressEndDetails)? onLongPressEnd;

  /// Action to perform when there is a drag while holding the button
  final Function(LongPressMoveUpdateDetails)? onLongPressMoveUpdate;

  /// Action to perform when there is a vertical drag while holding the button
  final Function(DragUpdateDetails)? onVerticalDragUpdate;

  /// Action to perform when dragging horizontally
  final Function(DragUpdateDetails)? onHorizontalDragUpdate;

  /// child widget to the button
  /// if the button has a child, the text and icon will be ignored
  /// and the child will be displayed in the button
  final Widget? child;

  @override
  State<LMChatButton> createState() => _LMButtonState();

  /// CopyWith method to create a new instance of [LMChatButton] with the updated values
  /// This method is used to update the values of the [LMChatButton] widget
  /// by creating a new instance of the widget with the updated values
  LMChatButton copyWith({
    Key? key,
    LMChatText? text,
    VoidCallback? onTap,
    LMChatText? activeText,
    bool? isActive,
    LMChatButtonStyle? style,
    VoidCallback? onTextTap,
    LMChatIcon? icon,
    VoidCallback? onLongPress,
    Function(LongPressStartDetails)? onLongPressStart,
    Function(LongPressEndDetails)? onLongPressEnd,
    Function(LongPressMoveUpdateDetails)? onLongPressMoveUpdate,
    Function(DragUpdateDetails)? onVerticalDragUpdate,
    Function(DragUpdateDetails)? onHorizontalDragUpdate,
    bool? gesturesEnabled,
    Widget? child,
  }) {
    return LMChatButton(
      key: key ?? this.key,
      text: text ?? this.text,
      onTap: onTap ?? this.onTap,
      activeText: activeText ?? this.activeText,
      isActive: isActive ?? this.isActive,
      style: style ?? this.style,
      onTextTap: onTextTap ?? this.onTextTap,
      icon: icon ?? this.icon,
      onLongPress: onLongPress ?? this.onLongPress,
      onLongPressStart: onLongPressStart ?? this.onLongPressStart,
      onLongPressEnd: onLongPressEnd ?? this.onLongPressEnd,
      onLongPressMoveUpdate:
          onLongPressMoveUpdate ?? this.onLongPressMoveUpdate,
      onVerticalDragUpdate: onVerticalDragUpdate ?? this.onVerticalDragUpdate,
      onHorizontalDragUpdate:
          onHorizontalDragUpdate ?? this.onHorizontalDragUpdate,
      gesturesEnabled: gesturesEnabled ?? this.gesturesEnabled,
      child: child ?? this.child,
    );
  }
}

class _LMButtonState extends State<LMChatButton>
    with SingleTickerProviderStateMixin {
  bool _active = false;
  bool _isLongPressed = false;
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  Offset _dragOffset = Offset.zero;

  bool? _isHorizontalDrag;
  Offset? _dragStartOffset;

  @override
  void initState() {
    super.initState();
    _active = widget.isActive;
    final inStyle = widget.style ?? LMChatButtonStyle.basic();
    _controller = AnimationController(
      duration: inStyle.animationDuration,
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 1.0).animate(_controller);
  }

  @override
  void didUpdateWidget(LMChatButton oldWidget) {
    super.didUpdateWidget(oldWidget);
    _active = widget.isActive;
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final inStyle = widget.style ?? LMChatButtonStyle.basic();
    _scaleAnimation =
        Tween<double>(begin: 1.0, end: inStyle.scaleOnLongPress ?? 1.0)
            .animate(_controller);

    return GestureDetector(
      onTap: () {
        setState(() {
          _active = !_active;
        });
        widget.onTap?.call();
      },
      onLongPressStart: widget.gesturesEnabled
          ? (details) {
              setState(() {
                _isLongPressed = true;
                _dragOffset = Offset.zero;
                _dragStartOffset = details.globalPosition;
                _isHorizontalDrag = null;
              });
              _controller.forward();
              widget.onLongPressStart?.call(details);
            }
          : null,
      onLongPress: widget.gesturesEnabled ? widget.onLongPress : null,
      onLongPressMoveUpdate: widget.gesturesEnabled
          ? (details) {
              if (_isLongPressed) {
                final inStyle = widget.style ?? LMChatButtonStyle.basic();

                if (_dragStartOffset == null) {
                  _dragStartOffset = details.globalPosition;
                  return;
                }

                // Determine drag direction if not yet determined
                if (_isHorizontalDrag == null) {
                  final dragDelta = details.globalPosition - _dragStartOffset!;
                  if (dragDelta.distance > inStyle.dragDirectionThreshold) {
                    _isHorizontalDrag = dragDelta.dx.abs() > dragDelta.dy.abs();
                  } else {
                    return;
                  }
                }

                final newOffset = details.offsetFromOrigin;
                double constrainedX = 0.0;
                double constrainedY = 0.0;

                if (_isHorizontalDrag!) {
                  constrainedX =
                      newOffset.dx.clamp(-inStyle.maxHorizontalDrag, 0.0);

                  if (constrainedX <= -inStyle.horizontalCancelThreshold &&
                      constrainedX > -(inStyle.horizontalCancelThreshold + 1)) {
                    debugPrint('Crossed cancel threshold');
                  } else if (constrainedX <= -inStyle.maxHorizontalDrag) {
                    debugPrint('Near maximum horizontal drag');
                    widget.onHorizontalDragUpdate?.call(
                      DragUpdateDetails(
                        globalPosition: details.globalPosition,
                        delta: Offset(constrainedX, 0),
                      ),
                    );
                  }
                } else {
                  constrainedY =
                      newOffset.dy.clamp(-inStyle.maxVerticalDrag, 0.0);

                  if (constrainedY <= -inStyle.verticalLockThreshold &&
                      constrainedY > -(inStyle.verticalLockThreshold + 1)) {
                    debugPrint('Crossed lock threshold');
                  } else if (constrainedY <= -inStyle.maxVerticalDrag) {
                    debugPrint('Near maximum vertical drag');
                    widget.onVerticalDragUpdate?.call(
                      DragUpdateDetails(
                        globalPosition: details.globalPosition,
                        delta: Offset(0, constrainedY),
                      ),
                    );
                  }
                }

                setState(() {
                  _dragOffset = Offset(constrainedX, constrainedY);
                });

                widget.onLongPressMoveUpdate?.call(details);
              }
            }
          : null,
      onLongPressEnd: widget.gesturesEnabled
          ? (details) {
              setState(() {
                _isLongPressed = false;
                _dragOffset = Offset.zero;
                _dragStartOffset = null;
                _isHorizontalDrag = null;
              });
              _controller.reverse();
              widget.onLongPressEnd?.call(details);
              debugPrint('Long press ended, drag reset');
            }
          : null,
      behavior: HitTestBehavior.opaque,
      child: AnimatedBuilder(
        animation: _scaleAnimation,
        builder: (context, child) {
          return Transform.translate(
            offset: _dragOffset,
            child: Transform.scale(
              scale: _scaleAnimation.value,
              child: child,
            ),
          );
        },
        child: Container(
          height: inStyle.height,
          width: inStyle.width,
          margin: inStyle.margin,
          padding: inStyle.padding ?? EdgeInsets.zero,
          decoration: BoxDecoration(
            color: inStyle.backgroundColor ?? LMChatTheme.theme.backgroundColor,
            borderRadius: BorderRadius.circular(inStyle.borderRadius ?? 0),
            border: inStyle.border,
          ),
          child: widget.child ??
              Flex(
                direction: inStyle.direction ?? Axis.horizontal,
                mainAxisSize: MainAxisSize.min,
                mainAxisAlignment:
                    inStyle.mainAxisAlignment ?? MainAxisAlignment.center,
                children: [
                  inStyle.placement == LMChatIconButtonPlacement.start
                      ? _active
                          ? (inStyle.activeIcon ??
                                  inStyle.icon ??
                                  widget.icon) ??
                              const SizedBox.shrink()
                          : inStyle.icon ??
                              widget.icon ??
                              const SizedBox.shrink()
                      : const SizedBox.shrink(),
                  GestureDetector(
                    onTap: inStyle.showText ? widget.onTextTap : null,
                    behavior: HitTestBehavior.translucent,
                    child: Flex(
                      direction: Axis.horizontal,
                      children: [
                        inStyle.placement == LMChatIconButtonPlacement.start
                            ? (widget.icon != null ||
                                    inStyle.icon != null ||
                                    inStyle.activeIcon != null)
                                ? SizedBox(
                                    width: inStyle.spacing ?? 0,
                                  )
                                : const SizedBox.shrink()
                            : const SizedBox.shrink(),
                        inStyle.showText
                            ? Container(
                                padding: inStyle.textPadding,
                                child: _active
                                    ? widget.activeText ??
                                        widget.text ??
                                        const SizedBox.shrink()
                                    : widget.text ?? const SizedBox.shrink(),
                              )
                            : const SizedBox.shrink(),
                        inStyle.placement == LMChatIconButtonPlacement.end
                            ? (widget.icon != null ||
                                    inStyle.icon != null ||
                                    inStyle.activeIcon != null)
                                ? SizedBox(width: inStyle.spacing ?? 0)
                                : const SizedBox.shrink()
                            : const SizedBox.shrink(),
                      ],
                    ),
                  ),
                  inStyle.placement == LMChatIconButtonPlacement.end
                      ? _active
                          ? inStyle.activeIcon ??
                              widget.icon ??
                              inStyle.icon ??
                              const SizedBox.shrink()
                          : widget.icon ??
                              inStyle.icon ??
                              const SizedBox.shrink()
                      : const SizedBox.shrink(),
                ],
              ),
        ),
      ),
    );
  }
}

/// {@template lm_chat_button_style}
/// [LMChatButtonStyle] is used to style the [LMChatButton]
/// {@endtemplate}
class LMChatButtonStyle {
  /// padding of the button, defaults to zero
  final EdgeInsets? padding;

  /// margin of the button, defaults to zero
  final EdgeInsets? margin;

  /// background color of the button, defaults to transparent
  final Color? backgroundColor;

  /// border radius of the button container
  final double? borderRadius;

  /// height of the button
  final double? height;

  /// width of the button
  final double? width;

  /// border of the button
  final Border? border;

  /// placement of the icon in the button
  final LMChatIconButtonPlacement placement;

  /// axis alignment for setting button's icon and text spacing
  final MainAxisAlignment? mainAxisAlignment;

  /// space between the text and icon
  final double? spacing;

  /// whether to show the text in the button
  final bool showText;

  /// Icon to be displayed in the button
  final LMChatIcon? icon;

  /// Icon to be displayed in the button if the button is active
  final LMChatIcon? activeIcon;

  /// padding for the text
  final EdgeInsets? textPadding;

  /// Scale factor for the button when long pressed
  final double? scaleOnLongPress;

  /// Duration for the scale animation
  final Duration animationDuration;

  /// Maximum horizontal drag distance allowed
  final double maxHorizontalDrag;

  /// Maximum vertical drag distance allowed
  final double maxVerticalDrag;

  /// Minimum drag distance to determine drag direction
  final double dragDirectionThreshold;

  /// Threshold for horizontal cancel action
  final double horizontalCancelThreshold;

  /// Threshold for vertical lock action
  final double verticalLockThreshold;

  /// Direction of the icon and text
  final Axis? direction;

  /// {@macro lm_chat_button_style}
  const LMChatButtonStyle({
    this.padding,
    this.margin,
    this.backgroundColor,
    this.border,
    this.borderRadius,
    this.height,
    this.width,
    this.placement = LMChatIconButtonPlacement.start,
    this.spacing,
    this.mainAxisAlignment,
    this.showText = true,
    this.icon,
    this.activeIcon,
    this.textPadding,
    this.scaleOnLongPress,
    this.animationDuration = const Duration(milliseconds: 200),
    this.maxHorizontalDrag = 160.0,
    this.maxVerticalDrag = 80.0,
    this.dragDirectionThreshold = 10.0,
    this.horizontalCancelThreshold = 50.0,
    this.verticalLockThreshold = 50.0,
    this.direction,
  });

  /// Basic style factory constructor; used as default style
  factory LMChatButtonStyle.basic() {
    return const LMChatButtonStyle(
      padding: EdgeInsets.all(4),
      backgroundColor: Colors.transparent,
      borderRadius: 8,
      height: 28,
      spacing: 4,
      textPadding: EdgeInsets.zero,
      animationDuration: Duration(milliseconds: 200),
      maxHorizontalDrag: 160.0,
      maxVerticalDrag: 80.0,
      dragDirectionThreshold: 10.0,
      horizontalCancelThreshold: 50.0,
      verticalLockThreshold: 50.0,
    );
  }

  /// CopyWith method to create a new instance of [LMChatButtonStyle] with the updated values
  LMChatButtonStyle copyWith({
    EdgeInsets? padding,
    EdgeInsets? margin,
    Color? backgroundColor,
    Border? border,
    double? borderRadius,
    double? height,
    double? width,
    LMChatIconButtonPlacement? placement,
    MainAxisAlignment? mainAxisAlignment,
    double? spacing,
    bool? showText,
    LMChatIcon? icon,
    LMChatIcon? activeIcon,
    EdgeInsets? textPadding,
    double? scaleOnLongPress,
    Duration? animationDuration,
    double? maxHorizontalDrag,
    double? maxVerticalDrag,
    double? dragDirectionThreshold,
    double? horizontalCancelThreshold,
    double? verticalLockThreshold,
    Axis? direction,
  }) {
    return LMChatButtonStyle(
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      border: border ?? this.border,
      borderRadius: borderRadius ?? this.borderRadius,
      height: height ?? this.height,
      width: width ?? this.width,
      placement: placement ?? this.placement,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      spacing: spacing ?? this.spacing,
      showText: showText ?? this.showText,
      icon: icon ?? this.icon,
      activeIcon: activeIcon ?? this.activeIcon,
      textPadding: textPadding ?? this.textPadding,
      scaleOnLongPress: scaleOnLongPress ?? this.scaleOnLongPress,
      animationDuration: animationDuration ?? this.animationDuration,
      maxHorizontalDrag: maxHorizontalDrag ?? this.maxHorizontalDrag,
      maxVerticalDrag: maxVerticalDrag ?? this.maxVerticalDrag,
      dragDirectionThreshold:
          dragDirectionThreshold ?? this.dragDirectionThreshold,
      horizontalCancelThreshold:
          horizontalCancelThreshold ?? this.horizontalCancelThreshold,
      verticalLockThreshold:
          verticalLockThreshold ?? this.verticalLockThreshold,
      direction: direction ?? this.direction,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/buttons/floating_action_button.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

class LMChatFloatingActionButton extends StatelessWidget {
  final bool isCollapsed;
  final String? text;

  final VoidCallback? onTap;

  const LMChatFloatingActionButton({
    super.key,
    this.isCollapsed = false,
    this.text,
    this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return FloatingActionButton(
      onPressed: () {},
      child: const Icon(Icons.add),
    );
  }
}

class LMChatFloatingActionButtonStyle {
  final Color? backgroundColor;

  final double? collapsedHeight;
  final double? collapsedWidth;

  final double? expandedHeight;
  final double? expandedWidth;

  final LMChatIcon? icon;

  final bool? showTextOnCollapsed;

  final bool? showTextOnExpanded;

  final Duration? animationDuration;

  final Curve? animationCurve;

  const LMChatFloatingActionButtonStyle({
    this.backgroundColor,
    this.icon,
    this.collapsedHeight,
    this.collapsedWidth,
    this.expandedHeight,
    this.expandedWidth,
    this.showTextOnCollapsed,
    this.showTextOnExpanded,
    this.animationDuration,
    this.animationCurve,
  });

  LMChatFloatingActionButtonStyle copyWith({
    Color? backgroundColor,
    LMChatIcon? icon,
    double? collapsedHeight,
    double? collapsedWidth,
    double? expandedHeight,
    double? expandedWidth,
    bool? showTextOnCollapsed,
    bool? showTextOnExpanded,
  }) {
    return LMChatFloatingActionButtonStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      icon: icon ?? this.icon,
      collapsedHeight: collapsedHeight ?? this.collapsedHeight,
      collapsedWidth: collapsedWidth ?? this.collapsedWidth,
      expandedHeight: expandedHeight ?? this.expandedHeight,
      expandedWidth: expandedWidth ?? this.expandedWidth,
      showTextOnCollapsed: showTextOnCollapsed ?? this.showTextOnCollapsed,
      showTextOnExpanded: showTextOnExpanded ?? this.showTextOnExpanded,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/dialog/dialog.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';

/// {@template lm_chat_dialog}
/// A widget to show a chat dialog.
/// {@endtemplate}
class LMChatDialog extends StatelessWidget {
  /// {@macro lm_chat_dialog}
  /// Creates a [LMChatDialog] widget.
  const LMChatDialog({
    super.key,
    this.style,
    this.title,
    this.content,
    this.actions,
  });

  /// The style of the dialog.
  final LMChatDialogStyle? style;

  /// The title of the dialog.
  final Widget? title;

  /// The content of the dialog.
  final Widget? content;

  /// The actions of the dialog.
  final List<Widget>? actions;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: style?.backgroundColor ?? LMChatTheme.theme.container,
      shape: style?.shape,
      title: title,
      content: content,
      actions: actions,
    );
  }
}

/// The style of the [LMChatDialog].
class LMChatDialogStyle {
  /// The background color of the dialog.
  final Color? backgroundColor;

  /// Shape of the dialog.
  final ShapeBorder? shape;

  /// Constructs an instance of [LMChatDialogStyle].
  const LMChatDialogStyle({
    this.backgroundColor,
    this.shape,
  });

  /// Creates a copy of this [LMChatDialogStyle] but with the given fields
  /// replaced with the new values.
  /// If the new values are null, the original values will be used.
  LMChatDialogStyle copyWith({
    Color? backgroundColor,
    ShapeBorder? shape,
  }) {
    return LMChatDialogStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      shape: shape ?? this.shape,
    );
  }

  /// basic style
  /// The default style of the dialog.
  factory LMChatDialogStyle.basic() {
    return const LMChatDialogStyle();
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/extras/appbar.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

/// A custom AppBar for chat interfaces.
class LMChatAppBar extends StatelessWidget implements PreferredSizeWidget {
  /// Creates an instance of [LMChatAppBar].
  const LMChatAppBar({
    super.key,
    this.leading,
    this.trailing,
    this.title,
    this.subtitle,
    this.style,
    this.banner,
    this.backButtonCallback,
    this.bottom,
    this.titleBuilder,
    this.subtitleBuilder,
  });

  /// The widget to display as the leading element.
  final Widget? leading;

  /// The list of widgets to display at the end of the AppBar.
  final List<Widget>? trailing;

  /// The main title of the AppBar.
  final Widget? title;

  /// The subtitle displayed below the title.
  final Widget? subtitle;

  /// An optional banner widget.
  final Widget? banner;

  /// An optional bottom widget.
  final PreferredSizeWidget? bottom;

  /// Callback function for the back button.
  final Function? backButtonCallback;

  /// The style configuration for the AppBar.
  final LMChatAppBarStyle? style;

  /// The builder for the title where you want to modify it
  final Widget Function(Widget)? titleBuilder;

  /// The builder for the subtitle where you want to modify it
  final Widget Function(Widget)? subtitleBuilder;

  @override
  Widget build(BuildContext context) {
    final theme = LMChatTheme.theme;
    final inStyle = style ?? theme.appBarStyle;

    return Theme(
      data: ThemeData.from(
        colorScheme: ColorScheme.fromSeed(
          seedColor: LMChatTheme.theme.primaryColor,
        ),
      ),
      child: SafeArea(
        bottom: false,
        child: Container(
          height: inStyle.height,
          width: inStyle.width ?? double.infinity,
          margin: inStyle.margin ?? EdgeInsets.zero,
          decoration: BoxDecoration(
            color: inStyle.backgroundColor ?? Colors.white,
            border: inStyle.border,
            boxShadow: inStyle.shadow,
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              if (bottom != null) const SizedBox(height: 12),
              Padding(
                padding: inStyle.padding ??
                    const EdgeInsets.symmetric(
                      horizontal: 12.0,
                      vertical: 2.0,
                    ),
                child: Row(
                  children: inStyle.centerTitle
                      ? [
                          Expanded(
                            child: Row(
                              children: [
                                leading ??
                                    (inStyle.showBackButton
                                        ? LMChatButton(
                                            onTap: () {
                                              Navigator.of(context).pop();
                                              backButtonCallback?.call();
                                            },
                                            style: LMChatButtonStyle(
                                              height: 28,
                                              width: 28,
                                              borderRadius: 6,
                                              padding: EdgeInsets.zero,
                                              icon: LMChatIcon(
                                                type: LMChatIconType.icon,
                                                icon: Icons.arrow_back,
                                                style: LMChatIconStyle(
                                                  color: LMChatTheme
                                                      .theme.onContainer,
                                                  size: 24,
                                                  boxSize: 28,
                                                ),
                                              ),
                                              backgroundColor: LMChatTheme
                                                  .theme.container,
                                            ),
                                          )
                                        : const SizedBox.shrink()),
                              ],
                            ),
                          ),
                          Expanded(
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                titleBuilder?.call(
                                        title ?? const SizedBox.shrink()) ??
                                    title ??
                                    const SizedBox.shrink(),
                              ],
                            ),
                          ),
                          Expanded(
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.end,
                              children: trailing != null
                                  ? trailing!
                                  : [const SizedBox.shrink()],
                            ),
                          )
                        ]
                      : [
                          leading ??
                              (inStyle.showBackButton
                                  ? LMChatButton(
                                      onTap: () {
                                        Navigator.of(context).pop();
                                        backButtonCallback?.call();
                                      },
                                      style: LMChatButtonStyle(
                                        height: 28,
                                        width: 28,
                                        borderRadius: 6,
                                        padding: EdgeInsets.zero,
                                        icon: LMChatIcon(
                                          type: LMChatIconType.icon,
                                          icon: Icons.arrow_back,
                                          style: LMChatIconStyle(
                                            color: LMChatTheme.theme.onContainer,
                                            size: 24,
                                            boxSize: 28,
                                          ),
                                        ),
                                        backgroundColor:
                                            LMChatTheme.theme.container,
                                      ),
                                    )
                                  : const SizedBox.shrink()),
                          banner != null
                              ? SizedBox(width: inStyle.gap ?? 16)
                              : const SizedBox.shrink(),
                          banner ?? const SizedBox.shrink(),
                          leading != null || inStyle.showBackButton
                              ? SizedBox(width: inStyle.gap ?? 16)
                              : const SizedBox.shrink(),
                          Expanded(
                            child: Column(
                              mainAxisSize: MainAxisSize.max,
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Container(
                                  constraints: BoxConstraints(
                                    minWidth: 80.w,
                                  ),
                                  child: titleBuilder?.call(
                                          title ?? const SizedBox.shrink()) ??
                                      title ??
                                      const SizedBox.shrink(),
                                ),
                                (subtitleBuilder != null || subtitle != null)
                                    ? const SizedBox(height: 0)
                                    : const SizedBox.shrink(),
                                subtitleBuilder?.call(
                                        subtitle ?? const SizedBox.shrink()) ??
                                    subtitle ??
                                    const SizedBox.shrink(),
                              ],
                            ),
                          ),
                          if (trailing != null) ...trailing!
                        ],
                ),
              ),
              if (bottom != null) const SizedBox(height: 12),
              if (bottom != null) bottom!
            ],
          ),
        ),
      ),
    );
  }

  /// Creates a copy of the current [LMChatAppBar] with the given parameters.
  LMChatAppBar copyWith({
    Widget? leading,
    List<Widget>? trailing,
    Widget? title,
    Widget? subtitle,
    Widget? banner,
    PreferredSizeWidget? bottom,
    Function? backButtonCallback,
    LMChatAppBarStyle? style,
  }) {
    return LMChatAppBar(
      leading: leading ?? this.leading,
      trailing: trailing ?? this.trailing,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      banner: banner ?? this.banner,
      bottom: bottom ?? this.bottom,
      backButtonCallback: backButtonCallback ?? this.backButtonCallback,
      style: style ?? this.style,
    );
  }

  @override
  Size get preferredSize => Size.fromHeight(style?.height ?? 72);
}

/// Style configuration for [LMChatAppBar].
class LMChatAppBarStyle {
  /// Creates an instance of [LMChatAppBarStyle].
  const LMChatAppBarStyle({
    this.backgroundColor,
    this.border,
    this.margin,
    this.padding,
    this.height,
    this.width,
    this.shadow,
    this.gap,
    this.centerTitle = false,
    this.showBackButton = true,
  });

  /// Background color of the AppBar.
  final Color? backgroundColor;

  /// Height of the AppBar.
  final double? height;

  /// Width of the AppBar.
  final double? width;

  /// Gap between elements in the AppBar.
  final double? gap;

  /// Border of the AppBar.
  final Border? border;

  /// Padding inside the AppBar.
  final EdgeInsets? padding;

  /// Margin outside the AppBar.
  final EdgeInsets? margin;

  /// Shadow effects for the AppBar.
  final List<BoxShadow>? shadow;

  /// Whether to center the title.
  final bool centerTitle;

  /// Whether to show the back button.
  final bool showBackButton;

  /// Creates a copy of the current [LMChatAppBarStyle] with the given parameters.
  LMChatAppBarStyle copyWith({
    Color? backgroundColor,
    double? height,
    double? width,
    Border? border,
    EdgeInsets? padding,
    EdgeInsets? margin,
    List<BoxShadow>? shadow,
    bool? centerTitle,
    double? gap,
    bool? showBackButton,
  }) {
    return LMChatAppBarStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      height: height ?? this.height,
      width: width ?? this.width,
      margin: margin ?? this.margin,
      padding: padding ?? this.padding,
      border: border ?? this.border,
      shadow: shadow ?? this.shadow,
      centerTitle: centerTitle ?? this.centerTitle,
      gap: gap ?? this.gap,
      showBackButton: showBackButton ?? this.showBackButton,
    );
  }

  /// A basic style for the AppBar.
  factory LMChatAppBarStyle.basic(Color? backgroundColor) {
    return LMChatAppBarStyle(
      backgroundColor: backgroundColor ?? LMChatDefaultTheme.container,
      width: double.infinity,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/extras/chip.dart
================================================
import 'package:flutter/material.dart';

/// {@template lm_chat_chip}
/// A widget which displays a chip.
/// {@endtemplate}
class LMChatChip extends StatelessWidget {
  /// {@macro lm_chat_chip}
  const LMChatChip({
    super.key,
    required this.label,
    this.onTap,
    this.style,
  });

  /// The callback when the chip is tapped.
  final VoidCallback? onTap;

  /// The label of the chip.
  final Widget label;

  /// The style of the chip.
  final LMChatChipStyle? style;

  /// Creates a copy of this [LMChatChip] but with the given fields replaced with the new values.
  /// If the new values are null, then the old values are used.
  LMChatChip copyWith({
    VoidCallback? onTap,
    Widget? label,
    LMChatChipStyle? style,
  }) {
    return LMChatChip(
      onTap: onTap ?? this.onTap,
      label: label ?? this.label,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    return InkWell(
      splashFactory: InkRipple.splashFactory,
      onTap: onTap,
      child: Chip(
        label: label,
        backgroundColor: style?.backgroundColor,
        shape: style?.shape,
        padding: style?.padding ?? const EdgeInsets.symmetric(horizontal: 16.0),
        labelPadding: style?.labelPadding ?? EdgeInsets.zero,
        elevation: 0,
        side: style?.side,
      ),
    );
  }
}

/// {@template lm_chat_chip_style}
/// A class which describes the style for the [LMChatChip]
/// {@endtemplate}
class LMChatChipStyle {
  /// The background color of the chip.
  final Color? backgroundColor;

  /// The shape of the chip.
  final OutlinedBorder? shape;

  /// The padding of the chip.
  final EdgeInsets? padding;

  /// The margin of the chip.
  final EdgeInsets? margin;

  /// The label padding of the chip.
  final EdgeInsets? labelPadding;

  /// The elevation of the chip.
  final double? elevation;

  /// The Border of the chip.
  final BorderSide? side;

  /// {@macro lm_chat_chip_style}
  const LMChatChipStyle({
    this.backgroundColor,
    this.shape,
    this.padding,
    this.margin,
    this.labelPadding,
    this.elevation,
    this.side,
  });

  /// Creates a copy of this [LMChatChipStyle] but with the given fields replaced with the new values.
  /// If the new values are null, then the old values are used.
  LMChatChipStyle copyWith({
    Color? backgroundColor,
    OutlinedBorder? shape,
    EdgeInsets? padding,
    EdgeInsets? labelPadding,
    double? elevation,
    BorderSide? side,
  }) {
    return LMChatChipStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      shape: shape ?? this.shape,
      padding: padding ?? this.padding,
      labelPadding: labelPadding ?? this.labelPadding,
      elevation: elevation ?? this.elevation,
      side: side ?? this.side,
    );
  }

  /// Create a default [LMChatChipStyle]
  factory LMChatChipStyle.basic() {
    return LMChatChipStyle(
      backgroundColor: Colors.white,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16.0),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      labelPadding: EdgeInsets.zero,
      elevation: 0,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/extras/loader.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';

class LMChatLoader extends StatelessWidget {
  final bool isPrimary;
  final LMChatLoaderStyle? style;

  const LMChatLoader({
    super.key,
    this.isPrimary = true,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    LMChatLoaderStyle style = this.style ?? LMChatTheme.theme.loaderStyle;
    return Center(
      child: CircularProgressIndicator.adaptive(
        backgroundColor: style.backgroundColor,
        valueColor: AlwaysStoppedAnimation<Color>(
          style.color ??
              (isPrimary ? LMChatTheme.theme.primaryColor : Colors.white),
        ),
      ),
    );
  }

  LMChatLoader copyWith({
    bool? isPrimary,
    LMChatLoaderStyle? style,
  }) {
    return LMChatLoader(
      isPrimary: isPrimary ?? this.isPrimary,
      style: style ?? this.style,
    );
  }
}

class LMChatLoaderStyle {
  final Color? color;
  final Color? backgroundColor;

  const LMChatLoaderStyle({
    this.color,
    this.backgroundColor,
  });

  LMChatLoaderStyle copyWith({
    Color? color,
    Color? backgroundColor,
  }) {
    return LMChatLoaderStyle(
      color: color ?? this.color,
      backgroundColor: backgroundColor ?? this.backgroundColor,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/icon/icon.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/enums.dart';
import 'package:flutter_svg/flutter_svg.dart';

/// A simple icon widget to be used throughout the Chat
/// Represents three types of icons - icon, png, svg
/// Provides customisability through [LMChatIconStyle]
class LMChatIcon extends StatelessWidget {
  /// enum describing the type of icon to be shown
  final LMChatIconType type;

  /// if [LMChatIconType.icon] then pass icon of type [IconData]
  final IconData? icon;

  /// if [LMChatIconType.png] or [LMChatIconType.svg] then
  /// pass path of icon [String]
  final String? assetPath;

  /// style class for styling the icon [LMChatIconStyle]
  final LMChatIconStyle? style;

  /// either the icon [IconData] or asset path [String] must be provided
  const LMChatIcon({
    super.key,
    required this.type,
    this.assetPath,
    this.icon,
    this.style,
  }) : assert(icon != null || assetPath != null);

  getIconWidget(LMChatIconStyle style) {
    switch (type) {
      case LMChatIconType.icon:
        return Icon(
          icon,
          color: style.color,
          size: style.size?.abs() ?? 24,
        );
      case LMChatIconType.svg:
        return SizedBox(
          width: style.size?.abs() ?? 24,
          height: style.size?.abs() ?? 24,
          child: SvgPicture.asset(
            assetPath!,
            color: style.color,
            colorBlendMode:
                style.color == null ? BlendMode.srcIn : BlendMode.srcATop,
            fit: style.fit ?? BoxFit.contain,
          ),
        );
      case LMChatIconType.png:
        return SizedBox(
          width: style.size?.abs() ?? 24,
          height: style.size?.abs() ?? 24,
          child: Image.asset(
            assetPath!,
            fit: BoxFit.contain,
          ),
        );
    }
  }

  @override
  Widget build(BuildContext context) {
    final inStyle = style ?? LMChatIconStyle.basic();
    return Container(
      height: inStyle.boxSize ?? inStyle.size,
      width: inStyle.boxSize ?? inStyle.size,
      margin: inStyle.margin,
      padding: inStyle.boxPadding,
      decoration: BoxDecoration(
        color: inStyle.backgroundColor,
        borderRadius: BorderRadius.all(
          Radius.circular(inStyle.boxBorderRadius ?? 0),
        ),
        border: Border.all(
          width: inStyle.boxBorder ?? 0.0,
          strokeAlign: BorderSide.strokeAlignOutside,
          color: inStyle.boxBorderColor ?? Colors.transparent,
        ),
      ),
      child: getIconWidget(inStyle),
    );
  }

  LMChatIcon copyWith({
    LMChatIconType? type,
    IconData? icon,
    String? assetPath,
    LMChatIconStyle? style,
  }) {
    return LMChatIcon(
      type: type ?? this.type,
      icon: icon ?? this.icon,
      assetPath: assetPath ?? this.assetPath,
      style: style ?? this.style,
    );
  }
}

class LMChatIconStyle {
  /// color of the icon, not applicable on [LMChatIconType.png]
  final Color? color;

  /// square size of the icon
  final double? size;

  /// square size of the box surrounding the icon
  final double? boxSize;

  /// weight of the border around the box
  final double? boxBorder;

  /// weight of the border around the box
  final Color? boxBorderColor;

  /// radius of the box around the icon
  final double? boxBorderRadius;

  /// padding around icon with respect to the box
  final EdgeInsets? boxPadding;

  /// margin around the box
  final EdgeInsets? margin;

  /// color of the box, or background color of icon
  final Color? backgroundColor;

  /// fit inside the box for icon
  final BoxFit? fit;

  const LMChatIconStyle({
    this.color,
    this.size,
    this.boxSize,
    this.boxBorder,
    this.boxBorderColor,
    this.boxBorderRadius,
    this.boxPadding,
    this.margin,
    this.backgroundColor,
    this.fit,
  });

  factory LMChatIconStyle.basic() {
    return const LMChatIconStyle(
      size: 24,
      boxPadding: EdgeInsets.zero,
      fit: BoxFit.contain,
    );
  }

  LMChatIconStyle copyWith({
    Color? color,
    double? size,
    double? boxSize,
    double? boxBorder,
    double? boxBorderRadius,
    Color? boxBorderColor,
    EdgeInsets? boxPadding,
    EdgeInsets? margin,
    Color? backgroundColor,
    BoxFit? fit,
  }) {
    return LMChatIconStyle(
      color: color ?? this.color,
      size: size ?? this.size,
      boxSize: boxSize ?? this.boxSize,
      boxBorder: boxBorder ?? this.boxBorder,
      boxBorderColor: boxBorderColor ?? this.boxBorderColor,
      boxBorderRadius: boxBorderRadius ?? this.boxBorderRadius,
      boxPadding: boxPadding ?? this.boxPadding,
      margin: margin ?? this.margin,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      fit: fit ?? this.fit,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/menu/custom_pop_up_menu_style.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/common/icon/icon.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/common/text/text.dart';

/// A class representing the style properties for a custom popup menu.
class LMChatCustomPopupMenuStyle {
  /// The background color of the popup menu.
  Color? backgroundColor;

  /// Text style for the popup menu.
  LMChatTextStyle? textStyle;

  /// Icon style for the popup menu.
  LMChatIconStyle? iconStyle;

  /// The foreground color of the menu box.
  Color? menuBoxForegroundColor;

  /// The height of the menu box.
  double? menuBoxHeight;

  /// The width of the menu box.
  double? menuBoxWidth;

  /// The padding of the menu box.
  EdgeInsets? menuBoxPadding;

  /// The margin of the menu box.
  EdgeInsets? menuBoxMargin;

  /// The decoration of the menu box.
  BoxDecoration? menuBoxDecoration;

  /// Text style for the popup menu.
  TextStyle? menuTextStyle;

  /// Creates a new instance of [LMChatCustomPopupMenuStyle].
  LMChatCustomPopupMenuStyle({
    this.backgroundColor,
    this.textStyle,
    this.iconStyle,
    this.menuBoxForegroundColor,
    this.menuBoxHeight,
    this.menuBoxWidth,
    this.menuBoxPadding,
    this.menuBoxMargin,
    this.menuBoxDecoration,
    this.menuTextStyle,
  });

  /// Creates a copy of this [LMChatCustomPopupMenuStyle] but with the given fields replaced with the new values.
  /// If the new values are null, the old values are used.

  LMChatCustomPopupMenuStyle copyWith({
    Color? backgroundColor,
    LMChatTextStyle? textStyle,
    LMChatIconStyle? iconStyle,
    Color? menuBoxForegroundColor,
    double? menuBoxHeight,
    double? menuBoxWidth,
    EdgeInsets? menuBoxPadding,
    EdgeInsets? menuBoxMargin,
    BoxDecoration? menuBoxDecoration,
    TextStyle? menuTextStyle,
  }) {
    return LMChatCustomPopupMenuStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      textStyle: textStyle ?? this.textStyle,
      iconStyle: iconStyle ?? this.iconStyle,
      menuBoxForegroundColor:
          menuBoxForegroundColor ?? this.menuBoxForegroundColor,
      menuBoxHeight: menuBoxHeight ?? this.menuBoxHeight,
      menuBoxWidth: menuBoxWidth ?? this.menuBoxWidth,
      menuBoxPadding: menuBoxPadding ?? this.menuBoxPadding,
      menuBoxMargin: menuBoxMargin ?? this.menuBoxMargin,
      menuBoxDecoration: menuBoxDecoration ?? this.menuBoxDecoration,
      menuTextStyle: menuTextStyle ?? this.menuTextStyle,
    );
  }

  /// Merges this [LMChatCustomPopupMenuStyle] with another [LMChatCustomPopupMenuStyle].
  LMChatCustomPopupMenuStyle merge(LMChatCustomPopupMenuStyle? other) {
    if (other == null) return this;
    return copyWith(
      backgroundColor: other.backgroundColor ?? backgroundColor,
      textStyle: other.textStyle ?? textStyle,
      iconStyle: other.iconStyle ?? iconStyle,
      menuBoxForegroundColor:
          other.menuBoxForegroundColor ?? menuBoxForegroundColor,
      menuBoxHeight: other.menuBoxHeight ?? menuBoxHeight,
      menuBoxWidth: other.menuBoxWidth ?? menuBoxWidth,
      menuBoxPadding: other.menuBoxPadding ?? menuBoxPadding,
      menuBoxMargin: other.menuBoxMargin ?? menuBoxMargin,
      menuBoxDecoration: other.menuBoxDecoration ?? menuBoxDecoration,
      menuTextStyle: other.menuTextStyle ?? menuTextStyle,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/menu/menu.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_menu}
/// The chat menu widget.
/// This widget is used to show the chat menu.
/// The [LMChatMenu] widget takes the following parameters:
/// - [menuItems]: The list of menu items.
/// - [child]: The child widget.
/// - [style]: The style of the menu.
/// {@endtemplate}

class LMChatMenu extends StatelessWidget {
  /// Creates a new [LMChatMenu] with the provided values.
  /// The [menuItems] parameter is required.
  /// The [child] parameter is required.
  /// The [style] parameter is optional.
  /// The [key] parameter is optional.
  const LMChatMenu({
    super.key,
    required this.menuItems,
    required this.child,
    this.style,
  });

  /// The list of menu items.
  final List<LMChatMenuItem> menuItems;

  /// The child widget.
  final Widget child;

  /// The style of the menu.
  final LMChatMenuStyle? style;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onLongPressStart: (details) {
        _showMenu(context, details);
      },
      child: child,
    );
  }

  void _showMenu(BuildContext context, LongPressStartDetails details) {
    if (menuItems.isNotEmpty) {
      // finding the overlay to show the menu
      final RenderBox overlay =
          Overlay.of(context).context.findRenderObject() as RenderBox;
      // finding the position of the tap
      final RelativeRect position = RelativeRect.fromRect(
        Rect.fromPoints(
          details.globalPosition,
          details.globalPosition.translate(0, 0),
        ),
        overlay.localToGlobal(Offset.zero) & overlay.size,
      );
      // showing the menu
      showMenu(
        context: context,
        position: position,
        elevation: style?.elevation,
        shadowColor: style?.shadowColor,
        surfaceTintColor: style?.surfaceTintColor,
        semanticLabel: style?.semanticLabel,
        shape: style?.shape,
        color: style?.color,
        constraints: style?.constraints,
        clipBehavior: style?.clipBehavior ?? Clip.none,
        items: [
          for (LMChatMenuItem menuItem in menuItems)
            PopupMenuItem(
              onTap: () {
                menuItem.onTap();
              },
              padding: style?.itemPadding ?? EdgeInsets.zero,
              child: ListTile(
                leading: menuItem.leading,
                title: menuItem.title,
              ),
            ),
          // kVerticalPaddingSmall,
        ],
      );
    }
  }
}

/// {@template lm_chat_menu_style}
/// The style for the chat menu.
/// This class is used to style the chat menu.
/// The [LMChatMenuStyle] class takes the following parameters:
/// - [elevation]: The elevation of the menu.
/// - [shadowColor]: The shadow color of the menu.
/// - [surfaceTintColor]: The surface tint color of the menu.
/// - [semanticLabel]: The semantic label of the menu.
/// - [shape]: The shape of the menu.
/// - [color]: The color of the menu.
/// - [constraints]: The constraints of the menu.
/// - [clipBehavior]: The clip behavior of the menu.
/// - [itemPadding]: The padding of the menu item.
/// {@endtemplate}

class LMChatMenuStyle {
  /// The elevation of the menu.
  final double? elevation;

  /// The shadow color of the menu.
  final Color? shadowColor;

  /// The surface tint color of the menu.
  final Color? surfaceTintColor;

  /// The semantic label of the menu.
  final String? semanticLabel;

  /// The shape of the menu.
  final ShapeBorder? shape;

  /// The color of the menu.
  final Color? color;

  /// The constraints of the menu.
  final BoxConstraints? constraints;

  /// The clip behavior of the menu.
  final Clip? clipBehavior;

  /// The padding of the menu item.
  final EdgeInsets? itemPadding;

  /// Creates a new [LMChatMenuStyle] with the provided values.
  const LMChatMenuStyle({
    this.elevation,
    this.shadowColor,
    this.surfaceTintColor,
    this.semanticLabel,
    this.shape,
    this.color,
    this.constraints,
    this.clipBehavior,
    this.itemPadding,
  });

  /// Creates a copy of this [LMChatMenuStyle] but with the given fields replaced with the new values.
  /// If the new values are null, the old values are used.
  LMChatMenuStyle copyWith({
    double? elevation,
    Color? shadowColor,
    Color? surfaceTintColor,
    String? semanticLabel,
    ShapeBorder? shape,
    Color? color,
    BoxConstraints? constraints,
    Clip? clipBehavior,
    EdgeInsets? itemPadding,
  }) {
    return LMChatMenuStyle(
      elevation: elevation ?? this.elevation,
      shadowColor: shadowColor ?? this.shadowColor,
      surfaceTintColor: surfaceTintColor ?? this.surfaceTintColor,
      semanticLabel: semanticLabel ?? this.semanticLabel,
      shape: shape ?? this.shape,
      color: color ?? this.color,
      constraints: constraints ?? this.constraints,
      clipBehavior: clipBehavior ?? this.clipBehavior,
      itemPadding: itemPadding ?? this.itemPadding,
    );
  }

  /// A basic style for the chat menu.
  factory LMChatMenuStyle.basic({Color? onContainer}) => LMChatMenuStyle(
        elevation: 8,
        shadowColor: Colors.black.withOpacity(0.2),
        surfaceTintColor: onContainer ?? Colors.white,
        semanticLabel: 'Chat Menu',
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
        ),
        color: Colors.white,
        constraints: BoxConstraints(
          minWidth: 12.w,
          maxWidth: 60.w,
        ),
        clipBehavior: Clip.none,
        itemPadding: EdgeInsets.zero,
      );
}



================================================
File: lib/packages/ui/lib/src/widgets/common/menu/menu_item.dart
================================================
import 'package:flutter/material.dart';

/// {@template chat_menu_item}
/// The chat menu item widget.
/// This widget is used to show the chat menu item.
/// The [LMChatMenuItem] widget takes the following parameters:
/// - [leading]: The leading widget.
/// - [title]: The title widget.
/// - [onTap]: The onTap function.
/// {@endtemplate}
class LMChatMenuItem {
  /// Creates a new [LMChatMenuItem] with the provided values.
  const LMChatMenuItem({
    this.leading,
    required this.title,
    required this.onTap,
  });

  /// The leading widget.
  final Widget? leading;

  /// The title widget.
  final Widget title;

  /// The onTap function.
  final VoidCallback onTap;

  /// copyWith method
  /// This method is used to create a copy of the [LMChatMenuItem] but with the given fields replaced with the new values.
  /// If the new values are null, the old values are used.
  /// The method returns a new [LMChatMenuItem] object.
  LMChatMenuItem copyWith({
    Widget? leading,
    Widget? title,
    VoidCallback? onTap,
  }) {
    return LMChatMenuItem(
      leading: leading ?? this.leading,
      title: title ?? this.title,
      onTap: onTap ?? this.onTap,
    );
  }
}
/// {@template chat_menu_item_style}
/// The style for the chat menu item.
/// This class is used to style the chat menu item.
/// The [LMChatMenuItemStyle] widget takes the following parameters:
/// {@endtemplate}
class LMChatMenuItemStyle {}



================================================
File: lib/packages/ui/lib/src/widgets/common/sheets/bottom_sheet.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

class LMChatBottomSheet extends StatefulWidget {
  final LMChatText? title;
  final List<Widget> children;
  final LMChatBottomSheetStyle? style;

  const LMChatBottomSheet({
    Key? key,
    required this.children,
    this.style,
    this.title,
  }) : super(key: key);

  @override
  State<LMChatBottomSheet> createState() => _LMBottomSheetState();

  LMChatBottomSheet copyWith({
    LMChatText? title,
    List<Widget>? children,
    LMChatBottomSheetStyle? style,
  }) {
    return LMChatBottomSheet(
      title: title ?? this.title,
      style: style ?? this.style,
      children: children ?? this.children,
    );
  }
}

class _LMBottomSheetState extends State<LMChatBottomSheet> {
  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    Size screenSize = MediaQuery.of(context).size;
    LMChatThemeData theme = LMChatTheme.theme;
    return Container(
      width: screenSize.width,
      height: widget.style?.height,
      decoration: BoxDecoration(
        color: widget.style?.backgroundColor ?? theme.container,
        borderRadius: widget.style?.borderRadius,
        boxShadow: widget.style?.boxShadow,
      ),
      constraints: BoxConstraints(
        maxHeight: widget.style?.height ?? screenSize.height * 0.8,
        minHeight: screenSize.height * 0.2,
      ),
      margin: widget.style?.margin,
      padding:
          widget.style?.padding ?? const EdgeInsets.symmetric(horizontal: 20.0),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const SizedBox(height: 12),
          widget.style?.dragBar ??
              Container(
                width: 48,
                height: 8,
                decoration: ShapeDecoration(
                  color: widget.style?.dragBarColor ?? theme.disabledColor
                    ..withAlpha(200),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(99),
                  ),
                ),
              ),
          const SizedBox(height: 24),
          widget.title != null
              ? Container(
                  alignment: Alignment.topLeft,
                  margin: const EdgeInsets.only(bottom: 15),
                  child: widget.title)
              : const SizedBox.shrink(),
          Flexible(
            child: ListView.builder(
              shrinkWrap: true,
              padding: EdgeInsets.zero,
              itemBuilder: (context, index) => widget.children[index],
              itemCount: widget.children.length,
            ),
          ),
          const SizedBox(height: 24),
        ],
      ),
    );
  }
}

class LMChatBottomSheetStyle {
  final LMChatTextStyle? titleStyle;
  final Color? backgroundColor;
  final BorderRadiusGeometry? borderRadius;
  final double? height;
  final double? elevation;
  final EdgeInsets? padding;
  final EdgeInsets? margin;
  final List<BoxShadow>? boxShadow;
  final Widget? dragBar;
  final Color? dragBarColor;

  const LMChatBottomSheetStyle({
    this.titleStyle,
    this.backgroundColor,
    this.borderRadius,
    this.height,
    this.elevation,
    this.padding,
    this.margin,
    this.boxShadow,
    this.dragBar,
    this.dragBarColor,
  });

  LMChatBottomSheetStyle copyWith({
    Color? backgroundColor,
    BorderRadiusGeometry? borderRadius,
    double? height,
    double? elevation,
    EdgeInsets? padding,
    EdgeInsets? margin,
    List<BoxShadow>? boxShadow,
    Widget? dragBar,
    Color? dragBarColor,
    LMChatTextStyle? titleStyle,
  }) {
    return LMChatBottomSheetStyle(
      titleStyle: titleStyle ?? this.titleStyle,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      borderRadius: borderRadius ?? this.borderRadius,
      height: height ?? this.height,
      elevation: elevation ?? this.elevation,
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      boxShadow: boxShadow ?? this.boxShadow,
      dragBar: dragBar ?? this.dragBar,
      dragBarColor: dragBarColor ?? this.dragBarColor,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/snackbar/snackbar.dart
================================================
import 'package:flutter/material.dart';

class LMChatSnackBar extends SnackBar {
  final LMChatSnackBarStyle? style;

  LMChatSnackBar({
    super.key,
    this.style,
    required super.content,
  }) : super(
          action: style?.action,
          backgroundColor: style?.backgroundColor,
          behavior: style?.behavior,
          elevation: style?.elevation,
          margin: style?.margin,
          padding: style?.padding,
          shape: style?.shape,
          duration: style?.duration ?? const Duration(seconds: 4),
          animation: style?.animation,
          onVisible: style?.onVisible,
          clipBehavior: style?.clipBehavior ?? Clip.hardEdge,
          actionOverflowThreshold: style?.actionOverflowThreshold,
          closeIconColor: style?.closeIconColor,
          dismissDirection: style?.dismissDirection ?? DismissDirection.down,
          showCloseIcon: style?.showCloseIcon,
          width: style?.width,
        );

  LMChatSnackBar copyWith({
    LMChatSnackBarStyle? style,
    Widget? content,
  }) {
    return LMChatSnackBar(
      style: style ?? this.style,
      content: content ?? this.content,
    );
  }
}

class LMChatSnackBarStyle {
  final SnackBarAction? action;
  final Color? backgroundColor;
  final SnackBarBehavior? behavior;
  final double? elevation;
  final EdgeInsetsGeometry? margin;
  final EdgeInsetsGeometry? padding;
  final ShapeBorder? shape;
  final Duration? duration;
  final Animation<double>? animation;
  final VoidCallback? onVisible;
  final double? actionOverflowThreshold;
  final Clip? clipBehavior;
  final Color? closeIconColor;
  final DismissDirection? dismissDirection;
  final bool? showCloseIcon;
  final double? width;

  const LMChatSnackBarStyle({
    this.action,
    this.backgroundColor,
    this.behavior,
    this.elevation,
    this.margin,
    this.padding,
    this.shape,
    this.duration,
    this.animation,
    this.onVisible,
    this.actionOverflowThreshold,
    this.clipBehavior,
    this.closeIconColor,
    this.dismissDirection,
    this.showCloseIcon,
    this.width,
  });

  LMChatSnackBarStyle copyWith({
    SnackBarAction? action,
    Color? backgroundColor,
    SnackBarBehavior? behavior,
    double? elevation,
    EdgeInsetsGeometry? margin,
    EdgeInsetsGeometry? padding,
    ShapeBorder? shape,
    Duration? duration,
    Animation<double>? animation,
    VoidCallback? onVisible,
    double? actionOverflowThreshold,
    Clip? clipBehavior,
    Color? closeIconColor,
    DismissDirection? dismissDirection,
    bool? showCloseIcon,
    double? width,
  }) {
    return LMChatSnackBarStyle(
      action: action ?? this.action,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      behavior: behavior ?? this.behavior,
      elevation: elevation ?? this.elevation,
      margin: margin ?? this.margin,
      padding: padding ?? this.padding,
      shape: shape ?? this.shape,
      duration: duration ?? this.duration,
      animation: animation ?? this.animation,
      onVisible: onVisible ?? this.onVisible,
      actionOverflowThreshold:
          actionOverflowThreshold ?? this.actionOverflowThreshold,
      clipBehavior: clipBehavior ?? this.clipBehavior,
      closeIconColor: closeIconColor ?? this.closeIconColor,
      dismissDirection: dismissDirection ?? this.dismissDirection,
      showCloseIcon: showCloseIcon ?? this.showCloseIcon,
      width: width ?? this.width,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/text/text.dart
================================================
import 'package:flutter/material.dart';

/// {@template lm_chat_text}
/// A simple text widget to be used throughout the Chat experience
///
/// Provides high level customisability through [LMChatTextStyle]
///
/// Also, can add onTap functionality, and underlays
/// {@endtemplate}
class LMChatText extends StatelessWidget {
  /// text to be shown as [String]
  final String text;

  /// onTap functionality by providing a [Function]
  final Function()? onTap;

  /// style class to provide appearance customisability
  final LMChatTextStyle? style;

  /// {@macro lm_chat_text}
  const LMChatText(
    this.text, {
    Key? key,
    this.style,
    this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    LMChatTextStyle inStyle = style ?? LMChatTextStyle.basic();

    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: inStyle.padding ?? EdgeInsets.zero,
        decoration: BoxDecoration(
          color: inStyle.backgroundColor ?? Colors.transparent,
          borderRadius: BorderRadius.circular(inStyle.borderRadius ?? 4),
        ),
        child: AbsorbPointer(
          absorbing: onTap == null,
          child: Text(
            text,
            textAlign: inStyle.textAlign,
            maxLines: inStyle.maxLines,
            style: inStyle.textStyle,
          ),
        ),
      ),
    );
  }

  /// copyWith function to get a new object of [LMChatText]
  /// with specific single values passed
  LMChatText copyWith({
    String? text,
    LMChatTextStyle? style,
    Function()? onTap,
  }) {
    return LMChatText(
      text ?? this.text,
      style: style ?? this.style,
      onTap: onTap ?? this.onTap,
    );
  }
}

/// {@template lm_chat_text_style}
/// Style class for [LMChatText]; used for customization
/// {@endtemplate}
class LMChatTextStyle {
  /// [int] describing maximum lines a text spans
  final int? maxLines;

  /// Align behaviour for text [TextAlign]
  final TextAlign? textAlign;

  /// Default Flutter styling class for changing look of the text [TextStyle]
  final TextStyle? textStyle;

  /// Padding between the surrounding box and text
  final EdgeInsetsGeometry? padding;

  /// Background colour of the surrounding box of text
  final Color? backgroundColor;

  /// Border radius of the surrounding box of text
  final double? borderRadius;

  /// Background colour of the surrounding box of text
  final BoxBorder? border;

  /// The minimum number of lines to be supported
  final int? minLines;

  /// {@macro lm_chat_text}
  const LMChatTextStyle({
    this.textStyle,
    this.maxLines,
    this.minLines,
    this.textAlign,
    this.padding,
    this.border,
    this.borderRadius,
    this.backgroundColor,
  });

  /// Basic style factory constructor; used as default
  factory LMChatTextStyle.basic() {
    return const LMChatTextStyle(
      textAlign: TextAlign.start,
      textStyle: TextStyle(
        fontSize: 14,
        overflow: TextOverflow.ellipsis,
      ),
    );
  }

  /// copyWith function to get a new object of [LMChatTextStyle]
  /// with specific single values passed
  LMChatTextStyle copyWith({
    bool? selectable,
    TextStyle? textStyle,
    int? maxLines,
    int? minLines,
    TextOverflow? overflow,
    TextAlign? textAlign,
    EdgeInsetsGeometry? padding,
    BoxBorder? border,
    double? borderRadius,
    Color? backgroundColor,
  }) {
    return LMChatTextStyle(
      textStyle: textStyle ?? this.textStyle,
      maxLines: maxLines ?? this.maxLines,
      minLines: minLines ?? this.minLines,
      textAlign: textAlign ?? this.textAlign,
      padding: padding ?? this.padding,
      border: border ?? this.border,
      borderRadius: borderRadius ?? this.borderRadius,
      backgroundColor: backgroundColor ?? this.backgroundColor,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/common/tile/tile.dart
================================================
import 'package:flutter/material.dart';

/// {@template lm_chat_tile}
/// A widget to display a tile in the chat list
/// It can be used to display a chat room or a user in the chat list
/// It can be customized using the [LMChatTileStyle] using `style` property
/// extra properties can be passed using the `leading`, `title`, `subtitle` and `trailing` properties
/// {@endtemplate}
class LMChatTile extends StatelessWidget {
  /// {@macro lm_chat_tile}
  const LMChatTile({
    super.key,
    this.onTap,
    this.style,
    this.leading,
    this.title,
    this.subtitle,
    this.trailing,
    this.absorbTouch,
  });

  final VoidCallback? onTap;
  final LMChatTileStyle? style;

  final bool? absorbTouch;

  final Widget? leading;
  final Widget? title;
  final Widget? subtitle;
  final Widget? trailing;

  @override
  Widget build(BuildContext context) {
    // Either pick the passed style or the default style
    final inStyle = style ?? LMChatTileStyle.basic();

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: onTap,
      child: AbsorbPointer(
        absorbing: absorbTouch ?? true,
        child: Container(
          height: inStyle.height,
          width: inStyle.width,
          decoration: inStyle.decoration ??
              BoxDecoration(
                color: inStyle.backgroundColor,
                border: inStyle.border,
                borderRadius: BorderRadius.all(
                  Radius.circular(inStyle.borderRadius ?? 0),
                ),
              ),
          margin: inStyle.margin ?? const EdgeInsets.all(0),
          padding: inStyle.padding ?? const EdgeInsets.all(8),
          child: Row(
            mainAxisAlignment:
                inStyle.mainAxisAlignment ?? MainAxisAlignment.start,
            crossAxisAlignment:
                inStyle.crossAxisAlignment ?? CrossAxisAlignment.center,
            children: [
              leading ??
                  Container(
                    height: 48,
                    width: 48,
                    decoration: const BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.grey,
                    ),
                  ),
              SizedBox(width: inStyle.gap * 3),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    title ??
                        Container(
                          height: 14,
                          width: 120,
                          decoration: const BoxDecoration(
                            color: Colors.grey,
                          ),
                        ),
                    if (subtitle != null) SizedBox(height: inStyle.verticalGap),
                    subtitle ?? const SizedBox(),
                  ],
                ),
              ),
              if (trailing != null) const SizedBox(width: 8),
              trailing ?? const SizedBox()
            ],
          ),
        ),
      ),
    );
  }

  /// `copyWith` method to update the properties of the tile
  /// with new values without changing the original tile
  LMChatTile copyWith({
    Function()? onTap,
    LMChatTileStyle? style,
    Widget? leading,
    Widget? title,
    Widget? subtitle,
    Widget? trailing,
  }) {
    return LMChatTile(
      onTap: onTap ?? this.onTap,
      style: style ?? this.style,
      leading: leading ?? this.leading,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      trailing: trailing ?? this.trailing,
    );
  }
}

class LMChatTileStyle {
  /// background color of the tile, defaults to transparent
  final Color? backgroundColor;

  /// border around the tile
  final Border? border;

  /// border radius of the tile, visible when bgColor is passed
  final double? borderRadius;

  /// box decoration for the tile
  /// if passed, border radius and background color are ignored
  final BoxDecoration? decoration;

  /// main axis alignment for the row inside the tile
  final MainAxisAlignment? mainAxisAlignment;

  /// cross axis alignment for the row inside the tile
  final CrossAxisAlignment? crossAxisAlignment;

  /// padding from exterior bounds (borders)
  final EdgeInsets? padding;

  /// margin around the tile
  final EdgeInsets? margin;

  /// height of the tile
  final double? height;

  /// width of the tile
  final double? width;

  /// gap between the leading and title/subtitle
  final double gap;

  /// gap between the title and subtitle
  final double? verticalGap;

  const LMChatTileStyle({
    this.backgroundColor,
    this.border,
    this.borderRadius,
    this.decoration,
    this.mainAxisAlignment,
    this.crossAxisAlignment,
    this.padding,
    this.margin,
    this.height,
    this.width,
    this.verticalGap,
    required this.gap,
  });

  LMChatTileStyle copyWith(
      {Color? backgroundColor,
      Border? border,
      double? borderRadius,
      BoxDecoration? decoration,
      MainAxisAlignment? mainAxisAlignment,
      CrossAxisAlignment? crossAxisAlignment,
      EdgeInsets? padding,
      EdgeInsets? margin,
      double? height,
      double? width,
      double? gap,
      double? verticalGap}) {
    return LMChatTileStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      border: border ?? this.border,
      decoration: decoration ?? this.decoration,
      borderRadius: borderRadius ?? this.borderRadius,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      height: height ?? this.height,
      width: width ?? this.width,
      gap: gap ?? this.gap,
      verticalGap: verticalGap ?? this.verticalGap,
    );
  }

  factory LMChatTileStyle.basic() {
    return const LMChatTileStyle(
      backgroundColor: Colors.transparent,
      borderRadius: 0,
      mainAxisAlignment: MainAxisAlignment.start,
      crossAxisAlignment: CrossAxisAlignment.center,
      padding: EdgeInsets.all(12),
      width: double.infinity,
      gap: 4,
      verticalGap: 2,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/packages/expandable_text/expandable_text.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/media/attachment_convertor.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/conversation/chat_bubble_clipper.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';
import 'package:swipe_to_action/swipe_to_action.dart';
import 'package:custom_pop_up_menu/custom_pop_up_menu.dart';
import 'package:collection/collection.dart';

part 'chat_bubble_content.dart';
part 'chat_bubble_footer.dart';
part 'chat_bubble_header.dart';
part 'chat_bubble_media.dart';
part 'chat_bubble_reply.dart';
part 'chat_bubble_sides.dart';
part 'chat_bubble_state.dart';
part 'chat_bubble_reactions.dart';

/// {@template lm_chat_bubble}
/// The chat bubble widget.
/// This widget is used to display the chat bubble.
/// {@endtemplate}
class LMChatBubble extends StatefulWidget {
  /// [LMChatConversationViewData] is data of the conversation.
  final LMChatConversationViewData conversation;

  /// The current user.
  final LMChatUserViewData currentUser;

  /// The user of the conversation.
  final LMChatUserViewData conversationUser;

  /// The list of attachments for this chat bubble
  final List<LMChatAttachmentViewData>? attachments;

  /// The list of attachments for this chat bubble
  final List<LMChatReactionViewData>? reactions;

  /// The user meta for this chat bubble
  final Map<int, LMChatUserViewData>? userMeta;

  /// is the message sent by the current user.
  final bool? isSent;

  /// The reply icon.
  final LMChatIcon? replyIcon;

  /// The avatar of the user.
  final LMChatProfilePicture? avatar;

  /// The avatar builder for the user.
  final LMChatProfilePictureBuilder? avatarBuilder;

  /// The function to call when a reply is made.
  final Function(LMChatConversationViewData)? onReply;

  /// The function to call when a tag is tapped.
  final Function(String tag) onTagTap;

  /// The deleted text.
  final LMChatText? deletedText;

  /// The style of the bubble.
  final LMChatBubbleStyle? style;

  /// The selected state of the bubble.
  final bool isSelected;

  /// The function to call when the bubble is tapped.
  final Function(bool isSelected, State<LMChatBubble> state)? onTap;

  /// The function to call when the bubble media is tapped.
  final void Function()? onMediaTap;

  /// The function to call when the bubble is long pressed.
  final Function(bool isSelected, State<LMChatBubble> state)? onLongPress;

  /// The function to call when the bubble is selectable on tap.
  final bool Function()? isSelectableOnTap;

  /// The header builder.
  final Widget Function(BuildContext context, LMChatBubbleHeader header)?
      headerBuilder;

  /// The content builder.
  final Widget Function(BuildContext context, LMChatBubbleContent content)?
      contentBuilder;

  /// The footer builder.
  final Widget Function(BuildContext context, LMChatBubbleFooter footer)?
      footerBuilder;

  /// The deleted text builder.
  final Widget Function(BuildContext context, LMChatText text)?
      deletedTextBuilder;

  /// bool to check whether a message is a DM message
  final bool? isDM;

  /// The media builder.
  final Widget Function(
    BuildContext context,
    List<LMChatAttachmentViewData>? attachments,
    LMChatBubbleMedia media,
  )? mediaBuilder;

  /// The function to call when a reaction is made.
  final Function(String reaction)? onReaction;

  /// The function to call when a reaction is removed from bottom sheet.
  final Function(String reaction)? onRemoveReaction;

  /// The builder function to build a reply widget
  final Function(LMChatConversationViewData reply, LMChatBubbleReply oldWidget)?
      replyBuilder;

  /// The Link Preview widget builder.s
  final Widget Function(
    LMChatOGTagsViewData ogTags,
    LMChatLinkPreview oldLinkPreviewWidget,
  )? linkPreviewBuilder;

  /// Builder for bubble reactions
  final Widget Function(List<LMChatReactionViewData> reactions,
      LMChatBubbleReactions oldWidget)? bubbleReactionsBuilder;

  /// Builder for reactions bar on chat bubble
  final Widget Function(LMChatReactionBar oldWidget)? reactionBarBuilder;

  ///Callback for catching when reactions are tapped
  final VoidCallback? onReactionsTap;

  /// Poll Widget
  final LMChatPoll? poll;

  /// Poll Widget builder
  final LMChatPollBuilder? pollBuilder;

  /// Instance of [LMChatAudioHandler] to manage audio playback seamlessly
  final LMChatAudioHandler? audioHandler;

  /// Callback for reply tap
  final VoidCallback? onReplyTap;

  /// The action helper for the chat bubble
  final LMChatConversationActionInterface? actionHelper;

  final Widget Function(BuildContext context, Widget container)?
      chatBubbleContainerBuilder;

  /// The [LMChatBubble] widget constructor.
  /// used to display the chat bubble.
  const LMChatBubble({
    super.key,
    required this.conversation,
    required this.currentUser,
    required this.conversationUser,
    required this.onTagTap,
    this.audioHandler,
    this.reactions,
    this.userMeta,
    this.onRemoveReaction,
    this.attachments,
    this.style,
    this.contentBuilder,
    this.onReply,
    this.replyIcon,
    this.avatar,
    this.avatarBuilder,
    this.isSent,
    this.deletedText,
    this.isSelected = false,
    this.isDM,
    this.onTap,
    this.onMediaTap,
    this.onLongPress,
    this.isSelectableOnTap,
    this.headerBuilder,
    this.footerBuilder,
    this.deletedTextBuilder,
    this.mediaBuilder,
    this.onReaction,
    this.linkPreviewBuilder,
    this.poll,
    this.pollBuilder,
    this.bubbleReactionsBuilder,
    this.reactionBarBuilder,
    this.replyBuilder,
    this.onReactionsTap,
    this.onReplyTap,
    this.actionHelper,
    this.chatBubbleContainerBuilder,
  });

  /// Creates a copy of this [LMChatBubble] but with the given fields replaced with the new values.
  /// If the new values are null, then the old values are used.
  LMChatBubble copyWith({
    LMChatConversationViewData? conversation,
    LMChatUserViewData? currentUser,
    LMChatUserViewData? conversationUser,
    List<LMChatAttachmentViewData>? attachments,
    List<LMChatReactionViewData>? reactions,
    Map<int, LMChatUserViewData>? userMeta,
    bool? isSent,
    LMChatIcon? replyIcon,
    LMChatProfilePicture? avatar,
    LMChatProfilePictureBuilder? avatarBuilder,
    Function(LMChatConversationViewData)? onReply,
    Function(String tag)? onTagTap,
    LMChatText? deletedText,
    LMChatBubbleStyle? style,
    bool? isSelected,
    Function(bool isSelected, State<LMChatBubble> state)? onTap,
    void Function()? onMediaTap,
    Function(bool isSelected, State<LMChatBubble> state)? onLongPress,
    bool Function()? isSelectableOnTap,
    Widget Function(BuildContext context, LMChatBubbleHeader header)?
        headerBuilder,
    Widget Function(BuildContext context, LMChatBubbleContent content)?
        contentBuilder,
    Widget Function(BuildContext context, LMChatBubbleFooter footer)?
        footerBuilder,
    Widget Function(BuildContext context, LMChatText text)? deletedTextBuilder,
    bool? isDM,
    Widget Function(
            BuildContext context,
            List<LMChatAttachmentViewData>? attachments,
            LMChatBubbleMedia media)?
        mediaBuilder,
    Function(String reaction)? onReaction,
    Function(String reaction)? onRemoveReaction,
    Function(LMChatConversationViewData reply, LMChatBubbleReply oldWidget)?
        replyBuilder,
    Widget Function(LMChatOGTagsViewData ogTags,
            LMChatLinkPreview oldLinkPreviewWidget)?
        linkPreviewBuilder,
    Widget Function(List<LMChatReactionViewData> reactions,
            LMChatBubbleReactions oldWidget)?
        bubbleReactionsBuilder,
    Widget Function(LMChatReactionBar oldWidget)? reactionBarBuilder,
    VoidCallback? onReactionsTap,
    LMChatPoll? poll,
    LMChatPollBuilder? pollBuilder,
    LMChatAudioHandler? audioHandler,
    VoidCallback? onReplyTap,
    LMChatConversationActionInterface? actionHelper,
    Widget Function(BuildContext context, Widget container)?
        chatBubbleContainerBuilder,
  }) {
    return LMChatBubble(
      conversation: conversation ?? this.conversation,
      currentUser: currentUser ?? this.currentUser,
      conversationUser: conversationUser ?? this.conversationUser,
      attachments: attachments ?? this.attachments,
      reactions: reactions ?? this.reactions,
      userMeta: userMeta ?? this.userMeta,
      isSent: isSent ?? this.isSent,
      replyIcon: replyIcon ?? this.replyIcon,
      avatar: avatar ?? this.avatar,
      avatarBuilder: avatarBuilder ?? this.avatarBuilder,
      onReply: onReply ?? this.onReply,
      onTagTap: onTagTap ?? this.onTagTap,
      deletedText: deletedText ?? this.deletedText,
      style: style ?? this.style,
      isSelected: isSelected ?? this.isSelected,
      onTap: onTap ?? this.onTap,
      onMediaTap: onMediaTap ?? this.onMediaTap,
      onLongPress: onLongPress ?? this.onLongPress,
      isSelectableOnTap: isSelectableOnTap ?? this.isSelectableOnTap,
      headerBuilder: headerBuilder ?? this.headerBuilder,
      contentBuilder: contentBuilder ?? this.contentBuilder,
      footerBuilder: footerBuilder ?? this.footerBuilder,
      deletedTextBuilder: deletedTextBuilder ?? this.deletedTextBuilder,
      isDM: isDM ?? this.isDM,
      mediaBuilder: mediaBuilder ?? this.mediaBuilder,
      onReaction: onReaction ?? this.onReaction,
      onRemoveReaction: onRemoveReaction ?? this.onRemoveReaction,
      replyBuilder: replyBuilder ?? this.replyBuilder,
      linkPreviewBuilder: linkPreviewBuilder ?? this.linkPreviewBuilder,
      bubbleReactionsBuilder:
          bubbleReactionsBuilder ?? this.bubbleReactionsBuilder,
      reactionBarBuilder: reactionBarBuilder ?? this.reactionBarBuilder,
      onReactionsTap: onReactionsTap ?? this.onReactionsTap,
      poll: poll ?? this.poll,
      pollBuilder: pollBuilder ?? this.pollBuilder,
      audioHandler: audioHandler ?? this.audioHandler,
      onReplyTap: onReplyTap ?? this.onReplyTap,
      actionHelper: actionHelper ?? this.actionHelper,
      chatBubbleContainerBuilder:
          chatBubbleContainerBuilder ?? this.chatBubbleContainerBuilder,
    );
  }

  @override
  State<LMChatBubble> createState() => _LMChatBubbleState();
}

class _LMChatBubbleState extends State<LMChatBubble> {
  late LMChatConversationViewData conversation;
  late LMChatUserViewData currentUser;
  late LMChatUserViewData conversationUser;
  late GlobalObjectKey _chatBubbleKey;

  bool isSent = false;
  bool _isSelected = false;
  bool _isDeleted = false;
  final LMChatThemeData _themeData = LMChatTheme.theme;

  final CustomPopupMenuController reactionBarController =
      CustomPopupMenuController();
  final LMChatThemeData theme = LMChatTheme.theme;
  List<LMChatReactionViewData>? reactions = [];

  // Add ValueNotifier for voice note duration
  late final ValueNotifier<Duration> _voiceNoteDurationNotifier;

  @override
  void initState() {
    super.initState();
    conversation = widget.conversation;
    currentUser = widget.currentUser;
    conversationUser = widget.conversationUser;
    isSent = currentUser.id == conversationUser.id;
    _isSelected = widget.isSelected;
    _isDeleted = conversation.deletedByUserId != null;
    _chatBubbleKey = GlobalObjectKey(conversation.id);
    reactions = widget.reactions;

    // Initialize voice note duration from metadata if available
    final Duration initialDuration;
    if (!_isDeleted) {
      final voiceNoteAttachment = widget.attachments?.firstWhereOrNull(
          (attachment) => attachment.type == kAttachmentTypeVoiceNote);

      initialDuration = Duration(
        seconds: int.tryParse(
              voiceNoteAttachment?.meta?["duration"]?.toString() ?? "0",
            ) ??
            0,
      );
    } else {
      initialDuration = Duration.zero;
    }
    _voiceNoteDurationNotifier = ValueNotifier(initialDuration);
  }

  @override
  void didUpdateWidget(LMChatBubble old) {
    super.didUpdateWidget(old);
    conversation = widget.conversation;
    currentUser = widget.currentUser;
    conversationUser = widget.conversationUser;
    isSent = currentUser.id == conversationUser.id;
    _isSelected = widget.isSelected;
    _isDeleted = conversation.deletedByUserId != null;
    reactions = widget.reactions;

    // Update duration notifier if attachments change
    if (!_isDeleted &&
        widget.attachments?.first.meta?["duration"] !=
            old.attachments?.first.meta?["duration"]) {
      _voiceNoteDurationNotifier.value = Duration(
        seconds: int.tryParse(
              widget.attachments?.first.meta["duration"]?.toString() ?? "0",
            ) ??
            0,
      );
    }
  }

  @override
  void dispose() {
    _voiceNoteDurationNotifier.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    double finalWidth = calculateFinalWidth();

    final inStyle = widget.style ?? LMChatTheme.theme.bubbleStyle;
    return _isDeleted
        ? _defChatBubbleBuilder(inStyle, context, finalWidth)
        : Swipeable(
            dismissThresholds: const {SwipeDirection.startToEnd: 0.0},
            movementDuration: const Duration(milliseconds: 50),
            key: ObjectKey(conversation.id),
            onSwipe: (direction) {
              if (widget.onReply != null &&
                  widget.conversation.deletedByUserId == null) {
                widget.onReply!(conversation);
              }
            },
            background: Padding(
              padding: EdgeInsets.only(
                left: 2.w,
                right: 2.w,
                top: 0.2.h,
                bottom: 0.2.h,
              ),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  widget.replyIcon ??
                      LMChatIcon(
                        type: LMChatIconType.icon,
                        icon: Icons.reply_outlined,
                        style: LMChatIconStyle(
                          color: LMChatTheme.theme.primaryColor,
                          size: 28,
                          boxSize: 28,
                        ),
                      ),
                ],
              ),
            ),
            direction: SwipeDirection.startToEnd,
            child: _defChatBubbleBuilder(inStyle, context, finalWidth),
          );
  }

  Widget _defChatBubbleBuilder(
      LMChatBubbleStyle inStyle, BuildContext context, double finalWidth) {
    return GestureDetector(
      onLongPress: () {
        if (_isDeleted) return;
        // Only handle long press if not already selected
        if (!_isSelected) {
          setState(() {
            _isSelected = true;
          });
          widget.onLongPress?.call(_isSelected, this);
          reactionBarController.showMenu();

          final RenderBox renderBox = context.findRenderObject() as RenderBox;
          final Offset bubblePosition = renderBox.localToGlobal(Offset.zero);
          final Size bubbleSize = renderBox.size;

          // Calculate menu position based on bubble width and alignment
          const double menuWidth = 180.0; // Fixed menu width
          double menuX;

          if (isSent) {
            // For sent messages (right aligned), position from right edge
            menuX = bubblePosition.dx + bubbleSize.width - menuWidth;
          } else {
            // For received messages (left aligned), position from left edge
            menuX = bubblePosition.dx;
          }

          final Offset offset = Offset(
            menuX,
            bubblePosition.dy + bubbleSize.height + 4, // 4px gap below bubble
          );

          widget.actionHelper?.showSelectionMenu(
            context,
            offset,
          );
        }
      },
      onTap: () {
        if (_isDeleted) return;

        setState(() {
          if (_isSelected) {
            _isSelected = false;
            widget.onTap?.call(_isSelected, this);
          } else {
            // Only allow selection on tap if explicitly enabled
            if (widget.isSelectableOnTap?.call() ?? false) {
              _isSelected = true;
              widget.onTap?.call(_isSelected, this);
            }
          }
        });
      },
      child: Stack(
        children: [
          AnimatedContainer(
            duration: const Duration(
              milliseconds: 300,
            ),
            foregroundDecoration: BoxDecoration(
              color: _isSelected
                  ? inStyle.selectedColor ??
                      const Color.fromRGBO(0, 96, 86, 0.3)
                  : null,
            ),
            padding: EdgeInsets.only(
              left: 1.8.w,
              right: 1.8.w,
              top: conversation.conversationViewType !=
                      LMChatConversationViewType.bottom
                  ? 0.8.h
                  : 0,
              bottom: 0.6.h,
            ),
            child: Row(
              mainAxisAlignment:
                  isSent ? MainAxisAlignment.end : MainAxisAlignment.start,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                if (!isSent) ...[
                  widget.avatarBuilder?.call(
                        context,
                        _defAvatar(!isSent),
                      ) ??
                      const SizedBox.shrink(),
                  // create a space between the bubble and the avatar
                  SizedBox(width: inStyle.gap),
                ],
                widget.chatBubbleContainerBuilder?.call(
                      context,
                      _defChatContainer(inStyle, context, finalWidth),
                    ) ??
                    _defChatContainer(inStyle, context, finalWidth),
                if (isSent) ...[
                  // create a space between the bubble and the avatar
                  SizedBox(width: inStyle.gap),
                  widget.avatarBuilder?.call(
                        context,
                        _defAvatar(isSent),
                      ) ??
                      const SizedBox.shrink(),
                ]
              ],
            ),
          ),
          _buildReactionButton(),
        ],
      ),
    );
  }

  Column _defChatContainer(
      LMChatBubbleStyle inStyle, BuildContext context, double finalWidth) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        AbsorbPointer(
          absorbing: _isDeleted,
          child: Container(
            decoration: inStyle.decoration ??
                BoxDecoration(
                  color:
                      !inStyle.enableClipper ? inStyle.backgroundColor : null,
                ),
            constraints: BoxConstraints(
              minHeight: 2.h,
              minWidth: conversation.answer.split('\n').length > 4 ? 40.w : 5.w,
              maxWidth:
                  (widget.attachments != null && widget.attachments!.isNotEmpty)
                      ? 60.w
                      : conversation.state == 10
                          ? 70.w
                          : 65.w,
            ),
            child: inStyle.enableClipper
                ? PhysicalShape(
                    clipper: inStyle.clipper ??
                        LMChatBubbleClipper(
                          isSent: isSent,
                          conversationViewType:
                              conversation.conversationViewType ??
                                  LMChatConversationViewType.top,
                        ),
                    color: inStyle.backgroundColor ?? _themeData.container,
                    child: _defBubble(inStyle, context, finalWidth),
                  )
                : _defBubble(inStyle, context, finalWidth),
          ),
        ),
        widget.bubbleReactionsBuilder?.call(
                reactions ?? [],
                LMChatBubbleReactions(
                  conversation: conversation,
                  currentUser: currentUser,
                  userMeta: widget.userMeta ?? {},
                  onRemoveReaction: widget.onRemoveReaction,
                  reactions: reactions,
                  onReactionsTap: widget.onReactionsTap,
                )) ??
            LMChatBubbleReactions(
              conversation: conversation,
              currentUser: currentUser,
              userMeta: widget.userMeta ?? {},
              onRemoveReaction: widget.onRemoveReaction,
              reactions: reactions,
              onReactionsTap: widget.onReactionsTap,
            ),
      ],
    );
  }

  Padding _defBubble(
      LMChatBubbleStyle inStyle, BuildContext context, double finalWidth) {
    return Padding(
      padding: isSent
          ? EdgeInsets.only(
              top: _isDeleted ? 0.8.h : 1.h,
              bottom: _isDeleted ? 1.2.h : 1.h,
              left: 3.w,
              right: 3.w + (inStyle.enableClipper ? 10 : 0),
            )
          : EdgeInsets.only(
              top: _isDeleted ? 0.8.h : 1.h,
              bottom: _isDeleted ? 1.2.h : 1.h,
              left: 3.w + (inStyle.enableClipper ? 10 : 0),
              right: 3.w,
            ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (inStyle.showHeader ?? true)
            widget.headerBuilder?.call(
                    context,
                    LMChatBubbleHeader(
                      conversationUser: widget.conversationUser,
                    )) ??
                LMChatBubbleHeader(
                  conversationUser: widget.conversationUser,
                ),
          // poll widget
          if (conversation.state == 10 && !_isDeleted) ...[
            widget.pollBuilder?.call(
                  context,
                  widget.poll ??
                      LMChatPoll(
                        pollData: conversation,
                      ),
                  conversation,
                ) ??
                widget.poll ??
                LMChatPoll(
                  pollData: conversation,
                ),
          ],
          // link preview widget
          if (conversation.ogTags != null &&
              conversation.deletedByUserId == null)
            widget.linkPreviewBuilder?.call(
                  conversation.ogTags!,
                  _defLinkPreviewWidget(conversation.ogTags!),
                ) ??
                _defLinkPreviewWidget(conversation.ogTags!),
          if (conversation.replyConversationObject != null &&
              conversation.deletedByUserId == null) ...[
            widget.replyBuilder?.call(
                    conversation.replyConversationObject!, _defReplyWidget()) ??
                _defReplyWidget(),
            const SizedBox(height: 4),
          ],
          AbsorbPointer(
            absorbing: _isSelected,
            child: GestureDetector(
              onTap: () {
                if (widget.attachments != null) {
                  widget.onMediaTap?.call();
                }
              },
              child: !_isDeleted
                  ? widget.mediaBuilder?.call(
                        context,
                        widget.attachments ?? [],
                        LMChatBubbleMedia(
                          audioHandler: widget.audioHandler,
                          conversation: conversation,
                          attachments: widget.attachments ?? [],
                          count: conversation.attachments?.length ?? 0,
                          attachmentUploaded:
                              conversation.attachmentsUploaded ?? false,
                          onVoiceNoteDurationUpdate: kAttachmentTypeVoiceNote ==
                                  widget.attachments?.first.type
                              ? _handleVoiceNoteDurationUpdate
                              : null,
                        ),
                      ) ??
                      LMChatBubbleMedia(
                        audioHandler: widget.audioHandler,
                        conversation: conversation,
                        attachments: widget.attachments ?? [],
                        count: conversation.attachments?.length ?? 0,
                        attachmentUploaded:
                            conversation.attachmentsUploaded ?? false,
                        onVoiceNoteDurationUpdate: kAttachmentTypeVoiceNote ==
                                widget.attachments?.first.type
                            ? _handleVoiceNoteDurationUpdate
                            : null,
                      )
                  : const SizedBox.shrink(),
            ),
          ),
          _isDeleted
              ? widget.deletedText ??
                  widget.deletedTextBuilder?.call(
                    context,
                    _defDeletedWidget(),
                  ) ??
                  _defDeletedWidget()
              : conversation.state == 10
                  ? const SizedBox.shrink()
                  : widget.contentBuilder?.call(
                        context,
                        LMChatBubbleContent(
                          conversation: widget.attachments?.first.type == "gif"
                              ? conversation.copyWith(answer: _getGIFText())
                              : conversation,
                          onTagTap: widget.onTagTap,
                          style: theme.contentStyle,
                        ),
                      ) ??
                      LMChatBubbleContent(
                        conversation: widget.attachments?.first.type == "gif"
                            ? conversation.copyWith(answer: _getGIFText())
                            : conversation,
                        onTagTap: widget.onTagTap,
                        style: theme.contentStyle,
                      ),
          if (conversation.deletedByUserId == null &&
              inStyle.showFooter == true)
            Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: kAttachmentTypeVoiceNote == widget.attachments?.first.type
                  ? ValueListenableBuilder<Duration>(
                      valueListenable: _voiceNoteDurationNotifier,
                      builder: (context, duration, _) {
                        final footerWidget = LMChatBubbleFooter(
                          conversation: conversation,
                          textWidth: finalWidth,
                          voiceDuration: LMChatText(
                            formatDuration(duration.inSeconds),
                            style: LMChatTextStyle(
                              textStyle: TextStyle(
                                fontSize: 12,
                                color: LMChatTheme.theme.onContainer
                                    .withOpacity(0.6),
                              ),
                            ),
                          ),
                        );

                        return widget.footerBuilder?.call(
                              context,
                              footerWidget,
                            ) ??
                            footerWidget;
                      },
                    )
                  : widget.footerBuilder?.call(
                        context,
                        LMChatBubbleFooter(
                          conversation: conversation,
                          textWidth: finalWidth,
                        ),
                      ) ??
                      LMChatBubbleFooter(
                        conversation: conversation,
                        textWidth: finalWidth,
                      ),
            ),
        ],
      ),
    );
  }

  LMChatBubbleReply _defReplyWidget() {
    return LMChatBubbleReply(
      onTap: widget.onReplyTap,
      replyToConversation: conversation.replyConversationObject!,
      title: LMChatText(
        currentUser.id == conversation.replyConversationObject!.memberId
            ? "You"
            : conversation.replyConversationObject!.member!.name,
        style: LMChatTextStyle(
          maxLines: 1,
          textStyle: TextStyle(
            overflow: TextOverflow.ellipsis,
            color: _themeData.primaryColor,
            fontSize: 12,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }

  LMChatLinkPreview _defLinkPreviewWidget(LMChatOGTagsViewData ogTags) {
    return LMChatLinkPreview(
      ogTags: ogTags,
      style: widget.style?.linkPreviewStyle ??
          LMChatLinkPreviewStyle.basic(
            inactiveColor: _themeData.inActiveColor,
            containerColor: _themeData.onContainer,
          ),
    );
  }

  LMChatText _defDeletedWidget() {
    return LMChatText(
      _getDeletedText(),
      style: LMChatTextStyle(
        textStyle: _isDeleted
            ? TextStyle(
                fontStyle: FontStyle.italic,
                color: LMChatTheme.theme.disabledColor,
              )
            : TextStyle(
                fontSize: 14,
                color: LMChatTheme.theme.disabledColor,
              ),
      ),
    );
  }

  String _getDeletedText() {
    return conversation.deletedByUserId == conversation.memberId
        ? conversation.deletedByUserId == currentUser.id
            ? 'You deleted this message'
            : "This message was deleted"
        : "This message was deleted by a community manager";
  }

  String _getGIFText() {
    String gifText = conversation.answer;
    const String gifMessageIndicator =
        "* This is a gif message. Please update your app *";

    if (gifText.endsWith(gifMessageIndicator)) {
      gifText = gifText
          .substring(0, gifText.length - gifMessageIndicator.length)
          .trim();
    }

    return gifText;
  }

  double calculateFinalWidth() {
    // if the conversation is a poll, return the max width
    if (conversation.state == 10) return double.infinity;

    // Get all lines of text
    final lines =
        LMChatTaggingHelper.convertRouteToTag(widget.conversation.answer)!
            .split('\n');

    // Measure width for each line
    double maxTextWidth = 0;
    for (String line in lines) {
      final textPainter = TextPainter(
        text: TextSpan(
          text: line,
          style: const TextStyle(fontSize: 14),
        ),
        maxLines: 1,
        textDirection: TextDirection.ltr,
      );
      textPainter.layout();
      if (textPainter.width > maxTextWidth) {
        maxTextWidth = textPainter.width;
      }
    }
    maxTextWidth += 1; // Add padding

    // Determine the width to use
    if ((widget.attachments != null && widget.attachments!.isNotEmpty) ||
        conversation.replyId != null ||
        conversation.replyConversationObject != null) {
      return 65.w; // Full width if media or reply is present
    }

    if (conversation.ogTags != null) {
      return double.infinity; // Full width if link preview is present
    }

    if (widget.isDM == true) {
      return maxTextWidth; // Only consider text width for DM
    } else {
      // Measure the header width if a header is present and not a DM
      final headerPainter = TextPainter(
        text: TextSpan(
          text: conversationUser.name,
          style: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
          ),
        ),
        maxLines: 1,
        textDirection: TextDirection.ltr,
      );
      headerPainter.layout();
      double headerWidth =
          conversation.memberId == currentUser.id ? 0 : headerPainter.width;

      return maxTextWidth > headerWidth ? maxTextWidth : headerWidth;
    }
  }

  Widget _buildReactionButton() {
    return IgnorePointer(
      child: SizedBox(
        height: getHeightOfWidget(_chatBubbleKey),
        child: CustomPopupMenu(
          pressType: PressType.longPress,
          controller: reactionBarController,
          arrowColor: Colors.transparent,
          barrierColor: Colors.transparent,
          position: PreferredPosition.top,
          verticalMargin: 4,
          menuBuilder: () =>
              widget.reactionBarBuilder?.call(LMChatReactionBar(
                onReaction: (reaction) {
                  widget.onReaction?.call(reaction);
                  reactionBarController.hideMenu();
                  if (_isSelected) {
                    _isSelected = false;
                    widget.onTap?.call(_isSelected, this);
                  } else {
                    if (widget.isSelectableOnTap?.call() ?? false) {
                      _isSelected = !_isSelected;
                      widget.onTap?.call(_isSelected, this);
                    }
                  }
                },
              )) ??
              LMChatReactionBar(
                onReaction: (reaction) {
                  widget.onReaction?.call(reaction);
                  reactionBarController.hideMenu();
                  if (_isSelected) {
                    _isSelected = false;
                    widget.onTap?.call(_isSelected, this);
                  } else {
                    if (widget.isSelectableOnTap?.call() ?? false) {
                      _isSelected = !_isSelected;
                      widget.onTap?.call(_isSelected, this);
                    }
                  }
                },
              ),
          child: const SizedBox(),
        ),
      ),
    );
  }

  String formatDuration(int seconds) {
    final minutes = (seconds / 60).floor();
    final remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

  // Update the duration handler to use ValueNotifier
  void _handleVoiceNoteDurationUpdate(Duration duration) {
    // If duration is 0, reset to initial duration from metadata
    if (duration.inSeconds == 0) {
      final initialDuration = Duration(
        seconds: int.tryParse(
              widget.attachments?.first.meta?["duration"]?.toString() ?? "0",
            ) ??
            0,
      );
      _voiceNoteDurationNotifier.value = initialDuration;
    } else {
      _voiceNoteDurationNotifier.value = duration;
    }
  }

  LMChatProfilePicture? _defAvatar(bool toShowAvatar) {
    if (toShowAvatar) return widget.avatar;
    return null;
  }
}

/// {@template lm_chat_bubble_style}
/// Style configuration for the chat bubble.
/// {@endtemplate}
class LMChatBubbleStyle {
  /// The background color of the chat bubble.
  /// It will be ignored if BoxDecoration is applied.
  final Color? backgroundColor;

  /// The decoration of the chat bubble.
  /// If set, the background color will be ignored.
  /// when using a decoration, make sure to set enableClipper to false.
  /// to get the desired shape.
  final BoxDecoration? decoration;

  /// The color when the chat bubble is selected.
  final Color? selectedColor;

  /// Whether to show action buttons.
  final bool? showActions;

  /// Whether to show the header.
  final bool? showHeader;

  /// Whether to show the footer.
  final bool? showFooter;

  /// Whether to show the sides.
  final bool? showSides;

  /// Whether to show the avatar.
  final bool? showAvatar;

  /// The style of the link preview.
  final LMChatLinkPreviewStyle? linkPreviewStyle;

  /// Whether to enable clipper, it is enabled by default.
  /// The clipper will clip the chat bubble to the def
  /// If set to false, the clipper will be disabled and the box decoration will be applied.
  /// If set to true, the clipper will be enabled and the box decoration will not be applied.
  final bool enableClipper;

  /// The custom clipper for the chat bubble.
  /// to create a custom shape for the chat bubble.
  /// If set, the default clipper will be ignored.
  final CustomClipper<Path>? clipper;

  /// The gap between the chat bubble and the user avatar.
  /// This is only applicable when the avatar is shown.
  final double gap;

  /// {@macro lm_chat_bubble_style}
  LMChatBubbleStyle({
    this.backgroundColor,
    this.decoration,
    this.selectedColor,
    this.showActions,
    this.showAvatar,
    this.showFooter,
    this.showHeader,
    this.showSides,
    this.linkPreviewStyle,
    this.enableClipper = true,
    this.clipper,
    this.gap = 0,
  });

  /// Creates a copy of the current style with optional new values.
  /// If the new values are null, the old values are used.
  LMChatBubbleStyle copyWith({
    Color? backgroundColor,
    BoxDecoration? decoration,
    Color? selectedColor,
    bool? showActions,
    bool? showAvatar,
    bool? showFooter,
    bool? showHeader,
    bool? showSides,
    LMChatLinkPreviewStyle? linkPreviewStyle,
    bool? enableClipper,
    CustomClipper<Path>? clipper,
    double? gap,
  }) {
    return LMChatBubbleStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      decoration: decoration ?? this.decoration,
      selectedColor: selectedColor ?? this.selectedColor,
      showActions: showActions ?? this.showActions,
      showAvatar: showAvatar ?? this.showAvatar,
      showFooter: showFooter ?? this.showFooter,
      showHeader: showHeader ?? this.showHeader,
      showSides: showSides ?? this.showSides,
      linkPreviewStyle: linkPreviewStyle ?? this.linkPreviewStyle,
      enableClipper: enableClipper ?? this.enableClipper,
      clipper: clipper ?? this.clipper,
      gap: gap ?? this.gap,
    );
  }

  /// Creates a basic style with default values.
  factory LMChatBubbleStyle.basic() {
    return LMChatBubbleStyle(
      backgroundColor: LMChatTheme.isThemeDark
          ? LMChatDefaultDarkTheme.container.withAlpha(255)
          : LMChatDefaultTheme.container,
      selectedColor: const Color.fromRGBO(0, 96, 86, 0.3),
      showSides: true,
      showActions: true,
      showAvatar: true,
      showFooter: true,
      showHeader: true,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_clipper.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

// import '../bubble_type.dart';

/// This class is a sample of a custom clipper that creates a visually
/// appealing chat bubble.
///
/// The chat bubble is shaped as shown in the following illustration:
class LMChatBubbleClipper extends CustomClipper<Path> {
  ///The values assigned to the clipper types [BubbleType.sendBubble] and
  ///[BubbleType.receiverBubble] are distinct.
  final bool isSent;

  ///The radius, which creates the curved appearance of the chat widget,
  ///has a default value of 10.
  final double radius;

  /// The "nip" creates the curved shape of the chat widget
  /// and has a default nipHeight of 10.
  final double nipHeight;

  /// The "nip" creates the curved shape of the chat widget
  /// and has a default nipWidth of 15.
  final double nipWidth;

  /// The "nip" creates the curved shape of the chat widget
  /// and has a default nipRadius of 3.
  final double nipRadius;

  final LMChatConversationViewType conversationViewType;

  LMChatBubbleClipper({
    this.isSent = true,
    this.radius = 10,
    this.nipHeight = 10,
    this.nipWidth = 10,
    this.nipRadius = 3,
    required this.conversationViewType,
  });

  @override
  Path getClip(Size size) {
    var path = Path();

    if (isSent) {
      if (conversationViewType == LMChatConversationViewType.bottom) {
        path.lineTo(size.width - nipWidth - radius, 0);
        path.arcToPoint(Offset(size.width - nipWidth, radius),
            radius: Radius.circular(radius));
        path.lineTo(size.width - nipWidth, size.height - radius);
        path.arcToPoint(Offset(size.width - nipWidth - radius, size.height),
            radius: Radius.circular(radius));
        path.lineTo(radius, size.height);
        path.arcToPoint(Offset(0, size.height - radius),
            radius: Radius.circular(radius));
        path.lineTo(0, radius);
        path.arcToPoint(Offset(radius, 0), radius: Radius.circular(radius));
      } else {
        path.lineTo(size.width - radius - nipWidth - radius / 2, 0);
        path.arcToPoint(
            Offset(size.width - nipWidth - radius / 2, nipHeight / 2),
            radius: Radius.circular(radius));
        path.arcToPoint(Offset(size.width, 0),
            radius: const Radius.circular(30));
        path.arcToPoint(Offset(size.width - nipWidth, nipHeight + radius),
            radius: const Radius.circular(30), clockwise: false);
        path.lineTo(size.width - nipWidth, size.height - radius);
        path.arcToPoint(Offset(size.width - nipWidth - radius, size.height),
            radius: Radius.circular(radius));
        path.lineTo(radius, size.height);
        path.arcToPoint(Offset(0, size.height - radius),
            radius: Radius.circular(radius));
        path.lineTo(0, radius);
        path.arcToPoint(Offset(radius, 0), radius: Radius.circular(radius));
      }
    } else {
      if (conversationViewType == LMChatConversationViewType.bottom) {
        path.moveTo(nipWidth + radius, 0);
        path.lineTo(size.width - radius, 0);
        path.arcToPoint(Offset(size.width, radius),
            radius: Radius.circular(radius));
        path.lineTo(size.width, size.height - radius);
        path.arcToPoint(Offset(size.width - radius, size.height),
            radius: Radius.circular(radius));
        path.lineTo(radius + nipWidth, size.height);
        path.arcToPoint(Offset(nipWidth, size.height - radius),
            radius: Radius.circular(radius));
        path.lineTo(nipWidth, radius);
        path.arcToPoint(Offset(radius + nipWidth, 0),
            radius: Radius.circular(radius));
      } else {
        path.arcToPoint(Offset(nipWidth + radius / 2, nipHeight / 2),
            radius: Radius.circular(30));
        path.arcToPoint(Offset(nipWidth + radius + radius / 2, 0),
            radius: Radius.circular(radius));
        path.lineTo(size.width - radius, 0);
        path.arcToPoint(Offset(size.width, radius),
            radius: Radius.circular(radius));
        path.lineTo(size.width, size.height - radius);
        path.arcToPoint(Offset(size.width - radius, size.height),
            radius: Radius.circular(radius));
        path.lineTo(nipWidth + radius, size.height);
        path.arcToPoint(Offset(nipWidth, size.height - radius),
            radius: Radius.circular(radius));
        path.lineTo(nipWidth, nipHeight + radius);
        path.arcToPoint(Offset(0, 0),
            radius: Radius.circular(30), clockwise: false);
      }
    }

    return path;
  }

  @override
  bool shouldReclip(CustomClipper<Path> oldClipper) => false;
}


================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_content.dart
================================================
part of 'chat_bubble.dart';

typedef LMChatBubbleContentBuilder = Widget Function(
    LMChatConversationViewData conversation);

class LMChatBubbleContent extends StatelessWidget {
  const LMChatBubbleContent({
    super.key,
    required this.conversation,
    required this.onTagTap,
    this.style,
  });

  final LMChatConversationViewData conversation;
  final Function(String tag) onTagTap;
  final LMChatBubbleContentStyle? style;

  @override
  Widget build(BuildContext context) {
    final LMChatBubbleContentStyle inStyle =
        style ?? LMChatTheme.theme.contentStyle;

    return Padding(
      padding: inStyle.padding ?? EdgeInsets.zero,
      child: conversation.answer.isNotEmpty
          ? LMChatExpandableText(
              conversation.answer,
              expandText: "see more",
              enableSelection: inStyle.enableSelection ?? false,
              animation: inStyle.animation ?? true,
              maxLines: inStyle.visibleLines ?? 6,
              mentionStyle: inStyle.tagStyle,
              linkStyle: inStyle.linkStyle ??
                  TextStyle(
                    color: LMChatTheme.theme.linkColor,
                    fontSize: 14,
                  ),
              textAlign: TextAlign.left,
              style: inStyle.textStyle ??
                  TextStyle(
                    fontSize: 14,
                    color: LMChatTheme.theme.onContainer,
                    fontWeight: FontWeight.w400,
                  ),
              linkEllipsis: true,
              onTagTap: onTagTap,
            )
          : const SizedBox(),
    );
  }

  LMChatBubbleContent copyWith({
    LMChatConversationViewData? conversation,
    Function(String tag)? onTagTap,
    LMChatBubbleContentStyle? style,
  }) {
    return LMChatBubbleContent(
      conversation: conversation ?? this.conversation,
      onTagTap: onTagTap ?? this.onTagTap,
      style: style ?? this.style,
    );
  }
}

class LMChatBubbleContentStyle {
  final int? visibleLines;
  final TextStyle? textStyle;
  final TextStyle? linkStyle;
  final TextStyle? tagStyle;
  final bool? animation;
  final TextStyle? expandTextStyle;
  final TextAlign? textAlign;
  final String? expandText;
  final EdgeInsets? padding;
  final EdgeInsets? margin;
  final bool? enableSelection;

  const LMChatBubbleContentStyle({
    this.textStyle,
    this.linkStyle,
    this.expandTextStyle,
    this.expandText,
    this.animation,
    this.visibleLines,
    this.textAlign,
    this.padding,
    this.margin,
    this.tagStyle,
    this.enableSelection,
  });

  LMChatBubbleContentStyle copyWith({
    int? visibleLines,
    TextStyle? textStyle,
    TextStyle? linkStyle,
    TextStyle? tagStyle,
    bool? animation,
    TextStyle? expandTextStyle,
    TextAlign? textAlign,
    String? expandText,
    double? width,
    double? height,
    EdgeInsets? padding,
    EdgeInsets? margin,
    bool? enableSelection,
  }) {
    return LMChatBubbleContentStyle(
      textStyle: textStyle ?? this.textStyle,
      linkStyle: linkStyle ?? this.linkStyle,
      expandTextStyle: expandTextStyle ?? this.expandTextStyle,
      expandText: expandText ?? this.expandText,
      animation: animation ?? this.animation,
      visibleLines: visibleLines ?? this.visibleLines,
      textAlign: textAlign ?? this.textAlign,
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      enableSelection: enableSelection ?? this.enableSelection,
    );
  }

  factory LMChatBubbleContentStyle.basic({Color? onContainer}) =>
      LMChatBubbleContentStyle(
        textStyle: TextStyle(
          color: onContainer ?? LMChatDefaultTheme.onContainer,
          fontSize: 14,
          fontWeight: FontWeight.w400,
        ),
      );
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_footer.dart
================================================
part of 'chat_bubble.dart';

/// A widget that represents the footer of a chat bubble.
class LMChatBubbleFooter extends StatelessWidget {
  /// The conversation data associated with the chat bubble.
  final LMChatConversationViewData conversation;

  /// Optional width for the footer.
  final double? textWidth;

  /// Optional timestamp text widget.
  final LMChatText? timeStamp;

  /// Optional pending timer icon.
  final LMChatIcon? pendingTimer;

  /// Optional style for the footer.
  final LMChatBubbleFooterStyle? style;

  /// Optional timestamp text widget.
  final Widget? voiceDuration;

  /// Creates an instance of [LMChatBubbleFooter].
  const LMChatBubbleFooter({
    super.key,
    required this.conversation, // Required conversation data.
    this.textWidth, // Accept the width.
    this.pendingTimer,
    this.timeStamp,
    this.style,
    this.voiceDuration,
  });

  @override
  Widget build(BuildContext context) {
    // Builds the footer widget.
    return SizedBox(
      width: calculateFooterWidth(),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          if (voiceDuration != null) const SizedBox(width: 60),
          voiceDuration ?? const SizedBox.shrink(),
          if (voiceDuration != null) const Spacer(),
          if (conversation.isEdited ?? false) ...[
            LMChatText(
              'Edited',
              style: LMChatTextStyle(
                textStyle: TextStyle(
                  fontSize: 12,
                  color: LMChatTheme.theme.onContainer.withOpacity(0.6),
                ),
              ),
            ),
            LMChatText(
              ' • ',
              style: LMChatTextStyle(
                textStyle: TextStyle(
                  fontSize: 12,
                  color: LMChatTheme.theme.onContainer.withOpacity(0.6),
                ),
              ),
            ),
          ],
          conversation.createdAt.isNotEmpty
              ? LMChatText(
                  conversation.createdAt,
                  style: LMChatTextStyle(
                    textStyle: TextStyle(
                      fontSize: 12,
                      color: LMChatTheme.theme.onContainer.withOpacity(0.6),
                    ),
                  ),
                )
              : LMChatIcon(
                  type: LMChatIconType.icon,
                  icon: Icons.timer_outlined,
                  style: LMChatIconStyle(
                    size: 12,
                    color: LMChatTheme.theme.onContainer.withOpacity(0.6),
                  ),
                ),
          // Use the width to push the footer
        ],
      ),
    );
  }

  /// Calculates the width of the footer based on its content.
  double calculateFooterWidth() {
    double? timestamp, edited, result = 0;
    // Measure the footer text width
    final footerPainter = TextPainter(
      text: TextSpan(
        text: conversation.createdAt, // Use the footer content.
        style: const TextStyle(fontSize: 13), // Use the appropriate style.
      ),
      maxLines: 1,
      textDirection: TextDirection.ltr,
    );
    footerPainter.layout();
    timestamp = footerPainter.width;

    if (conversation.isEdited ?? false) {
      final editedTextPainter = TextPainter(
        text: const TextSpan(
          text: 'Edited  • ', // Use the appropriate text for edited status.
          style: TextStyle(fontSize: 12), // Use the appropriate style.
        ),
        maxLines: 1,
        textDirection: TextDirection.ltr,
      );
      editedTextPainter.layout();
      edited = editedTextPainter.width + 2;
    }

    result = timestamp + (edited ?? 0);
    return (textWidth ?? 0) > result ? textWidth ?? 0 : result;
  }

  /// Creates a copy of the current [LMChatBubbleFooter] with optional new values.
  LMChatBubbleFooter copyWith({
    LMChatConversationViewData? conversation,
    LMChatText? timeStamp,
    LMChatIcon? pendingTimer,
    LMChatBubbleFooterStyle? style,
    double? textWidth,
    Widget? voiceDuration,
  }) {
    return LMChatBubbleFooter(
      conversation: conversation ?? this.conversation,
      timeStamp: timeStamp ?? this.timeStamp,
      pendingTimer: pendingTimer ?? this.pendingTimer,
      style: style ?? this.style,
      textWidth: textWidth ?? this.textWidth,
      voiceDuration: voiceDuration ?? this.voiceDuration,
    );
  }
}

/// A style class for customizing the appearance of the chat bubble footer.
class LMChatBubbleFooterStyle {
  /// Style for the timestamp text.
  final LMChatTextStyle? timeStampStyle;

  /// Style for the pending icon.
  final LMChatIconStyle? pendingIconStyle;

  /// Alignment of the main axis.
  final MainAxisAlignment? mainAxisAlignment;

  /// Alignment of the cross axis.
  final CrossAxisAlignment? crossAxisAlignment;

  /// Creates an instance of [LMChatBubbleFooterStyle].
  LMChatBubbleFooterStyle({
    this.crossAxisAlignment,
    this.mainAxisAlignment,
    this.pendingIconStyle,
    this.timeStampStyle,
  });

  /// Creates a copy of the current [LMChatBubbleFooterStyle] with optional new values.
  LMChatBubbleFooterStyle copyWith({
    LMChatTextStyle? timeStampStyle,
    LMChatIconStyle? pendingIconStyle,
    MainAxisAlignment? mainAxisAlignment,
    CrossAxisAlignment? crossAxisAlignment,
  }) {
    return LMChatBubbleFooterStyle(
      timeStampStyle: timeStampStyle ?? this.timeStampStyle,
      pendingIconStyle: pendingIconStyle ?? this.pendingIconStyle,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
    );
  }

  /// Creates a basic instance of [LMChatBubbleFooterStyle].
  factory LMChatBubbleFooterStyle.basic() {
    return LMChatBubbleFooterStyle();
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_header.dart
================================================
part of 'chat_bubble.dart';

class LMChatBubbleHeader extends StatelessWidget {
  final LMChatUserViewData conversationUser;
  final LMChatTextStyle? style;

  const LMChatBubbleHeader({
    super.key,
    this.style,
    required this.conversationUser,
  });

  LMChatBubbleHeader copyWith({
    LMChatTextStyle? style,
  }) {
    return LMChatBubbleHeader(
      conversationUser: conversationUser,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        LMChatText(
          conversationUser.name,
          style: style ??
              LMChatTextStyle(
                textStyle: TextStyle(
                  fontWeight: FontWeight.w600,
                  color: LMChatTheme.theme.primaryColor,
                ),
              ),
        ),
      ],
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_media.dart
================================================
part of 'chat_bubble.dart';

class LMChatBubbleMedia extends StatelessWidget {
  final List<LMChatAttachmentViewData> attachments;
  final int count;
  final bool attachmentUploaded;
  final LMChatConversationViewData conversation;

  final LMChatImageBuilder? imageBuilder;
  final LMChatVideoBuilder? videoBuilder;
  final LMChatGIFBuilder? gifBuilder;
  final LMChatVoiceNoteBuilder? voiceNoteBuilder; // Add audio builder

  final LMChatDocumentThumbnailBuilder? documentThumbnailBuilder;
  final LMChatDocumentTilePreviewBuilder? documentTilePreviewBuilder;

  final LMChatAudioHandler? audioHandler;

  /// Callback for voice note duration updates
  final Function(Duration)? onVoiceNoteDurationUpdate;

  const LMChatBubbleMedia({
    super.key,
    required this.conversation,
    required this.attachments,
    required this.count,
    required this.attachmentUploaded,
    this.audioHandler,
    this.imageBuilder,
    this.videoBuilder,
    this.gifBuilder,
    this.voiceNoteBuilder, // Add audio builder
    this.documentThumbnailBuilder,
    this.documentTilePreviewBuilder,
    this.onVoiceNoteDurationUpdate,
  });

  LMChatBubbleMedia copyWith({
    List<LMChatAttachmentViewData>? attachments,
    int? count,
    bool? attachmentUploaded,
    LMChatConversationViewData? conversation,
    LMChatImageBuilder? imageBuilder,
    LMChatVideoBuilder? videoBuilder,
    LMChatGIFBuilder? gifBuilder,
    LMChatVoiceNoteBuilder? voiceNoteBuilder, // Add audio builder
    LMChatDocumentThumbnailBuilder? documentThumbnailBuilder,
    LMChatDocumentTilePreviewBuilder? documentTilePreviewBuilder,
    Function(Duration)? onVoiceNoteDurationUpdate,
  }) {
    return LMChatBubbleMedia(
      conversation: conversation ?? this.conversation,
      attachments: attachments ?? this.attachments,
      count: count ?? this.count,
      attachmentUploaded: attachmentUploaded ?? this.attachmentUploaded,
      imageBuilder: imageBuilder ?? this.imageBuilder,
      videoBuilder: videoBuilder ?? this.videoBuilder,
      gifBuilder: gifBuilder ?? this.gifBuilder,
      voiceNoteBuilder:
          voiceNoteBuilder ?? this.voiceNoteBuilder, // Add audio builder
      documentThumbnailBuilder:
          documentThumbnailBuilder ?? this.documentThumbnailBuilder,
      documentTilePreviewBuilder:
          documentTilePreviewBuilder ?? this.documentTilePreviewBuilder,
      onVoiceNoteDurationUpdate:
          onVoiceNoteDurationUpdate ?? this.onVoiceNoteDurationUpdate,
    );
  }

  @override
  Widget build(BuildContext context) {
    return count > 0
        ? Column(
            children: [
              const SizedBox(height: 4),
              getContent(context) ?? const SizedBox.shrink(),
            ],
          )
        : const SizedBox.shrink();
  }

  Widget? getContent(BuildContext context) {
    Widget? mediaWidget;
    if (count > 0 &&
        conversation.deletedByUserId == null &&
        attachments.isNotEmpty) {
      if (attachments.first.type ==
              mapMediaTypeToString(LMChatMediaType.image) ||
          attachments.first.type ==
              mapMediaTypeToString(LMChatMediaType.video)) {
        mediaWidget = _defaultMediaWidget(context);
      } else if (attachments.first.type ==
          mapMediaTypeToString(LMChatMediaType.document)) {
        switch (attachments.length) {
          case 1:
            mediaWidget = LMChatDocumentThumbnail(
              media: attachments.first.toMediaModel(),
              style: LMChatDocumentThumbnailStyle(height: 140, width: 55.w),
              showOverlay: true,
            );
          default:
            mediaWidget = LMChatDocumentTilePreview(
              mediaList: attachments.map((e) => e.toMediaModel()).toList(),
              style: LMChatDocumentTilePreviewStyle(
                tileStyle: LMChatDocumentTileStyle(
                  width: 55.w,
                ),
              ),
            );
        }
      } else if (conversation.ogTags != null) {
        mediaWidget = const SizedBox.shrink();
      } else if (attachments.first.type ==
          mapMediaTypeToString(LMChatMediaType.gif)) {
        mediaWidget = LMChatGIF(media: attachments.first.toMediaModel());
      } else if (attachments.first.type ==
          mapMediaTypeToString(LMChatMediaType.voiceNote)) {
        mediaWidget = voiceNoteBuilder?.call(
              context,
              attachments.first,
              LMChatVoiceNote(
                media: attachments.first.toMediaModel(),
                handler: audioHandler,
                onDurationUpdate: onVoiceNoteDurationUpdate,
              ),
            ) ??
            LMChatVoiceNote(
              media: attachments.first.toMediaModel(),
              handler: audioHandler,
              onDurationUpdate: onVoiceNoteDurationUpdate,
            );
      } else {
        mediaWidget = null;
      }
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          mediaWidget ?? const SizedBox.shrink(),
          conversation.answer.isEmpty
              ? const SizedBox.shrink()
              : kVerticalPaddingSmall,
        ],
      );
    }
    return null;
  }

  Widget _defaultMediaWidget(BuildContext context) {
    if (attachments.first.attachmentFile != null) {
      return getImageFileMessage(context, attachments, imageBuilder);
    }
    return getImageMessage(context, attachments, imageBuilder);
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_reactions.dart
================================================
part of 'chat_bubble.dart';

class LMChatBubbleReactions extends StatefulWidget {
  final LMChatConversationViewData conversation;
  final LMChatUserViewData currentUser;
  final Map<int, LMChatUserViewData> userMeta;
  final List<LMChatReactionViewData>? reactions;
  final bool? isSent;
  final Function(String reaction)? onRemoveReaction;
  final LMChatBubbleReactionsStyle? style;
  final VoidCallback? onReactionsTap;

  const LMChatBubbleReactions({
    super.key,
    this.isSent,
    this.onRemoveReaction,
    this.reactions,
    required this.userMeta,
    required this.conversation,
    required this.currentUser,
    this.style,
    this.onReactionsTap,
  });

  @override
  State<LMChatBubbleReactions> createState() => _LMChatBubbleReactionsState();
}

class _LMChatBubbleReactionsState extends State<LMChatBubbleReactions> {
  LMChatConversationViewData? conversation;
  List<LMChatReactionViewData> reactions = [];
  Map<String, List<LMChatReactionViewData>> mappedReactions = {};

  @override
  void initState() {
    super.initState();
    conversation = widget.conversation;
    reactions = widget.reactions ?? [];
    mappedReactions = convertListToMapReaction(reactions);
  }

  @override
  void didUpdateWidget(covariant LMChatBubbleReactions oldWidget) {
    conversation = widget.conversation;
    reactions = widget.reactions ?? [];
    mappedReactions = convertListToMapReaction(reactions);
    super.didUpdateWidget(oldWidget);
  }

  @override
  Widget build(BuildContext context) {
    List<String> keys = mappedReactions.keys.toList();
    LMChatBubbleReactionsStyle effectiveStyle =
        widget.style ?? LMChatTheme.theme.bubbleReactionsStyle;

    return ((conversation!.hasReactions ?? false) &&
            (widget.reactions != null && widget.reactions!.isNotEmpty) &&
            conversation!.deletedByUserId == null)
        ? Container(
            padding: effectiveStyle.padding ?? EdgeInsets.zero,
            margin: effectiveStyle.margin ?? EdgeInsets.zero,
            child: GestureDetector(
              onTap: () {
                showModalBottomSheet(
                  context: context,
                  backgroundColor: Colors.transparent,
                  elevation: 5,
                  useSafeArea: true,
                  builder: (context) => LMChatReactionBottomSheet(
                    mappedReactions: mappedReactions,
                    userMeta: widget.userMeta,
                    currentUser: widget.currentUser,
                    conversation: conversation!,
                    onRemoveReaction: widget.onRemoveReaction,
                  ),
                );
                widget.onReactionsTap?.call();
              },
              child: Row(
                mainAxisSize: MainAxisSize.min,
                mainAxisAlignment: MainAxisAlignment.end,
                children: <Widget>[
                  if (keys.length >= 2)
                    Container(
                      padding:
                          effectiveStyle.containerPadding ?? EdgeInsets.zero,
                      decoration: BoxDecoration(
                        color: effectiveStyle.containerColor ??
                            LMChatTheme.theme.container,
                        borderRadius: BorderRadius.circular(
                          effectiveStyle.containerBorderRadius ?? 18.0,
                        ),
                      ),
                      child: LMChatText(
                        '${keys[1]}${mappedReactions[keys[1]]!.length}',
                        style: LMChatTextStyle(
                          textStyle: effectiveStyle.reactionTextStyle ??
                              const TextStyle(),
                        ),
                      ),
                    ),
                  if (keys.length >= 3)
                    Container(
                      margin: const EdgeInsets.only(left: 4.0),
                      padding: effectiveStyle.containerPadding,
                      decoration: BoxDecoration(
                        color: effectiveStyle.containerColor ??
                            LMChatTheme.theme.container,
                        borderRadius: BorderRadius.circular(
                          effectiveStyle.containerBorderRadius ?? 18.0,
                        ),
                      ),
                      child: LMChatText(
                        '${keys[2]}${mappedReactions[keys[2]]!.length}',
                        style: LMChatTextStyle(
                          textStyle: effectiveStyle.reactionTextStyle,
                        ),
                      ),
                    ),
                  kHorizontalPaddingSmall,
                  if (keys.length > 3)
                    Container(
                      padding: effectiveStyle.containerPadding,
                      decoration: BoxDecoration(
                        color: effectiveStyle.containerColor ??
                            LMChatTheme.theme.container,
                        borderRadius: BorderRadius.circular(
                          effectiveStyle.containerBorderRadius ?? 18.0,
                        ),
                      ),
                      child: Text(
                        '...',
                        style: effectiveStyle.reactionTextStyle,
                      ),
                    ),
                ],
              ),
            ),
          )
        : const SizedBox();
  }

  Map<String, List<LMChatReactionViewData>> convertListToMapReaction(
      List<LMChatReactionViewData> reaction) {
    Map<String, List<LMChatReactionViewData>> mappedReactions = {};
    mappedReactions = {'All': reaction};
    for (var element in reaction) {
      if (mappedReactions.containsKey(element.reaction)) {
        mappedReactions[element.reaction]?.add(element);
      } else {
        mappedReactions[element.reaction] = [element];
      }
    }
    return mappedReactions;
  }
}

///{@template lm_chat_bubble_reactions_style}
/// A class that defines the style for the chat bubble reactions.
///
/// This class contains properties that determine the appearance of the
/// reaction bubbles in the chat interface, including padding, margin,
/// container color, border radius, and text style for the reactions.
/// {@endtemplate}
class LMChatBubbleReactionsStyle {
  /// The padding applied to the entire reaction bubble.
  final EdgeInsets? padding;

  /// The margin applied around the reaction bubble.
  final EdgeInsets? margin;

  /// The padding applied inside the container of the reaction bubble.
  final EdgeInsets? containerPadding;

  /// The background color of the reaction bubble container.
  final Color? containerColor;

  /// The border radius of the reaction bubble container.
  final double? containerBorderRadius;

  /// The text style applied to the reaction text within the bubble.
  final TextStyle? reactionTextStyle;

  /// {@macro lm_chat_bubble_reactions_style}
  const LMChatBubbleReactionsStyle({
    this.padding,
    this.margin,
    this.containerPadding,
    this.containerColor,
    this.containerBorderRadius,
    this.reactionTextStyle,
  });

  factory LMChatBubbleReactionsStyle.basic() {
    return const LMChatBubbleReactionsStyle(
      padding: EdgeInsets.only(top: 4),
      margin: EdgeInsets.only(left: 8),
      containerPadding: EdgeInsets.symmetric(horizontal: 10, vertical: 3),
      containerBorderRadius: 18.0,
      reactionTextStyle: TextStyle(),
    );
  }

  LMChatBubbleReactionsStyle copyWith({
    EdgeInsets? padding,
    EdgeInsets? margin,
    EdgeInsets? containerPadding,
    Color? containerColor,
    double? containerBorderRadius,
    TextStyle? reactionTextStyle,
  }) {
    return LMChatBubbleReactionsStyle(
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      containerPadding: containerPadding ?? this.containerPadding,
      containerColor: containerColor ?? this.containerColor,
      containerBorderRadius:
          containerBorderRadius ?? this.containerBorderRadius,
      reactionTextStyle: reactionTextStyle ?? this.reactionTextStyle,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_reply.dart
================================================
part of 'chat_bubble.dart';

/// {@template lm_chat_bubble_reply}
/// A widget to display a reply to a conversation
/// {@endtemplate}
class LMChatBubbleReply extends StatelessWidget {
  /// The conversation to which the reply is made
  final LMChatConversationViewData replyToConversation;

  /// Title widget of the reply item, if not provided, the name of the member
  final Widget? title;

  /// Subtitle widget of the reply item, if not provided, the text of reply
  final Widget? subtitle;

  /// Media widget of the reply item, if not provided, the media files
  final Widget? media;

  /// Style of the reply item
  final LMChatBubbleReplyStyle? chatBubbleReplyStyle;

  /// onTap function for the reply item
  final VoidCallback? onTap;

  /// {@macro lm_chat_bubble_reply}
  const LMChatBubbleReply({
    super.key,
    required this.replyToConversation,
    this.title,
    this.subtitle,
    this.media,
    this.chatBubbleReplyStyle,
    this.onTap,
  });

  LMChatBubbleReply copyWith({
    LMChatConversationViewData? replyToConversation,
    Widget? title,
    Widget? subtitle,
    Widget? media,
    LMChatBubbleReplyStyle? chatBubbleReplyStyle,
    VoidCallback? onTap,
  }) {
    return LMChatBubbleReply(
      replyToConversation: replyToConversation ?? this.replyToConversation,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      media: media ?? this.media,
      chatBubbleReplyStyle: chatBubbleReplyStyle ?? this.chatBubbleReplyStyle,
      onTap: onTap ?? this.onTap,
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = LMChatTheme.theme;
    final inStyle = chatBubbleReplyStyle ?? theme.replyStyle;
    return GestureDetector(
      onTap: onTap,
      behavior: HitTestBehavior.translucent,
      child: Container(
        clipBehavior: Clip.hardEdge,
        decoration: BoxDecoration(
          color:
              inStyle.backgroundColor ?? theme.disabledColor.withOpacity(0.2),
          borderRadius: BorderRadius.circular(inStyle.borderRadius ?? 8),
        ),
        constraints: BoxConstraints(
          minWidth: 20.w,
          maxWidth: 64.w,
        ),
        margin: inStyle.margin ?? const EdgeInsets.symmetric(vertical: 4),
        padding: inStyle.padding,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.start,
          children: [
            Container(
              height: 6.h,
              width: 1.w,
              decoration: BoxDecoration(
                color: inStyle.highlightColor ?? theme.primaryColor,
              ),
            ),
            kHorizontalPaddingMedium,
            Expanded(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  title ??
                      LMChatText(
                        replyToConversation.member!.name,
                        style: LMChatTextStyle(
                          maxLines: 1,
                          minLines: 1,
                          textStyle: TextStyle(
                            overflow: TextOverflow.ellipsis,
                            color: theme.primaryColor,
                            fontSize: 12,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                  kVerticalPaddingXSmall,
                  replyToConversation.deletedByUserId != null
                      ? LMChatText(
                          "Deleted message",
                          style: LMChatTextStyle(
                            textStyle:
                                replyToConversation.deletedByUserId != null
                                    ? TextStyle(
                                        fontStyle: FontStyle.italic,
                                        color: LMChatTheme.theme.disabledColor,
                                      )
                                    : TextStyle(
                                        fontSize: 14,
                                        color: LMChatTheme.theme.disabledColor,
                                      ),
                          ),
                        )
                      : subtitle ??
                          LMChatText(
                            replyToConversation.answer.isEmpty
                                ? "Media files"
                                : LMChatTaggingHelper.convertRouteToTag(
                                    replyToConversation.answer,
                                    withTilde: false,
                                  )!,
                            style: LMChatTextStyle(
                              maxLines: 1,
                              textStyle: TextStyle(
                                overflow: TextOverflow.ellipsis,
                                color: theme.onContainer,
                                fontSize: 12,
                              ),
                            ),
                          ),
                ],
              ),
            ),
            kHorizontalPaddingMedium,
          ],
        ),
      ),
    );
  }
}

/// {@template lm_chat_bubble_reply_style}
/// Style for the reply item
/// {@endtemplate}
class LMChatBubbleReplyStyle {
  /// Background color of the reply item
  final Color? backgroundColor;

  /// Highlight color of the reply item
  final Color? highlightColor;

  /// Border radius of the reply item
  final double? borderRadius;

  /// Padding inside the reply bubble
  final EdgeInsetsGeometry? padding;

  /// Margin outside the reply bubble
  final EdgeInsetsGeometry? margin;

  /// Style of the title widget
  final LMChatTextStyle? titleStyle;

  /// Style of the subtitle widget
  final LMChatTextStyle? subtitleStyle;

  /// Style of the media widget
  final LMChatImageStyle? mediaStyle;

  /// {@macro lm_chat_bubble_reply_style}
  const LMChatBubbleReplyStyle({
    this.backgroundColor,
    this.highlightColor,
    this.borderRadius,
    this.titleStyle,
    this.subtitleStyle,
    this.mediaStyle,
    this.margin,
    this.padding,
  });

  LMChatBubbleReplyStyle copyWith({
    Color? backgroundColor,
    Color? highlightColor,
    double? borderRadius,
    EdgeInsetsGeometry? padding,
    EdgeInsetsGeometry? margin,
    LMChatTextStyle? titleStyle,
    LMChatTextStyle? subtitleStyle,
    LMChatImageStyle? mediaStyle,
  }) {
    return LMChatBubbleReplyStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      highlightColor: highlightColor ?? this.highlightColor,
      borderRadius: borderRadius ?? this.borderRadius,
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      titleStyle: titleStyle ?? this.titleStyle,
      subtitleStyle: subtitleStyle ?? this.subtitleStyle,
      mediaStyle: mediaStyle ?? this.mediaStyle,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_sides.dart
================================================
part of 'chat_bubble.dart';

class LMChatBubbleSides extends StatelessWidget {
  const LMChatBubbleSides({super.key});

  @override
  Widget build(BuildContext context) {
    return const SizedBox.shrink();
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/conversation/chat_bubble_state.dart
================================================
part of 'chat_bubble.dart';

class LMChatStateBubble extends StatelessWidget {
  final String message;
  final LMChatStateBubbleStyle? style;

  const LMChatStateBubble({
    super.key,
    this.style,
    required this.message,
  });

  /// CopyWith function to get a new object of [LMChatStateBubble]
  /// with specific single values passed
  LMChatStateBubble copyWith({
    LMChatStateBubbleStyle? style,
    String? message,
  }) {
    return LMChatStateBubble(
      style: style ?? this.style,
      message: message ?? this.message,
    );
  }

  @override
  Widget build(BuildContext context) {
    final inStyle = style ?? LMChatTheme.theme.stateBubbleStyle;
    return IntrinsicWidth(
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        children: [
          IntrinsicWidth(
            child: Container(
              constraints: BoxConstraints(maxWidth: 70.w),
              margin: const EdgeInsets.symmetric(vertical: 5),
              padding: const EdgeInsets.symmetric(
                horizontal: 8,
                vertical: 4,
              ),
              decoration: inStyle.boxDecoration ??
                  BoxDecoration(
                    color: inStyle.backgroundColor ??
                        LMChatTheme.theme.container.withOpacity(0.5),
                    borderRadius:
                        BorderRadius.circular(inStyle.borderRadius ?? 18),
                    border: inStyle.border,
                  ),
              alignment: inStyle.alignment ?? Alignment.center,
              child: LMChatText(
                message,
                style: inStyle.messageStyle ??
                    LMChatTextStyle(
                      textAlign: TextAlign.center,
                      textStyle: TextStyle(
                        fontSize: 12,
                        color: LMChatTheme.theme.onContainer,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
              ),
            ),
          )
        ],
      ),
    );
  }
}

class LMChatStateBubbleStyle {
  final Color? backgroundColor;
  final BoxDecoration? boxDecoration;
  final double? borderRadius;
  final Border? border;
  final List<BoxShadow>? shadow;
  final LMChatTextStyle? messageStyle;
  final AlignmentGeometry? alignment;

  LMChatStateBubbleStyle({
    this.backgroundColor,
    this.border,
    this.borderRadius,
    this.boxDecoration,
    this.messageStyle,
    this.shadow,
    this.alignment,
  });

  LMChatStateBubbleStyle copyWith({
    Color? backgroundColor,
    BoxDecoration? boxDecoration,
    double? borderRadius,
    Border? border,
    List<BoxShadow>? shadow,
    LMChatTextStyle? messageStyle,
    AlignmentGeometry? alignment,
  }) {
    return LMChatStateBubbleStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      boxDecoration: boxDecoration ?? this.boxDecoration,
      border: border ?? this.border,
      borderRadius: borderRadius ?? this.borderRadius,
      messageStyle: messageStyle ?? this.messageStyle,
      shadow: shadow ?? this.shadow,
      alignment: alignment ?? this.alignment,
    );
  }

  factory LMChatStateBubbleStyle.basic(Color? onContainer) {
    return LMChatStateBubbleStyle(
      messageStyle: LMChatTextStyle(
        textAlign: TextAlign.center,
        textStyle: TextStyle(
          fontSize: 12,
          color: onContainer,
          overflow: TextOverflow.ellipsis,
        ),
      ),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/error.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/enums.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

class LMChatMediaErrorWidget extends StatelessWidget {
  final bool isPP;
  final LMChatMediaErrorStyle? style;

  const LMChatMediaErrorWidget({Key? key, this.isPP = false, this.style})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      color: isPP
          ? (style?.primaryColor ?? LMChatTheme.theme.primaryColor)
          : (style?.backgroundColor ?? LMChatDefaultTheme.whiteColor),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.error_outline,
            style: LMChatIconStyle(
              size: 10,
              color: isPP
                  ? (style?.iconColor ?? LMChatDefaultTheme.whiteColor)
                  : (style?.textColor ?? LMChatDefaultTheme.blackColor),
            ),
          ),
          isPP ? const SizedBox() : const SizedBox(height: 12),
          isPP
              ? const SizedBox()
              : LMChatText(
                  "An error occurred fetching media",
                  style: LMChatTextStyle(
                    textAlign: TextAlign.center,
                    textStyle: TextStyle(
                      fontSize: 8,
                      color: isPP
                          ? (style?.textColor ?? LMChatDefaultTheme.whiteColor)
                          : (style?.textColor ?? LMChatDefaultTheme.blackColor),
                    ),
                  ),
                )
        ],
      ),
    );
  }
}

class LMChatMediaErrorStyle {
  final Color? primaryColor;
  final Color? backgroundColor;
  final Color? iconColor;
  final Color? textColor;

  LMChatMediaErrorStyle({
    this.primaryColor,
    this.backgroundColor,
    this.iconColor,
    this.textColor,
  });
}



================================================
File: lib/packages/ui/lib/src/widgets/media/gif.dart
================================================
import 'package:flutter/material.dart';
import 'package:gif/gif.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

///{@template lm_chat_gif}
/// A widget to display and control GIF animations in the LMChat UI.
/// The [media] parameter is required and contains the GIF data.
/// {@endtemplate}
class LMChatGIF extends StatefulWidget {
  /// {@macro lm_chat_gif}
  const LMChatGIF({
    super.key,
    required this.media,
    this.fps,
    this.duration,
    this.overlay,
    this.style,
    this.autoplay,
  }) : assert((duration == null) || (fps == null),
            'Either duration or fps must be provided, but not both.');

  /// Creates a copy of this [LMChatGIF] but with the given fields replaced with the new values.
  ///
  /// If the new values are null, then the old values are used.
  LMChatGIF copyWith({
    LMChatMediaModel? media,
    int? fps,
    Duration? duration,
    Widget? overlay,
    LMChatGIFStyle? style,
    bool? autoplay,
  }) {
    return LMChatGIF(
      media: media ?? this.media,
      fps: fps ?? this.fps,
      duration: duration ?? this.duration,
      overlay: overlay ?? this.overlay,
      style: style ?? this.style,
      autoplay: autoplay ?? this.autoplay,
    );
  }

  /// The media model containing the GIF data.
  final LMChatMediaModel media;

  /// The frames per second for the GIF animation.
  final int? fps;

  /// The duration of the GIF animation.
  final Duration? duration;

  /// An optional overlay widget to be displayed on top of the GIF.
  final Widget? overlay;

  /// The style configuration for the GIF widget.
  final LMChatGIFStyle? style;

  /// The bool to control whether GIF autoplays or not
  final bool? autoplay;

  @override
  State<LMChatGIF> createState() => _LMChatGIFState();
}

class _LMChatGIFState extends State<LMChatGIF> with TickerProviderStateMixin {
  late GifController _controller;
  late ImageProvider<Object> imageProvider;
  bool _isGIFPlaying = false; // Renamed for clarity

  @override
  void initState() {
    super.initState();
    _controller = GifController(vsync: this);
    _isGIFPlaying = widget.autoplay ?? false;
    _initializeImageProvider();
  }

  void _initializeImageProvider() {
    if (widget.media.mediaUrl != null) {
      imageProvider = NetworkImage(widget.media.mediaUrl!);
    } else if (widget.media.mediaFile != null) {
      imageProvider = FileImage(widget.media.mediaFile!);
    } else {
      // Handle error case if both are null
      debugPrint('Error: No media URL or file provided.');
      return;
    }
  }

  @override
  void didUpdateWidget(LMChatGIF oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.media != oldWidget.media) {
      _initializeImageProvider();
      _controller.reset();
      _isGIFPlaying = false;
    }
  }

  @override
  void deactivate() {
    _controller.stop();
    _isGIFPlaying = false;
    super.deactivate();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _togglePlayPause() {
    setState(() {
      if (_isGIFPlaying) {
        _controller.stop();
      } else {
        _controller.repeat();
      }
      _isGIFPlaying = !_isGIFPlaying;
    });
  }

  @override
  Widget build(BuildContext context) {
    final style = widget.style ?? const LMChatGIFStyle();
    return GestureDetector(
      onTap: _togglePlayPause,
      child: ClipRRect(
        borderRadius: style.borderRadius ?? BorderRadius.circular(6),
        child: Container(
          width: style.width,
          height: style.height,
          color: style.backgroundColor,
          child: Stack(
            alignment: Alignment.center,
            children: [
              Gif(
                image: imageProvider,
                controller: _controller,
                autostart:
                    widget.autoplay ?? false ? Autostart.loop : Autostart.no,
                duration: widget.duration,
                fps: widget.fps,
                fit: style.fit ?? BoxFit.cover,
                placeholder: (context) => LMChatMediaShimmerWidget(
                  width: style.width,
                ),
                onFetchCompleted: () {
                  // Do nothing on fetch complete to keep the first frame
                },
              ),
              Visibility(
                visible: !_isGIFPlaying,
                child: Container(
                  height: style.overlaySize ?? 42,
                  width: style.overlaySize ?? 42,
                  decoration: BoxDecoration(
                    color: style.overlayColor ?? LMChatTheme.theme.onContainer,
                    borderRadius:
                        style.overlayBorderRadius ?? BorderRadius.circular(24),
                  ),
                  child: Center(
                    child: LMChatText(
                      "GIF",
                      style: style.overlayTextStyle ??
                          LMChatTextStyle(
                            textStyle: TextStyle(
                              color: LMChatTheme.theme.container,
                            ),
                          ),
                    ),
                  ),
                ),
              ),
              if (widget.overlay != null) widget.overlay!,
            ],
          ),
        ),
      ),
    );
  }
}

/// Defines the style properties for the LMChatGIF widget.
class LMChatGIFStyle {
  /// Creates an LMChatGIFStyle instance.
  const LMChatGIFStyle({
    this.width,
    this.height,
    this.borderRadius,
    this.fit,
    this.backgroundColor,
    this.overlayTextStyle,
    this.overlayColor,
    this.overlaySize,
    this.overlayBorderRadius,
  });

  /// The width of the GIF container.
  final double? width;

  /// The height of the GIF container.
  final double? height;

  /// The border radius of the GIF container.
  final BorderRadius? borderRadius;

  /// The fit of the GIF within its container.
  final BoxFit? fit;

  /// The background color of the GIF container.
  final Color? backgroundColor;

  /// The style for the "GIF" text overlay.
  final LMChatTextStyle? overlayTextStyle;

  /// The color of the overlay container.
  final Color? overlayColor;

  /// The size of the overlay container.
  final double? overlaySize;

  /// The border radius of the overlay container.
  final BorderRadius? overlayBorderRadius;

  /// Creates a basic LMChatGIFStyle with default values.
  factory LMChatGIFStyle.basic() {
    return LMChatGIFStyle(
      borderRadius: BorderRadius.circular(8),
      overlayColor: Colors.black.withOpacity(0.5),
      overlaySize: 42,
      overlayBorderRadius: BorderRadius.circular(21),
    );
  }

  /// Creates a copy of this LMChatGIFStyle but with the given fields replaced with the new values.
  LMChatGIFStyle copyWith({
    double? width,
    double? height,
    BorderRadius? borderRadius,
    BoxFit? fit,
    Color? backgroundColor,
    LMChatTextStyle? overlayTextStyle,
    Color? overlayColor,
    double? overlaySize,
    BorderRadius? overlayBorderRadius,
  }) {
    return LMChatGIFStyle(
      width: width ?? this.width,
      height: height ?? this.height,
      borderRadius: borderRadius ?? this.borderRadius,
      fit: fit ?? this.fit,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      overlayTextStyle: overlayTextStyle ?? this.overlayTextStyle,
      overlayColor: overlayColor ?? this.overlayColor,
      overlaySize: overlaySize ?? this.overlaySize,
      overlayBorderRadius: overlayBorderRadius ?? this.overlayBorderRadius,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/image.dart
================================================
import 'dart:async';
import 'dart:io';
import 'dart:ui' as ui;

import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';
import 'package:photo_view/photo_view.dart';

/// {@template lm_chat_image}
/// A widget to display an image in a post.
/// The image can be fetched from a URL or from a file.
/// The [LMChatImage] can be customized by passing in the required parameters
/// and can be used in a post.
/// The image can be tapped to perform an action.
/// The image can be customized by passing in the required parameters
/// and can be used in a post.
/// {@endtemplate}
class LMChatImage extends StatefulWidget {
  ///{@macro lm_chat_image}
  const LMChatImage({
    super.key,
    this.imageUrl,
    this.imageFile,
    this.imageAssetPath,
    this.onError,
    this.style,
    this.onTap,
  }) : assert(imageUrl != null || imageFile != null || imageAssetPath != null);

  /// The URL of the image (image from network)
  final String? imageUrl;

  /// The file of the image (image from file)
  final File? imageFile;

  /// The path of the image (image from asset)
  final String? imageAssetPath;

  /// {@macro chat_error_handler}
  final LMChatErrorHandler? onError;

  /// The style class of this widget, used for customisation
  final LMChatImageStyle? style;

  /// onTap callback for the widget; triggered when tapped
  final VoidCallback? onTap;

  @override
  State<LMChatImage> createState() => _LMImageState();

  /// copyWith function that returns a new instance of LMChatImage
  /// with the values copied from the old one.
  LMChatImage copyWith({
    String? imageUrl,
    File? imageFile,
    String? imageAssetPath,
    LMChatImageStyle? style,
    LMChatErrorHandler? onError,
    VoidCallback? onTap,
  }) {
    return LMChatImage(
      imageUrl: imageUrl ?? this.imageUrl,
      imageFile: imageFile ?? this.imageFile,
      imageAssetPath: imageAssetPath ?? this.imageAssetPath,
      style: style ?? this.style,
      onError: onError ?? this.onError,
      onTap: onTap ?? this.onTap,
    );
  }
}

class _LMImageState extends State<LMChatImage> {
  LMChatImageStyle? style;

  // Determines if the image is an SVG image based on the file extension of the URL
  bool _isSvgImage() {
    return widget.imageUrl != null && widget.imageUrl!.endsWith('.svg');
  }

  /// Initializes the state of the widget by setting up the style
  @override
  void initState() {
    super.initState();
    style = widget.style ?? LMChatTheme.theme.imageStyle;
  }

  /// Builds the widget tree for the image widget
  /// Returns a GestureDetector that handles tap events
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onTap,
      child: _buildImageWidget(),
    );
  }

  /// Determines which type of image to build based on the provided source
  /// Returns the appropriate image widget for URL, File, or Asset images
  Widget _buildImageWidget() {
    if (widget.imageUrl != null) {
      return _buildNetworkImage();
    }
    if (widget.imageFile != null) {
      return _buildFileImage();
    }
    if (widget.imageAssetPath != null) {
      return _buildAssetImage();
    }
    return const SizedBox();
  }

  /// Builds a PhotoView widget with proper scaling based on image dimensions
  ///
  /// Parameters:
  /// - imageProvider: The provider for the image source
  /// - context: The build context
  /// - imageWidth: The width of the image
  /// - imageHeight: The height of the image
  ///
  /// Returns a PhotoView widget with calculated scaling parameters
  Widget _buildPhotoView({
    required ImageProvider imageProvider,
    required BuildContext context,
    required double imageWidth,
    required double imageHeight,
  }) {
    // Calculate container dimensions
    final containerWidth = style?.width ?? 100.w;
    final containerHeight = style?.height ?? 80.h;

    // Calculate scale to fit
    final double scaleX = containerWidth / imageWidth;
    final double scaleY = containerHeight / imageHeight;
    final double minScale = scaleX < scaleY ? scaleX : scaleY;

    return PhotoView(
      imageProvider: imageProvider,
      maxScale: 3.0,
      minScale: minScale,
      initialScale: minScale,
      tightMode: true,
    );
  }

  /// Builds a widget for displaying network images
  /// Uses CachedNetworkImage for efficient loading and caching
  /// Returns a Container with the network image
  Widget _buildNetworkImage() {
    return Container(
      padding: style?.padding,
      margin: style?.margin,
      decoration: BoxDecoration(
        borderRadius: style!.borderRadius ?? BorderRadius.zero,
        color: style?.backgroundColor,
      ),
      clipBehavior: Clip.hardEdge,
      child: _isSvgImage()
          ? SvgPicture.network(
              widget.imageUrl!,
              height: style?.height,
              width: style?.width,
              fit: style?.boxFit ?? BoxFit.contain,
              placeholderBuilder: (context) {
                return style!.loaderWidget ??
                    LMChatMediaShimmerWidget(
                      height: style!.height,
                      width: style!.width ?? 100.w,
                    );
              },
              // errorBuilder: (context, error, stackTrace) {
              //   debugPrint('Error loading image: $error');
              //   if (widget.onError != null) {
              //     widget.onError!(error.toString(), StackTrace.empty);
              //   }
              //   return style!.errorWidget ?? _defaultErrorWidget();
              // },
            )
          : CachedNetworkImage(
              cacheKey: widget.imageUrl!,
              height: style?.height,
              width: style?.width,
              imageUrl: widget.imageUrl!,
              fit: style?.boxFit ?? BoxFit.contain,
              fadeInDuration: const Duration(milliseconds: 100),
              imageBuilder: (context, imageProvider) {
                ImageStream stream =
                    imageProvider.resolve(ImageConfiguration.empty);
                late ImageInfo imageInfo;

                return FutureBuilder(
                  future: Future(() async {
                    Completer<void> completer = Completer();
                    stream.addListener(
                      ImageStreamListener((info, _) {
                        imageInfo = info;
                        completer.complete();
                      }),
                    );
                    await completer.future;
                    return imageInfo;
                  }),
                  builder: (context, snapshot) {
                    if (!snapshot.hasData) {
                      return const Center(child: CircularProgressIndicator());
                    }

                    final imageInfo = snapshot.data as ImageInfo;
                    return _buildPhotoView(
                      imageProvider: imageProvider,
                      context: context,
                      imageWidth: imageInfo.image.width.toDouble(),
                      imageHeight: imageInfo.image.height.toDouble(),
                    );
                  },
                );
              },
              errorWidget: (context, url, error) {
                debugPrint('Error loading image: $error');
                if (widget.onError != null) {
                  widget.onError!(error.toString(), StackTrace.empty);
                }
                return style!.errorWidget ?? _defaultErrorWidget();
              },
              progressIndicatorBuilder: (context, url, progress) =>
                  style!.shimmerWidget ??
                  LMChatMediaShimmerWidget(
                    height: style!.height,
                    width: style!.width ?? 100.w,
                  ),
            ),
    );
  }

  /// Builds a widget for displaying images from local files
  /// Uses FutureBuilder to handle async loading of image dimensions
  /// Returns a Container with the file image
  Widget _buildFileImage() {
    return Container(
      padding: style?.padding,
      margin: style?.margin,
      decoration: BoxDecoration(
        borderRadius: style!.borderRadius ?? BorderRadius.zero,
        color: style?.backgroundColor,
      ),
      child: FutureBuilder<ui.Image>(
        future: _getImageDimensions(FileImage(widget.imageFile!)),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          return _buildPhotoView(
            imageProvider: FileImage(widget.imageFile!),
            context: context,
            imageWidth: snapshot.data!.width.toDouble(),
            imageHeight: snapshot.data!.height.toDouble(),
          );
        },
      ),
    );
  }

  /// Builds a widget for displaying images from assets
  /// Uses FutureBuilder to handle async loading of image dimensions
  /// Returns a Container with the asset image
  Widget _buildAssetImage() {
    return Container(
      padding: style?.padding,
      margin: style?.margin,
      decoration: BoxDecoration(
        borderRadius: style!.borderRadius ?? BorderRadius.zero,
        color: style?.backgroundColor,
      ),
      child: FutureBuilder<ui.Image>(
        future: _getImageDimensions(AssetImage(widget.imageAssetPath!)),
        builder: (context, snapshot) {
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          return _buildPhotoView(
            imageProvider: AssetImage(widget.imageAssetPath!),
            context: context,
            imageWidth: snapshot.data!.width.toDouble(),
            imageHeight: snapshot.data!.height.toDouble(),
          );
        },
      ),
    );
  }

  /// Helper function to get image dimensions asynchronously
  ///
  /// Parameters:
  /// - provider: The ImageProvider to get dimensions from
  ///
  /// Returns a Future that resolves to the image dimensions
  Future<ui.Image> _getImageDimensions(ImageProvider provider) async {
    final Completer<ui.Image> completer = Completer<ui.Image>();
    final ImageStream stream = provider.resolve(ImageConfiguration.empty);

    final listener = ImageStreamListener((ImageInfo info, bool _) {
      completer.complete(info.image);
    });

    stream.addListener(listener);
    return completer.future;
  }

  /// Builds a default error widget to display when image loading fails
  /// Returns a Container with error icon and message
  Widget _defaultErrorWidget() {
    return Container(
      color: Colors.grey,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          LMChatIcon(
            type: LMChatIconType.icon,
            icon: Icons.error_outline,
            style: LMChatIconStyle(
              size: 24,
              color: Colors.grey.shade300,
            ),
          ),
          const SizedBox(height: 24),
          const LMChatText(
            "An error occurred fetching media",
            style: LMChatTextStyle(
              textStyle: TextStyle(
                fontSize: 14,
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// {@template lm_chat_image_style}
/// The style class for [LMChatImage]
///
/// Provides multiple levels of customisations.
/// {@endtemplate}
class LMChatImageStyle {
  /// Height of the image widget
  final double? height;

  /// Width of the image widget
  final double? width;

  /// Aspect ratio of the image widget
  final double? aspectRatio;

  /// Radius of the border of the image widget
  final BorderRadius? borderRadius;

  /// Color of the border of the image widget
  final Color? borderColor;

  /// Padding of the image widget
  final EdgeInsets? padding;

  /// Margin of the image widget from outside
  final EdgeInsets? margin;

  /// Fit of the container box of the image
  final BoxFit? boxFit;

  /// Color of the background of the image widget
  final Color? backgroundColor;

  /// Widget to show while the network image loads
  final Widget? loaderWidget;

  /// Widget to show if the network image fails to load
  final Widget? errorWidget;

  /// Widget to show a shimmer while presenting the image
  final Widget? shimmerWidget;

  ///{@macro lm_chat_image_style}
  const LMChatImageStyle({
    this.height,
    this.width,
    this.aspectRatio,
    this.borderRadius,
    this.borderColor,
    this.loaderWidget,
    this.errorWidget,
    this.shimmerWidget,
    this.boxFit,
    this.padding,
    this.margin,
    this.backgroundColor,
  });

  /// Creates a copy of the current style with the given parameters.
  ///
  /// All non-null parameters will override the current style's parameters.
  /// All null parameters will keep the current style's parameter.
  LMChatImageStyle copyWith({
    double? height,
    double? width,
    double? aspectRatio,
    BorderRadius? borderRadius,
    Color? borderColor,
    Widget? loaderWidget,
    Widget? errorWidget,
    Widget? shimmerWidget,
    BoxFit? boxFit,
    EdgeInsets? padding,
    EdgeInsets? margin,
    Color? backgroundColor,
  }) {
    return LMChatImageStyle(
      height: height ?? this.height,
      width: width ?? this.width,
      aspectRatio: aspectRatio ?? this.aspectRatio,
      borderRadius: borderRadius ?? this.borderRadius,
      borderColor: borderColor ?? this.borderColor,
      loaderWidget: loaderWidget ?? this.loaderWidget,
      errorWidget: errorWidget ?? this.errorWidget,
      shimmerWidget: shimmerWidget ?? this.shimmerWidget,
      boxFit: boxFit ?? this.boxFit,
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
      backgroundColor: backgroundColor ?? this.backgroundColor,
    );
  }

  /// Creates a basic instance of [LMChatImageStyle].
  ///
  /// Optionally takes a [primaryColor] parameter to customize the style.
  factory LMChatImageStyle.basic({Color? primaryColor}) =>
      const LMChatImageStyle();
}



================================================
File: lib/packages/ui/lib/src/widgets/media/link_preview.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';
import 'package:url_launcher/url_launcher.dart';

/// {@template lm_chat_link_preview}
/// A widget to display a link preview in a chatroom.
/// The [LMChatLinkPreview] can be customized by passing in the required parameters
/// and can be used in a chatroom.
/// {@endtemplate}
class LMChatLinkPreview extends StatelessWidget {
  /// {@macro lm_chat_link_preview}
  const LMChatLinkPreview({
    super.key,
    required this.ogTags,
    this.onTap,
    this.imageBuilder,
    this.titleBuilder,
    this.subtitleBuilder,
    this.style,
  });

  /// The data required to display the Open Graph tags in the chat.
  final LMChatOGTagsViewData ogTags;

  /// The callback function for the onTap event.
  final VoidCallback? onTap;

  /// The builder function for the image widget in the link preview.
  final Widget Function(BuildContext, LMChatImage)? imageBuilder;

  /// The builder function for the title widget in the link preview.
  final LMChatTextBuilder? titleBuilder;

  /// The builder function for the subtitle widget in the link preview .
  final LMChatTextBuilder? subtitleBuilder;

  /// The style configuration for the link preview .
  final LMChatLinkPreviewStyle? style;

  /// Creates a copy of the current LMChatLinkPreview instance with the provided values.
  LMChatLinkPreview copyWith({
    LMChatOGTagsViewData? ogTags,
    VoidCallback? onTap,
    Widget Function(BuildContext, LMChatImage)? imageBuilder,
    LMChatTextBuilder? titleBuilder,
    LMChatTextBuilder? subtitleBuilder,
    LMChatLinkPreviewStyle? style,
  }) {
    return LMChatLinkPreview(
      ogTags: ogTags ?? this.ogTags,
      onTap: onTap ?? this.onTap,
      imageBuilder: imageBuilder ?? this.imageBuilder,
      titleBuilder: titleBuilder ?? this.titleBuilder,
      subtitleBuilder: subtitleBuilder ?? this.subtitleBuilder,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    return ClipRRect(
      borderRadius: style?.decoration?.borderRadius ?? BorderRadius.circular(8),
      child: GestureDetector(
        onTap: () {
          if (onTap != null) {
            onTap!();
          } else if (ogTags.url != null && ogTags.url!.isNotEmpty) {
            launchUrl(Uri.parse(ogTags.url!));
          }
        },
        child: Container(
          width: style?.width ?? double.infinity,
          height: style?.height,
          margin: style?.margin,
          padding: style?.padding,
          decoration: style?.decoration ??
              const BoxDecoration(
                color: Color(0x1a9b9b9b),
              ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if ((ogTags.imageUrl != null && ogTags.imageUrl!.isNotEmpty) ||
                  imageBuilder != null)
                AbsorbPointer(
                  child:
                      imageBuilder?.call(context, _defImage()) ?? _defImage(),
                ),
              if ((ogTags.title != null && ogTags.title!.isNotEmpty) ||
                  titleBuilder != null)
                titleBuilder?.call(context, _defTitle()) ?? _defTitle(),
              if ((ogTags.description != null &&
                      ogTags.description!.isNotEmpty) ||
                  subtitleBuilder != null)
                subtitleBuilder?.call(context, _defSubTitle()) ??
                    _defSubTitle(),
            ],
          ),
        ),
      ),
    );
  }

  LMChatText _defSubTitle() {
    return LMChatText(
      ogTags.description ?? "",
      style: style?.subtitleStyle ??
          const LMChatTextStyle(
            padding: EdgeInsets.only(
              top: 2,
              bottom: 16,
              left: 8,
              right: 8,
            ),
            textStyle: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w400,
              color: Colors.grey,
              overflow: TextOverflow.ellipsis,
            ),
            maxLines: 2,
          ),
    );
  }

  LMChatText _defTitle() {
    return LMChatText(
      ogTags.title ?? "",
      style: style?.titleStyle ??
          const LMChatTextStyle(
            padding: EdgeInsets.only(
              top: 8,
              bottom: 2,
              left: 8,
              right: 8,
            ),
            textStyle: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w500,
              overflow: TextOverflow.ellipsis,
            ),
            maxLines: 2,
          ),
    );
  }

  LMChatImage _defImage() {
    return LMChatImage(
      imageUrl: ogTags.imageUrl,
      style: style?.imageStyle ??
          const LMChatImageStyle(
            height: 190,
            width: 225,
            boxFit: BoxFit.fill,
            errorWidget: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.link,
              style: LMChatIconStyle(
                size: 32,
              ),
            ),
          ),
    );
  }
}

/// {@template chat_link_preview_style}
/// Represents the style configuration for the LMChatLinkPreviewBar widget.
/// The [leadingStyle] defines the style for the leading image.
/// The [titleStyle] defines the style for the title text.
/// The [subtitleStyle] defines the style for the subtitle text.
/// The [cancelButtonStyle] defines the style for the cancel button.
/// The [margin] defines the margin around the widget.
/// The [padding] defines the padding around the widget.
/// The [innerPadding] defines the padding inside the widget.
/// The [height] defines the height of the widget.
/// The [width] defines the width of the widget.
/// The [decoration] defines the decoration for the widget.
/// {@endtemplate}
class LMChatLinkPreviewStyle {
  /// The style for the leading image.
  final LMChatImageStyle? imageStyle;

  /// The style for the title text.
  final LMChatTextStyle? titleStyle;

  /// The style for the subtitle text.
  final LMChatTextStyle? subtitleStyle;

  /// The margin around the widget.
  final EdgeInsets? margin;

  /// The padding around the widget.
  final EdgeInsets? padding;

  /// The padding inside the widget.
  final EdgeInsets? innerPadding;

  /// The height of the widget.
  final double? height;

  /// The width of the widget.
  final double? width;

  /// The decoration for the widget.
  final BoxDecoration? decoration;

  /// Creates a new instance of LMChatLinkPreviewStyle.
  /// {@macro chat_link_preview_style}
  LMChatLinkPreviewStyle({
    this.imageStyle,
    this.titleStyle,
    this.subtitleStyle,
    this.margin,
    this.padding,
    this.innerPadding,
    this.height,
    this.width,
    this.decoration,
  });

  /// Creates a copy of the current LMChatLinkPreviewStyle instance with the provided values.
  /// If no values are provided, the current values are used.
  /// {@macro chat_link_preview_style}
  LMChatLinkPreviewStyle copyWith({
    LMChatImageStyle? imageStyle,
    LMChatTextStyle? titleStyle,
    LMChatTextStyle? subtitleStyle,
    EdgeInsets? margin,
    EdgeInsets? padding,
    EdgeInsets? innerPadding,
    double? height,
    double? width,
    BoxDecoration? decoration,
  }) {
    return LMChatLinkPreviewStyle(
      imageStyle: imageStyle ?? this.imageStyle,
      titleStyle: titleStyle ?? this.titleStyle,
      subtitleStyle: subtitleStyle ?? this.subtitleStyle,
      margin: margin ?? this.margin,
      padding: padding ?? this.padding,
      innerPadding: innerPadding ?? this.innerPadding,
      height: height ?? this.height,
      width: width ?? this.width,
      decoration: decoration ?? this.decoration,
    );
  }

  /// Creates a new instance of LMChatLinkPreviewStyle with the default values.
  /// {@macro chat_link_preview_style}
  factory LMChatLinkPreviewStyle.basic({
    Color? inactiveColor,
    Color? containerColor,
  }) {
    return LMChatLinkPreviewStyle(
      decoration: BoxDecoration(
        color: containerColor?.withOpacity(0.05),
        borderRadius: BorderRadius.circular(8),
      ),
      margin: const EdgeInsets.only(
        bottom: 8,
      ),
      padding: const EdgeInsets.only(
        bottom: 6,
      ),
      innerPadding: const EdgeInsets.only(
        top: 8,
        bottom: 8,
        left: 8,
        right: 30,
      ),
      width: double.infinity,
      imageStyle: const LMChatImageStyle(
        height: 190,
        width: double.infinity,
        boxFit: BoxFit.fill,
        errorWidget: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.link,
          style: LMChatIconStyle(
            size: 32,
          ),
        ),
      ),
      titleStyle: const LMChatTextStyle(
        padding: EdgeInsets.only(
          top: 8,
          bottom: 2,
          left: 8,
          right: 8,
        ),
        textStyle: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w500,
          overflow: TextOverflow.ellipsis,
        ),
        maxLines: 2,
      ),
      subtitleStyle: LMChatTextStyle(
        padding: const EdgeInsets.only(
          top: 2,
          bottom: 8,
          left: 8,
          right: 8,
        ),
        textStyle: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.w400,
          color: inactiveColor,
          overflow: TextOverflow.ellipsis,
        ),
        maxLines: 2,
      ),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/link_preview_bar.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:url_launcher/url_launcher.dart';

/// {@template chat_link_preview_bar}
/// A widget to display a link preview bar on top of the chat bar textfield.
///
/// The [LMChatLinkPreviewBar] can be customized by passing in the required parameters
/// and can be used in a chatroom.
/// {@endtemplate}
class LMChatLinkPreviewBar extends StatelessWidget {
  /// {@macro chat_link_preview_bar}
  const LMChatLinkPreviewBar({
    super.key,
    required this.ogTags,
    this.onCanceled,
    this.onTap,
    this.leadingBuilder,
    this.titleBuilder,
    this.subtitleBuilder,
    this.linkTextBuilder,
    this.cancelButtonBuilder,
    this.style,
  });

  /// The [LMChatOGTagsViewData] to be displayed in the link preview bar.
  final LMChatOGTagsViewData ogTags;

  /// The onCanceled function of the link preview bar.
  final VoidCallback? onCanceled;

  /// The onTap function of the link preview bar.
  final VoidCallback? onTap;

  /// The builder function for the leading widget in the link preview bar.
  final Widget Function(BuildContext, LMChatImage)? leadingBuilder;

  /// The builder function for the title widget in the link preview bar.
  final LMChatTextBuilder? titleBuilder;

  /// The builder function for the subtitle widget in the link preview bar.
  final LMChatTextBuilder? subtitleBuilder;

  /// The builder function for link text
  final LMChatTextBuilder? linkTextBuilder;

  /// The builder function for the cancel button widget in the link preview bar.
  final LMChatButtonBuilder? cancelButtonBuilder;

  /// The style configuration for the link preview bar.
  final LMChatLinkPreviewBarStyle? style;

  /// Creates a copy of the current LMChatLinkPreviewBar instance with the provided values.
  /// If no values are provided, the current values are used.
  LMChatLinkPreviewBar copyWith({
    LMChatOGTagsViewData? ogTags,
    VoidCallback? onCanceled,
    VoidCallback? onTap,
    Widget Function(BuildContext, LMChatImage)? leadingBuilder,
    LMChatTextBuilder? titleBuilder,
    LMChatTextBuilder? subtitleBuilder,
    LMChatTextBuilder? linkTextBuilder,
    LMChatButtonBuilder? cancelButtonBuilder,
    LMChatLinkPreviewBarStyle? style,
  }) {
    return LMChatLinkPreviewBar(
      ogTags: ogTags ?? this.ogTags,
      onCanceled: onCanceled ?? this.onCanceled,
      onTap: onTap ?? this.onTap,
      leadingBuilder: leadingBuilder ?? this.leadingBuilder,
      titleBuilder: titleBuilder ?? this.titleBuilder,
      subtitleBuilder: subtitleBuilder ?? this.subtitleBuilder,
      linkTextBuilder: linkTextBuilder ?? this.linkTextBuilder,
      cancelButtonBuilder: cancelButtonBuilder ?? this.cancelButtonBuilder,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    final themeData = LMChatTheme.theme;
    return GestureDetector(
      onTap: () {
        if (onTap != null) {
          onTap!();
        } else if (ogTags.url != null && ogTags.url!.isNotEmpty) {
          launchUrl(Uri.parse(ogTags.url!));
        }
      },
      child: Container(
        width: style?.width ?? 80.w,
        height: style?.height,
        decoration: style?.decoration?.copyWith(
              color: themeData.container,
            ) ??
            BoxDecoration(
              color: themeData.container,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(8),
              ),
            ),
        margin: style?.margin,
        padding: style?.padding,
        child: Container(
          decoration: style?.decoration ??
              BoxDecoration(
                color: themeData.onContainer.withOpacity(0.05),
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(8),
                ),
              ),
          child: Stack(
            alignment: Alignment.topRight,
            children: [
              Padding(
                padding: style?.innerPadding ??
                    const EdgeInsets.only(
                      top: 8,
                      bottom: 8,
                      left: 8,
                      right: 30,
                    ),
                child: Row(
                  children: [
                    leadingBuilder?.call(context, _defLeading()) ??
                        _defLeading(),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          titleBuilder?.call(context, _defTitle()) ??
                              _defTitle(),
                          subtitleBuilder?.call(context, _defSubTitle()) ??
                              _defSubTitle(),
                          linkTextBuilder?.call(context, _defLinkText()) ??
                              _defLinkText(),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              cancelButtonBuilder?.call(
                    _defCancelButton(),
                  ) ??
                  _defCancelButton(),
            ],
          ),
        ),
      ),
    );
  }

  LMChatText _defLinkText() {
    // convert link text in lower case to avoid case sensitivity
    String link = ogTags.url?.toLowerCase() ?? "";
    return LMChatText(
      link,
      style: style?.linkTextStyle ??
          LMChatTextStyle(
            padding: EdgeInsets.symmetric(horizontal: 1.w),
            textStyle: const TextStyle(
              fontSize: 12,
              color: Colors.grey,
              fontWeight: FontWeight.w400,
              overflow: TextOverflow.ellipsis,
            ),
            maxLines: 1,
          ),
    );
  }

  LMChatImage _defLeading() {
    return LMChatImage(
      imageUrl: ogTags.imageUrl,
      style: style?.leadingStyle ??
          const LMChatImageStyle(
            borderRadius: BorderRadius.all(
              Radius.circular(2),
            ),
            height: 80,
            width: 80,
            boxFit: BoxFit.fill,
            margin: EdgeInsets.symmetric(horizontal: 6),
            errorWidget: LMChatIcon(
              type: LMChatIconType.icon,
              icon: Icons.link,
              style: LMChatIconStyle(
                size: 32,
              ),
            ),
          ),
    );
  }

  LMChatText _defTitle() {
    return LMChatText(
      ogTags.title ?? "",
      style: style?.titleStyle ??
          LMChatTextStyle(
            padding: EdgeInsets.symmetric(horizontal: 1.w),
            textStyle: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w500,
              overflow: TextOverflow.ellipsis,
            ),
            maxLines: 2,
          ),
    );
  }

  LMChatText _defSubTitle() {
    return LMChatText(
      ogTags.description ?? "",
      style: style?.subtitleStyle ??
          LMChatTextStyle(
            padding: EdgeInsets.symmetric(horizontal: 1.w),
            textStyle: const TextStyle(
              fontSize: 14,
              color: Colors.grey,
              fontWeight: FontWeight.w400,
              overflow: TextOverflow.ellipsis,
            ),
            maxLines: 2,
          ),
    );
  }

  LMChatButton _defCancelButton() {
    return LMChatButton(
      onTap: onCanceled,
      icon: const LMChatIcon(
        type: LMChatIconType.icon,
        icon: Icons.close,
        style: LMChatIconStyle(
          size: 20,
        ),
      ),
      style: style?.cancelButtonStyle ??
          const LMChatButtonStyle(
            backgroundColor: Colors.transparent,
            padding: EdgeInsets.all(6),
            borderRadius: 100,
            margin: EdgeInsets.all(8),
          ),
    );
  }
}

/// {@template chat_link_preview_bar_style}
/// Represents the style configuration for the LMChatLinkPreviewBar widget.
/// The [leadingStyle] defines the style for the leading image.
/// The [titleStyle] defines the style for the title text.
/// The [subtitleStyle] defines the style for the subtitle text.
/// The [cancelButtonStyle] defines the style for the cancel button.
/// The [margin] defines the margin around the widget.
/// The [padding] defines the padding around the widget.
/// The [innerPadding] defines the padding inside the widget.
/// The [height] defines the height of the widget.
/// The [width] defines the width of the widget.
/// The [decoration] defines the decoration for the widget.
/// {@endtemplate}
class LMChatLinkPreviewBarStyle {
  final LMChatImageStyle? leadingStyle;
  final LMChatTextStyle? titleStyle;
  final LMChatTextStyle? subtitleStyle;
  final LMChatTextStyle? linkTextStyle;
  final LMChatButtonStyle? cancelButtonStyle;
  final EdgeInsets? margin;
  final EdgeInsets? padding;
  final EdgeInsets? innerPadding;
  final double? height;
  final double? width;
  final BoxDecoration? decoration;

  /// Creates a new instance of LMChatLinkPreviewBarStyle.
  /// {@macro chat_link_preview_bar_style}
  LMChatLinkPreviewBarStyle({
    this.leadingStyle,
    this.titleStyle,
    this.subtitleStyle,
    this.linkTextStyle,
    this.cancelButtonStyle,
    this.margin,
    this.padding,
    this.innerPadding,
    this.height,
    this.width,
    this.decoration,
  });

  /// Creates a copy of the current LMChatLinkPreviewBarStyle instance with the provided values.
  /// If no values are provided, the current values are used.
  /// {@macro chat_link_preview_bar_style}
  LMChatLinkPreviewBarStyle copyWith({
    LMChatImageStyle? leadingStyle,
    LMChatTextStyle? titleStyle,
    LMChatTextStyle? subtitleStyle,
    LMChatTextStyle? linkTextStyle,
    LMChatButtonStyle? cancelButtonStyle,
    EdgeInsets? margin,
    EdgeInsets? padding,
    EdgeInsets? innerPadding,
    double? height,
    double? width,
    BoxDecoration? decoration,
  }) {
    return LMChatLinkPreviewBarStyle(
      leadingStyle: leadingStyle ?? this.leadingStyle,
      titleStyle: titleStyle ?? this.titleStyle,
      subtitleStyle: subtitleStyle ?? this.subtitleStyle,
      linkTextStyle: linkTextStyle ?? this.linkTextStyle,
      cancelButtonStyle: cancelButtonStyle ?? this.cancelButtonStyle,
      margin: margin ?? this.margin,
      padding: padding ?? this.padding,
      innerPadding: innerPadding ?? this.innerPadding,
      height: height ?? this.height,
      width: width ?? this.width,
      decoration: decoration ?? this.decoration,
    );
  }

  /// Creates a new instance of LMChatLinkPreviewBarStyle with the default values.
  /// {@macro chat_link_preview_bar_style}
  factory LMChatLinkPreviewBarStyle.basic({
    Color? inActiveColor,
    Color? containerColor,
  }) {
    return LMChatLinkPreviewBarStyle(
      decoration: BoxDecoration(
        color: containerColor?.withOpacity(0.05),
        borderRadius: const BorderRadius.vertical(
          top: Radius.circular(8),
        ),
      ),
      innerPadding: const EdgeInsets.only(
        top: 8,
        bottom: 8,
        left: 8,
        right: 30,
      ),
      width: 80.w,
      linkTextStyle: LMChatTextStyle(
        padding: EdgeInsets.symmetric(horizontal: 1.w),
        textStyle: TextStyle(
          fontSize: 12,
          color: inActiveColor,
          fontWeight: FontWeight.w400,
          overflow: TextOverflow.ellipsis,
        ),
        maxLines: 1,
      ),
      leadingStyle: const LMChatImageStyle(
        borderRadius: BorderRadius.all(
          Radius.circular(4),
        ),
        height: 80,
        width: 80,
        boxFit: BoxFit.fill,
        margin: EdgeInsets.symmetric(horizontal: 6),
        errorWidget: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.link,
          style: LMChatIconStyle(
            size: 32,
          ),
        ),
      ),
      titleStyle: LMChatTextStyle(
        padding: EdgeInsets.symmetric(horizontal: 1.w),
        textStyle: const TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.w500,
          overflow: TextOverflow.ellipsis,
        ),
        maxLines: 2,
      ),
      subtitleStyle: LMChatTextStyle(
        padding: EdgeInsets.symmetric(horizontal: 1.w),
        textStyle: TextStyle(
          fontSize: 14,
          color: inActiveColor,
          fontWeight: FontWeight.w400,
          overflow: TextOverflow.ellipsis,
        ),
        maxLines: 2,
      ),
      cancelButtonStyle: const LMChatButtonStyle(
        backgroundColor: Colors.transparent,
        padding: EdgeInsets.all(6),
        borderRadius: 100,
        margin: EdgeInsets.all(8),
      ),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/video.dart
================================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:media_kit/media_kit.dart';
import 'package:media_kit_video/media_kit_video.dart';
// import 'package:media_kit_video/media_kit_video_controls/media_kit_video_controls.dart'
//     as media_kit_video_controls;

/// A widget that displays a video in a chat interface.
class LMChatVideo extends StatefulWidget {
  /// The media model containing video information.
  final LMChatMediaModel media;

  /// The style configuration for the video.
  final LMChatVideoStyle? style;

  /// A builder for the mute button.
  final LMChatButtonBuilder? muteButton;

  const LMChatVideo({
    super.key,
    required this.media,
    this.style,
    this.muteButton,
  });

  /// Creates a copy of the current LMChatVideo with optional new values.
  LMChatVideo copyWith({
    LMChatMediaModel? media,
    LMChatVideoStyle? style,
    LMChatButtonBuilder? muteButton,
  }) {
    return LMChatVideo(
      media: media ?? this.media,
      style: style ?? this.style,
      muteButton: muteButton ?? this.muteButton,
    );
  }

  @override
  State<LMChatVideo> createState() => _LMChatVideoState();
}

/// State for the LMChatVideo widget.
class _LMChatVideoState extends State<LMChatVideo> {
  /// The video controller for managing video playback.
  VideoController? _controller;

  /// The player instance for video playback.
  Player? _player;

  /// Future for initializing the controller.
  Future<void>? init;

  /// Notifier to track mute state.
  ValueNotifier<bool>? isMuted;

  /// Notifier to track play/pause state.
  ValueNotifier<bool>? isPlaying;

  /// Notifier to trigger video rebuilds.
  ValueNotifier<bool> rebuildVideo = ValueNotifier(false);

  /// The video controller instance.
  VideoController? controller;

  /// The style configuration for the video.
  LMChatVideoStyle? style;

  @override
  void initState() {
    super.initState();
    init = _initController();
    isMuted = ValueNotifier(false);
    isPlaying = ValueNotifier(false);
  }

  @override
  void didUpdateWidget(old) {
    init = _initController();
    super.didUpdateWidget(old);
  }

  @override
  void deactivate() {
    _player?.stop();
    super.deactivate();
  }

  @override
  void dispose() {
    _player?.dispose();
    super.dispose();
  }

  /// Initializes the video controller based on the media source.
  Future<void> _initController() async {
    _player ??= Player(
      configuration: PlayerConfiguration(
        bufferSize: 4 * 1024 * 1024,
        ready: () {},
        muted: false,
      ),
    );
    _controller ??= VideoController(
      _player!,
      configuration: const VideoControllerConfiguration(
        scale: 0.5,
      ),
    );

    // initialise the controller based on the video source type
    // network or file
    if (widget.media.mediaUrl != null) {
      // if the video source type is network, then the video source is a url
      return await _player!.open(
        Media(widget.media.mediaUrl!),
        play: true,
      );
    } else {
      return await _player!.open(
        await Media.memory(widget.media.mediaFile!.readAsBytesSync()),
        play: true,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final chatTheme = LMChatTheme.theme;
    style = widget.style ?? chatTheme.videoStyle;
    return Container(
      height: style?.height,
      width: style?.width ?? 100.w,
      decoration: BoxDecoration(
        color: style?.backgroundColor ?? chatTheme.onPrimary,
        border: Border.all(
          color: style?.borderColor ?? Colors.transparent,
          width: style?.borderWidth ?? 0,
        ),
        borderRadius: style?.borderRadius ?? BorderRadius.circular(8.0),
      ),
      child: AspectRatio(
        // aspectRatio:
        aspectRatio: (style?.width ?? widget.media.width?.toDouble() ?? 100.w) /
            (style?.height ?? widget.media.height?.toDouble() ?? 56.h),
        child: MaterialVideoControlsTheme(
          fullscreen: const MaterialVideoControlsThemeData(),
          normal: MaterialVideoControlsThemeData(
            bottomButtonBar: [
              const MaterialPositionIndicator(),
              const Spacer(),
              ValueListenableBuilder(
                valueListenable: isMuted!,
                builder: (context, state, _) {
                  return widget.muteButton?.call(_defMuteButton(state)) ??
                      _defMuteButton(state);
                },
              ),
            ],
            bottomButtonBarMargin: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 8,
            ),
            seekBarMargin: const EdgeInsets.symmetric(
              horizontal: 8,
              vertical: 12,
            ),
            seekBarPositionColor:
                style?.seekBarColor ?? chatTheme.secondaryColor,
            seekBarThumbColor: style?.seekBarColor ?? chatTheme.secondaryColor,
          ),
          child: Video(
            fit: style?.boxFit ?? BoxFit.contain,
            aspectRatio: style?.aspectRatio,
            controller: _controller!,
          ),
        ),
      ),
    );
  }

  /// Defines the mute button for the video.
  LMChatButton _defMuteButton(bool state) {
    return LMChatButton(
      onTap: () {
        state ? _player!.setVolume(100) : _player!.setVolume(0);
        isMuted!.value = !isMuted!.value;
      },
      icon: LMChatIcon(
        type: LMChatIconType.icon,
        style: LMChatIconStyle(
          color: LMChatTheme.theme.container,
        ),
        icon: state ? Icons.volume_off : Icons.volume_up,
      ),
    );
  }
}

/// Configuration for the LMChatVideo widget's style.
class LMChatVideoStyle {
  // Video structure variables
  /// The height of the video.
  final double? height;

  /// The width of the video.
  final double? width;

  /// The aspect ratio of the video (defaults to 16/9).
  final double? aspectRatio;

  /// The border radius of the video (defaults to 0).
  final BorderRadius? borderRadius;

  /// The border color of the video.
  final Color? borderColor;

  /// The background color of the video.
  final Color? backgroundColor;

  /// The border width of the video.
  final double? borderWidth;

  /// The box fit of the video (defaults to BoxFit.cover).
  final BoxFit? boxFit;

  /// Padding around the video.
  final EdgeInsets? padding;

  /// Margin around the video.
  final EdgeInsets? margin;

  // Video styling variables
  /// The color of the seek bar.
  final Color? seekBarColor;

  /// The color of the seek bar buffer.
  final Color? seekBarBufferColor;

  /// The text style for the progress text.
  final TextStyle? progressTextStyle;

  /// The widget displayed while loading the video.
  final Widget? loaderWidget;

  /// The widget displayed on error.
  final Widget? errorWidget;

  /// The widget displayed while shimmering.
  final Widget? shimmerWidget;

  /// The button for playing the video.
  final LMChatButton? playButton;

  /// The button for pausing the video.
  final LMChatButton? pauseButton;

  /// The button for muting the video.
  final LMChatButton? muteButton;
  // Video functionality control variables
  /// Whether to show video controls.
  final bool? showControls;

  /// Whether the video should autoplay.
  final bool? autoPlay;

  /// Whether the video should loop.
  final bool? looping;

  /// Whether to allow full screen mode.
  final bool? allowFullScreen;

  /// Whether to allow muting.
  final bool? allowMuting;

  const LMChatVideoStyle({
    this.height,
    this.width,
    this.aspectRatio,
    this.borderRadius,
    this.borderColor,
    this.backgroundColor,
    this.borderWidth,
    this.boxFit,
    this.seekBarColor,
    this.seekBarBufferColor,
    this.progressTextStyle,
    this.loaderWidget,
    this.errorWidget,
    this.shimmerWidget,
    this.playButton,
    this.pauseButton,
    this.muteButton,
    this.showControls,
    this.autoPlay,
    this.looping,
    this.allowFullScreen,
    this.allowMuting,
    this.padding,
    this.margin,
  });

  /// Creates a copy of the current LMChatVideoStyle with optional new values.
  LMChatVideoStyle copyWith({
    double? height,
    double? width,
    double? aspectRatio,
    BorderRadius? borderRadius,
    Color? borderColor,
    double? borderWidth,
    BoxFit? boxFit,
    Color? seekBarColor,
    Color? seekBarBufferColor,
    TextStyle? progressTextStyle,
    Widget? loaderWidget,
    Widget? errorWidget,
    Widget? shimmerWidget,
    LMChatButton? playButton,
    LMChatButton? pauseButton,
    LMChatButton? muteButton,
    bool? showControls,
    bool? autoPlay,
    bool? looping,
    bool? allowFullScreen,
    bool? allowMuting,
    EdgeInsets? padding,
    EdgeInsets? margin,
  }) {
    return LMChatVideoStyle(
      height: height ?? this.height,
      width: width ?? this.width,
      aspectRatio: aspectRatio ?? this.aspectRatio,
      borderRadius: borderRadius ?? this.borderRadius,
      borderColor: borderColor ?? this.borderColor,
      borderWidth: borderWidth ?? this.borderWidth,
      boxFit: boxFit ?? this.boxFit,
      seekBarColor: seekBarColor ?? this.seekBarColor,
      seekBarBufferColor: seekBarBufferColor ?? this.seekBarBufferColor,
      progressTextStyle: progressTextStyle ?? this.progressTextStyle,
      loaderWidget: loaderWidget ?? this.loaderWidget,
      errorWidget: errorWidget ?? this.errorWidget,
      shimmerWidget: shimmerWidget ?? this.shimmerWidget,
      playButton: playButton ?? this.playButton,
      pauseButton: pauseButton ?? this.pauseButton,
      muteButton: muteButton ?? this.muteButton,
      showControls: showControls ?? this.showControls,
      autoPlay: autoPlay ?? this.autoPlay,
      looping: looping ?? this.looping,
      allowFullScreen: allowFullScreen ?? this.allowFullScreen,
      allowMuting: allowMuting ?? this.allowMuting,
      padding: padding ?? this.padding,
      margin: margin ?? this.margin,
    );
  }

  /// Creates a basic LMChatVideoStyle with a loader widget.
  factory LMChatVideoStyle.basic({Color? primaryColor}) =>
      const LMChatVideoStyle(
        loaderWidget: LMChatLoader(),
      );
}



================================================
File: lib/packages/ui/lib/src/widgets/media/voice_note.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_audio}
/// A widget to display and control audio playback in the LMChat UI.
/// The [media] parameter is required and contains the audio data.
/// {@endtemplate}
class LMChatVoiceNote extends StatefulWidget {
  /// {@macro lm_chat_audio}
  /// Creates an instance of [LMChatVoiceNote].
  const LMChatVoiceNote({
    super.key,
    required this.media,
    this.style,
    this.autoplay,
    this.onPlay,
    this.onPause,
    this.onSlide,
    this.onSlideEnd,
    this.onSlideStart,
    this.handler,
    this.onDurationUpdate,
  });

  /// Creates a copy of this [LMChatVoiceNote] but with the given fields replaced with the new values.
  ///
  /// If the new values are null, then the old values are used.
  LMChatVoiceNote copyWith({
    LMChatMediaModel? media,
    LMChatVoiceNoteStyle? style,
    bool? autoplay,
    Function()? onPlay,
    Function()? onPause,
    Function(double)? onSlide,
    Function(double)? onSlideStart,
    Function(double)? onSlideEnd,
    LMChatAudioHandler? handler,
    Function(Duration)? onDurationUpdate,
  }) {
    return LMChatVoiceNote(
      media: media ?? this.media,
      style: style ?? this.style,
      autoplay: autoplay ?? this.autoplay,
      onPlay: onPlay ?? this.onPlay,
      onPause: onPause ?? this.onPause,
      onSlide: onSlide ?? this.onSlide,
      onSlideStart: onSlideStart ?? this.onSlideStart,
      onSlideEnd: onSlideEnd ?? this.onSlideEnd,
      handler: handler ?? this.handler,
      onDurationUpdate: onDurationUpdate ?? this.onDurationUpdate,
    );
  }

  /// The media model containing the audio data.
  final LMChatMediaModel media;

  /// The style configuration for the audio widget.
  final LMChatVoiceNoteStyle? style;

  /// The bool to control whether audio autoplays or not.
  final bool? autoplay;

  /// Callback function that is called when the audio starts playing.
  final Function()? onPlay;

  /// Callback function that is called when the audio is paused.
  final Function()? onPause;

  /// Callback function that is called when the audio slider is changed.
  final Function(double)? onSlide;

  /// Callback function that is called when the audio slider change starts.
  final Function(double)? onSlideStart;

  /// Callback function that is called when the audio slider change ends.
  final Function(double)? onSlideEnd;

  /// External FlutterSoundPlayer instance that can be passed to control audio externally
  final LMChatAudioHandler? handler;

  /// Callback function that is called when the audio duration updates.
  final Function(Duration)? onDurationUpdate;

  @override
  State<LMChatVoiceNote> createState() => _LMChatVoiceNoteState();
}

class _LMChatVoiceNoteState extends State<LMChatVoiceNote>
    with WidgetsBindingObserver {
  FlutterSoundPlayer? _localPlayer;
  late final bool _useExternalHandler;
  bool _isAudioPlaying = false;
  double _progress = 0.0;
  Duration _totalDuration = Duration.zero;
  bool _isDragging = false;
  String? _currentMediaPath;
  bool _wasPlayingBeforePause = false;

  // Subscriptions
  StreamSubscription? _playerSubscription;
  StreamSubscription? _progressSubscription;
  StreamSubscription? _handlerSubscription;
  StreamSubscription? _durationSubscription;

  Duration? _initialSeekPosition;

  // Add new state variable to track last played position
  Duration _lastPlayedPosition = Duration.zero;

  // Add this field at the top with other state variables
  Duration _initialDuration = Duration.zero;

  // Add this near other state variables in _LMChatVoiceNoteState
  StreamSubscription? _audioStateSubscription;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _useExternalHandler = widget.handler != null;
    _currentMediaPath = widget.media.mediaFile?.path ?? widget.media.mediaUrl;

    // Add audio state subscription
    _audioStateSubscription = widget.handler?.audioStateStream.listen((state) {
      if (state == LMChatAudioState.stopped && mounted) {
        _resetPlayback();
      }
    });

    // Parse initial duration from metadata if available
    _initialDuration = Duration(
      seconds: int.tryParse(
            widget.media.meta?["duration"]?.toString() ?? "0",
          ) ??
          0,
    );
    if (_initialDuration > Duration.zero) {
      _totalDuration = _initialDuration;
    }

    if (_useExternalHandler) {
      _initializeHandlerSubscriptions();
    }

    // Only fetch duration if not available from metadata
    if (_initialDuration == Duration.zero) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _initializeAndGetDuration();
      });
    }

    if (widget.autoplay ?? false) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _startPlayer();
      });
    }

    if (_useExternalHandler && _currentMediaPath != null) {
      _durationSubscription = widget.handler!
          .getDurationStream(_currentMediaPath!)
          .listen((duration) {
        widget.onDurationUpdate?.call(duration);
      });
    }
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    switch (state) {
      case AppLifecycleState.paused:
      case AppLifecycleState.inactive:
        _wasPlayingBeforePause = _isAudioPlaying;
        if (_isAudioPlaying) {
          _pausePlayback();
        }
        break;
      case AppLifecycleState.resumed:
        if (_wasPlayingBeforePause) {
          _resumePlayback();
        }
        break;
      default:
        break;
    }
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _currentMediaPath = widget.media.mediaFile?.path ?? widget.media.mediaUrl;
    if (widget.autoplay ?? false) {
      _startPlayer();
    }
  }

  @override
  void didUpdateWidget(LMChatVoiceNote oldWidget) {
    super.didUpdateWidget(oldWidget);

    final newMediaPath = widget.media.mediaFile?.path ?? widget.media.mediaUrl;

    if (_currentMediaPath != newMediaPath) {
      // Reset last played position when media changes
      _lastPlayedPosition = Duration.zero;

      // Clean up old resources and reset state
      if (_isAudioPlaying ||
          (_useExternalHandler && (widget.handler?.player.isPaused ?? false))) {
        _pausePlayback();
        _progress = 0.0;
        _totalDuration = Duration.zero;
      }
      _cleanupPlayer();

      // Update path and reinitialize if needed
      _currentMediaPath = newMediaPath;

      // If autoplay is enabled for the new media, start playing it
      if (widget.autoplay ?? false) {
        _startPlayer();
      }
    }

    // Handle handler changes
    if (oldWidget.handler != widget.handler) {
      _cleanupSubscriptions();
      _useExternalHandler = widget.handler != null;

      // // Reset state when handler changes
      // _progress = 0.0;
      // _lastPlayedPosition = Duration.zero;
      // _totalDuration = Duration.zero;
      // widget.onDurationUpdate?.call(Duration.zero);

      // if (_useExternalHandler) {
      //   _initializeHandlerSubscriptions();

      //   // Set up duration subscription for new handler
      //   if (_currentMediaPath != null) {
      //     _durationSubscription?.cancel();
      //     _durationSubscription = widget.handler!
      //         .getDurationStream(_currentMediaPath!)
      //         .listen((duration) {
      //       widget.onDurationUpdate?.call(duration);
      //     });
      //   }
      // }
    }
  }

  void _cleanupPlayer() {
    _progress = 0.0;
    _totalDuration = Duration.zero;
    if (_localPlayer != null) {
      _localPlayer!.closePlayer();
      _localPlayer = null;
    }
    _cleanupSubscriptions();
  }

  Future<void> _stopAllOtherPlayers() async {
    try {
      if (_useExternalHandler) {
        // First check if any audio is playing and if it's different from current
        String? currentPlayingUrl = widget.handler!.currentlyPlayingUrl;
        if (currentPlayingUrl != null &&
            currentPlayingUrl.isNotEmpty &&
            currentPlayingUrl != _currentMediaPath) {
          await widget.handler!.stopAudio();
          await Future.delayed(const Duration(milliseconds: 100));
        }
      } else {
        if (_localPlayer?.isPlaying ?? false) {
          await _localPlayer!.stopPlayer();
          _playerSubscription?.cancel();
          _playerSubscription = null;
        }
      }
    } catch (e) {
      print('Error stopping other players: $e');
    }
  }

  Future<void> _startPlayer() async {
    if (_currentMediaPath == null) return;

    try {
      // First ensure complete cleanup of any existing playback
      await _stopAllOtherPlayers();

      // Reset all state to ensure fresh start
      _progressSubscription?.cancel();
      _playerSubscription?.cancel();

      // Only preserve initial seek position if it was explicitly set
      final preservedSeekPosition = _initialSeekPosition;

      setState(() {
        _progress = 0.0;
        _totalDuration = Duration.zero;
        _isAudioPlaying = false; // Ensure we start from a clean state
      });

      // Restore initial seek position if it existed
      _initialSeekPosition = preservedSeekPosition;

      if (_useExternalHandler) {
        // Ensure handler is in a clean state
        await widget.handler!.stopAudio();
        await Future.delayed(const Duration(milliseconds: 50));
        await _startWithHandler();
      } else {
        // For local player, close and reinitialize to ensure clean state
        if (_localPlayer != null) {
          await _localPlayer!.closePlayer();
          _localPlayer = null;
        }
        await _initializeLocalPlayer();
        await _startWithLocalPlayer();
      }
    } catch (e) {
      print('Error starting player: $e');
      _handlePlaybackError();
    }
  }

  void _handlePlaybackError() {
    setState(() {
      _isAudioPlaying = false;
      _progress = 0.0;
    });
    widget.onPause?.call();
    _cleanupPlayer();
  }

  void _initializeHandlerSubscriptions() {
    // Listen to external player state changes
    _handlerSubscription = widget.handler!.currentlyPlayingStream.listen((url) {
      if (!mounted) return;

      // If a different URL is playing, ensure this widget shows as paused
      if (url != _currentMediaPath && _isAudioPlaying) {
        setState(() {
          _isAudioPlaying = false;
          _progress = 0.0;
        });
        widget.onPause?.call();
      } else if (url == _currentMediaPath && !_isAudioPlaying) {
        // If this URL started playing, update state
        setState(() {
          _isAudioPlaying = true;
        });
        widget.onPlay?.call();
      }
    });
  }

  Future<void> _initializeLocalPlayer() async {
    if (_localPlayer != null) return;

    try {
      _localPlayer = FlutterSoundPlayer();
      await _localPlayer!.openPlayer();

      // Get initial duration if we don't have it yet
      if (_totalDuration == Duration.zero && _currentMediaPath != null) {
        Duration? duration = await _localPlayer!.startPlayer(
          fromURI: _currentMediaPath,
          whenFinished: () async {
            await _localPlayer!.stopPlayer();
          },
        );

        if (duration != null && mounted) {
          setState(() => _totalDuration = duration);
        }
        await _localPlayer!.stopPlayer();
      }
    } catch (e) {
      print('Error initializing local player: $e');
      // Clean up on error
      await _localPlayer?.closePlayer();
      _localPlayer = null;
    }
  }

  void _subscribeToProgressUpdates() {
    if (!_useExternalHandler || _currentMediaPath == null) return;

    _progressSubscription?.cancel();
    _progressSubscription =
        widget.handler!.getProgressStream(_currentMediaPath!).listen(
      (progress) {
        if (!mounted || _isDragging) return;
        setState(() {
          _totalDuration = progress.duration;
          widget.onDurationUpdate?.call(progress.position);
          if (_totalDuration.inMilliseconds > 0) {
            _progress = (progress.position.inMilliseconds /
                    _totalDuration.inMilliseconds)
                .clamp(0.0, 1.0);
          }
        });
      },
      onError: (error) {
        print('Error in progress stream: $error');
      },
    );
  }

  Future<void> _startWithHandler() async {
    await widget.handler!.stopAudio();

    await widget.handler!.playAudio(_currentMediaPath!);

    if (_initialSeekPosition != null) {
      await widget.handler!.seekTo(_initialSeekPosition!);
      _initialSeekPosition = null;
    } else if (_progress > 0) {
      final position = Duration(
        milliseconds: (_totalDuration.inMilliseconds * _progress).toInt(),
      );
      await widget.handler!.seekTo(position);
    }

    _subscribeToProgressUpdates();
    setState(() => _isAudioPlaying = true);
    widget.onPlay?.call();
  }

  Future<void> _startWithLocalPlayer() async {
    if (_localPlayer == null) {
      await _initializeLocalPlayer();
    }

    if (_localPlayer == null) return;

    try {
      if (_localPlayer!.isPaused || _localPlayer!.isPlaying) {
        await _localPlayer!.stopPlayer();
      }

      await _localPlayer!
          .setSubscriptionDuration(const Duration(milliseconds: 100));

      Duration? startDuration = await _localPlayer!.startPlayer(
        fromURI: _currentMediaPath,
        whenFinished: _onPlaybackComplete,
      );

      if (startDuration != null) {
        setState(() => _totalDuration = startDuration);
      }

      if (_initialSeekPosition != null) {
        await _localPlayer!.seekToPlayer(_initialSeekPosition!);
        _initialSeekPosition = null;
      } else if (_progress > 0 && _totalDuration.inMilliseconds > 0) {
        final position = Duration(
          milliseconds: (_totalDuration.inMilliseconds * _progress).toInt(),
        );
        await _localPlayer!.seekToPlayer(position);
      }

      _setupLocalPlayerProgress();
      setState(() => _isAudioPlaying = true);
      widget.onPlay?.call();
    } catch (e) {
      print('Error in _startWithLocalPlayer: $e');
      setState(() => _isAudioPlaying = false);
      widget.onPause?.call();
    }
  }

  void _onPlaybackComplete() {
    if (!mounted) return;
    _resetPlayback();
    if (_useExternalHandler) {
      widget.handler!.stopAudio();
    } else {
      _localPlayer?.stopPlayer();
    }
  }

  void _setupLocalPlayerProgress() {
    _playerSubscription?.cancel();
    _playerSubscription = _localPlayer?.onProgress?.listen(
      (e) {
        if (!mounted || _isDragging) return;

        setState(() {
          if (e.duration.inMilliseconds > 0) {
            _totalDuration = e.duration;
            widget.onDurationUpdate?.call(e.position);
            _progress = (e.position.inMilliseconds / e.duration.inMilliseconds)
                .clamp(0.0, 1.0);

            if (_progress >= 0.99) {
              _onPlaybackComplete();
            }
          }
        });
      },
      onError: (error) {
        print('Error in local player progress: $error');
        _onPlaybackComplete();
      },
    );
  }

  Future<void> _togglePlayPause() async {
    try {
      if (_totalDuration == Duration.zero) {
        await _initializeAndGetDuration();
      }

      if (_useExternalHandler) {
        // Check current playing URL first
        String? currentPlayingUrl = widget.handler!.currentlyPlayingUrl;

        if (_isAudioPlaying) {
          // Only pause if this voice note is currently playing
          if (currentPlayingUrl == _currentMediaPath) {
            await _pausePlayback();
          } else {
            // If different voice note is playing, start this one
            await _startPlayer();
          }
        } else {
          // If nothing is playing or different voice note is paused, start fresh
          if (currentPlayingUrl == null ||
              currentPlayingUrl != _currentMediaPath) {
            await _startPlayer();
          } else {
            // If slider was moved, use that position instead of last played position
            if (_progress !=
                _lastPlayedPosition.inMilliseconds /
                    _totalDuration.inMilliseconds) {
              _lastPlayedPosition = Duration(
                milliseconds:
                    (_totalDuration.inMilliseconds * _progress).toInt(),
              );
            }
            await _resumePlayback();
          }
        }
      } else {
        // Local player logic remains the same
        if (_isAudioPlaying) {
          await _pausePlayback();
        } else {
          if (_lastPlayedPosition > Duration.zero) {
            await _resumePlayback();
          } else {
            await _startPlayer();
          }
        }
      }
    } catch (e) {
      print('Error toggling play/pause: $e');
    }
  }

  Future<void> _pausePlayback() async {
    try {
      if (_useExternalHandler) {
        // Verify this voice note is actually playing before pausing
        String? currentPlayingUrl = widget.handler!.currentlyPlayingUrl;
        if (currentPlayingUrl == _currentMediaPath) {
          // Store the current position before pausing
          if (_totalDuration.inMilliseconds > 0) {
            _lastPlayedPosition = Duration(
              milliseconds: (_totalDuration.inMilliseconds * _progress).toInt(),
            );
          }
          await widget.handler!.pauseAudio();
          _progressSubscription?.cancel();
        }
      } else {
        if (_localPlayer?.isPlaying ?? false) {
          _lastPlayedPosition = Duration(
            milliseconds: (_totalDuration.inMilliseconds * _progress).toInt(),
          );
          await _localPlayer!.pausePlayer();
        }
      }
      setState(() => _isAudioPlaying = false);
      widget.onPause?.call();
    } catch (e) {
      print('Error pausing playback: $e');
      _resetPlayback();
    }
  }

  Future<void> _resumePlayback() async {
    try {
      if (_useExternalHandler) {
        // Check if this voice note was the last one playing
        String? currentPlayingUrl = widget.handler!.currentlyPlayingUrl;
        if (currentPlayingUrl == null ||
            currentPlayingUrl != _currentMediaPath) {
          // If different or no voice note was playing, start fresh
          await _startPlayer();
          return;
        }

        await widget.handler!.resumeAudio();

        // Always use the current progress position instead of last played position
        if (_totalDuration.inMilliseconds > 0) {
          final targetPosition = Duration(
            milliseconds: (_totalDuration.inMilliseconds * _progress).toInt(),
          );
          await widget.handler!.seekTo(targetPosition);
        }

        _subscribeToProgressUpdates();
      } else {
        // Local player logic
        if (_localPlayer == null) {
          await _startWithLocalPlayer();
          return;
        }

        await _localPlayer!.resumePlayer();

        // Always use the current progress position
        if (_totalDuration.inMilliseconds > 0) {
          final targetPosition = Duration(
            milliseconds: (_totalDuration.inMilliseconds * _progress).toInt(),
          );
          await _localPlayer!.seekToPlayer(targetPosition);
        }

        _setupLocalPlayerProgress();
      }

      setState(() => _isAudioPlaying = true);
      widget.onPlay?.call();
    } catch (e) {
      print('Error resuming playback: $e');
      setState(() => _isAudioPlaying = false);
      widget.onPause?.call();
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);

    _cleanupSubscriptions();
    _cleanupPlayer();
    _durationSubscription?.cancel();
    _audioStateSubscription?.cancel();

    super.dispose();
  }

  void _cleanupSubscriptions() {
    _playerSubscription?.cancel();
    _handlerSubscription?.cancel();
    _progressSubscription?.cancel();
  }

  @override
  Widget build(BuildContext context) {
    final style = widget.style ?? const LMChatVoiceNoteStyle();
    return Container(
      width: style.width,
      height: style.height,
      color: style.backgroundColor,
      padding: style.padding ?? const EdgeInsets.only(left: 8),
      child: Row(
        children: [
          LMChatButton(
            icon: LMChatIcon(
              type: LMChatIconType.icon,
              icon: _isAudioPlaying ? Icons.pause : Icons.play_arrow,
              style: LMChatIconStyle(
                size: 28,
                boxSize: 32,
                color: style.iconColor ?? LMChatTheme.theme.onPrimary,
              ),
            ),
            onTap: _togglePlayPause,
            style: LMChatButtonStyle(
              height: 36,
              width: 36,
              borderRadius: 18,
              backgroundColor:
                  style.buttonColor ?? LMChatTheme.theme.secondaryColor,
            ),
          ),
          Expanded(
            child: Slider(
              value: _progress.clamp(0.0, 1.0),
              onChanged: (value) {
                setState(() {
                  _progress = value;
                });
                if (_totalDuration.inMilliseconds > 0) {
                  final currentPosition = Duration(
                    milliseconds:
                        (_totalDuration.inMilliseconds * value).toInt(),
                  );
                  if (!_isAudioPlaying) {
                    _initialSeekPosition = currentPosition;
                  }
                  widget.onDurationUpdate?.call(currentPosition);
                }
                widget.onSlide?.call(value);
              },
              onChangeStart: (value) async {
                _isDragging = true;
                if (_totalDuration == Duration.zero) {
                  await _initializeAndGetDuration();
                }
                widget.onSlideStart?.call(value);
              },
              onChangeEnd: (value) async {
                _isDragging = false;
                if (_totalDuration.inMilliseconds > 0) {
                  final position = Duration(
                    milliseconds:
                        (_totalDuration.inMilliseconds * value).toInt(),
                  );

                  if (_useExternalHandler) {
                    if (_isAudioPlaying) {
                      await widget.handler!.seekTo(position);
                    }
                  } else {
                    if (_isAudioPlaying && _localPlayer != null) {
                      await _localPlayer!.seekToPlayer(position);
                    }
                  }
                }
                widget.onSlideEnd?.call(value);
              },
              min: style.sliderMin,
              max: style.sliderMax,
              divisions: style.sliderDivisions,
              activeColor:
                  style.sliderActiveColor ?? LMChatTheme.theme.secondaryColor,
              inactiveColor:
                  style.sliderInactiveColor ?? LMChatTheme.theme.disabledColor,
              thumbColor:
                  style.sliderThumbColor ?? LMChatTheme.theme.secondaryColor,
            ),
          ),
          // Add more UI elements like duration, etc.
        ],
      ),
    );
  }

  // Update _initializeAndGetDuration to avoid unnecessary player initialization
  Future<void> _initializeAndGetDuration() async {
    if (_totalDuration != Duration.zero || _currentMediaPath == null) return;

    try {
      if (_useExternalHandler) {
        final duration = await widget.handler!.getDuration(_currentMediaPath!);
        if (duration != null && mounted) {
          setState(() => _totalDuration = duration);
          widget.onDurationUpdate?.call(duration);
        }
      } else {
        // Create a temporary player just for getting duration
        final tempPlayer = FlutterSoundPlayer();
        await tempPlayer.openPlayer();

        Duration? duration = await tempPlayer.startPlayer(
          fromURI: _currentMediaPath,
          whenFinished: () async {
            await tempPlayer.stopPlayer();
          },
        );

        await tempPlayer.stopPlayer();
        await tempPlayer.closePlayer();

        if (duration != null && mounted) {
          setState(() => _totalDuration = duration);
          widget.onDurationUpdate?.call(duration);
        }
      }
    } catch (e) {
      print('Error getting duration: $e');
      if (mounted) {
        setState(() => _totalDuration = Duration.zero);
      }
    }
  }

  // Add method to reset playback state
  void _resetPlayback() {
    setState(() {
      _isAudioPlaying = false;
      _progress = 0.0;
      _lastPlayedPosition = Duration.zero;
      widget.onDurationUpdate?.call(Duration.zero);
    });
    widget.onPause?.call();
  }
}

/// Defines the style properties for the LMChatAudio widget.
class LMChatVoiceNoteStyle {
  /// The width of the audio container.
  final double? width;

  /// The height of the audio container.
  final double? height;

  /// The background color of the audio container.
  final Color? backgroundColor;

  /// The color of the play/pause icon.
  final Color? iconColor;

  /// The padding around the audio container.
  final EdgeInsets? padding;

  /// The minimum value of the slider.
  final double sliderMin;

  /// The maximum value of the slider.
  final double sliderMax;

  /// The number of discrete divisions in the slider.
  final int? sliderDivisions;

  /// The color of the active portion of the slider.
  final Color? sliderActiveColor;

  /// The color of the inactive portion of the slider.
  final Color? sliderInactiveColor;

  /// The color of the slider's thumb.
  final Color? sliderThumbColor;

  /// The color of the button.
  final Color? buttonColor;

  /// Creates an instance of [LMChatVoiceNoteStyle].
  const LMChatVoiceNoteStyle({
    this.width,
    this.height,
    this.backgroundColor,
    this.iconColor,
    this.padding,
    this.sliderMin = 0.0,
    this.sliderMax = 1.0,
    this.sliderDivisions,
    this.sliderActiveColor,
    this.sliderInactiveColor,
    this.sliderThumbColor,
    this.buttonColor,
  });

  /// Creates a basic instance of [LMChatVoiceNoteStyle].
  factory LMChatVoiceNoteStyle.basic() {
    return const LMChatVoiceNoteStyle();
  }

  /// Creates a copy of this [LMChatVoiceNoteStyle] but with the given fields replaced with the new values.
  LMChatVoiceNoteStyle copyWith({
    double? width,
    double? height,
    Color? backgroundColor,
    Color? iconColor,
    EdgeInsets? padding,
    double? sliderMin,
    double? sliderMax,
    int? sliderDivisions,
    Color? sliderActiveColor,
    Color? sliderInactiveColor,
    Color? sliderThumbColor,
    Color? buttonColor,
  }) {
    return LMChatVoiceNoteStyle(
      width: width ?? this.width,
      height: height ?? this.height,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      iconColor: iconColor ?? this.iconColor,
      padding: padding ?? this.padding,
      sliderMin: sliderMin ?? this.sliderMin,
      sliderMax: sliderMax ?? this.sliderMax,
      sliderDivisions: sliderDivisions ?? this.sliderDivisions,
      sliderActiveColor: sliderActiveColor ?? this.sliderActiveColor,
      sliderInactiveColor: sliderInactiveColor ?? this.sliderInactiveColor,
      sliderThumbColor: sliderThumbColor ?? this.sliderThumbColor,
      buttonColor: buttonColor ?? this.buttonColor,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/document/document.dart
================================================
import 'package:likeminds_chat_flutter_ui/src/widgets/media/document/preview.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/media/document/thumbnail.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/media/document/tile.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/shimmers/document_shimmer.dart';

export 'package:likeminds_chat_flutter_ui/src/widgets/media/document/preview.dart';
export 'package:likeminds_chat_flutter_ui/src/widgets/media/document/thumbnail.dart';
export 'package:likeminds_chat_flutter_ui/src/widgets/media/document/tile.dart';

class LMChatDocumentStyle {
  final LMChatDocumentPreviewStyle? previewStyle;
  final LMChatDocumentShimmerStyle? shimmerStyle;
  final LMChatDocumentTilePreviewStyle? previewTileStyle;
  final LMChatDocumentThumbnailStyle? thumbnailStyle;
  final LMChatDocumentTileStyle? tileStyle;

  LMChatDocumentStyle({
    this.previewStyle,
    this.previewTileStyle,
    this.shimmerStyle,
    this.tileStyle,
    this.thumbnailStyle,
  });

  factory LMChatDocumentStyle.basic() {
    return LMChatDocumentStyle(
      previewStyle: LMChatDocumentPreviewStyle.basic(),
      previewTileStyle: LMChatDocumentTilePreviewStyle.basic(),
      shimmerStyle: LMChatDocumentShimmerStyle.basic(),
      thumbnailStyle: LMChatDocumentThumbnailStyle.basic(),
      tileStyle: LMChatDocumentTileStyle.basic(),
    );
  }

  LMChatDocumentStyle copyWith({
    LMChatDocumentPreviewStyle? previewStyle,
    LMChatDocumentShimmerStyle? shimmerStyle,
    LMChatDocumentTilePreviewStyle? previewTileStyle,
    LMChatDocumentThumbnailStyle? thumbnailStyle,
    LMChatDocumentTileStyle? tileStyle,
  }) {
    return LMChatDocumentStyle(
      previewStyle: previewStyle ?? this.previewStyle,
      shimmerStyle: shimmerStyle ?? this.shimmerStyle,
      previewTileStyle: previewTileStyle ?? this.previewTileStyle,
      thumbnailStyle: thumbnailStyle ?? this.thumbnailStyle,
      tileStyle: tileStyle ?? this.tileStyle,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/document/preview.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

///{@template lm_chat_document_preview}
/// A widget that displays a document preview with single attachment.
/// {@endtemplate}
class LMChatDocumentPreview extends StatefulWidget {
  /// The list of documents to display.
  final LMChatMediaModel media;

  /// The style for the document preview.
  final LMChatDocumentPreviewStyle? style;

  ///{@macro lm_chat_document_preview}
  const LMChatDocumentPreview({
    super.key,
    required this.media,
    this.style,
  });

  /// Creates a copy of this [LMChatDocumentPreview] but with the given fields replaced with the new values.
  LMChatDocumentPreview copyWith({
    LMChatMediaModel? media,
    LMChatDocumentPreviewStyle? style,
  }) {
    return LMChatDocumentPreview(
      media: media ?? this.media,
      style: style ?? this.style,
    );
  }

  @override
  State<LMChatDocumentPreview> createState() => _LMChatDocumentPreviewState();
}

/// The state for the DocumentFactory widget.
class _LMChatDocumentPreviewState extends State<LMChatDocumentPreview> {
  /// The list of documents to display.
  LMChatMediaModel? media;

  /// The result of the document preview.
  String? result;

  @override
  void initState() {
    super.initState();
    media = widget.media;
  }

  @override
  void didUpdateWidget(covariant LMChatDocumentPreview oldWidget) {
    super.didUpdateWidget(oldWidget);
    media = widget.media;
  }

  @override
  Widget build(BuildContext context) {
    final style = widget.style ?? LMChatDocumentPreviewStyle.basic();
    return Column(
      children: [
        Expanded(
          child: Container(
            decoration: BoxDecoration(
              color: style.backgroundColor,
              borderRadius: style.borderRadius,
            ),
            clipBehavior: Clip.hardEdge,
            padding: style.padding,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                Expanded(
                  child: LMChatDocumentThumbnail(
                    media: media!,
                    style: style.thumbnailStyle,
                  ),
                ),
                kVerticalPaddingXLarge,
              ],
            ),
          ),
        ),
      ],
    );
  }
}

///{@template lm_chat_document_tile_preview}
/// A widget that displays multiple document previews.
/// {@endtemplate}
class LMChatDocumentTilePreview extends StatefulWidget {
  /// The list of documents to display.
  final List<LMChatMediaModel> mediaList;

  /// The style for the document tile preview.
  final LMChatDocumentTilePreviewStyle? style;

  ///{@macro lm_chat_document_tile_preview}
  const LMChatDocumentTilePreview({
    super.key,
    required this.mediaList,
    this.style,
  });

  @override
  State<LMChatDocumentTilePreview> createState() =>
      LMChatDocumentTilePreviewState();
}

/// The state for the GetMultipleDocPreview widget.
class LMChatDocumentTilePreviewState extends State<LMChatDocumentTilePreview> {
  /// The list of documents to display.
  List<LMChatMediaModel>? mediaList;

  /// A notifier that triggers a rebuild of the widget.
  ValueNotifier<bool> rebuildCurr = ValueNotifier<bool>(false);

  /// The number of documents to display initially.
  int length = 2;

  /// Callback for when the "more" button is tapped.
  void onMoreButtonTap() {
    length = mediaList!.length;
    rebuildCurr.value = !rebuildCurr.value;
  }

  @override
  Widget build(BuildContext context) {
    mediaList = widget.mediaList;
    final style = widget.style ?? LMChatDocumentTilePreviewStyle.basic();
    return ValueListenableBuilder(
      valueListenable: rebuildCurr,
      builder: (context, _, __) {
        return Container(
          decoration: BoxDecoration(
            color: style.backgroundColor,
            borderRadius: style.borderRadius,
          ),
          padding: style.padding,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              ListView.builder(
                shrinkWrap: true,
                padding: EdgeInsets.zero,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: length,
                itemBuilder: (context, index) => LMChatDocumentTile(
                  media: mediaList![index],
                  style: style.tileStyle,
                ),
              ),
              mediaList!.length > 2 && mediaList!.length != length
                  ? const SizedBox(height: 8)
                  : const SizedBox(),
              mediaList!.length > 2 && mediaList!.length != length
                  ? GestureDetector(
                      onTap: onMoreButtonTap,
                      behavior: HitTestBehavior.translucent,
                      child: SizedBox(
                        width: 64,
                        height: 24,
                        child: LMChatText(
                          '+ ${mediaList!.length - 2} more',
                          style: style.moreButtonStyle ??
                              LMChatTextStyle(
                                textStyle: TextStyle(
                                  color: LMChatTheme.theme.secondaryColor,
                                  fontSize: 14,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                        ),
                      ),
                    )
                  : const SizedBox(),
            ],
          ),
        );
      },
    );
  }
}

/// Defines the style properties for the LMChatDocumentPreview widget.
class LMChatDocumentPreviewStyle {
  /// Creates an LMChatDocumentPreviewStyle instance.
  const LMChatDocumentPreviewStyle({
    this.maxWidth,
    this.maxHeight,
    this.backgroundColor,
    this.borderRadius,
    this.padding,
    this.thumbnailStyle,
    this.fileNameStyle,
    this.detailsStyle,
  });

  /// The maximum width of the preview container.
  final double? maxWidth;

  /// The maximum height of the preview container.
  final double? maxHeight;

  /// The background color of the preview container.
  final Color? backgroundColor;

  /// The border radius of the preview container.
  final BorderRadius? borderRadius;

  /// The padding of the preview container.
  final EdgeInsets? padding;

  /// The style for the document thumbnail.
  final LMChatDocumentThumbnailStyle? thumbnailStyle;

  /// The style for the file name text.
  final LMChatTextStyle? fileNameStyle;

  /// The style for the document details.
  final LMChatTextStyle? detailsStyle;

  /// Creates a basic LMChatDocumentPreviewStyle with default values.
  factory LMChatDocumentPreviewStyle.basic() {
    return LMChatDocumentPreviewStyle(
      backgroundColor: Colors.white,
      borderRadius: BorderRadius.circular(8),
      padding: const EdgeInsets.all(16),
      fileNameStyle: const LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 12,
          overflow: TextOverflow.ellipsis,
        ),
      ),
    );
  }

  /// Creates a copy of this LMChatDocumentPreviewStyle but with the given fields replaced with the new values.
  LMChatDocumentPreviewStyle copyWith({
    double? maxWidth,
    double? maxHeight,
    Color? backgroundColor,
    BorderRadius? borderRadius,
    EdgeInsets? padding,
    LMChatDocumentThumbnailStyle? thumbnailStyle,
    LMChatTextStyle? fileNameStyle,
    LMChatTextStyle? detailsStyle,
  }) {
    return LMChatDocumentPreviewStyle(
      maxWidth: maxWidth ?? this.maxWidth,
      maxHeight: maxHeight ?? this.maxHeight,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      borderRadius: borderRadius ?? this.borderRadius,
      padding: padding ?? this.padding,
      thumbnailStyle: thumbnailStyle ?? this.thumbnailStyle,
      fileNameStyle: fileNameStyle ?? this.fileNameStyle,
      detailsStyle: detailsStyle ?? this.detailsStyle,
    );
  }
}

/// Defines the style properties for the LMChatDocumentTilePreview widget.
class LMChatDocumentTilePreviewStyle {
  /// Creates an LMChatDocumentTilePreviewStyle instance.
  const LMChatDocumentTilePreviewStyle({
    this.backgroundColor,
    this.borderRadius,
    this.padding,
    this.tileStyle,
    this.moreButtonStyle,
  });

  /// The background color of the tile preview container.
  final Color? backgroundColor;

  /// The border radius of the tile preview container.
  final BorderRadius? borderRadius;

  /// The padding of the tile preview container.
  final EdgeInsets? padding;

  /// The style for individual document tiles.
  final LMChatDocumentTileStyle? tileStyle;

  /// The style for the "more" button.
  final LMChatTextStyle? moreButtonStyle;

  /// Creates a basic LMChatDocumentTilePreviewStyle with default values.
  factory LMChatDocumentTilePreviewStyle.basic() {
    return LMChatDocumentTilePreviewStyle(
      backgroundColor: Colors.white,
      borderRadius: BorderRadius.circular(8),
      padding: const EdgeInsets.all(8),
    );
  }

  /// Creates a copy of this LMChatDocumentTilePreviewStyle but with the given fields replaced with the new values.
  LMChatDocumentTilePreviewStyle copyWith({
    Color? backgroundColor,
    BorderRadius? borderRadius,
    EdgeInsets? padding,
    LMChatDocumentTileStyle? tileStyle,
    LMChatTextStyle? moreButtonStyle,
  }) {
    return LMChatDocumentTilePreviewStyle(
      backgroundColor: backgroundColor ?? this.backgroundColor,
      borderRadius: borderRadius ?? this.borderRadius,
      padding: padding ?? this.padding,
      tileStyle: tileStyle ?? this.tileStyle,
      moreButtonStyle: moreButtonStyle ?? this.moreButtonStyle,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/document/thumbnail.dart
================================================
import 'package:flutter/material.dart';
import 'dart:io';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:open_file/open_file.dart';
import 'package:pdf_render/pdf_render_widgets.dart';

///{@template lm_chat_document}
/// A widget that displays a thumbnail for a document.
/// {@endtemplate}
class LMChatDocumentThumbnail extends StatefulWidget {
  /// The document to display.
  final LMChatMediaModel media;

  /// The overlay tile widget to show on top of the thumbnail
  final LMChatDocumentTile? overlay;

  /// The style class for this thumbnail widget
  final LMChatDocumentThumbnailStyle? style;

  /// Bool to control whether to show tile overlay or not
  final bool showOverlay;

  ///{@macro lm_chat_document}
  const LMChatDocumentThumbnail({
    super.key,
    required this.media,
    this.showOverlay = false,
    this.style,
    this.overlay,
  });

  /// Creates a copy of this widget with the given parameters replaced.
  LMChatDocumentThumbnail copyWith({
    LMChatMediaModel? media,
    LMChatDocumentTile? overlay,
    LMChatDocumentThumbnailStyle? style,
    bool? showOverlay,
  }) {
    return LMChatDocumentThumbnail(
      media: media ?? this.media,
      overlay: overlay ?? this.overlay,
      style: style ?? this.style,
      showOverlay: showOverlay ?? this.showOverlay,
    );
  }

  @override
  State<LMChatDocumentThumbnail> createState() =>
      _LMChatDocumentThumbnailState();
}

/// The state for the LMChatDocumentThumbnail widget.
class _LMChatDocumentThumbnailState extends State<LMChatDocumentThumbnail> {
  /// The URL of the file.
  String? url;

  /// The file object.
  File? file;

  /// A future that loads the file.
  Future? loadedFile;

  /// The widget that displays the document file.
  Widget? documentFile;

  /// Style class for thumbnail widget
  LMChatDocumentThumbnailStyle? style;

  @override
  void initState() {
    super.initState();
    style = widget.style;
    loadedFile = loadFile();
  }

  @override
  void didUpdateWidget(LMChatDocumentThumbnail oldWidget) {
    super.didUpdateWidget(oldWidget);
    style = widget.style;
    if (oldWidget.media.mediaUrl != widget.media.mediaUrl ||
        oldWidget.media.mediaFile != widget.media.mediaFile) {
      loadedFile = loadFile();
    }
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder(
      future: loadedFile,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.done &&
            snapshot.hasData) {
          return AbsorbPointer(
            absorbing:
                widget.media.mediaUrl == null && widget.media.mediaFile == null,
            child: InkWell(
              onTap: () async {
                // get the file path and open the file
                final filePath = (snapshot.data as File).path;
                OpenFile.open(filePath, type: 'application/pdf');
              },
              child: Stack(
                children: [
                  SizedBox(
                    child: documentFile!,
                  ),
                  widget.showOverlay
                      ? widget.overlay ??
                          Positioned(
                            bottom: -2,
                            child: LMChatDocumentTile(
                              media: widget.media,
                              style: style?.overlayStyle ??
                                  LMChatDocumentTileStyle(
                                    padding: EdgeInsets.zero,
                                    width: 52.w,
                                    backgroundColor:
                                        LMChatTheme.theme.container,
                                  ),
                            ),
                          )
                      : const SizedBox.shrink(),
                ],
              ),
            ),
          );
        } else if (snapshot.connectionState == ConnectionState.waiting) {
          return LMChatDocumentShimmer(
            style: style?.shimmerStyle,
          );
        } else {
          return const SizedBox.shrink();
        }
      },
    );
  }

  /// Loads the file from the URL or local storage.
  Future loadFile() async {
    url = widget.media.mediaUrl;
    if (widget.media.mediaFile != null) {
      file = widget.media.mediaFile;
      // _fileName = basenameWithoutExtension(file!.path);
    } else {
      final String url = widget.media.mediaUrl!;
      // _fileName = basenameWithoutExtension(url);
      final path = await downloadFile(fileUrl: url);
      file = File(path);
    }

    // _fileSize = getFileSizeString(bytes: widget.media.size ?? 0);
    documentFile = PdfDocumentLoader.openFile(
      file!.path,
      pageNumber: 1,
      pageBuilder: (context, textureBuilder, pageSize) => SizedBox(
        child: Container(
          height: style?.height,
          width: style?.width,
          clipBehavior: Clip.hardEdge,
          padding: style?.padding,
          decoration: BoxDecoration(
            borderRadius: style?.borderRadius ??
                const BorderRadius.all(
                  Radius.circular(kBorderRadiusMedium),
                ),
          ),
          child: FittedBox(
            fit: BoxFit.fitWidth,
            child: textureBuilder(
              allowAntialiasingIOS: true,
              backgroundFill: true,
              size: Size(pageSize.width, pageSize.height),
            ),
          ),
        ),
      ),
    );
    return file;
  }
}

/// Defines the style properties for a document tile in the LMChat UI.
class LMChatDocumentThumbnailStyle {
  /// The height of the document thumbnail.
  final double? height;

  /// The width of the document thumbnail.
  final double? width;

  /// The border of the document thumbnail.
  final Border? border;

  /// The border radius of the document thumbnail.
  final BorderRadius? borderRadius;

  /// The padding of the document thumbnail.
  final EdgeInsets? padding;

  /// The background color of the document thumbnail.
  final Color? backgroundColor;

  /// The style for the overlay document thumbnail style
  final LMChatDocumentTileStyle? overlayStyle;

  /// The style for the shimmer widget shown
  final LMChatDocumentShimmerStyle? shimmerStyle;

  /// Constructor for LMChatDocumentThumbnailStyle.
  LMChatDocumentThumbnailStyle({
    this.height,
    this.width,
    this.border,
    this.borderRadius,
    this.padding,
    this.backgroundColor,
    this.overlayStyle,
    this.shimmerStyle,
  });

  /// Creates a copy of the current style with the given parameters.
  LMChatDocumentThumbnailStyle copyWith({
    double? height,
    double? width,
    Border? border,
    BorderRadius? borderRadius,
    EdgeInsets? padding,
    Color? backgroundColor,
    LMChatDocumentTileStyle? overlayStyle,
    LMChatDocumentShimmerStyle? shimmerStyle,
  }) {
    return LMChatDocumentThumbnailStyle(
      height: height ?? this.height,
      width: width ?? this.width,
      border: border ?? this.border,
      borderRadius: borderRadius ?? this.borderRadius,
      padding: padding ?? this.padding,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      overlayStyle: overlayStyle ?? this.overlayStyle,
      shimmerStyle: shimmerStyle ?? this.shimmerStyle,
    );
  }

  /// A factory constructor that returns a basic instance of [LMChatDocumentThumbnailStyle].
  factory LMChatDocumentThumbnailStyle.basic() {
    return LMChatDocumentThumbnailStyle(
      height: 100.0,
      width: 100.0,
      border: Border.all(color: Colors.grey),
      borderRadius: BorderRadius.circular(8.0),
      padding: const EdgeInsets.all(8.0),
      backgroundColor: Colors.white,
      overlayStyle: LMChatDocumentTileStyle.basic(),
      shimmerStyle: LMChatDocumentShimmerStyle.basic(),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/media/document/tile.dart
================================================
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:open_file/open_file.dart';
import 'package:path/path.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

///{@template lm_chat_document_tile}
/// A widget that displays a tile for a document.
///{@endtemplate}
class LMChatDocumentTile extends StatefulWidget {
  /// The document to display.
  final LMChatMediaModel media;

  /// The title of the document.
  final Widget? title;

  /// The subtitle of the document.
  final Widget? subtitle;

  /// The icon to display for the document.
  final Widget? documentIcon;

  /// The style for the document tile.
  final LMChatDocumentTileStyle? style;

  ///{@macro lm_chat_document_tile}
  const LMChatDocumentTile({
    super.key,
    required this.media,
    this.style,
    this.title,
    this.subtitle,
    this.documentIcon,
  });

  /// Creates a copy of this widget with the given parameters replaced.
  LMChatDocumentTile copyWith({
    LMChatMediaModel? media,
    Widget? title,
    Widget? subtitle,
    Widget? documentIcon,
    LMChatDocumentTileStyle? style,
  }) {
    return LMChatDocumentTile(
      media: media ?? this.media,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      documentIcon: documentIcon ?? this.documentIcon,
      style: style ?? this.style,
    );
  }

  @override
  State<LMChatDocumentTile> createState() => _LMChatDocumentTileState();
}

/// The state for the LMChatDocumentTile widget.
class _LMChatDocumentTileState extends State<LMChatDocumentTile> {
  /// The name of the file.
  String? _fileName;

  /// The extension of the file.
  final String _fileExtension = 'pdf';

  /// The size of the file.
  String? _fileSize;

  /// A future that loads the file.
  Future? loadedFile;

  late LMChatDocumentTileStyle style;

  /// Loads the file from the URL or local storage.
  Future loadFile() async {
    File file;
    if (widget.media.mediaFile != null) {
      file = widget.media.mediaFile!;
    } else {
      final String path = await downloadFile(media: widget.media);
      file = File(path);
    }
    _fileSize = getFileSizeString(
        bytes: widget.media.size ?? widget.media.meta?['size'] ?? 0);
    _fileName = basenameWithoutExtension(file.path);
    return file;
  }

  @override
  void initState() {
    super.initState();
    loadedFile = loadFile();
    style = widget.style ?? LMChatDocumentTileStyle();
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder(
        future: loadedFile,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.done &&
              snapshot.hasData) {
            return InkWell(
              onTap: () async {
                // get the file path and open the file
                final filePath = (snapshot.data as File).path;
                OpenFile.open(filePath, type: 'application/pdf');
              },
              child: Padding(
                padding: const EdgeInsets.symmetric(
                  vertical: kPaddingXSmall,
                ),
                child: Container(
                  height: style.height ?? 60,
                  width: style.width ?? 55.w,
                  decoration: BoxDecoration(
                    border: Border.all(color: LMChatDefaultTheme.greyColor),
                    borderRadius: BorderRadius.circular(kBorderRadiusMedium),
                    color: LMChatTheme.theme.container,
                  ),
                  child: Padding(
                    padding: style.padding ??
                        const EdgeInsets.symmetric(
                          vertical: 0,
                          horizontal: kPaddingXSmall,
                        ),
                    child: Row(
                      mainAxisAlignment: style.rowMainAxisAlignment ??
                          MainAxisAlignment.center,
                      children: [
                        kHorizontalPaddingMedium,
                        widget.documentIcon ?? _defaultDocumentIcon(),
                        kHorizontalPaddingMedium,
                        Expanded(
                          child: Column(
                            crossAxisAlignment: style.crossAxisAlignment ??
                                CrossAxisAlignment.start,
                            mainAxisAlignment: style.mainAxisAlignment ??
                                MainAxisAlignment.center,
                            children: [
                              widget.title ?? _defaultTitle(),
                              kVerticalPaddingSmall,
                              widget.subtitle ?? _defaultSubtitle()
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          } else {
            return LMChatDocumentShimmer(style: style.shimmerStyle);
          }
        });
  }

  Row _defaultSubtitle() {
    return Row(
      children: [
        widget.media.pageCount != null
            ? Row(
                children: <Widget>[
                  widget.media.pageCount == null
                      ? const SizedBox()
                      : kHorizontalPaddingXSmall,
                  widget.media.pageCount == null
                      ? const SizedBox()
                      : LMChatText(
                          "${widget.media.pageCount!} ${widget.media.pageCount! > 1 ? "Pages" : "Page"}",
                          style: style.subtitleStyle ??
                              const LMChatTextStyle(
                                textStyle: TextStyle(
                                  fontSize: 10,
                                  color: LMChatDefaultTheme.greyColor,
                                ),
                              ),
                        ),
                  kHorizontalPaddingXSmall,
                  LMChatText(
                    '·',
                    style: style.subtitleStyle ??
                        const LMChatTextStyle(
                          textStyle: TextStyle(
                            fontSize: 10,
                            color: LMChatDefaultTheme.greyColor,
                          ),
                        ),
                  ),
                ],
              )
            : const SizedBox(),
        kHorizontalPaddingXSmall,
        LMChatText(
          _fileSize!.toUpperCase(),
          style: style.subtitleStyle ??
              const LMChatTextStyle(
                textStyle: TextStyle(
                  fontSize: 10,
                  color: LMChatDefaultTheme.greyColor,
                ),
              ),
        ),
        kHorizontalPaddingXSmall,
        LMChatText(
          '·',
          style: style.subtitleStyle ??
              const LMChatTextStyle(
                textStyle: TextStyle(
                  fontSize: 10,
                  color: LMChatDefaultTheme.greyColor,
                ),
              ),
        ),
        kHorizontalPaddingXSmall,
        LMChatText(
          _fileExtension.toUpperCase(),
          style: style.subtitleStyle ??
              const LMChatTextStyle(
                textStyle: TextStyle(
                  fontSize: 10,
                  color: LMChatDefaultTheme.greyColor,
                ),
              ),
        ),
      ],
    );
  }

  LMChatText _defaultTitle() {
    return LMChatText(
      _fileName ?? '',
      style: style.titleStyle ??
          const LMChatTextStyle(
            textStyle: TextStyle(
              fontSize: 12,
              color: LMChatDefaultTheme.greyColor,
              overflow: TextOverflow.ellipsis,
            ),
          ),
    );
  }

  LMChatIcon _defaultDocumentIcon() {
    return LMChatIcon(
      type: LMChatIconType.svg,
      assetPath: kDocumentIcon,
      style: style.iconStyle ??
          LMChatIconStyle(
            size: 28,
            boxSize: 32,
            boxPadding: EdgeInsets.zero,
            color: style.iconColor,
          ),
    );
  }
}

/// Defines the style properties for a document tile in the LMChat UI.
class LMChatDocumentTileStyle {
  /// The height of the document tile.
  final double? height;

  /// The width of the document tile.
  final double? width;

  /// The border of the document tile.
  final Border? border;

  /// The border radius of the document tile.
  final BorderRadius? borderRadius;

  /// The cross-axis alignment of the document tile's content.
  final CrossAxisAlignment? crossAxisAlignment;

  /// The main-axis alignment of the document tile's content.
  final MainAxisAlignment? mainAxisAlignment;

  /// The main-axis alignment of the row within the document tile.
  final MainAxisAlignment? rowMainAxisAlignment;

  /// The padding of the document tile.
  final EdgeInsets? padding;

  /// The background color of the document tile.
  final Color? backgroundColor;

  /// The color of the icon in the document tile.
  final Color? iconColor;

  /// The color of the text in the document tile.
  final Color? textColor;

  /// The style for the document icon in the document tile.
  final LMChatIconStyle? iconStyle;

  /// The style for the title text in the document tile.
  final LMChatTextStyle? titleStyle;

  /// The style for the subtitle text in the document tile.
  final LMChatTextStyle? subtitleStyle;

  /// The style class for the shimmer shown while loading
  final LMChatDocumentShimmerStyle? shimmerStyle;

  /// Constructor for LMChatDocumentTileStyle.
  LMChatDocumentTileStyle({
    this.height,
    this.width,
    this.border,
    this.borderRadius,
    this.crossAxisAlignment,
    this.mainAxisAlignment,
    this.rowMainAxisAlignment,
    this.padding,
    this.backgroundColor,
    this.iconColor,
    this.iconStyle,
    this.textColor,
    this.titleStyle,
    this.subtitleStyle,
    this.shimmerStyle,
  });

  /// Creates a copy of the current style with the given parameters.
  LMChatDocumentTileStyle copyWith({
    double? height,
    double? width,
    Border? border,
    BorderRadius? borderRadius,
    CrossAxisAlignment? crossAxisAlignment,
    MainAxisAlignment? mainAxisAlignment,
    MainAxisAlignment? rowMainAxisAlignment,
    EdgeInsets? padding,
    Color? backgroundColor,
    Color? iconColor,
    LMChatIconStyle? iconStyle,
    Color? textColor,
    LMChatTextStyle? titleStyle,
    LMChatTextStyle? subtitleStyle,
    LMChatDocumentShimmerStyle? shimmerStyle,
  }) {
    return LMChatDocumentTileStyle(
      height: height ?? this.height,
      width: width ?? this.width,
      border: border ?? this.border,
      borderRadius: borderRadius ?? this.borderRadius,
      crossAxisAlignment: crossAxisAlignment ?? this.crossAxisAlignment,
      mainAxisAlignment: mainAxisAlignment ?? this.mainAxisAlignment,
      rowMainAxisAlignment: rowMainAxisAlignment ?? this.rowMainAxisAlignment,
      padding: padding ?? this.padding,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      iconColor: iconColor ?? this.iconColor,
      iconStyle: iconStyle ?? this.iconStyle,
      textColor: textColor ?? this.textColor,
      titleStyle: titleStyle ?? this.titleStyle,
      subtitleStyle: subtitleStyle ?? this.subtitleStyle,
      shimmerStyle: shimmerStyle ?? this.shimmerStyle,
    );
  }

  /// A factory constructor that returns a basic instance of [LMChatDocumentTileStyle].
  factory LMChatDocumentTileStyle.basic() {
    return LMChatDocumentTileStyle(
      height: 100.0,
      width: 100.0,
      border: Border.all(color: Colors.grey),
      borderRadius: BorderRadius.circular(8.0),
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisAlignment: MainAxisAlignment.start,
      rowMainAxisAlignment: MainAxisAlignment.start,
      padding: const EdgeInsets.all(8.0),
      backgroundColor: Colors.white,
      iconColor: Colors.black,
      textColor: Colors.black,
      titleStyle: LMChatTextStyle.basic(),
      subtitleStyle: LMChatTextStyle.basic(),
      shimmerStyle: LMChatDocumentShimmerStyle.basic(),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/paginated_list/dual_side_paginated_list.dart
================================================
import 'dart:async';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/paginated_list/pagination_controller.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/paginated_list/pagination_utils.dart';
import 'package:super_sliver_list/super_sliver_list.dart';

/// {@template lm_dual_side_paged_list}
/// A widget that displays a list of items that can be paginated from both sides.
/// {@endtemplate}

class LMDualSidePagedList<T> extends StatefulWidget {
  /// The callback function triggered when pagination conditions are satisfied
  final Future<void> Function(
    int page,
    LMPaginationDirection paginationDirection,
    T? item,
  ) onPaginationTriggered;

  /// The function to build a widget for an item in the list.
  final ItemBuilder<T> itemBuilder;

  /// The builder for the first page's error indicator.
  final WidgetBuilder? firstPageErrorIndicatorBuilder;

  /// The builder for a new page's error indicator.
  final WidgetBuilder? newPageErrorIndicatorBuilder;

  /// The builder for the first page's progress indicator.
  final WidgetBuilder? firstPageProgressIndicatorBuilder;

  /// The builder for a new page's progress indicator.
  final WidgetBuilder? newPageProgressIndicatorBuilder;

  /// The builder for a no items list indicator.
  final WidgetBuilder? noItemsFoundIndicatorBuilder;

  /// The builder for an indicator that all items have been fetched.
  final WidgetBuilder? noMoreItemsIndicatorBuilder;

  /// The initial page to load.
  final int initialPage;

  /// The pagination controller to manage the pagination.
  final LMDualSidePaginationController<T> paginationController;

  /// The axis along which the scroll view scrolls.
  final Axis? scrollDirection;

  /// Whether the scroll view scrolls in the reverse direction.
  final bool? reverse;

  /// Whether this is the primary scroll view associated with the parent.
  final bool? primary;

  /// The physics for the scroll view's scrolling behavior.
  final ScrollPhysics? physics;

  /// Whether the extent of the scroll view should be shrink-wrapped.
  final bool? shrinkWrap;

  /// The amount of space by which to inset the children.
  final EdgeInsetsGeometry? padding;

  /// A callback to find the index of a child.
  final ChildIndexGetter? findChildIndexCallback;

  /// Whether to add automatic keep-alives to children.
  final bool? addAutomaticKeepAlives;

  /// Whether to add repaint boundaries to children.
  final bool? addRepaintBoundaries;

  /// Whether to add semantic indexes to children.
  final bool? addSemanticIndexes;

  /// The amount of space to cache before and after the visible area.
  final double? cacheExtent;

  /// The number of children that contribute to the semantics tree.
  final int? semanticChildCount;

  /// The drag start behavior for the scroll view.
  final DragStartBehavior? dragStartBehavior;

  /// The behavior for dismissing the keyboard when scrolling.
  final ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;

  /// The restoration ID to save and restore the scroll view's state.
  final String? restorationId;

  /// The clip behavior for the scroll view.
  final Clip? clipBehavior;

  /// Provides an estimation of the extent of the scroll view.
  final ExtentEstimationProvider? extentEstimation;

  /// The policy for pre-calculating the extent of the scroll view.
  final ExtentPrecalculationPolicy? extentPrecalculationPolicy;

  /// Whether to delay populating the cache area.
  final bool? delayPopulatingCacheArea;

  /// Pagination type
  final LMPaginationType paginationType;

  /// {@macro lm_dual_side_paged_list}
  const LMDualSidePagedList({
    super.key,
    required this.onPaginationTriggered,
    required this.itemBuilder,
    this.firstPageProgressIndicatorBuilder,
    this.newPageProgressIndicatorBuilder,
    this.noItemsFoundIndicatorBuilder,
    this.noMoreItemsIndicatorBuilder,
    this.firstPageErrorIndicatorBuilder,
    this.newPageErrorIndicatorBuilder,
    required this.initialPage,
    required this.paginationController,
    this.scrollDirection,
    this.reverse,
    this.primary,
    this.physics,
    this.shrinkWrap,
    this.padding,
    this.findChildIndexCallback,
    this.addAutomaticKeepAlives,
    this.addRepaintBoundaries,
    this.addSemanticIndexes,
    this.cacheExtent,
    this.semanticChildCount,
    this.dragStartBehavior,
    this.keyboardDismissBehavior,
    this.restorationId,
    this.clipBehavior,
    this.extentEstimation,
    this.extentPrecalculationPolicy,
    this.delayPopulatingCacheArea,
    this.paginationType = LMPaginationType.both,
  });

  @override
  State<LMDualSidePagedList<T>> createState() => _LMDualSidePagedListState<T>();
}

class _LMDualSidePagedListState<T> extends State<LMDualSidePagedList<T>> {
  late int _currentPage; // Starting page
  late int _upSidePage;
  late int _downSidePage;
  bool _isLoadingFirstPage = true;
  bool _hasError = false;
  bool _paginationError = false;

  @override
  void initState() {
    super.initState();
    _currentPage = widget.initialPage;
    _upSidePage = _currentPage;
    _downSidePage = _currentPage;
    _loadInitialData();
    widget.paginationController.isFirstPageLoadedController.stream
        .listen((event) {
      if (event) {
        setState(() {
          _isLoadingFirstPage = false;
        });
      }
    });
    widget.paginationController.upSidePage.stream.listen((event) {
      _upSidePage = event;
    });
    widget.paginationController.downSidePage.stream.listen((event) {
      _downSidePage = event;
    });

    Timer? debounce;
    widget.paginationController.scrollController.addListener(() {
      // add listener to hit _loadMoreTop() when hitting top of the scroll view
      if (widget.paginationController.scrollController.position.pixels == 0) {
        if (debounce?.isActive ?? false) debounce?.cancel();
        debounce = Timer(const Duration(milliseconds: 200), () {
          _loadMoreTop();
        });
      }
    });
  }

  Future<void> _loadInitialData() async {
    try {
      await widget.onPaginationTriggered(
        _currentPage,
        LMPaginationDirection.top,
        null,
      );
    } catch (e) {
      if (mounted) {
        setState(() {
          _hasError = true;
          _isLoadingFirstPage = false;
        });
      }
    }
  }

  Future<void> _loadMoreTop() async {
    // check if last page is reached
    if (widget.paginationController.isLastPageToTopReached) {
      return;
    }
    // Check if type only allows bottom pagination
    if (widget.paginationType == LMPaginationType.top) {
      return;
    }
    if (widget.paginationController.isLoadingTop) {
      return; // Prevent multiple calls
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      setState(() {
        widget.paginationController.isLoadingTop = true;
      });
    });

    try {
      await widget.onPaginationTriggered(
        _upSidePage,
        LMPaginationDirection.bottom,
        widget.paginationController.itemList.first,
      );
    } catch (e) {
      setState(() {
        _paginationError = true;
      });
    }
  }

  Future<void> _loadMoreBottom() async {
    // check if last page is reached
    if (widget.paginationController.isLastPageToBottomReached) {
      return;
    }
    // Check if type only allows top pagination
    if (widget.paginationType == LMPaginationType.bottom) {
      return;
    }
    if (widget.paginationController.isLoadingBottom) {
      return; // Prevent multiple calls
    }

    setState(() {
      widget.paginationController.isLoadingBottom = true;
    });

    try {
      await widget.onPaginationTriggered(
        _downSidePage,
        LMPaginationDirection.top,
        widget.paginationController.itemList.last,
      );
    } catch (e) {
      setState(() {
        _paginationError = true;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoadingFirstPage) {
      return widget.firstPageProgressIndicatorBuilder?.call(context) ??
          const Center(child: CircularProgressIndicator());
    }

    if (_hasError) {
      return widget.firstPageErrorIndicatorBuilder?.call(context) ??
          const Center(child: Text("An error occurred"));
    }
    final items = widget.paginationController.itemList;

    if (items.isEmpty) {
      return widget.noItemsFoundIndicatorBuilder?.call(context) ??
          const Center(child: Text("No items found"));
    }

    return ValueListenableBuilder(
        valueListenable: widget.paginationController.isScrollingNotifier,
        builder: (context, _, __) {
          return _listBuilder(items);
        });
  }

  SuperListView _listBuilder(List<dynamic> items) {
    return SuperListView.builder(
      key: const ObjectKey("dual_side_paged_list"),
      scrollDirection: widget.scrollDirection ?? Axis.vertical,
      primary: widget.primary,
      physics: widget.physics,
      shrinkWrap: widget.shrinkWrap ?? false,
      padding: widget.padding,
      findChildIndexCallback: widget.findChildIndexCallback,
      addAutomaticKeepAlives: widget.addAutomaticKeepAlives ?? true,
      addRepaintBoundaries: widget.addRepaintBoundaries ?? true,
      addSemanticIndexes: widget.addSemanticIndexes ?? true,
      cacheExtent: widget.cacheExtent,
      semanticChildCount: widget.semanticChildCount,
      dragStartBehavior: widget.dragStartBehavior ?? DragStartBehavior.start,
      keyboardDismissBehavior: widget.keyboardDismissBehavior ??
          ScrollViewKeyboardDismissBehavior.manual,
      restorationId: widget.restorationId,
      clipBehavior: widget.clipBehavior ?? Clip.hardEdge,
      extentEstimation: widget.extentEstimation,
      extentPrecalculationPolicy: widget.extentPrecalculationPolicy,
      delayPopulatingCacheArea: widget.delayPopulatingCacheArea ?? false,
      controller: widget.paginationController.scrollController,
      listController: widget.paginationController.listController,
      reverse: widget.reverse ?? false,
      itemCount: items.length +
          (widget.paginationController.isLoadingBottom ? 1 : 0) +
          (widget.paginationController.isLoadingTop ? 1 : 0),
      itemBuilder: (context, index) {
        // // Trigger _loadMoreTop() when the first item is being built
        // if (index == 0 && !widget.paginationController.isLoadingTop) {
        //   SchedulerBinding.instance.addPostFrameCallback((_) {
        //     _loadMoreTop();
        //   });
        // }
        if (index == 0 && widget.paginationController.isLoadingTop) {
          return widget.newPageProgressIndicatorBuilder?.call(context) ??
              const Padding(
                padding: EdgeInsets.all(8.0),
                child: Center(
                  child: CircularProgressIndicator(),
                ),
              );
        }
        if (widget.paginationController.isLoadingBottom &&
            index == items.length) {
          return widget.newPageProgressIndicatorBuilder?.call(context) ??
              const Padding(
                padding: EdgeInsets.all(8.0),
                child: Center(
                  child: CircularProgressIndicator(),
                ),
              );
        }

        final actualIndex =
            widget.paginationController.isLoadingTop ? index - 1 : index;

        // Trigger _loadMoreBottom() when the last item is being built
        if (actualIndex == items.length - 3 &&
            !widget.paginationController.isLoadingBottom) {
          SchedulerBinding.instance.addPostFrameCallback((_) {
            _loadMoreBottom();
          });
        }
        if (actualIndex < items.length) {
          return widget.itemBuilder(context, items[actualIndex], actualIndex);
        }
        return null;
      },
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/paginated_list/pagination_controller.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:super_sliver_list/super_sliver_list.dart';

/// {@template lm_chat_pagination_controller}
/// A helper class to manage pagination for a list of items.
/// it is used in the [LMDualSidePagedList] widget.
/// {@endtemplate}
class LMDualSidePaginationController<T> {
  final StreamController<bool> isFirstPageLoadedController =
      StreamController<bool>();
  final StreamController<int> upSidePage = StreamController<int>();
  final StreamController<int> downSidePage = StreamController<int>();

  /// The list of items that have been loaded so far.
  List<T> itemList = [];

  final ListController _listController;
  final ScrollController _scrollController;

  /// Whether the top page is loading.
  bool isLoadingTop = false;

  /// Whether the bottom page is loading.
  bool isLoadingBottom = false;

  /// Whether the last page has been reached.
  bool isLastPageToBottomReached = false;

  /// Whether the first page has been reached.
  bool isLastPageToTopReached = false;

  /// The list controller to control the list view.
  ListController get listController => _listController;

  /// The scroll controller to control the scroll view.
  ScrollController get scrollController => _scrollController;

  final ValueNotifier<bool> isScrollingNotifier = ValueNotifier(false);

  /// Creates a new instance of [LMDualSidePaginationController].
  LMDualSidePaginationController({
    required ListController listController,
    required ScrollController scrollController,
  })  : _listController = listController,
        _scrollController = scrollController;

  /// Appends [newItems] to the previously loaded ones and replaces
  /// the next page's key.
  void appendPageToEnd(List<T> newItems, int? nextPageKey) {
    if (nextPageKey == null) {
      isLastPageToBottomReached = true;
    }
    isFirstPageLoadedController.add(true);
    downSidePage.add(nextPageKey ?? 0);
    itemList.addAll([...newItems]);
    isLoadingBottom = false;
  }

  /// Appends [newItems] to the previously loaded ones and sets the next page
  /// key to `null`.
  void appendLastPageToEnd(List<T> newItems) => appendPageToEnd(newItems, null);

  /// Prepends [newItems] to the previously loaded ones and replaces
  /// the previous page's key.
  void appendPageToStart(List<T> newItems, int? previousPageKey) {
    if (previousPageKey == null) {
      isLastPageToTopReached = true;
    }

    upSidePage.add(previousPageKey ?? 0);
    itemList.insertAll(0, [...newItems]);
    isLoadingTop = false;
    SchedulerBinding.instance.addPostFrameCallback((_) {
      // isLoadingTop = true;
      try {
        listController.jumpToItem(
          index: newItems.length,
          scrollController: scrollController,
          alignment: 0.0,
        );
      } on Exception catch (e) {
        debugPrint(e.toString());
      }
      isScrollingNotifier.value = !isScrollingNotifier.value;
    });
    // isLoadingTop = false;
    // isScrollingNotifier.value = !isScrollingNotifier.value;
  }

  /// Prepends [newItems] to the previously loaded ones and sets the previous
  /// page key to `null`.
  void appendFirstPageToStart(List<T> newItems) =>
      appendPageToStart(newItems, null);

  /// clears the list of items.
  /// This is useful when you want to reset the list.
  /// For example, when you want to load a new list of items.
  void clear() {
    itemList = [];
    upSidePage.add(0);
    downSidePage.add(0);
    isLastPageToBottomReached = false;
    isLastPageToTopReached = false;
  }

  /// Appends [newItems] to the previously loaded ones.
  void addAll(List<T> newItems) {
    itemList.addAll(newItems);
    upSidePage.add(2);
    downSidePage.add(2);
    isLoadingBottom = false;
    isLoadingTop = false;
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/paginated_list/pagination_utils.dart
================================================
import 'package:flutter/material.dart';

/// {@template lm_dual_side_paged_list_item_builder}
/// A builder function that builds a widget for an item in the list.
/// The [context] is the build context.
/// The [item] is the item to build the widget for.
/// The [index] is the index of the item in the list.
/// {@endtemplate}
typedef ItemBuilder<T> = Widget Function(
    BuildContext context, T item, int index);

/// enum to represent the direction of pagination
enum LMPaginationDirection {
  /// bottom side pagination, if reversed is true.
  bottom,

  /// bottom side pagination, if reversed is true.
  top,
}

/// enum to represent the direction in which pagination call will be triggered
enum LMPaginationType {
  /// trigger pagination when the user scrolls to the bottom of the list, if reversed is true.
  bottom,

  /// trigger pagination when the user scrolls to the top of the list, if reversed is true.
  top,

  /// trigger pagination when the user scrolls to the top or bottom of the list
  both,
}



================================================
File: lib/packages/ui/lib/src/widgets/poll/poll.dart
================================================

import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:likeminds_chat_flutter_ui/packages/expandable_text/expandable_text.dart';

part './poll_utils.dart';

/// {@template lm_chat_poll}
/// A widget that represents a poll in the LM Chat application.
///
/// This widget is a stateful widget that allows users to interact with
/// and participate in polls within the chat interface.
///
/// The `LMChatPoll` widget is designed to be used within the chat UI
/// and provides functionality for displaying poll options and handling
/// user input.
///
/// See also:
/// - [StatefulWidget], which is the base class for widgets that have mutable state.
/// - [LMChatPollState], which contains the state logic for this widget.
/// {@endtemplate}
class LMChatPoll extends StatefulWidget {
  /// {@macro lm_chat_poll}
  const LMChatPoll({
    super.key,
    required this.pollData,
    this.rebuildPollWidget,
    this.onEditVote,
    this.style,
    this.onOptionSelect,
    this.isVoteEditing = false,
    this.selectedOption = const [],
    this.onAddOptionSubmit,
    this.onVoteClick,
    this.onSubmit,
    this.onAnswerTextTap,
    this.pollQuestionBuilder,
    this.pollOptionBuilder,
    this.pollSelectionTextBuilder,
    this.addOptionButtonBuilder,
    this.submitButtonBuilder,
    this.editButtonBuilder,
    this.subTextBuilder,
    this.pollTypeTextBuilder,
    this.pollHeaderSeparatorBuilder,
    this.votingTypeTextBuilder,
    this.pollIconBuilder,
    this.timeLeftTextBuilder,
  });

  /// [ValueNotifier] to rebuild the poll widget
  final ValueNotifier<bool>? rebuildPollWidget;

  /// [LMChatPollViewData] to be displayed in the poll
  final LMChatConversationViewData pollData;

  /// Callback when the edit vote button is clicked
  final Function(LMChatConversationViewData)? onEditVote;

  /// [LMChatPollStyle] Style for the poll
  final LMChatPollStyle? style;

  /// Callback when an option is selected
  final void Function(LMChatPollOptionViewData)? onOptionSelect;

  /// [bool] to show is poll votes are being edited
  final bool isVoteEditing;

  /// [List<int>] selected option
  final List<int> selectedOption;

  /// Callback when the add option is submitted
  final void Function(String option)? onAddOptionSubmit;

  /// Callback when the vote is clicked
  final Function(LMChatPollOptionViewData)? onVoteClick;

  /// Callback when the submit button is clicked
  final Function(List<LMChatPollOptionViewData> selectedOption)? onSubmit;

  /// Callback when the subtext is clicked
  final VoidCallback? onAnswerTextTap;

  /// A builder function for creating a custom widget to display poll type text.
  ///
  /// The function takes a [BuildContext] and an optional [LMChatText] as parameters.
  ///
  /// - [context]: The build context in which the widget is built.
  /// - [pollTypeText]: An optional [LMChatText] object containing the poll type text.
  final Widget Function(BuildContext, LMChatText)? pollTypeTextBuilder;

  /// A builder function for creating a custom widget to display a separator in the poll header.
  ///
  /// The function takes a [BuildContext] as a parameter.
  ///
  /// - [context]: The build context in which the widget is built.
  final Widget Function(BuildContext)? pollHeaderSeparatorBuilder;

  /// A builder function for creating a custom widget to display voting type text.
  ///
  /// The function takes a [BuildContext] and an optional [LMChatText] as parameters.
  ///
  /// - [context]: The build context in which the widget is built.
  /// - [votingTypeText]: An optional [LMChatText] object containing the voting type text.
  final Widget Function(BuildContext, LMChatText)? votingTypeTextBuilder;

  /// A builder function for creating a custom widget to display a poll icon.
  ///
  /// The function takes a [BuildContext] and an optional [LMChatIcon] as parameters.
  ///
  /// - [context]: The build context in which the widget is built.
  /// - [pollIcon]: An optional [LMChatIcon] object containing the poll icon.
  final Widget Function(BuildContext, LMChatIcon)? pollIconBuilder;

  /// A builder function for creating a custom widget to display the time left for the poll.
  ///
  /// The function takes a [BuildContext] and an optional [LMChatText] as parameters.
  ///
  /// - [context]: The build context in which the widget is built.
  /// - [timeLeftText]: An optional [LMChatText] object containing the time left text.
  final Widget Function(BuildContext, LMChatText?)? timeLeftTextBuilder;

  /// [Widget Function(BuildContext)] Builder for the poll question
  final Widget Function(BuildContext, LMChatExpandableText)?
      pollQuestionBuilder;

  /// [Widget Function(BuildContext)] Builder for the poll selection text
  final Widget Function(BuildContext, LMChatText)? pollSelectionTextBuilder;

  /// [Widget Function(BuildContext)] Builder for the poll option
  final Widget Function(
    BuildContext,
    LMChatPollOption,
    LMChatPollOptionViewData,
  )? pollOptionBuilder;

  /// [Widget Function(BuildContext, LMChatButton,  Function(String))] Builder for the add option button
  final Widget Function(BuildContext, LMChatButton, Function(String))?
      addOptionButtonBuilder;

  /// [LMChatButtonBuilder] Builder for the submit button
  final LMChatButtonBuilder? submitButtonBuilder;

  /// [LMChatButtonBuilder] Builder for the edit button
  final LMChatButtonBuilder? editButtonBuilder;

  /// [Widget Function(BuildContext)] Builder for the subtext
  final Widget Function(BuildContext, LMChatText)? subTextBuilder;

  /// copyWith method for the LMChatPoll
  /// Returns a new instance of LMChatPoll with the updated values
  /// The values that are not updated remain the same
  LMChatPoll copyWith({
    ValueNotifier<bool>? rebuildPollWidget,
    LMChatConversationViewData? pollData,
    Function(LMChatConversationViewData)? onEditVote,
    LMChatPollStyle? style,
    void Function(LMChatPollOptionViewData)? onOptionSelect,
    bool? isVoteEditing,
    List<int>? selectedOption,
    void Function(String option)? onAddOptionSubmit,
    Function(LMChatPollOptionViewData)? onVoteClick,
    Function(List<LMChatPollOptionViewData> selectedOption)? onSubmit,
    VoidCallback? onAnswerTextTap,
    Widget Function(BuildContext, LMChatText)? pollTypeTextBuilder,
    Widget Function(BuildContext)? pollHeaderSeparatorBuilder,
    Widget Function(BuildContext, LMChatText)? voteTypeTextBuilder,
    Widget Function(BuildContext, LMChatIcon)? pollIconBuilder,
    Widget Function(BuildContext, LMChatText?)? timeLeftTextBuilder,
    Widget Function(BuildContext, LMChatExpandableText)? pollQuestionBuilder,
    Widget Function(BuildContext, LMChatText)? pollSelectionTextBuilder,
    Widget Function(
      BuildContext,
      LMChatPollOption,
      LMChatPollOptionViewData,
    )? pollOptionBuilder,
    Widget Function(BuildContext, LMChatButton, Function(String))?
        addOptionButtonBuilder,
    LMChatButtonBuilder? submitButtonBuilder,
    LMChatButtonBuilder? editButtonBuilder,
    Widget Function(BuildContext, LMChatText)? subTextBuilder,
  }) {
    return LMChatPoll(
      rebuildPollWidget: rebuildPollWidget ?? this.rebuildPollWidget,
      pollData: pollData ?? this.pollData,
      onEditVote: onEditVote ?? this.onEditVote,
      style: style ?? this.style,
      onOptionSelect: onOptionSelect ?? this.onOptionSelect,
      isVoteEditing: isVoteEditing ?? this.isVoteEditing,
      selectedOption: selectedOption ?? this.selectedOption,
      onAddOptionSubmit: onAddOptionSubmit ?? this.onAddOptionSubmit,
      onVoteClick: onVoteClick ?? this.onVoteClick,
      onSubmit: onSubmit ?? this.onSubmit,
      onAnswerTextTap: onAnswerTextTap ?? this.onAnswerTextTap,
      pollTypeTextBuilder: pollTypeTextBuilder ?? this.pollTypeTextBuilder,
      pollHeaderSeparatorBuilder:
          pollHeaderSeparatorBuilder ?? this.pollHeaderSeparatorBuilder,
      votingTypeTextBuilder: voteTypeTextBuilder ?? this.votingTypeTextBuilder,
      pollIconBuilder: pollIconBuilder ?? this.pollIconBuilder,
      timeLeftTextBuilder: timeLeftTextBuilder ?? this.timeLeftTextBuilder,
      pollQuestionBuilder: pollQuestionBuilder ?? this.pollQuestionBuilder,
      pollSelectionTextBuilder:
          pollSelectionTextBuilder ?? this.pollSelectionTextBuilder,
      pollOptionBuilder: pollOptionBuilder ?? this.pollOptionBuilder,
      addOptionButtonBuilder:
          addOptionButtonBuilder ?? this.addOptionButtonBuilder,
      submitButtonBuilder: submitButtonBuilder ?? this.submitButtonBuilder,
      editButtonBuilder: editButtonBuilder ?? this.editButtonBuilder,
      subTextBuilder: subTextBuilder ?? this.subTextBuilder,
    );
  }

  @override
  State<LMChatPoll> createState() => _LMChatPollState();
}

class _LMChatPollState extends State<LMChatPoll> {
  final theme = LMChatTheme.theme;
  late LMChatPollStyle _lmChatPollStyle;
  final TextEditingController _addOptionController = TextEditingController();
  late ValueNotifier<bool> _rebuildPollWidget;
  bool _isVoteEditing = false;
  late List<int> selectedOption;
  late LMChatConversationViewData pollData;

// set poll data
  void _setPollData() {
    pollData = widget.pollData;
    _isVoteEditing = widget.isVoteEditing;
    selectedOption = widget.selectedOption;
  }

  @override
  void initState() {
    super.initState();
    // set poll style
    _lmChatPollStyle = widget.style ?? theme.pollStyle;
    // assign value notifier
    _rebuildPollWidget = widget.rebuildPollWidget ?? ValueNotifier(false);
    _setPollData();
  }

  @override
  void didUpdateWidget(covariant LMChatPoll oldWidget) {
    super.didUpdateWidget(oldWidget);
    // set poll style
    _lmChatPollStyle = widget.style ?? theme.pollStyle;
    // assign value notifier
    _rebuildPollWidget = widget.rebuildPollWidget ?? ValueNotifier(false);
    _setPollData();
  }

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder(
        valueListenable: _rebuildPollWidget,
        builder: (context, value, __) {
          return Container(
            margin: _lmChatPollStyle.margin,
            padding: _lmChatPollStyle.padding,
            decoration: _lmChatPollStyle.decoration?.copyWith(
                  color: _lmChatPollStyle.backgroundColor ?? theme.container,
                ) ??
                BoxDecoration(
                  color: _lmChatPollStyle.backgroundColor ?? theme.container,
                ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    widget.pollTypeTextBuilder?.call(
                          context,
                          _defPollTypeText(),
                        ) ??
                        _defPollTypeText(),
                    widget.pollHeaderSeparatorBuilder?.call(context) ??
                        _defHeaderSeparator(),
                    widget.votingTypeTextBuilder?.call(
                          context,
                          _defVotingTypeText(),
                        ) ??
                        _defVotingTypeText(),
                  ],
                ),
                LMChatDefaultTheme.kVerticalPaddingMedium,
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    widget.pollIconBuilder?.call(
                          context,
                          _defPollIcon(),
                        ) ??
                        _defPollIcon(),
                    widget.timeLeftTextBuilder?.call(
                          context,
                          _defTimeLeftText(),
                        ) ??
                        _defTimeLeftText() ??
                        const SizedBox.shrink(),
                  ],
                ),
                LMChatDefaultTheme.kVerticalPaddingMedium,
                widget.pollQuestionBuilder?.call(context, _defPollQuestion()) ??
                    _defPollQuestion(),
                LMChatDefaultTheme.kVerticalPaddingMedium,
                widget.pollSelectionTextBuilder?.call(
                      context,
                      _defPollSelection(),
                    ) ??
                    _defPollSelection(),
                const SizedBox(height: 8),
                _defPollOptionList(),
                //add and option button
                if (LMChatPollUtils.showAddOption(widget.pollData))
                  widget.addOptionButtonBuilder?.call(context,
                          _defAddOptionButton(context), _onAddOptionSubmit) ??
                      _defAddOptionButton(context),
                widget.subTextBuilder?.call(
                      context,
                      _defSubText(),
                    ) ??
                    _defSubText(),
                if (LMChatPollUtils.showSubmitButton(
                    widget.pollData, _isVoteEditing))
                  widget.submitButtonBuilder?.call(
                        _defSubmitButton(),
                      ) ??
                      _defSubmitButton(),
                if (LMChatPollUtils.showEditVote(
                    widget.pollData, _isVoteEditing))
                  widget.editButtonBuilder?.call(
                        _defEditButton(),
                      ) ??
                      _defEditButton(),
              ],
            ),
          );
        });
  }

  ListView _defPollOptionList() {
    return ListView.builder(
      physics: const NeverScrollableScrollPhysics(),
      shrinkWrap: true,
      padding: EdgeInsets.zero,
      itemCount: pollData.poll?.length,
      itemBuilder: (context, index) {
        return widget.pollOptionBuilder?.call(
              context,
              _defPollOption(index),
              pollData.poll![index],
            ) ??
            _defPollOption(index);
      },
    );
  }

  LMChatText _defPollTypeText() {
    return LMChatText(
      pollData.pollTypeText ?? pollData.pollType?.name ?? '',
      style: LMChatTextStyle(
        textStyle: TextStyle(
          height: 1.33,
          fontSize: 14,
          color: theme.inActiveColor,
        ),
      ),
    );
  }

  LMChatText? _defTimeLeftText() {
    return widget.pollData.expiryTime != null
        ? LMChatText(
            LMChatPollUtils.getTimeLeftInPoll(widget.pollData.expiryTime),
            style: LMChatTextStyle(
              borderRadius: 100,
              backgroundColor: theme.primaryColor,
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              textStyle: TextStyle(
                height: 1.33,
                fontSize: 14,
                color: theme.container,
              ),
            ),
          )
        : null;
  }

  LMChatIcon _defPollIcon() {
    return LMChatIcon(
      type: LMChatIconType.svg,
      assetPath: kPollIcon,
      style: LMChatIconStyle(
        size: 32,
        backgroundColor: theme.primaryColor,
        boxPadding: const EdgeInsets.all(8),
        boxBorderRadius: 100,
      ),
    );
  }

  LMChatText _defVotingTypeText() {
    return LMChatText(
      widget.pollData.submitTypeText ?? '',
      style: _lmChatPollStyle.voteTypeTextStyle,
    );
  }

  LMChatText _defHeaderSeparator() {
    return LMChatText(
      '●',
      style: LMChatTextStyle(
        padding: const EdgeInsets.symmetric(horizontal: 4),
        textStyle: TextStyle(
          fontSize: 6,
          color: theme.inActiveColor,
        ),
      ),
    );
  }

  LMChatText _defSubText() {
    return LMChatText(
      widget.pollData.pollAnswerText ?? '',
      onTap: widget.onAnswerTextTap,
      style: _lmChatPollStyle.pollAnswerStyle,
    );
  }

  LMChatButton _defAddOptionButton(BuildContext context) {
    return LMChatButton(
      onTap: () {
        //add option bottom sheet
        showModalBottomSheet(
          isScrollControlled: true,
          context: context,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.only(
              topLeft: Radius.circular(12),
              topRight: Radius.circular(12),
            ),
          ),
          builder: (context) => Padding(
            padding: EdgeInsets.only(
                bottom: MediaQuery.of(context).viewInsets.bottom),
            child: Container(
              color: theme.container,
              padding: const EdgeInsets.all(16),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 48,
                    height: 8,
                    decoration: ShapeDecoration(
                      color: theme.disabledColor..withAlpha(200),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(99),
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      const LMChatText(
                        'Add new poll option',
                        style: LMChatTextStyle(
                          textStyle: TextStyle(
                            height: 1.33,
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                      LMChatButton(
                        onTap: () {
                          Navigator.of(context).pop();
                        },
                        style: const LMChatButtonStyle(
                          backgroundColor: Colors.transparent,
                          icon: LMChatIcon(
                              type: LMChatIconType.icon, icon: Icons.close),
                        ),
                      ),
                    ],
                  ),
                  LMChatDefaultTheme.kVerticalPaddingSmall,
                  LMChatText(
                    'Enter an option that you think is missing in this poll. This can not be undone.',
                    style: LMChatTextStyle(
                        textStyle: TextStyle(
                      height: 1.33,
                      fontSize: 14,
                      fontWeight: FontWeight.w400,
                      color: theme.inActiveColor,
                      overflow: TextOverflow.visible,
                    )),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    child: TextField(
                      controller: _addOptionController,
                      decoration: const InputDecoration(
                        hintText: 'Type new option',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.all(Radius.circular(8)),
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.all(Radius.circular(8)),
                        ),
                        enabledBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.all(Radius.circular(8)),
                        ),
                      ),
                    ),
                  ),
                  LMChatButton(
                    onTap: () {
                      _onAddOptionSubmit(_addOptionController.text);
                    },
                    text: LMChatText(
                      'SUBMIT',
                      style: LMChatTextStyle(
                        textStyle: TextStyle(
                          height: 1.33,
                          fontSize: 16,
                          fontWeight: FontWeight.w400,
                          color: theme.container,
                        ),
                      ),
                    ),
                    style: LMChatButtonStyle(
                      backgroundColor: theme.primaryColor,
                      borderRadius: 100,
                      width: 150,
                      height: 44,
                    ),
                  ),
                  LMChatDefaultTheme.kVerticalPaddingMedium,
                ],
              ),
            ),
          ),
        );
      },
      text: const LMChatText(
        '+ Add an option',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            height: 1.33,
            fontSize: 16,
            fontWeight: FontWeight.w400,
          ),
        ),
      ),
      style: _lmChatPollStyle.addPollOptionButtonStyle!,
    );
  }

  void _onAddOptionSubmit(String optionText) {
    widget.onAddOptionSubmit?.call(optionText);
    Navigator.of(context).pop();
    _addOptionController.clear();
  }

  LMChatText _defPollSelection() {
    return LMChatText(
        _getPollSelectionText(widget.pollData.multipleSelectState,
                widget.pollData.multipleSelectNo) ??
            '',
        style: _lmChatPollStyle.pollInfoStyle);
  }

  String? _getPollSelectionText(
      LMChatPollMultiSelectState? pollMultiSelectState,
      int? pollMultiSelectNo) {
    if (pollMultiSelectNo == null || pollMultiSelectState == null) {
      return null;
    }
    switch (pollMultiSelectState) {
      case LMChatPollMultiSelectState.exactly:
        return "*Select ${pollMultiSelectState.name} $pollMultiSelectNo options.";
      case LMChatPollMultiSelectState.atMax:
        return "*Select ${pollMultiSelectState.name} $pollMultiSelectNo options.";
      case LMChatPollMultiSelectState.atLeast:
        return "*Select ${pollMultiSelectState.name} $pollMultiSelectNo options.";
      default:
        return null;
    }
  }

  LMChatExpandableText _defPollQuestion() {
    return LMChatExpandableText(
      pollData.answer,
      expandText: _lmChatPollStyle.pollTypeTextStyle ?? "See more",
      onTagTap: (value) {},
      style: _lmChatPollStyle.pollQuestionStyle,
    );
  }

  LMChatPollOption _defPollOption(int index) {
    return LMChatPollOption(
      style: widget.style?.pollOptionStyle ?? theme.pollStyle.pollOptionStyle,
      option: pollData.poll![index],
      isVoteEditing: _isVoteEditing,
      selectedOption: selectedOption,
      pollData: pollData,
      onOptionSelect: widget.onOptionSelect,
      onVoteClick: widget.onVoteClick,
    );
  }

  LMChatButton _defEditButton() {
    return LMChatButton(
      onTap: () {
        _isVoteEditing = true;
        widget.onEditVote?.call(widget.pollData);
      },
      text: LMChatText(
        'EDIT VOTE',
        style: LMChatTextStyle(
          textStyle: TextStyle(
            height: 1.33,
            fontSize: 16,
            fontWeight: FontWeight.w400,
            color: theme.primaryColor,
          ),
        ),
      ),
      style: _lmChatPollStyle.editPollButtonStyle,
    );
  }

  LMChatButton _defSubmitButton() {
    return LMChatButton(
        onTap: () {
          final selectedOptions = widget.pollData.poll
              ?.where((element) => selectedOption.contains(element.id))
              .toList();
          widget.onSubmit?.call(selectedOptions ?? []);
        },
        text: LMChatText(
          'SUBMIT VOTE',
          style: LMChatTextStyle(
            textStyle: TextStyle(
              height: 1.33,
              fontSize: 16,
              fontWeight: FontWeight.w400,
              color: theme.primaryColor,
            ),
          ),
        ),
        style: _lmChatPollStyle.submitPollButtonStyle);
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/poll/poll_option.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_poll_option}
/// Poll option widget
/// responsible for rendering the poll option
/// {@endtemplate}
class LMChatPollOption extends StatelessWidget {
  /// {@macro lm_chat_poll_option}
  LMChatPollOption({
    super.key,
    bool isVoteEditing = false,
    required List<int> selectedOption,
    required LMChatConversationViewData pollData,
    required this.option,
    this.onOptionSelect,
    this.onVoteClick,
    this.style,
    this.userTextBuilder,
    this.optionTextBuilder,
    this.selectedIconBuilder,
    this.voteCountTextBuilder,
  })  : _pollData = pollData,
        _selectedOption = selectedOption,
        _isVoteEditing = isVoteEditing;

  final bool _isVoteEditing;
  final LMChatThemeData _theme = LMChatTheme.theme;
  final List<int> _selectedOption;
  final LMChatConversationViewData _pollData;

  /// poll option data
  final LMChatPollOptionViewData option;

  /// poll option style
  final LMChatPollOptionStyle? style;

  /// callback when the option is selected
  final void Function(LMChatPollOptionViewData)? onOptionSelect;

  /// callback when the vote is clicked
  final void Function(LMChatPollOptionViewData)? onVoteClick;

  /// Builder for user text
  final LMChatTextBuilder? userTextBuilder;

  /// Builder for option text
  final LMChatTextBuilder? optionTextBuilder;

  /// Builder for selected icon
  final LMChatIconBuilder? selectedIconBuilder;

  /// Builder for vote count text
  final LMChatTextBuilder? voteCountTextBuilder;

  /// Creates a copy of this [LMChatPollOption] but with the given fields replaced with the new values.
  LMChatPollOption copyWith({
    Key? key,
    bool? isVoteEditing,
    List<int>? selectedOption,
    LMChatConversationViewData? pollData,
    LMChatPollOptionViewData? option,
    LMChatPollOptionStyle? style,
    void Function(LMChatPollOptionViewData)? onOptionSelect,
    void Function(LMChatPollOptionViewData)? onVoteClick,
    LMChatTextBuilder? userTextBuilder,
    LMChatTextBuilder? optionTextBuilder,
    LMChatIconBuilder? selectedIconBuilder,
    LMChatTextBuilder? voteCountTextBuilder,
  }) {
    return LMChatPollOption(
      key: key ?? this.key,
      isVoteEditing: isVoteEditing ?? _isVoteEditing,
      selectedOption: selectedOption ?? _selectedOption,
      pollData: pollData ?? _pollData,
      option: option ?? this.option,
      style: style ?? this.style,
      onOptionSelect: onOptionSelect ?? this.onOptionSelect,
      onVoteClick: onVoteClick ?? this.onVoteClick,
      userTextBuilder: userTextBuilder ?? this.userTextBuilder,
      optionTextBuilder: optionTextBuilder ?? this.optionTextBuilder,
      selectedIconBuilder: selectedIconBuilder ?? this.selectedIconBuilder,
      voteCountTextBuilder: voteCountTextBuilder ?? this.voteCountTextBuilder,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        InkWell(
          onTap: () {
            onOptionSelect?.call(option);
          },
          child: Stack(
            children: [
              if (_pollData.toShowResults != null &&
                  _pollData.toShowResults! &&
                  !_isVoteEditing)
                Positioned.fill(
                  child: Padding(
                    padding: const EdgeInsets.only(top: 8, bottom: 4),
                    child: LinearProgressIndicator(
                      value: (option.percentage ?? 0) / 100,
                      color: option.isSelected ?? false
                          ? style?.pollOptionSelectedColor
                          : style?.pollOptionOtherColor,
                      backgroundColor: _theme.container,
                      borderRadius: BorderRadius.circular(8),
                    ),
                  ),
                ),
              Container(
                width: double.infinity,
                margin: const EdgeInsets.only(top: 8, bottom: 4),
                decoration: style?.pollOptionDecoration ??
                    BoxDecoration(
                      borderRadius: BorderRadius.circular(8),
                      border: Border.all(
                        color: LMChatPollUtils.showTick(
                          _pollData,
                          option,
                          _selectedOption,
                          _isVoteEditing,
                        )
                            ? style?.pollOptionSelectedBorderColor ??
                                _theme.primaryColor
                            : _theme.inActiveColor,
                      ),
                    ),
                padding:
                    const EdgeInsets.symmetric(vertical: 8, horizontal: 16),
                child: Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          optionTextBuilder?.call(
                                  context, _defPollOptionText()) ??
                              _defPollOptionText(),
                          if (_pollData.allowAddOption ?? false)
                            userTextBuilder?.call(context, _defAddedByText()) ??
                                _defAddedByText(),
                        ],
                      ),
                    ),
                    if (LMChatPollUtils.showTick(
                        _pollData, option, _selectedOption, _isVoteEditing))
                      selectedIconBuilder?.call(context, _defSelectedIcon()) ??
                          _defSelectedIcon(),
                  ],
                ),
              ),
            ],
          ),
        ),
        if (LMChatPollUtils.showVoteText(
          _pollData,
        ))
          Padding(
            padding: const EdgeInsets.only(left: 8.0),
            child: voteCountTextBuilder?.call(
                  context,
                  _defVoteText(),
                ) ??
                _defVoteText(),
          ),
        LMChatDefaultTheme.kVerticalPaddingMedium,
      ],
    );
  }

  LMChatText _defVoteText() {
    return LMChatText(
      LMChatPollUtils.voteText(option.noVotes ?? 0),
      onTap: () {
        onVoteClick?.call(option);
      },
      style: style?.votesCountStyles ??
          LMChatTextStyle(
            textStyle: TextStyle(
              height: 1.33,
              fontSize: 14,
              fontWeight: FontWeight.w400,
              color: _theme.inActiveColor,
            ),
          ),
    );
  }

  LMChatIcon _defSelectedIcon() {
    return LMChatIcon(
      type: LMChatIconType.svg,
      assetPath: kTickIcon,
      style: LMChatIconStyle(
        boxSize: 22,
        margin: const EdgeInsets.only(left: 4),
        boxBorderRadius: 100,
        boxPadding: const EdgeInsets.all(4),
        size: 20,
        color: _theme.container,
        backgroundColor:
            style?.pollOptionSelectedCheckColor ?? _theme.primaryColor,
      ),
    );
  }

  LMChatText _defPollOptionText() {
    return LMChatText(option.text,
        style: style?.pollOptionTextStyle ??
            LMChatTextStyle(
              maxLines: 1,
              textStyle: TextStyle(
                overflow: TextOverflow.ellipsis,
                height: 1.50,
                fontSize: 16,
                fontWeight: FontWeight.w400,
                color: LMChatTheme.theme.onContainer,
              ),
            ));
  }

  LMChatText _defAddedByText() {
    return LMChatText(LMChatPollUtils.defAddedByMember(option.member),
        style: LMChatTextStyle(
          maxLines: 1,
          textStyle: TextStyle(
            overflow: TextOverflow.ellipsis,
            height: 1.25,
            fontSize: 12,
            fontWeight: FontWeight.w400,
            color: _theme.inActiveColor,
          ),
        ));
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/poll/poll_style.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

/// {@template lm_chat_poll_style}
/// Style class for Poll widget
/// {@endtemplate}
class LMChatPollStyle {
  ///[EdgeInsets] for margin
  final EdgeInsets? margin;

  ///[EdgeInsets] for padding
  final EdgeInsets? padding;

  ///[BoxDecoration] for decoration
  final BoxDecoration? decoration;

  ///[Color] for background color of the poll
  final Color? backgroundColor;

  ///[TextStyle] for poll question text
  final TextStyle? pollQuestionStyle;

  /// [String] for poll question expanded text
  final String? pollTypeTextStyle;

  ///[LMChatTextStyle] for poll info text
  final LMChatTextStyle? voteTypeTextStyle;

  ///[LMChatTextStyle] for poll answer text
  final LMChatTextStyle? pollAnswerStyle;

  /// [LMChatTextStyle] for time stamp text
  final LMChatTextStyle? timeStampStyle;

  /// [LMChatTextStyle] for submit poll text style
  final LMChatTextStyle? pollInfoStyle;

  /// [LMChatButtonStyle] for submit poll button style
  final LMChatButtonStyle? submitPollButtonStyle;

  ///[LMChatTextStyle] for edit poll options text
  final LMChatButtonStyle? editPollButtonStyle;

  /// [LMChatPollButtonStyle] for add poll option button style
  final LMChatButtonStyle? addPollOptionButtonStyle;

  /// [LMPollOptionStyle] for poll option style
  final LMChatPollOptionStyle? pollOptionStyle;

  /// {@macro lm_chat_poll_style}
  const LMChatPollStyle({
    this.margin,
    this.padding,
    this.decoration,
    this.backgroundColor,
    this.pollQuestionStyle,
    this.pollTypeTextStyle,
    this.voteTypeTextStyle,
    this.pollAnswerStyle,
    this.timeStampStyle,
    this.pollInfoStyle,
    this.submitPollButtonStyle,
    this.editPollButtonStyle,
    this.pollOptionStyle,
    this.addPollOptionButtonStyle,
  });

  /// basic poll style method for [LMChatPollStyle]
  factory LMChatPollStyle.basic({
    Color? primaryColor,
    Color? containerColor,
    Color? onContainer,
    Color? inActiveColor,
  }) {
    return LMChatPollStyle(
      margin: const EdgeInsets.symmetric(horizontal: 8),
      backgroundColor: containerColor ?? Colors.white,
      decoration: BoxDecoration(
        color: containerColor ?? Colors.white,
      ),
      pollQuestionStyle: TextStyle(
        color: onContainer,
        fontSize: 16,
      ),
      pollInfoStyle: LMChatTextStyle(
        textStyle: TextStyle(
          height: 1.33,
          fontSize: 14,
          fontWeight: FontWeight.w400,
          color: inActiveColor ?? Colors.grey,
        ),
      ),
      pollAnswerStyle: LMChatTextStyle(
        textStyle: TextStyle(
          height: 1.33,
          fontSize: 14,
          fontWeight: FontWeight.w400,
          color: primaryColor ?? LMChatDefaultTheme.primaryColor,
        ),
        padding: const EdgeInsets.symmetric(
          vertical: 6,
        ),
      ),
      voteTypeTextStyle: LMChatTextStyle(
        textStyle: TextStyle(
          height: 1.33,
          fontSize: 14,
          color: inActiveColor ?? LMChatDefaultTheme.inactiveColor,
        ),
      ),
      editPollButtonStyle: LMChatButtonStyle(
        icon: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.edit,
          style: LMChatIconStyle(
            color: primaryColor ?? LMChatDefaultTheme.primaryColor,
          ),
        ),
        backgroundColor: containerColor ?? LMChatDefaultTheme.container,
        borderRadius: 100,
        border: Border.all(
          color: primaryColor ?? LMChatDefaultTheme.primaryColor,
        ),
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
        margin: const EdgeInsets.only(top: 12, bottom: 6),
        spacing: 8,
      ),
      submitPollButtonStyle: LMChatButtonStyle(
        icon: LMChatIcon(
          type: LMChatIconType.icon,
          icon: Icons.touch_app_outlined,
          style: LMChatIconStyle(
            color: primaryColor ?? LMChatDefaultTheme.primaryColor,
          ),
        ),
        backgroundColor: containerColor ?? LMChatDefaultTheme.container,
        borderRadius: 100,
        border: Border.all(
          color: primaryColor ?? LMChatDefaultTheme.primaryColor,
        ),
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
        margin: const EdgeInsets.only(top: 12, bottom: 6),
        spacing: 8,
      ),
      addPollOptionButtonStyle: LMChatButtonStyle(
        backgroundColor: containerColor ?? LMChatDefaultTheme.container,
        width: double.infinity,
        margin: const EdgeInsets.symmetric(vertical: 8),
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        borderRadius: 8,
        border: Border.all(
          color: primaryColor ?? LMChatDefaultTheme.primaryColor,
        ),
      ),
      pollOptionStyle: LMChatPollOptionStyle.basic(
        primaryColor: primaryColor,
        inActiveColor: inActiveColor,
      ),
    );
  }

  /// copyWith method for [LMChatPollStyle]
  /// [LMChatPollStyle] object with values that are passed in the method
  /// will be updated and returned
  /// If a value is not passed in the method, then the value will remain the same
  /// as the original object
  LMChatPollStyle copyWith({
    EdgeInsets? margin,
    EdgeInsets? padding,
    BoxDecoration? decoration,
    Color? backgroundColor,
    TextStyle? pollQuestionStyle,
    String? pollTypeTextStyle,
    LMChatTextStyle? voteTypeTextStyle,
    LMChatTextStyle? pollAnswerStyle,
    LMChatTextStyle? timeStampStyle,
    LMChatTextStyle? pollInfoStyle,
    LMChatButtonStyle? submitPollButtonStyle,
    LMChatButtonStyle? editPollButtonStyle,
    LMChatButtonStyle? addPollOptionButtonStyle,
    LMChatPollOptionStyle? pollOptionStyle,
  }) {
    return LMChatPollStyle(
      margin: margin ?? this.margin,
      padding: padding ?? this.padding,
      decoration: decoration ?? this.decoration,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      pollQuestionStyle: pollQuestionStyle ?? this.pollQuestionStyle,
      pollTypeTextStyle: pollTypeTextStyle ?? this.pollTypeTextStyle,
      voteTypeTextStyle: voteTypeTextStyle ?? this.voteTypeTextStyle,
      pollAnswerStyle: pollAnswerStyle ?? this.pollAnswerStyle,
      timeStampStyle: timeStampStyle ?? this.timeStampStyle,
      pollInfoStyle: pollInfoStyle ?? this.pollInfoStyle,
      submitPollButtonStyle:
          submitPollButtonStyle ?? this.submitPollButtonStyle,
      editPollButtonStyle: editPollButtonStyle ?? this.editPollButtonStyle,
      addPollOptionButtonStyle:
          addPollOptionButtonStyle ?? this.addPollOptionButtonStyle,
      pollOptionStyle: pollOptionStyle ?? this.pollOptionStyle,
    );
  }
}

/// {@template lm_chat_poll_option_style}
/// Style class for Poll option widget
/// {@endtemplate}
class LMChatPollOptionStyle {
  ///[Color] for poll option selected color
  final Color? pollOptionSelectedColor;

  ///[Color] for poll option other color
  final Color? pollOptionOtherColor;

  ///[Color] for tick in poll option selected
  final Color? pollOptionSelectedCheckColor;

  ///[Color] for border of selected poll option
  final Color? pollOptionSelectedBorderColor;

  /// [Color] for text color of selected poll option
  final Color? pollOptionSelectedTextColor;

  /// [Color] for text color of other poll option
  final Color? pollOptionOtherTextColor;

  ///[LMChatTextStyle] for votes count text
  final LMChatTextStyle? votesCountStyles;

  ///[LMChatTextStyle] for poll option text style
  final LMChatTextStyle? pollOptionTextStyle;

  /// [BoxDecoration] for poll option decoration
  final BoxDecoration? pollOptionDecoration;

  /// {@macro lm_chat_poll_option_style}
  const LMChatPollOptionStyle({
    this.pollOptionSelectedColor,
    this.pollOptionOtherColor,
    this.pollOptionSelectedCheckColor,
    this.pollOptionSelectedBorderColor,
    this.pollOptionSelectedTextColor,
    this.votesCountStyles,
    this.pollOptionOtherTextColor,
    this.pollOptionTextStyle,
    this.pollOptionDecoration,
  });

  /// copyWith method for [LMChatPollOptionStyle]
  LMChatPollOptionStyle copyWith({
    Color? pollOptionSelectedColor,
    Color? pollOptionOtherColor,
    Color? pollOptionSelectedTickColor,
    Color? pollOptionSelectedBorderColor,
    Color? pollOptionSelectedTextColor,
    Color? pollOptionOtherTextColor,
    LMChatTextStyle? votesCountStyles,
    LMChatTextStyle? pollOptionTextStyle,
    BoxDecoration? pollOptionDecoration,
  }) {
    return LMChatPollOptionStyle(
      pollOptionSelectedColor:
          pollOptionSelectedColor ?? this.pollOptionSelectedColor,
      pollOptionOtherColor: pollOptionOtherColor ?? this.pollOptionOtherColor,
      pollOptionSelectedCheckColor:
          pollOptionSelectedTickColor ?? pollOptionSelectedCheckColor,
      pollOptionSelectedBorderColor:
          pollOptionSelectedBorderColor ?? this.pollOptionSelectedBorderColor,
      pollOptionSelectedTextColor:
          pollOptionSelectedTextColor ?? this.pollOptionSelectedTextColor,
      pollOptionOtherTextColor:
          pollOptionOtherTextColor ?? this.pollOptionOtherTextColor,
      votesCountStyles: votesCountStyles ?? this.votesCountStyles,
      pollOptionTextStyle: pollOptionTextStyle ?? this.pollOptionTextStyle,
      pollOptionDecoration: pollOptionDecoration ?? this.pollOptionDecoration,
    );
  }

  /// basic poll option style method for [LMChatPollOptionStyle]
  factory LMChatPollOptionStyle.basic(
      {Color? primaryColor, Color? inActiveColor}) {
    return LMChatPollOptionStyle(
      pollOptionSelectedColor: primaryColor?.withOpacity(0.3) ??
          const Color.fromARGB(255, 196, 208, 237),
      pollOptionOtherColor: inActiveColor?.withOpacity(0.3) ??
          const Color.fromRGBO(155, 155, 155, 0.3),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/poll/poll_utils.dart
================================================
part of './poll.dart';

/// {@template lm_chat_poll_utils}
/// Utility class for poll related operations.
/// {@endtemplate}
class LMChatPollUtils {
  /// Determines whether to show the edit vote button.
  static bool showEditVote(
      LMChatConversationViewData conversationData, bool isVoteEditing) {
    if (hasPollEnded(
        conversationData.expiryTime, conversationData.noPollExpiry)) {
      return false;
    }
    if (isVoteEditing) {
      return false;
    }
    if (isPollSubmitted(conversationData.poll ?? []) &&
        (conversationData.pollType == LMChatPollType.deferred ||
            (conversationData.allowVoteChange ?? false))) {
      return true;
    }
    return false;
  }

  /// Determines whether to show the add option button.
  static bool showAddOption(LMChatConversationViewData conversationData) {
    // return false if poll has ended.
    if (hasPollEnded(
        conversationData.expiryTime, conversationData.noPollExpiry)) {
      return false;
    }
    // if allowAddOption is true check if the poll is submitted or not
    if (conversationData.allowAddOption == true) {
      // if poll is not submitted return true
      if (!isPollSubmitted(conversationData.poll ?? [])) {
        return true;
      }
      // if poll is submitted and poll type is deferred return true
      if (conversationData.pollType == LMChatPollType.deferred) {
        return true;
      }
    }
    // return false if the above conditions are not met
    return false;
  }

  /// Determines whether to show the tick mark for a poll option.
  static bool showTick(
    LMChatConversationViewData conversationData,
    LMChatPollOptionViewData option,
    List<int> selectedOption,
    bool isVoteEditing,
  ) {
    if (isVoteEditing) {
      return selectedOption.contains(option.id);
    }
    if (isMultiChoicePoll(conversationData.multipleSelectNo,
            conversationData.multipleSelectState) &&
        (option.isSelected == true || selectedOption.contains(option.id))) {
      return true;
    } else {
      return false;
    }
  }

  /// Returns the vote count text based on the number of votes.
  static String voteText(int voteCount) {
    if (voteCount == 1) {
      return '1 vote';
    } else {
      return '$voteCount votes';
    }
  }

  /// Determines whether to show the submit button for the poll.
  static bool showSubmitButton(
      LMChatConversationViewData conversationData, bool isVoteEditing) {
    if (isVoteEditing) {
      return true;
    }
    if (isPollSubmitted(conversationData.poll ?? [])) {
      return false;
    }
    if ((conversationData.pollType != null &&
            isInstantPoll(conversationData.pollType!) &&
            isPollSubmitted(conversationData.poll!)) ||
        hasPollEnded(
            conversationData.expiryTime, conversationData.noPollExpiry)) {
      return false;
    } else if (!isMultiChoicePoll(conversationData.multipleSelectNo,
        conversationData.multipleSelectState)) {
      return false;
    } else {
      return true;
    }
  }

  /// Checks if the poll has been submitted.
  static bool isPollSubmitted(List<LMChatPollOptionViewData> poll) {
    return poll.any((element) => element.isSelected ?? false);
  }

  /// Checks if the poll has ended based on the expiry time.
  static bool hasPollEnded(int? expiryTime, [bool? noPollExpiry = false]) {
    // if noPollExpiry is true, the poll will never expire.
    if (noPollExpiry ?? false) {
      return false;
    }
    return expiryTime != null &&
        DateTime.now().millisecondsSinceEpoch > expiryTime;
  }

  /// Checks if the poll is an instant poll.
  static bool isInstantPoll(LMChatPollType? pollType) {
    return pollType != null && pollType == LMChatPollType.instant;
  }

  /// Checks if the poll is a multi-choice poll.
  static bool isMultiChoicePoll(int? pollMultiSelectNo,
      LMChatPollMultiSelectState? pollMultiSelectState) {
    if (pollMultiSelectNo == null || pollMultiSelectState == null) {
      return false;
    }
    if (pollMultiSelectState == LMChatPollMultiSelectState.exactly &&
        pollMultiSelectNo == 1) {
      return false;
    }
    return true;
  }

  /// Determines whether the option is selected by the user.
  static bool isSelectedByUser(
      LMChatPollOptionViewData? optionViewData, List<int> selectedOption) {
    if (optionViewData == null) {
      return false;
    }
    return selectedOption.contains(optionViewData.id);
  }

  /// Returns the vote count text based on the number of votes.
  static String defAddedByMember(
    LMChatUserViewData? userViewData,
  ) {
    return "Added by ${userViewData?.name ?? ""}";
  }

  /// Returns the time left in the poll.
  static String getTimeLeftInPoll(int? expiryTime) {
    if (expiryTime == null) {
      return "";
    }
    DateTime expiryTimeInDateTime =
        DateTime.fromMillisecondsSinceEpoch(expiryTime);
    DateTime now = DateTime.now();
    Duration difference = expiryTimeInDateTime.difference(now);
    if (difference.isNegative) {
      return "Poll Ended";
    }
    if (difference.inDays > 1) {
      return "Ends in ${difference.inDays} days";
    } else if (difference.inDays > 0) {
      return "Ends in ${difference.inDays} day";
    } else if (difference.inHours > 0) {
      return "Ends in  ${difference.inHours} hours";
    } else if (difference.inMinutes > 0) {
      return "Ends in  ${difference.inMinutes} minutes";
    } else {
      return "Just Now";
    }
  }

  /// checks if vote text should be shown
  static bool showVoteText(
    LMChatConversationViewData conversationData,
  ) {
    return conversationData.toShowResults ?? false;
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/profile/profile_picture.dart
================================================
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

class LMChatProfilePicture extends StatelessWidget {
  const LMChatProfilePicture({
    super.key,
    this.imageUrl,
    this.filePath,
    required this.fallbackText,
    this.onTap,
    this.style,
    this.overlay,
  });

  final String? imageUrl;
  final String? filePath;
  final String fallbackText;
  final Function()? onTap;
  final LMChatProfilePictureStyle? style;
  final Widget? overlay;

  // Determines if the image is an SVG image based on the file extension of the URL
  bool _isSvgImage() {
    return imageUrl != null && imageUrl!.endsWith('.svg');
  }

  @override
  Widget build(BuildContext context) {
    final inStyle = style ?? LMChatProfilePictureStyle.basic();
    final isSvgImage = _isSvgImage();
    return AbsorbPointer(
      absorbing: onTap == null,
      child: GestureDetector(
        onTap: () {
          if (onTap != null) onTap!();
        },
        child: Stack(
          alignment: Alignment.center,
          children: [
            Container(
              height: inStyle.size,
              width: inStyle.size,
              decoration: BoxDecoration(
                borderRadius: inStyle.boxShape == null
                    ? BorderRadius.circular(inStyle.borderRadius ?? 0)
                    : null,
                border: Border.all(
                  color: Colors.white,
                  width: inStyle.border ?? 0,
                ),
                shape: inStyle.boxShape ?? BoxShape.rectangle,
                color: imageUrl != null && imageUrl!.isNotEmpty
                    ? Colors.grey.shade300
                    : inStyle.backgroundColor ??
                        (LMChatTheme.isThemeDark
                            ? LMChatTheme.theme.container
                            : LMChatTheme.theme.primaryColor),
                image: filePath != null
                    ? DecorationImage(
                        image: FileImage(File(filePath!)),
                        fit: BoxFit.cover,
                      )
                    : imageUrl != null && imageUrl!.isNotEmpty && !isSvgImage
                        ? DecorationImage(
                            image: NetworkImage(imageUrl!),
                            fit: BoxFit.cover,
                          )
                        : null,
              ),
              padding: !isSvgImage
                  ? inStyle.textPadding ?? const EdgeInsets.all(5)
                  : EdgeInsets.zero,
              child: isSvgImage ||
                      (imageUrl == null || imageUrl!.isEmpty) &&
                          filePath == null
                  ? Center(
                      child: _isSvgImage()
                          ? SvgPicture.network(
                              imageUrl!,
                              fit: BoxFit.cover,
                              height: inStyle.size,
                              width: inStyle.size,
                            )
                          : LMChatText(
                              getInitials(fallbackText).toUpperCase(),
                              style: inStyle.fallbackTextStyle ??
                                  LMChatTextStyle(
                                    maxLines: 1,
                                    minLines: 1,
                                    textAlign: TextAlign.center,
                                    textStyle: TextStyle(
                                      overflow: TextOverflow.clip,
                                      color: LMChatTheme.isThemeDark
                                          ? LMChatTheme.theme.onContainer
                                          : LMChatTheme.theme.onPrimary,
                                      fontSize: inStyle.size != null
                                          ? inStyle.size! / 2
                                          : 24,
                                      fontWeight: FontWeight.w600,
                                    ),
                                  ),
                            ),
                    )
                  : null,
            ),
            if (overlay != null) overlay!,
          ],
        ),
      ),
    );
  }

  LMChatProfilePicture copyWith({
    String? imageUrl,
    String? fallbackText,
    Function()? onTap,
    LMChatProfilePictureStyle? style,
  }) {
    return LMChatProfilePicture(
      fallbackText: fallbackText ?? this.fallbackText,
      imageUrl: imageUrl ?? this.imageUrl,
      onTap: onTap ?? this.onTap,
      style: style ?? this.style,
    );
  }
}

class LMChatProfilePictureStyle {
  final double? size;
  final LMChatTextStyle? fallbackTextStyle;
  final double? borderRadius;
  final double? border;
  final Color? backgroundColor;
  final BoxShape? boxShape;
  final EdgeInsets? textPadding;

  const LMChatProfilePictureStyle({
    this.size = 48,
    this.borderRadius = 24,
    this.border = 0,
    this.backgroundColor,
    this.boxShape,
    this.textPadding,
    this.fallbackTextStyle,
  });

  factory LMChatProfilePictureStyle.basic() {
    return LMChatProfilePictureStyle(
      backgroundColor: (LMChatTheme.isThemeDark
          ? LMChatTheme.theme.container
          : LMChatTheme.theme.primaryColor),
      boxShape: BoxShape.circle,
      fallbackTextStyle: LMChatTextStyle(
        textStyle: TextStyle(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: LMChatTheme.isThemeDark
              ? LMChatTheme.theme.primaryColor
              : LMChatTheme.theme.onPrimary,
        ),
      ),
    );
  }

  LMChatProfilePictureStyle copyWith({
    double? size,
    LMChatTextStyle? fallbackTextStyle,
    double? borderRadius,
    double? border,
    Color? backgroundColor,
    BoxShape? boxShape,
    EdgeInsets? textPadding,
  }) {
    return LMChatProfilePictureStyle(
      size: size ?? this.size,
      borderRadius: borderRadius ?? this.borderRadius,
      border: border ?? this.border,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      boxShape: boxShape ?? this.boxShape,
      fallbackTextStyle: fallbackTextStyle ?? this.fallbackTextStyle,
      textPadding: textPadding ?? this.textPadding,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/profile/user_tile.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/models/models.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

/// [LMChatUserTile] is a [LMChatTile] that represents a user in a chat room.
class LMChatUserTile extends LMChatTile {
  /// [userViewData] is the user to be displayed in the tile.
  final LMChatUserViewData userViewData;

  final LMChatThemeData _chatTheme = LMChatTheme.theme;

  /// [LMChatUserTile] constructor to create an instance of [LMChatUserTile].
  LMChatUserTile({
    super.key,
    required this.userViewData,
    super.onTap,
    super.style,
    super.leading,
    super.title,
    super.subtitle,
    super.trailing,
    super.absorbTouch,
  });

  @override
  Widget build(BuildContext context) {
    return userViewData.isDeleted == true
        ? _defDeletedUserTile()
        : _defUserTile();
  }

  Widget _defDeletedUserTile() {
    return Row(
      children: [
        Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(27),
          ),
          height: 54,
          width: 54,
        ),
        LMChatDefaultTheme.kHorizontalPaddingSmall,
        LMChatDefaultTheme.kHorizontalPaddingMedium,
        const LMChatText(
          'Deleted User',
          style: LMChatTextStyle(
            textStyle: TextStyle(
              fontSize: LMChatDefaultTheme.kFontMedium,
            ),
          ),
        )
      ],
    );
  }

  LMChatTile _defUserTile() {
    return LMChatTile(
      onTap: onTap,
      style: style ??
          LMChatTileStyle(
            backgroundColor: _chatTheme.container,
            gap: 4,
            margin: const EdgeInsets.only(bottom: 2),
          ),
      leading: leading ??
          LMChatProfilePicture(
            style: LMChatProfilePictureStyle.basic().copyWith(
              size: 48,
            ),
            fallbackText: userViewData.name,
            imageUrl: userViewData.imageUrl,
            onTap: onTap,
          ),
      trailing: trailing,
      title: title ??
          LMChatText(
            userViewData.name,
            style: LMChatTextStyle(
              textStyle: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w400,
                color: _chatTheme.onContainer,
              ),
            ),
          ),
      subtitle: subtitle,
    );
  }

  /// `copyWith()` method to create a copy of the [LMChatUserTile] instance with the new values.
  @override
  LMChatTile copyWith({
    LMChatUserViewData? userViewData,
    VoidCallback? onTap,
    LMChatTileStyle? style,
    Widget? leading,
    Widget? title,
    Widget? subtitle,
    Widget? trailing,
  }) {
    return LMChatUserTile(
      userViewData: userViewData ?? this.userViewData,
      onTap: onTap ?? this.onTap,
      style: style ?? this.style,
      leading: leading ?? this.leading,
      title: title ?? this.title,
      subtitle: subtitle ?? this.subtitle,
      trailing: trailing ?? this.trailing,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/reaction/reaction.dart
================================================
export 'reaction_bar.dart';
export 'reaction_bottom_sheet.dart';
export 'reaction_emoji_keyboard.dart';



================================================
File: lib/packages/ui/lib/src/widgets/reaction/reaction_bar.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:likeminds_chat_flutter_ui/src/utils/utils.dart';
import 'package:likeminds_chat_flutter_ui/src/widgets/widgets.dart';

/// A list of emojis representing different reactions.
const List<String> reactionEmojis = ['\u2764', '😂', '😮', '😢', '😡', '👍'];

/// {@template lm_chat_reaction_bar}
/// A widget that displays a bar for selecting reactions.
/// {@endtemplate}
class LMChatReactionBar extends StatelessWidget {
  /// The function to call when a reaction is made.
  final Function(String reaction)? onReaction;

  /// The style class of the widget.
  final LMChatReactionBarStyle? style;

  ///{@macro lm_chat_reaction_bar}
  const LMChatReactionBar({
    Key? key,
    this.onReaction,
    this.style,
  }) : super(key: key);

  /// Creates a copy of the current instance with the given parameters.
  LMChatReactionBar copyWith({
    Function(String reaction)? onReaction,
    LMChatReactionBarStyle? style,
  }) {
    return LMChatReactionBar(
      key: key,
      onReaction: onReaction ?? this.onReaction,
      style: style ?? this.style,
    );
  }

  @override
  Widget build(BuildContext context) {
    LMChatReactionBarStyle effectiveStyle = style ??
        (LMChatTheme.theme.reactionBarStyle as LMChatReactionBarStyle?) ??
        LMChatReactionBarStyle.basic();
    return Align(
      alignment: Alignment.center,
      child: Container(
        decoration: BoxDecoration(
          color: effectiveStyle.background ?? LMChatTheme.theme.container,
          borderRadius: BorderRadius.circular(effectiveStyle.borderRadius ?? 6),
          boxShadow: [
            BoxShadow(
              blurRadius: 1,
              spreadRadius: 2,
              color: LMChatTheme.theme.onContainer.withOpacity(0.1),
            )
          ],
        ),
        width: effectiveStyle.width ?? 80.w,
        height: effectiveStyle.height ?? 6.h,
        child: getListOfReactions(
          onTap: onReaction,
          effectiveStyle: effectiveStyle, // Pass effectiveStyle here
        ),
      ),
    );
  }

  Widget getListOfReactions(
      {required Function(String)? onTap,
      required LMChatReactionBarStyle effectiveStyle}) {
    // Add effectiveStyle parameter
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: reactionEmojis
              .map(
                (e) => GestureDetector(
                  onTap: () => onTap?.call(e),
                  child: LMChatText(
                    e,
                    style: LMChatTextStyle(
                      textStyle: TextStyle(
                        fontSize: effectiveStyle.size ?? 24,
                      ),
                    ),
                  ),
                ),
              )
              .toList() +
          [
            GestureDetector(
              onTap: () => onTap?.call('Add'),
              child: LMChatIcon(
                type: LMChatIconType.icon,
                icon: Icons.add_reaction_outlined,
                style: effectiveStyle.addIconStyle ??
                    LMChatIconStyle(
                      size: effectiveStyle.size ?? 24,
                    ),
              ),
            )
          ],
    );
  }
}

/// A class that defines the style for the reaction bar in the chat interface.
class LMChatReactionBarStyle {
  /// The background color of the reaction bar.
  final Color? background;

  /// The width of the reaction bar.
  final double? width;

  /// The height of the reaction bar.
  final double? height;

  /// The border radius of the reaction bar's corners.
  final double? borderRadius;

  /// The size of the reaction icons within the bar.
  final double? size;

  /// The style of the add icon in reaction bar
  final LMChatIconStyle? addIconStyle;

  /// Creates an instance of [LMChatReactionBarStyle].
  LMChatReactionBarStyle({
    this.background,
    this.width,
    this.height,
    this.size,
    this.borderRadius,
    this.addIconStyle,
  });

  /// A factory constructor that returns a basic instance of [LMChatReactionBarStyle].
  factory LMChatReactionBarStyle.basic() {
    return LMChatReactionBarStyle();
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/reaction/reaction_bottom_sheet.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';

///{@template lm_chat_reaction_bottom_sheet}
/// A widget that displays a bottom sheet for selecting reactions.
///
/// This bottom sheet shows the available reactions for a conversation and allows
/// the current user to remove their reactions.
///{@endtemplate}
class LMChatReactionBottomSheet extends StatefulWidget {
  /// A map of reactions mapped to their corresponding
  /// list of reaction view data. This can be null if no reactions are available.
  final Map<String, List<LMChatReactionViewData>>? mappedReactions;

  /// The user data of the current user interacting with the
  /// reactions.
  final LMChatUserViewData currentUser;

  /// A map containing metadata about users involved in the
  /// conversation. This can be null if no user metadata is available.
  final Map<int, LMChatUserViewData?>? userMeta;

  /// The conversation data to which the reactions belong.
  final LMChatConversationViewData conversation;

  /// A callback function that is called when a reaction
  /// is removed. It takes the reaction as a string parameter.
  final Function(String reaction)? onRemoveReaction;

  ///{@macro lm_chat_reaction_bottom_sheet}
  final LMChatReactionBottomSheetStyle? style; // Add style parameter

  const LMChatReactionBottomSheet({
    super.key,
    this.mappedReactions,
    required this.currentUser,
    required this.conversation,
    this.userMeta,
    this.onRemoveReaction,
    this.style, // Include style in constructor
  });

  LMChatReactionBottomSheet copyWith({
    Map<String, List<LMChatReactionViewData>>? mappedReactions,
    LMChatUserViewData? currentUser,
    Map<int, LMChatUserViewData?>? userMeta,
    LMChatConversationViewData? conversation,
    Function(String reaction)? onRemoveReaction,
    LMChatReactionBottomSheetStyle? style,
  }) {
    return LMChatReactionBottomSheet(
      key: key ?? key,
      mappedReactions: mappedReactions ?? this.mappedReactions,
      currentUser: currentUser ?? this.currentUser,
      conversation: conversation ?? this.conversation,
      userMeta: userMeta ?? this.userMeta,
      onRemoveReaction: onRemoveReaction ?? this.onRemoveReaction,
      style: style ?? this.style,
    );
  }

  @override
  State<LMChatReactionBottomSheet> createState() =>
      _LMChatReactionBottomSheetState();
}

class _LMChatReactionBottomSheetState extends State<LMChatReactionBottomSheet> {
  String selectedKey = 'All';
  Map<String, List<LMChatReactionViewData>>? mappedReactions;
  Map<int, LMChatUserViewData?>? userMeta;
  LMChatUserViewData? currentUser;
  LMChatConversationViewData? conversation;
  late LMChatReactionBottomSheetStyle style;

  // Set data for bottom sheet
  void initialiseBottomSheetData() {
    mappedReactions = widget.mappedReactions;
    userMeta = widget.userMeta;
    currentUser = widget.currentUser;
    conversation = widget.conversation;
    style = widget.style ?? LMChatTheme.theme.reactionBottomSheetStyle;
  }

  @override
  Widget build(BuildContext context) {
    initialiseBottomSheetData();
    return Container(
      clipBehavior: Clip.none,
      padding: style.padding ??
          const EdgeInsets.symmetric(horizontal: 18.0), // Use style padding
      height: style.height ?? 60.h, // Use style height
      decoration: BoxDecoration(
        color: style.backgroundColor ??
            LMChatTheme.theme.container, // Use style background color
        borderRadius: style.borderRadius ??
            const BorderRadius.only(
              topLeft: Radius.circular(12.0),
              topRight: Radius.circular(12.0),
            ), // Use style border radius
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: <Widget>[
          kVerticalPaddingLarge,
          _buildTitle(), // Refactored title section
          kVerticalPaddingXLarge,
          _buildTabBar(), // Refactored tab bar section
          kVerticalPaddingLarge,
          _buildReactionList(), // Refactored reaction list section
        ],
      ),
    );
  }

  // New method to build the title
  Widget _buildTitle() {
    return LMChatText(
      'Reactions',
      style: style.titleStyle ??
          const LMChatTextStyle(
            textStyle: TextStyle(fontWeight: FontWeight.bold),
          ), // Use style title style
    );
  }

  // New method to build the tab bar
  Widget _buildTabBar() {
    return SizedBox(
      height: 40,
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          Container(
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: style.tabBarBorderColor ??
                      LMChatTheme.theme.disabledColor,
                  width: 1,
                ),
              ),
            ),
            width: 100.w - 40,
            height: 40,
            child: ListView.builder(
              itemCount: mappedReactions!.keys.length,
              scrollDirection: Axis.horizontal,
              itemBuilder: (context, reactionIndex) => GestureDetector(
                onTap: () {
                  setState(() {
                    selectedKey =
                        mappedReactions!.keys.elementAt(reactionIndex);
                  });
                },
                child: Container(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 5.0),
                  decoration: BoxDecoration(
                      border: selectedKey ==
                              mappedReactions!.keys.elementAt(reactionIndex)
                          ? Border(
                              bottom: BorderSide(
                                color: style.selectedTabColor ??
                                    LMChatTheme.theme
                                        .primaryColor, // Use style selected tab color
                                width: widget.style?.selectedTabBorderWidth ??
                                    1, // Use style selected tab border width
                              ),
                            )
                          : null),
                  child: LMChatText(
                    '${mappedReactions!.keys.elementAt(reactionIndex)} (${mappedReactions!.values.elementAt(reactionIndex).length})',
                    style: selectedKey ==
                            mappedReactions!.keys.elementAt(reactionIndex)
                        ? style.selectedTabTextStyle ??
                            LMChatTextStyle(
                              textStyle: TextStyle(
                                color: style.selectedTabColor ??
                                    LMChatTheme.theme.primaryColor,
                              ),
                            )
                        : style.tabTextStyle ??
                            const LMChatTextStyle(
                              textStyle: TextStyle(),
                            ),
                  ),
                ),
              ),
            ),
          )
        ],
      ),
    );
  }

  // New method to build the reaction list
  Widget _buildReactionList() {
    return Expanded(
      child: ListView.builder(
        itemCount: mappedReactions![selectedKey]!.length,
        itemBuilder: (context, itemIndex) => Container(
          margin: const EdgeInsets.only(bottom: 10),
          child: LMChatUserTile(
            absorbTouch: false,
            style: style.userTileStyle,
            onTap: mappedReactions![selectedKey]![itemIndex].userId ==
                    currentUser!.id
                ? () => widget.onRemoveReaction?.call(
                      mappedReactions![selectedKey]![itemIndex].reaction,
                    )
                : () {},
            userViewData:
                userMeta![mappedReactions![selectedKey]![itemIndex].userId]!,
            trailing: LMChatText(
              mappedReactions![selectedKey]![itemIndex].reaction,
              style: style.reactionTextStyle ??
                  const LMChatTextStyle(
                    // Use style reaction text style
                    textStyle: TextStyle(
                      fontSize: 28,
                    ),
                  ),
            ),
            subtitle: mappedReactions![selectedKey]![itemIndex].userId ==
                    currentUser!.id
                ? LMChatText(
                    'Tap to remove',
                    style: style.removeReactionTextStyle ??
                        const LMChatTextStyle(
                          // Use style remove reaction text style
                          textStyle: TextStyle(
                            color: LMChatDefaultTheme.greyColor,
                          ),
                        ),
                  )
                : const SizedBox(),
          ),
        ),
      ),
    );
  }
}

/// A class that defines the style for the reaction bottom sheet.
///
/// This class contains properties that determine the appearance of the
/// reaction bottom sheet, including padding, height, background color,
/// border radius, and styles for various UI elements within the bottom sheet.
class LMChatReactionBottomSheetStyle {
  /// The padding applied to the entire bottom sheet.
  final EdgeInsets? padding;

  /// The height of the bottom sheet.
  final double? height;

  /// The background color of the bottom sheet.
  final Color? backgroundColor;

  /// The border radius of the bottom sheet.
  final BorderRadius? borderRadius;

  /// The style for the title text in the bottom sheet.
  final LMChatTextStyle? titleStyle;

  /// The height of the tab bar within the bottom sheet.
  final double? tabBarHeight;

  /// The border color of the tab bar.
  final Color? tabBarBorderColor;

  /// The border width of the tab bar.
  final double? tabBarBorderWidth;

  /// The width of the tab bar.
  final double? tabBarWidth;

  /// The padding applied to each tab item in the tab bar.
  final EdgeInsets? tabItemPadding;

  /// The background color of the selected tab.
  final Color? selectedTabColor;

  /// The border width of the selected tab.
  final double? selectedTabBorderWidth;

  /// The style for the text in the selected tab.
  final LMChatTextStyle? selectedTabTextStyle;

  /// The style for the text in the tab items.
  final LMChatTextStyle? tabTextStyle;

  /// The margin applied to the list items in the bottom sheet.
  final EdgeInsets? listItemMargin;

  /// The style for the user tiles in the bottom sheet.
  final LMChatTileStyle? userTileStyle;

  /// The style for the reaction text within the bottom sheet.
  final LMChatTextStyle? reactionTextStyle;

  /// The style for the text indicating the removal of a reaction.
  final LMChatTextStyle? removeReactionTextStyle;

  const LMChatReactionBottomSheetStyle({
    this.padding,
    this.height,
    this.backgroundColor,
    this.borderRadius,
    this.titleStyle,
    this.tabBarHeight,
    this.tabBarBorderColor,
    this.tabBarBorderWidth,
    this.tabBarWidth,
    this.tabItemPadding,
    this.selectedTabColor,
    this.selectedTabBorderWidth,
    this.selectedTabTextStyle,
    this.tabTextStyle,
    this.listItemMargin,
    this.userTileStyle,
    this.reactionTextStyle,
    this.removeReactionTextStyle,
  });

  /// Creates a basic style for the reaction bottom sheet with default values.
  factory LMChatReactionBottomSheetStyle.basic() {
    return const LMChatReactionBottomSheetStyle(
      padding: EdgeInsets.symmetric(horizontal: 18.0),
      borderRadius: BorderRadius.only(
        topLeft: Radius.circular(12.0),
        topRight: Radius.circular(12.0),
      ),
      tabBarHeight: 40,
      tabBarBorderWidth: 1,
      tabItemPadding: EdgeInsets.symmetric(horizontal: 8.0, vertical: 5.0),
      selectedTabBorderWidth: 2,
      listItemMargin: EdgeInsets.only(bottom: 10),
      userTileStyle: LMChatTileStyle(verticalGap: 0, gap: 4),
    );
  }

  /// Creates a copy of the current style, allowing for modifications of specific properties.
  LMChatReactionBottomSheetStyle copyWith({
    EdgeInsets? padding,
    double? height,
    Color? backgroundColor,
    BorderRadius? borderRadius,
    LMChatTextStyle? titleStyle,
    double? tabBarHeight,
    Color? tabBarBorderColor,
    double? tabBarBorderWidth,
    double? tabBarWidth,
    EdgeInsets? tabItemPadding,
    Color? selectedTabColor,
    double? selectedTabBorderWidth,
    LMChatTextStyle? selectedTabTextStyle,
    LMChatTextStyle? tabTextStyle,
    EdgeInsets? listItemMargin,
    LMChatTileStyle? userTileStyle,
    LMChatTextStyle? reactionTextStyle,
    LMChatTextStyle? removeReactionTextStyle,
  }) {
    return LMChatReactionBottomSheetStyle(
      padding: padding ?? this.padding,
      height: height ?? this.height,
      backgroundColor: backgroundColor ?? this.backgroundColor,
      borderRadius: borderRadius ?? this.borderRadius,
      titleStyle: titleStyle ?? this.titleStyle,
      tabBarHeight: tabBarHeight ?? this.tabBarHeight,
      tabBarBorderColor: tabBarBorderColor ?? this.tabBarBorderColor,
      tabBarBorderWidth: tabBarBorderWidth ?? this.tabBarBorderWidth,
      tabBarWidth: tabBarWidth ?? this.tabBarWidth,
      tabItemPadding: tabItemPadding ?? this.tabItemPadding,
      selectedTabColor: selectedTabColor ?? this.selectedTabColor,
      selectedTabBorderWidth:
          selectedTabBorderWidth ?? this.selectedTabBorderWidth,
      selectedTabTextStyle: selectedTabTextStyle ?? this.selectedTabTextStyle,
      tabTextStyle: tabTextStyle ?? this.tabTextStyle,
      listItemMargin: listItemMargin ?? this.listItemMargin,
      userTileStyle: userTileStyle ?? this.userTileStyle,
      reactionTextStyle: reactionTextStyle ?? this.reactionTextStyle,
      removeReactionTextStyle:
          removeReactionTextStyle ?? this.removeReactionTextStyle,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/reaction/reaction_emoji_keyboard.dart
================================================
import 'package:emoji_picker_flutter/emoji_picker_flutter.dart';
import 'package:flutter/foundation.dart' as foundation;
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';

/// {@template lm_chat_reaction_keyboard}
///
/// A widget for choosing emojis from the keyboard
/// for reaction purposes, and more
///
/// {@endtemplate}
class LMChatReactionKeyboard extends StatelessWidget {
  /// The text editing controller for the emoji keyboard.
  final TextEditingController? textController;

  /// Callback function that is called when an emoji is selected.
  final Function(String emoji)? onEmojiSelected;

  /// The style configuration for the emoji keyboard.
  final LMChatReactionKeyboardStyle? style;

  /// {@macro lm_chat_reaction_keyboard}
  const LMChatReactionKeyboard({
    super.key,
    this.textController,
    this.onEmojiSelected,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    final effectiveStyle = style ?? LMChatTheme.theme.reactionKeyboardStyle;

    return SizedBox(
      height: 35.h,
      child: EmojiPicker(
        onEmojiSelected: (category, emoji) async {
          onEmojiSelected?.call(emoji.emoji);
        },
        onBackspacePressed: null,
        textEditingController: textController,
        config: Config(
          bottomActionBarConfig: BottomActionBarConfig(
            buttonIconColor: effectiveStyle.buttonIconColor ?? Colors.grey,
            backgroundColor:
                effectiveStyle.backgroundColor ?? LMChatTheme.theme.container,
            showSearchViewButton: false,
          ),
          searchViewConfig: SearchViewConfig(
            backgroundColor: effectiveStyle.searchViewBackgroundColor ??
                const Color(0xFFF2F2F2),
          ),
          categoryViewConfig: const CategoryViewConfig(
            initCategory: Category.RECENT,
            recentTabBehavior: RecentTabBehavior.RECENT,
          ),
          skinToneConfig: SkinToneConfig(
            dialogBackgroundColor: effectiveStyle.dialogBackgroundColor ??
                LMChatDefaultTheme.whiteColor,
            indicatorColor:
                effectiveStyle.indicatorColor ?? LMChatDefaultTheme.greyColor,
            enabled: true,
          ),
          emojiViewConfig: EmojiViewConfig(
            columns: effectiveStyle.columns ?? 7,
            emojiSizeMax: effectiveStyle.emojiSizeMax ??
                28 *
                    (foundation.defaultTargetPlatform == TargetPlatform.iOS
                        ? 1.30
                        : 1.0),
            verticalSpacing: 0,
            horizontalSpacing: 0,
            gridPadding: effectiveStyle.gridPadding ?? EdgeInsets.zero,
            recentsLimit: effectiveStyle.recentsLimit ?? 28,
            noRecents: effectiveStyle.noRecents ??
                const Text(
                  'No Recents',
                  style: TextStyle(fontSize: 20, color: Colors.black26),
                  textAlign: TextAlign.center,
                ),
            loadingIndicator:
                effectiveStyle.loadingIndicator ?? const SizedBox.shrink(),
            buttonMode: ButtonMode.MATERIAL,
            backgroundColor:
                effectiveStyle.backgroundColor ?? LMChatTheme.theme.container,
          ),
        ),
      ),
    );
  }
}

class LMChatReactionKeyboardStyle {
  /// The color of the button icons in the keyboard.
  final Color? buttonIconColor;

  /// The background color of the emoji keyboard.
  final Color? backgroundColor;

  /// The background color of the search view.
  final Color? searchViewBackgroundColor;

  /// The background color of the dialog.
  final Color? dialogBackgroundColor;

  /// The color of the indicator.
  final Color? indicatorColor;

  /// The number of columns in the emoji grid.
  final int? columns;

  /// The maximum size of the emojis.
  final double? emojiSizeMax;

  /// The padding for the emoji grid.
  final EdgeInsets? gridPadding;

  /// The limit for recent emojis.
  final int? recentsLimit;

  /// The widget displayed when there are no recent emojis.
  final Widget? noRecents;

  /// The widget displayed as a loading indicator.
  final Widget? loadingIndicator;

  LMChatReactionKeyboardStyle({
    this.buttonIconColor,
    this.backgroundColor,
    this.searchViewBackgroundColor,
    this.dialogBackgroundColor,
    this.indicatorColor,
    this.columns,
    this.emojiSizeMax,
    this.gridPadding,
    this.recentsLimit,
    this.noRecents,
    this.loadingIndicator,
  });

  /// Creates a basic style configuration for the emoji keyboard.
  static LMChatReactionKeyboardStyle basic() {
    return LMChatReactionKeyboardStyle(
      buttonIconColor: Colors.grey,
      columns: 7,
      gridPadding: EdgeInsets.zero,
      recentsLimit: 28,
      noRecents: const Text(
        'No Recents',
        style: TextStyle(fontSize: 20, color: Colors.black26),
        textAlign: TextAlign.center,
      ),
      loadingIndicator: const SizedBox.shrink(),
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/shimmers/chatroom_skeleton.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:shimmer/shimmer.dart';

/// [LMChatSkeletonChatPage] is a skeleton screen for the chat page.
class LMChatSkeletonChatPage extends StatelessWidget {
  const LMChatSkeletonChatPage({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      bottom: false,
      child: Container(
        color: LMChatTheme.theme.backgroundColor,
        child: Column(
          mainAxisSize: MainAxisSize.max,
          children: [
            const LMChatSkeletonAppBar(),
            const SizedBox(height: 18),
            Expanded(
              child: Padding(
                padding: const EdgeInsets.symmetric(),
                child: Container(
                  color: LMChatTheme.theme.backgroundColor,
                  child: const LMChatSkeletonChatList(),
                ),
              ),
            ),
            // const Spacer(),
            const LMChatSkeletonChatBar(),
          ],
        ),
      ),
    );
  }
}

class LMChatSkeletonAppBar extends StatelessWidget {
  const LMChatSkeletonAppBar({
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      color: LMChatTheme.theme.container,
      child: Padding(
        padding: const EdgeInsets.symmetric(
          horizontal: 18,
          vertical: 12,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.start,
          children: [
            LMChatSkeletonAnimation(
              child: Container(
                width: 28,
                height: 28,
                decoration: BoxDecoration(
                  color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                  borderRadius: const BorderRadius.all(
                    Radius.circular(8),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            LMChatSkeletonAnimation(
              child: Container(
                width: 42,
                height: 42,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  LMChatSkeletonAnimation(
                    child: Container(
                      width: 140,
                      height: 16,
                      decoration: BoxDecoration(
                        color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                        borderRadius: const BorderRadius.all(
                          Radius.circular(2),
                        ),
                      ),
                    ),
                  ),
                  LMChatDefaultTheme.kVerticalPaddingSmall,
                  LMChatSkeletonAnimation(
                    child: Container(
                      width: 100,
                      height: 12,
                      decoration: BoxDecoration(
                        color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                        borderRadius: const BorderRadius.all(
                          Radius.circular(2),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
            // LMChatDefaultTheme.kHorizontalPaddingMedium,
          ],
        ),
      ),
    );
  }
}

class LMChatSkeletonChatBar extends StatelessWidget {
  const LMChatSkeletonChatBar({
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      color: LMChatTheme.theme.backgroundColor,
      child: Padding(
        padding: EdgeInsets.only(
          left: 18,
          right: 18,
          top: 2.h,
          bottom: 2.h,
        ),
        child: Row(
          children: [
            Expanded(
              child: LMChatSkeletonAnimation(
                child: Container(
                  width: 90.w,
                  height: 6.h,
                  decoration: BoxDecoration(
                    color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                    borderRadius: BorderRadius.all(
                      Radius.circular(2.5.h),
                    ),
                  ),
                ),
              ),
            ),
            LMChatDefaultTheme.kHorizontalPaddingMedium,
            LMChatSkeletonAnimation(
              child: Container(
                width: 6.h,
                height: 6.h,
                decoration: BoxDecoration(
                  color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                  borderRadius: BorderRadius.all(
                    Radius.circular(3.h),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class LMChatSkeletonChatList extends StatelessWidget {
  const LMChatSkeletonChatList({
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    List<Widget> list = List.generate(
      10,
      (index) => LMChatSkeletonChatBubble(isSent: index % 3 == 0),
    );

    return Padding(
      padding: EdgeInsets.symmetric(
        vertical: 1.4.h,
        horizontal: 2.w,
      ),
      child: Column(
        children: list,
      ),
    );
  }
}

class LMChatSkeletonChatroomList extends StatelessWidget {
  const LMChatSkeletonChatroomList({
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    List<Widget> list = List.generate(
      6,
      (index) => const LMChatSkeletonChatroom(),
    );

    return Padding(
      padding: EdgeInsets.symmetric(
        vertical: 1.h,
      ),
      child: Column(
        children: list,
      ),
    );
  }
}

class LMChatSkeletonChatroom extends StatelessWidget {
  const LMChatSkeletonChatroom({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      color: LMChatTheme.theme.container,
      child: Padding(
        padding: EdgeInsets.only(
          left: 18,
          right: 18,
          bottom: 4.h,
        ),
        child: Row(
          children: [
            LMChatSkeletonAnimation(
              child: Container(
                width: 42,
                height: 42,
                decoration: BoxDecoration(
                  color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                  borderRadius: const BorderRadius.all(
                    Radius.circular(21),
                  ),
                ),
              ),
            ),
            LMChatDefaultTheme.kHorizontalPaddingMedium,
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  LMChatSkeletonAnimation(
                    child: Container(
                      width: 60.w,
                      height: 14,
                      decoration: BoxDecoration(
                        color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                        borderRadius: const BorderRadius.all(
                          Radius.circular(6),
                        ),
                      ),
                    ),
                  ),
                  LMChatDefaultTheme.kVerticalPaddingSmall,
                  LMChatSkeletonAnimation(
                    child: Container(
                      width: 40.w,
                      height: 10,
                      decoration: BoxDecoration(
                        color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                        borderRadius: const BorderRadius.all(
                          Radius.circular(4),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class LMChatSkeletonChatBubble extends StatelessWidget {
  final bool isSent;
  const LMChatSkeletonChatBubble({
    super.key,
    required this.isSent,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.symmetric(
        vertical: 1.h,
      ),
      child: Column(
        crossAxisAlignment:
            isSent ? CrossAxisAlignment.end : CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              if (isSent)
                const Spacer()
              else
                LMChatSkeletonAnimation(
                  child: Container(
                    width: 4.5.h,
                    height: 4.5.h,
                    decoration: BoxDecoration(
                      color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                      borderRadius: BorderRadius.all(
                        Radius.circular(3.h),
                      ),
                    ),
                  ),
                ),
              LMChatDefaultTheme.kHorizontalPaddingMedium,
              Container(
                decoration: BoxDecoration(
                  color: LMChatTheme.theme.container.withOpacity(0.5),
                  borderRadius: BorderRadius.circular(8),
                ),
                constraints: BoxConstraints(
                  maxWidth: 60.w,
                  maxHeight: 4.5.h,
                  minHeight: 4.5.h,
                ),
                alignment: Alignment.center,
                child: LMChatSkeletonAnimation(
                  child: Container(
                    width: double.infinity,
                    decoration: BoxDecoration(
                      color: LMChatTheme.theme.container.withOpacity(0.5),
                      borderRadius: BorderRadius.circular(1.h),
                    ),
                  ),
                ),
              ),
              LMChatDefaultTheme.kHorizontalPaddingMedium,
              if (isSent)
                LMChatSkeletonAnimation(
                  child: Container(
                    width: 4.5.h,
                    height: 4.5.h,
                    decoration: BoxDecoration(
                      color: LMChatTheme.theme.onContainer.withOpacity(0.5),
                      borderRadius: BorderRadius.all(
                        Radius.circular(3.h),
                      ),
                    ),
                  ),
                )
              else
                const Spacer(),
            ],
          ),
        ],
      ),
    );
  }
}

class LMChatSkeletonAnimation extends StatelessWidget {
  final Widget child;
  final Duration? duration;
  final Curve? curve;

  const LMChatSkeletonAnimation({
    super.key,
    required this.child,
    this.duration,
    this.curve,
  });

  @override
  Widget build(BuildContext context) {
    return Shimmer.fromColors(
      baseColor: Colors.grey.shade100,
      highlightColor: Colors.grey.shade300,
      period: const Duration(seconds: 1),
      direction: ShimmerDirection.ltr,
      child: child,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/shimmers/document_shimmer.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/likeminds_chat_flutter_ui.dart';
import 'package:shimmer/shimmer.dart';

/// {@template lm_chat_document_shimmer}
/// A shimmer loading widget that is shown while document tile is loading
/// {@endtemplate}
class LMChatDocumentShimmer extends StatelessWidget {
  /// The style for the document shimmer.
  final LMChatDocumentShimmerStyle? style;

  ///{@macro lm_chat_document_shimmer}
  const LMChatDocumentShimmer({super.key, this.style});

  @override
  Widget build(BuildContext context) {
    final style = this.style ?? LMChatDocumentShimmerStyle.basic();
    return Container(
      height: style.height ?? 80, // Default height
      width: style.width ?? 55.w, // Default width
      margin: style.margin,
      decoration: BoxDecoration(
        border: Border.all(
          color: style.borderColor ??
              LMChatTheme.theme.onContainer.withOpacity(0.5),
          width: style.borderWidth ?? 1,
        ),
        borderRadius: style.borderRadius,
      ),
      padding: style.padding,
      child: Shimmer.fromColors(
        baseColor:
            style.baseColor ?? LMChatTheme.theme.onContainer.withOpacity(0.2),
        highlightColor: style.highlightColor ??
            LMChatTheme.theme.onContainer.withOpacity(0.5),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: <Widget>[
            Container(
              height: style.iconSize ?? 40, // Default icon size
              width: style.iconSize ?? 40, // Default icon size
              color: LMChatTheme.theme.container,
            ),
            kHorizontalPaddingLarge,
            Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  height: style.titleHeight ?? 16, // Default title height
                  width: style.titleWidth ?? 28.w, // Default title width
                  color: LMChatTheme.theme.container,
                ),
                kVerticalPaddingMedium,
                Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  children: <Widget>[
                    Container(
                      height:
                          style.subtitleHeight ?? 12, // Default subtitle height
                      width:
                          style.subtitleWidth ?? 16.w, // Default subtitle width
                      color: LMChatTheme.theme.container,
                    ),
                    kHorizontalPaddingXSmall,
                    Text(
                      '·',
                      style: TextStyle(
                        fontSize: kFontSmall,
                        color: LMChatTheme.theme.disabledColor,
                      ),
                    ),
                    kHorizontalPaddingXSmall,
                    Container(
                      height: style.subtitleHeight,
                      width: style.subtitleWidth,
                      color: LMChatTheme.theme.container,
                    ),
                  ],
                )
              ],
            )
          ],
        ),
      ),
    );
  }
}

/// Defines the style properties for the LMChatDocumentShimmer widget.
class LMChatDocumentShimmerStyle {
  /// Creates an LMChatDocumentShimmerStyle instance.
  const LMChatDocumentShimmerStyle({
    this.height,
    this.width,
    this.margin,
    this.borderRadius,
    this.borderColor,
    this.borderWidth,
    this.padding,
    this.baseColor,
    this.highlightColor,
    this.iconSize,
    this.titleHeight,
    this.titleWidth,
    this.subtitleHeight,
    this.subtitleWidth,
  });

  /// The height of the shimmer container.
  final double? height;

  /// The width of the shimmer container.
  final double? width;

  /// The margin around the shimmer container.
  final EdgeInsetsGeometry? margin;

  /// The border radius of the shimmer container.
  final BorderRadius? borderRadius;

  /// The border color of the shimmer container.
  final Color? borderColor;

  /// The border width of the shimmer container.
  final double? borderWidth;

  /// The padding inside the shimmer container.
  final EdgeInsetsGeometry? padding;

  /// The base color for the shimmer effect.
  final Color? baseColor;

  /// The highlight color for the shimmer effect.
  final Color? highlightColor;

  /// The size of the icon placeholder.
  final double? iconSize;

  /// The height of the title placeholder.
  final double? titleHeight;

  /// The width of the title placeholder.
  final double? titleWidth;

  /// The height of the subtitle placeholder.
  final double? subtitleHeight;

  /// The width of the subtitle placeholder.
  final double? subtitleWidth;

  /// Creates a basic LMChatDocumentShimmerStyle with default values.
  factory LMChatDocumentShimmerStyle.basic() {
    return LMChatDocumentShimmerStyle(
      margin: const EdgeInsets.only(bottom: 10),
      borderRadius: BorderRadius.circular(kBorderRadiusMedium),
      borderColor: LMChatDefaultTheme.greyColor,
      borderWidth: 1,
      padding: const EdgeInsets.all(kPaddingLarge),
      baseColor: Colors.black26,
      highlightColor: Colors.black12,
    );
  }

  /// Creates a copy of this LMChatDocumentShimmerStyle but with the given fields replaced with the new values.
  LMChatDocumentShimmerStyle copyWith({
    double? height,
    double? width,
    EdgeInsetsGeometry? margin,
    BorderRadius? borderRadius,
    Color? borderColor,
    double? borderWidth,
    EdgeInsetsGeometry? padding,
    Color? baseColor,
    Color? highlightColor,
    double? iconSize,
    double? titleHeight,
    double? titleWidth,
    double? subtitleHeight,
    double? subtitleWidth,
  }) {
    return LMChatDocumentShimmerStyle(
      height: height ?? this.height,
      width: width ?? this.width,
      margin: margin ?? this.margin,
      borderRadius: borderRadius ?? this.borderRadius,
      borderColor: borderColor ?? this.borderColor,
      borderWidth: borderWidth ?? this.borderWidth,
      padding: padding ?? this.padding,
      baseColor: baseColor ?? this.baseColor,
      highlightColor: highlightColor ?? this.highlightColor,
      iconSize: iconSize ?? this.iconSize,
      titleHeight: titleHeight ?? this.titleHeight,
      titleWidth: titleWidth ?? this.titleWidth,
      subtitleHeight: subtitleHeight ?? this.subtitleHeight,
      subtitleWidth: subtitleWidth ?? this.subtitleWidth,
    );
  }
}



================================================
File: lib/packages/ui/lib/src/widgets/shimmers/media_shimmer.dart
================================================
import 'package:flutter/material.dart';
import 'package:likeminds_chat_flutter_ui/src/theme/theme.dart';
import 'package:shimmer/shimmer.dart';

class LMChatMediaShimmerWidget extends StatelessWidget {
  final bool isPP;
  final double? height;
  final double? width;
  final LMChatMediaShimmerStyle? style;

  const LMChatMediaShimmerWidget(
      {Key? key, this.isPP = false, this.height, this.width, this.style})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Shimmer.fromColors(
      baseColor: style?.baseColor ?? Colors.grey.shade100,
      highlightColor: style?.highlightColor ?? Colors.grey.shade200,
      period: const Duration(seconds: 2),
      direction: ShimmerDirection.ltr,
      child: isPP
          ? const CircleAvatar(backgroundColor: Colors.white)
          : Container(
              color: Colors.white,
              width: width ?? 55.w,
              height: height ?? 55.w,
            ),
    );
  }
}

class LMChatMediaShimmerStyle {
  final Color? baseColor;
  final Color? highlightColor;

  LMChatMediaShimmerStyle({
    this.baseColor,
    this.highlightColor,
  });
}



================================================
File: lib/packages/ui/test/likeminds_chat_flutter_ui_test.dart
================================================




================================================
File: .dart_tool/package_config.json
================================================
{
  "configVersion": 2,
  "packages": [
    {
      "name": "ansi_styles",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/ansi_styles-0.3.2+1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "args",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/args-2.7.0",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "async",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/async-2.12.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "boolean_selector",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/boolean_selector-2.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "characters",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/characters-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "charcode",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/charcode-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "cli_launcher",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/cli_launcher-0.3.1",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "cli_util",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/cli_util-0.4.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "clock",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/clock-1.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "collection",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/collection-1.19.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "conventional_commit",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/conventional_commit-0.6.0+1",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "fake_async",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/fake_async-1.3.2",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "file",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/file-6.1.4",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "flutter",
      "rootUri": "file:///Users/divyanshgandhi/Developer/flutter/packages/flutter",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "flutter_lints",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/flutter_lints-2.0.3",
      "packageUri": "lib/",
      "languageVersion": "2.19"
    },
    {
      "name": "flutter_test",
      "rootUri": "file:///Users/divyanshgandhi/Developer/flutter/packages/flutter_test",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "glob",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/glob-2.1.3",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "graphs",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/graphs-2.3.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "http",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/http-1.3.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "http_parser",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/http_parser-4.1.2",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "io",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/io-1.0.5",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "json_annotation",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/json_annotation-4.9.0",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "leak_tracker",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/leak_tracker-10.0.8",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "leak_tracker_flutter_testing",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/leak_tracker_flutter_testing-3.0.9",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "leak_tracker_testing",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/leak_tracker_testing-3.0.1",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "lints",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/lints-2.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "matcher",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/matcher-0.12.17",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "material_color_utilities",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/material_color_utilities-0.11.1",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "melos",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/melos-3.4.0",
      "packageUri": "lib/",
      "languageVersion": "2.18"
    },
    {
      "name": "meta",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/meta-1.16.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "mustache_template",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/mustache_template-2.0.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "path",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/path-1.9.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "platform",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/platform-3.1.6",
      "packageUri": "lib/",
      "languageVersion": "3.2"
    },
    {
      "name": "pool",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/pool-1.5.1",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "process",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/process-4.2.4",
      "packageUri": "lib/",
      "languageVersion": "2.14"
    },
    {
      "name": "prompts",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/prompts-2.0.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "pub_semver",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/pub_semver-2.2.0",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "pub_updater",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/pub_updater-0.3.1",
      "packageUri": "lib/",
      "languageVersion": "3.0"
    },
    {
      "name": "pubspec",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/pubspec-2.3.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "quiver",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/quiver-3.2.2",
      "packageUri": "lib/",
      "languageVersion": "2.17"
    },
    {
      "name": "sky_engine",
      "rootUri": "file:///Users/divyanshgandhi/Developer/flutter/bin/cache/pkg/sky_engine",
      "packageUri": "lib/",
      "languageVersion": "3.7"
    },
    {
      "name": "source_span",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/source_span-1.10.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "stack_trace",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/stack_trace-1.12.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "stream_channel",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/stream_channel-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "string_scanner",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/string_scanner-1.4.1",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "term_glyph",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/term_glyph-1.2.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "test_api",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/test_api-0.7.4",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "typed_data",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/typed_data-1.4.0",
      "packageUri": "lib/",
      "languageVersion": "3.5"
    },
    {
      "name": "uri",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/uri-1.0.0",
      "packageUri": "lib/",
      "languageVersion": "2.12"
    },
    {
      "name": "vector_math",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/vector_math-2.1.4",
      "packageUri": "lib/",
      "languageVersion": "2.14"
    },
    {
      "name": "vm_service",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/vm_service-14.3.1",
      "packageUri": "lib/",
      "languageVersion": "3.3"
    },
    {
      "name": "web",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/web-1.1.1",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "yaml",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/yaml-3.1.3",
      "packageUri": "lib/",
      "languageVersion": "3.4"
    },
    {
      "name": "yaml_edit",
      "rootUri": "file:///Users/divyanshgandhi/.pub-cache/hosted/pub.dev/yaml_edit-2.2.2",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    },
    {
      "name": "likeminds_chat_flutter",
      "rootUri": "../",
      "packageUri": "lib/",
      "languageVersion": "3.1"
    }
  ],
  "generated": "2025-04-03T17:23:31.527571Z",
  "generator": "pub",
  "generatorVersion": "3.7.2",
  "flutterRoot": "file:///Users/divyanshgandhi/Developer/flutter",
  "flutterVersion": "3.29.2",
  "pubCache": "file:///Users/divyanshgandhi/.pub-cache"
}



================================================
File: .github/pull_request_template.md
================================================
## Description

**Features**

**Bugs**

**What kind of change does this PR introduce?** (check at least one)

<!-- (Update "[ ]" to "[x]" to check a box) -->

- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] Hotfix (fixes a breaking changes)
- [ ] New Feature (non-breaking change which adds functionality)
- [ ] Other, please describe:

### Author Checklist

- [ ] Assignee added
- [ ] Reviewer added
- [ ] Description added
- [ ] Unit test cases added

### Reviewer Checklist

- [ ] PR title starts with Jira ticket number prefix
- [ ] If hotfix, Add Hotfix as prefix in PR title
- [ ] Label added
- [ ] Commit messages follows standard format (added, changed, removed, code commented and chore)
- [ ] Description about the Feature/ Bugs added


