Directory structure:
└── ai-mvp/
    ├── README.md
    ├── requirements.txt
    ├── api/
    │   ├── __init__.py
    │   ├── main.py
    │   ├── domain/
    │   │   ├── __init__.py
    │   │   └── interfaces/
    │   │       └── code_generator_service.py
    │   ├── infrastructure/
    │   │   ├── __init__.py
    │   │   └── services/
    │   │       └── code_generator_service_impl.py
    │   └── presentation/
    │       ├── __init__.py
    │       └── websocket_handler.py
    ├── code_generator/
    │   ├── __init__.py
    │   ├── __main__.py
    │   ├── config/
    │   │   ├── __init__.py
    │   │   └── settings.py
    │   ├── core/
    │   │   ├── __init__.py
    │   │   ├── generator.py
    │   │   └── project_creator.py
    │   └── utils/
    │       ├── __init__.py
    │       └── documentation.py
    └── document_parser/
        ├── __init__.py
        ├── __main__.py
        ├── config/
        │   ├── __init__.py
        │   └── settings.py
        ├── core/
        │   ├── __init__.py
        │   └── parser.py
        └── utils/
            └── __init__.py

================================================
File: README.md
================================================
# LikeMinds Android Feed SDK Code Generator

This project provides tools for generating code for the LikeMinds Android Feed SDK using AI.

## Features

- Documentation parsing and processing
- AI-powered code generation using Gemini 2.5 Pro
- Interactive code generation interface
- Streaming and non-streaming output options

## Project Structure

```
ai-mvp/
├── code_generator/           # Main code generation package
│   ├── core/                # Core functionality
│   │   └── generator.py     # Code generation logic
│   ├── config/              # Configuration
│   │   └── settings.py      # Settings and defaults
│   ├── utils/               # Utilities
│   │   └── documentation.py # Documentation handling
│   ├── __init__.py          # Package initialization
│   └── __main__.py          # Main entry point
├── document_parser.py        # Documentation parsing utility
├── combined_documentation.md # SDK documentation
├── requirements.txt          # Python dependencies
└── .env                      # Environment variables
```

## Setup

1. Clone the repository
2. Create a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   ```
3. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Create a `.env` file with your Gemini API key and model name:
   ```
   GEMINI_API_KEY=your_api_key_here
   GEMINI_MODEL_NAME=gemini-2.5-pro-exp-03-25
   ```

## Usage

### Documentation Parser

To parse and process the SDK documentation:
```bash
python document_parser.py
```

### Code Generator

To start the interactive code generator:
```bash
python -m code_generator
```

The code generator will:
1. Load the SDK documentation
2. Provide an interactive interface
3. Generate code based on your requests
4. Support both streaming and non-streaming output

## Default Values

The code generator uses the following default values:
- API Key: `701a4436-6bab-45b7-92e5-a1c61763e229`
- Model Name: `gemini-2.5-pro-exp-03-25`
- Username: `test`

These values are automatically used when generating code that requires authentication.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## License

This project is licensed under the MIT License - see the LICENSE file for details.



================================================
File: requirements.txt
================================================
# No external dependencies required 

google-genai>=0.3.0
python-dotenv>=1.0.0
fastapi>=0.104.0
uvicorn>=0.24.0
websockets>=12.0 


================================================
File: api/__init__.py
================================================
"""
AI MVP API Package

This package contains the main API implementation for the AI MVP project.
It follows a clean architecture pattern with separate layers for:
- Presentation (routes, controllers)
- Domain (business logic)
- Infrastructure (external services, databases)
"""

__version__ = "0.1.0" 


================================================
File: api/main.py
================================================
from fastapi import FastAPI, WebSocket
from api.presentation import WebSocketHandler

app = FastAPI()
websocket_handler = WebSocketHandler()

@app.websocket("/api/ttandroid")
async def websocket_endpoint(websocket: WebSocket):
    """
    WebSocket endpoint for code generation.
    
    Expected message format:
    {
        "user_query": "string"  # The query for code generation
    }
    
    Response format:
    {
        "type": "Text" | "Error" | "Result",
        "value": "string" | object
    }
    """
    await websocket_handler.handle_websocket(websocket) 


================================================
File: api/domain/__init__.py
================================================
"""
Domain Layer

This package contains the core business logic and domain models:
- Business rules
- Domain entities
- Use cases
- Domain services
"""

from .interfaces.code_generator_service import CodeGeneratorService

__all__ = ['CodeGeneratorService'] 


================================================
File: api/domain/interfaces/code_generator_service.py
================================================
from typing import Optional, Dict, Callable

class CodeGeneratorService:
    """Interface for code generator service."""
    
    def generate_project(self, user_query: str, on_chunk: Callable[[str], None]) -> Optional[Dict]:
        """
        Generate a project based on user query.
        
        Args:
            user_query (str): The user's input query
            on_chunk (Callable[[str], None]): Callback function to handle each chunk of output
            
        Returns:
            Optional[Dict]: The generated project data or None if generation failed
        """
        raise NotImplementedError 


================================================
File: api/infrastructure/__init__.py
================================================
"""
Infrastructure Layer

This package contains external service integrations and infrastructure components:
- Database adapters
- External API clients
- Message brokers
- Caching systems
"""

from .services.code_generator_service_impl import CodeGeneratorServiceImpl

__all__ = ['CodeGeneratorServiceImpl'] 


================================================
File: api/infrastructure/services/code_generator_service_impl.py
================================================
from typing import Optional, Dict, Callable
from code_generator.core import CodeGenerator
from code_generator.config import Settings
from api.domain import CodeGeneratorService

class CodeGeneratorServiceImpl(CodeGeneratorService):
    """Implementation of the code generator service."""
    
    def __init__(self):
        """Initialize the service with settings."""
        self.settings = Settings()
        self.generator = CodeGenerator(self.settings)
    
    async def generate_project(self, user_query: str, on_chunk: Callable[[Dict], None]) -> Optional[Dict]:
        """
        Generate a project based on user query.
        
        Args:
            user_query (str): The user's input query
            on_chunk (Callable[[Dict], None]): Callback function to handle each chunk of output
            
        Returns:
            Optional[Dict]: The generated project data or None if generation failed
        """
        try:
            # Create project using the generator
            success = await self.generator.create_project(user_query, on_chunk)
            return {"success": success}
        except Exception as e:
            await on_chunk({
                "type": "Error",
                "value": str(e)
            })
            return None 


================================================
File: api/presentation/__init__.py
================================================
"""
Presentation Layer

This package contains the presentation layer components of the API:
- Route handlers
- WebSocket handlers
- Request/response models
- Controllers
"""

from .websocket_handler import WebSocketHandler

__all__ = ['WebSocketHandler'] 


================================================
File: api/presentation/websocket_handler.py
================================================
import json
from fastapi import WebSocket
from api.infrastructure.services.code_generator_service_impl import CodeGeneratorServiceImpl
from typing import Dict

class WebSocketHandler:
    """Handler for WebSocket connections."""
    
    def __init__(self):
        """Initialize the WebSocket handler."""
        self.code_generator_service = CodeGeneratorServiceImpl()
    
    async def handle_websocket(self, websocket: WebSocket):
        """
        Handle WebSocket connection and messages.
        
        Args:
            websocket (WebSocket): The WebSocket connection
        """
        await websocket.accept()
        
        try:
            while True:
                # Receive message from client
                data = await websocket.receive_text()
                message = json.loads(data)
                
                if "user_query" not in message:
                    await websocket.send_json({
                        "type": "Error",
                        "value": "Missing user_query in request"
                    })
                    continue
                
                # Define callback for handling chunks
                async def on_chunk(response: Dict):
                    await websocket.send_json(response)
                
                # Generate project
                result = await self.code_generator_service.generate_project(
                    message["user_query"],
                    on_chunk
                )
                
                # Send final result
                await websocket.send_json({
                    "type": "Result",
                    "value": result
                })
                
        except Exception as e:
            await websocket.send_json({
                "type": "Error",
                "value": str(e)
            })
        finally:
            await websocket.close() 


================================================
File: code_generator/__init__.py
================================================
"""
Code Generator for LikeMinds Android Feed SDK

This package provides an interactive interface to generate code for the LikeMinds Android Feed SDK
using the Gemini 2.5 Pro model. It uses the combined documentation as context to generate
accurate and relevant code snippets based on user requests.
"""

__version__ = "1.0.0"
__all__ = [] 


================================================
File: code_generator/__main__.py
================================================
"""
Main entry point for the code generator.
"""

import sys
from code_generator.config import Settings
from code_generator.core import CodeGenerator

def main():
    """Main entry point for the code generator."""
    try:
        # Initialize settings
        settings = Settings()
        
        # Initialize code generator
        generator = CodeGenerator(settings)
        
        print("Welcome to the LikeMinds Android Feed SDK Code Generator!")
        print("Type 'exit' to quit.")
        print("--------------------------------------------------")
        
        while True:
            user_input = input("\nWhat project would you like to generate? ")
            
            if user_input.lower() == 'exit':
                break
                
            try:
                print("\nGenerating project...")
                success = generator.create_project(user_input)
                
                if success:
                    print("\nProject generated successfully!")
                else:
                    print("\nFailed to generate project. Please check the error messages above.")
                    
            except Exception as e:
                print(f"\nAn error occurred: {str(e)}")
                break
                
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main() 


================================================
File: code_generator/config/__init__.py
================================================
"""
Configuration settings for the code generator.
"""

from code_generator.config.settings import Settings

__all__ = ["Settings"] 


================================================
File: code_generator/config/settings.py
================================================
"""
Configuration settings for the code generator.
"""

import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()


class Settings:
    """
    Configuration settings for the code generator.
    Provides default values and environment variable loading.
    """
    
    def __init__(self):
        """Initialize settings with default values and load environment variables."""
        # API Configuration
        self.gemini_api_key = os.getenv("GEMINI_API_KEY")
        self.model_name = os.getenv("GEMINI_MODEL_NAME")
        # Template repository URL   
        self.template_repo_url = os.getenv("TEMPLATE_REPO_URL")  
        # Documentation path
        self.documentation_path = os.getenv("OUTPUT_FILE")
        # Output directory for generated projects
        self.output_dir = os.getenv("OUTPUT_DIR")

        # Default values for code generation
        self.default_username = "test"
        self.default_api_key = "701a4436-6bab-45b7-92e5-a1c61763e229"
        
        # Validate required settings
        self._validate_settings()
    
    def _validate_settings(self):
        """Validate that required settings are present and have valid values."""
        # Validate Gemini API Key
        if not self.gemini_api_key:
            raise ValueError("GEMINI_API_KEY not found in environment variables or .env file")
        if len(self.gemini_api_key) < 32:
            raise ValueError("GEMINI_API_KEY must be at least 32 characters long")
            
        # Validate Model Name
        if not self.model_name:
            raise ValueError("GEMINI_MODEL_NAME not found in environment variables or .env file")
        print(f"Model name from settings: {self.model_name}")
        if self.model_name not in ["gemini-2.5-pro-exp-03-25"]:
            raise ValueError("GEMINI_MODEL_NAME must be 'gemini-2.5-pro-exp-03-25'")
            
        # Validate Template Repository URL
        if not self.template_repo_url:
            raise ValueError("TEMPLATE_REPO_URL not found in environment variables or .env file")
        if not self.template_repo_url.startswith(("http://", "https://")):
            raise ValueError("TEMPLATE_REPO_URL must be a valid HTTP/HTTPS URL")
            
        # Validate Documentation Path
        if not self.documentation_path:
            raise ValueError("OUTPUT_FILE not found in environment variables or .env file")
        if not os.path.exists(self.documentation_path):
            raise ValueError(f"Documentation file not found at: {self.documentation_path}")
        if not os.path.isfile(self.documentation_path):
            raise ValueError(f"Documentation path must be a file: {self.documentation_path}")

        # Validate Output Directory
        if not self.output_dir:
            raise ValueError("OUTPUT_DIR not found in environment variables or .env file")
            


================================================
File: code_generator/core/__init__.py
================================================
"""
Core functionality for the code generator.
"""

from code_generator.core.generator import CodeGenerator

__all__ = ["CodeGenerator"] 


================================================
File: code_generator/core/generator.py
================================================
"""
Generates code using the Gemini model based on documentation.
"""

import json
import os
import subprocess
import shutil
from typing import Dict, Optional, Callable

from fastapi import WebSocket
import google.genai as genai
from google.genai import types
from code_generator.config import Settings
from code_generator.core.project_creator import ProjectCreator
from code_generator.utils import DocumentationManager

class CodeGenerator:
    """Generates code using the Gemini model based on documentation."""

    def __init__(self, settings: Settings):
        """Initialize the code generator with settings."""
        self.settings = settings
        self.documentation_manager = DocumentationManager(self.settings.documentation_path)
        self.project_creator = ProjectCreator(settings)
        
        # Configure Gemini
        self.client = genai.Client(
            api_key=settings.gemini_api_key,
            http_options=types.HttpOptions(api_version='v1alpha')
        )

    def run(self):
        """Run the code generator in interactive mode."""
        print("Welcome to the LikeMinds Android Feed SDK Code Generator!")
        print("Type 'exit' to quit.")
        print("--------------------------------------------------")
        
        while True:
            user_input = input("\nWhat project would you like to generate? ")
            
            if user_input.lower() == 'exit':
                break
                
            try:
                print("\nGenerating project...")
                success = self.create_project(user_input)
                
                if success:
                    print("\nProject generated successfully!")
                else:
                    print("\nFailed to generate project. Please check the error messages above.")
                    
            except Exception as e:
                print(f"\nAn error occurred: {str(e)}")
                break

    def _get_template_build_config(self) -> str:
        """Get the build configuration from the template repository."""
        try:
            # Use the local template directory
            template_dir = os.path.join(os.getcwd(), "code_generator", "likeminds-feed-android-social-feed-theme")
            
            # Read build configuration files
            build_config = []
            
            # Read build.gradle
            with open(os.path.join(template_dir, 'build.gradle'), 'r') as f:
                build_config.append("build.gradle:\n" + f.read())
            
            # Read gradle.properties
            with open(os.path.join(template_dir, 'gradle.properties'), 'r') as f:
                build_config.append("gradle.properties:\n" + f.read())
            
            # Read settings.gradle
            with open(os.path.join(template_dir, 'settings.gradle'), 'r') as f:
                build_config.append("settings.gradle:\n" + f.read())
            
            # Read local.properties
            with open(os.path.join(template_dir, 'local.properties'), 'r') as f:
                build_config.append("local.properties:\n" + f.read())
            
            # Skip binary files (gradlew and gradlew.bat)
            
            # Read gradle directory files
            gradle_dir = os.path.join(template_dir, 'gradle')
            if os.path.exists(gradle_dir):
                for root, dirs, files in os.walk(gradle_dir):
                    for file in files:
                        file_path = os.path.join(root, file)
                        relative_path = os.path.relpath(file_path, template_dir)
                        
                        # Skip binary files
                        if file.endswith('.jar') or file.endswith('.bat'):
                            continue
                            
                        try:
                            with open(file_path, 'r') as f:
                                build_config.append(f"{relative_path}:\n" + f.read())
                        except UnicodeDecodeError:
                            # Skip binary files
                            continue
            
            return "\n\n".join(build_config)
            
        except Exception as e:
            print(f"Error getting template build configuration: {str(e)}")
            return ""

    def _create_prompt(self, user_input: str) -> str:
        """Create a prompt for the Gemini model."""
        # Load documentation
        docs_manager = DocumentationManager(self.settings.documentation_path)
        documentation = docs_manager.load_documentation()
        
        # Get template build configuration
        build_config = self._get_template_build_config()
        
        prompt = f"""You are an expert Android developer specializing in the LikeMinds Feed SDK. 
        Your task is to generate Android project code based on the following request: {user_input}

        Follow these guidelines:
        1. Use the LikeMinds Feed SDK documentation provided below for implementation details
        2. Generate ALL necessary files including build configuration files
        3. Use the correct SDK classes and methods as specified in the documentation
        4. Follow Android best practices and Kotlin coding conventions
        5. Include proper error handling and logging
        6. Use the default username and API key provided in the settings
        7. Use the template's build configuration files as a reference for your generated files

        Documentation:
        {documentation}

        Default Settings:
        - Username: {self.settings.default_username}
        - API Key: {self.settings.default_api_key}

        Template Build Configuration:
        {build_config}

        Return a JSON object with the following structure:
        {{
            "project_name": "string",
            "files": [
                {{
                    "path": "string",  // Path relative to project root
                    "content": "string"  // File content
                }}
            ]
        }}

        Example response:
        {{
            "project_name": "SocialFeedApp",
            "files": [
                {{
                    "path": "build.gradle",
                    "content": "plugins { ... }"
                }},
                {{
                    "path": "app/build.gradle",
                    "content": "plugins { ... }"
                }},
                {{
                    "path": "settings.gradle",
                    "content": "rootProject.name = ..."
                }},
                {{
                    "path": "gradle.properties",
                    "content": "org.gradle.jvmargs=..."
                }},
                {{
                    "path": "app/src/main/java/com/example/socialfeed/MainActivity.kt",
                    "content": "package com.example.socialfeed\\n\\nimport ..."
                }}
            ]
        }}

        CRITICAL: Your response must be a valid JSON object. Do not include any markdown formatting, additional text, or explanations."""
        
        return prompt

    async def generate_code(self, user_input: str, on_chunk: Callable[[Dict], None]) -> Optional[Dict]:
        """Generate code using the Gemini model."""
        try:
            # Create prompt
            prompt = self._create_prompt(user_input)
            
            # Generate content with streaming
            print("\nGenerating code...")
            response = self.client.models.generate_content_stream(
                model=self.settings.model_name,
                contents=prompt,
            )
            
            # Process streaming response
            full_response = ""
            for chunk in response:
                if chunk.text:
                    chunk_text = chunk.text
                    print(chunk_text, end='', flush=True)
                    full_response += chunk_text
                    await on_chunk({
                        "type": "Text",
                        "value": chunk_text
                    })
            
            print("\n")  # Add newline after streaming
            
            # Clean up the response to ensure it's valid JSON
            # Remove any markdown formatting or extra text
            full_response = full_response.strip()
            if full_response.startswith("```json"):
                full_response = full_response[7:]
            if full_response.endswith("```"):
                full_response = full_response[:-3]
            full_response = full_response.strip()
            
            # Print the cleaned response for debugging
            print("Cleaned Response:\n", full_response)
            
            # Parse response
            try:
                return json.loads(full_response)
            except json.JSONDecodeError as e:
                error_msg = f"Error: Invalid JSON response from model. Please try again.\nJSON Parse Error: {str(e)}"
                print(error_msg)
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
                return None
                
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            await on_chunk({
                "type": "Error",
                "value": error_msg
            })
            return None

    async def create_project(self, user_input: str, on_chunk: Callable[[Dict], None]) -> bool:
        """
        Generate and create a complete Android project.
        
        Args:
            user_input (str): User's input describing the project to generate
            on_chunk (Callable[[Dict], None]): Callback function to handle each chunk of output
            
        Returns:
            bool: True if project was created successfully, False otherwise
        """
        try:
            # Generate project data
            project_data = await self.generate_code(user_input, on_chunk)
            
            # Create project using template
            success = self.project_creator.create_project(project_data)
            
            if success:
                await on_chunk({
                    "type": "Success",
                    "value": "Project created successfully!"
                })
            else:
                await on_chunk({
                    "type": "Error",
                    "value": "Failed to create project"
                })
            
            return success
            
        except Exception as e:
            error_msg = f"Error creating project: {str(e)}"
            print(error_msg)
            await on_chunk({
                "type": "Error",
                "value": error_msg
            })
            return False


================================================
File: code_generator/core/project_creator.py
================================================
"""
Project creator agent for generating actual Android projects from generated code.
"""

import os
import subprocess
import shutil
from pathlib import Path
from typing import Dict, List, Optional
from code_generator.config import Settings

class ProjectCreator:
    """
    Agent responsible for creating actual Android projects from generated code.
    """
    
    def __init__(self, settings: Settings):
        """
        Initialize the project creator.
        
        Args:
            settings (Settings): Settings object containing configuration
        """
        self.settings = settings
        self.output_dir = os.path.join(os.getcwd(), self.settings.output_dir)
        os.makedirs(self.output_dir, exist_ok=True)
    
    def create_project(self, project_data: Dict) -> bool:
        """
        Create a complete Android project from the generated data.
        
        Args:
            project_data (Dict): Project data containing file structure and content
            
        Returns:
            bool: True if project was created successfully, False otherwise
        """
        try:
            if not project_data:
                print("Error: No project data provided")
                return False
                
            if "project_name" not in project_data:
                print("Error: Project name not found in project data")
                return False
                
            if "files" not in project_data:
                print("Error: No files found in project data")
                return False
            
            # Create project directory
            project_name = project_data["project_name"]
            project_dir = os.path.join(self.output_dir, project_name)
            print(f"\nCreating project directory: {project_dir}")
            os.makedirs(project_dir, exist_ok=True)
            
            # Get template directory path
            template_dir = os.path.join(os.getcwd(), "code_generator", "likeminds-feed-android-social-feed-theme")
            
            # Copy Gradle wrapper files
            gradle_wrapper_files = [
                'gradlew',
                'gradlew.bat',
                'gradle/wrapper/gradle-wrapper.jar'
            ]
            
            for file in gradle_wrapper_files:
                src_path = os.path.join(template_dir, file)
                dst_path = os.path.join(project_dir, file)
                
                # Create parent directories if they don't exist
                os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                
                # Copy file
                shutil.copy2(src_path, dst_path)
            
            # Create files from generated data
            print("Creating project files...")
            for file_data in project_data["files"]:
                file_path = file_data["path"]
                content = file_data["content"]
                
                full_path = os.path.join(project_dir, file_path)
                print(f"Creating file: {full_path}")
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                with open(full_path, "w") as f:
                    f.write(content)
            
            return True
            
        except Exception as e:
            print(f"Error creating project: {str(e)}")
            return False 


================================================
File: code_generator/utils/__init__.py
================================================
"""
Utility functions and classes for the code generator.
"""

from code_generator.utils.documentation import DocumentationManager

__all__ = ['DocumentationManager'] 


================================================
File: code_generator/utils/documentation.py
================================================
"""
Documentation management utilities for the code generator.
"""

import os
from typing import Optional

class DocumentationManager:
    """
    Manages loading and handling of SDK documentation.
    """
    
    def __init__(self, documentation_path: str):
        """
        Initialize the documentation manager.
        
        Args:
            documentation_path (str): Path to the documentation file
        """
        self.documentation_path = documentation_path
        self._documentation: Optional[str] = None
    
    def load_documentation(self) -> str:
        """
        Load the documentation file into memory.
        
        Returns:
            str: The contents of the documentation file
            
        Raises:
            FileNotFoundError: If the documentation file doesn't exist
        """
        if self._documentation is None:
            if not os.path.exists(self.documentation_path):
                raise FileNotFoundError(f"Documentation file not found at {self.documentation_path}")
            
            with open(self.documentation_path, 'r', encoding='utf-8') as f:
                self._documentation = f.read()
        
        return self._documentation
    
    def clear_cache(self):
        """Clear the cached documentation."""
        self._documentation = None 


================================================
File: document_parser/__init__.py
================================================
"""
Document Parser package for processing and combining markdown documentation.
"""

__version__ = "1.0.0"
__all__ = []



================================================
File: document_parser/__main__.py
================================================
"""
Main entry point for the document parser package.
"""

from document_parser.core import DocumentParser
from document_parser.config import Settings

def main():
    """Main entry point for the document parser."""
    try:
        # Initialize settings and document parser
        settings = Settings()
        parser = DocumentParser(settings)
        
        # Generate combined document
        parser.generate_combined_document()

    except Exception as e:
        print(f"An error occurred: {str(e)}")

if __name__ == '__main__':
    main()



================================================
File: document_parser/config/__init__.py
================================================
"""
Document parser configuration package.
"""

from document_parser.config.settings import Settings

__all__ = ['Settings']



================================================
File: document_parser/config/settings.py
================================================
"""
Configuration settings for the document parser.
"""

import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Settings:
    """
    Configuration settings for the document parser.
    Provides default values and environment variable loading.
    """
    
    def __init__(self):
        """Initialize settings with default values and load environment variables."""
        # Repository configuration
        self.repo_url = os.getenv("REPO_URL")
        self.included_dirs = os.getenv("INCLUDED_DIRS", "").split(",")
        self.excluded_dirs = os.getenv("EXCLUDED_DIRS", "").split(",")
        
        # Output configuration
        self.output_file = os.getenv("OUTPUT_FILE")
        
        # Validate required settings
        self._validate_settings()
    
    def _validate_settings(self):
        """Validate that required settings are present."""
        if not self.repo_url:
            raise ValueError("REPO_URL not found in environment variables or .env file")
        if not self.included_dirs or self.included_dirs == [""]:
            raise ValueError("INCLUDED_DIRS not found in environment variables or .env file")
        if not self.output_file:
            raise ValueError("OUTPUT_FILE not found in environment variables or .env file") 


================================================
File: document_parser/core/__init__.py
================================================
"""
Core functionality for the document parser.
"""

from document_parser.core.parser import DocumentParser

__all__ = ["DocumentParser"]



================================================
File: document_parser/core/parser.py
================================================
"""
Core document parsing functionality.
"""

import os
import shutil
import subprocess
from typing import List, Set
import requests
from urllib.parse import urlparse
import re
from document_parser.config import Settings

class DocumentParser:
    def __init__(self, settings: Settings = None):
        """
        Initialize the document parser with settings.
        
        Args:
            settings (Settings, optional): Settings object for configuration
        """
        self.settings = settings or Settings()
        self.repo_name = self.settings.repo_url.split('/')[-1].replace('.git', '')
        self.repo_path = os.path.abspath(self.repo_name)
        self.processed_files: Set[str] = set()
        self.combined_content = []
        self.github_files = {}  # Store GitHub file content and their IDs

    def clone_repository(self):
        """Clone the repository if it doesn't exist."""
        if not os.path.exists(self.repo_path):
            try:
                subprocess.run(['git', 'clone', self.settings.repo_url], check=True)
                print(f"Successfully cloned repository from {self.settings.repo_url}")
            except subprocess.CalledProcessError as e:
                print(f"Error cloning repository: {str(e)}")
                raise

    def cleanup(self):
        """Remove the cloned repository after processing."""
        try:
            if os.path.exists(self.repo_path):
                shutil.rmtree(self.repo_path)
                print(f"Cleaned up repository at {self.repo_path}")
        except Exception as e:
            print(f"Error during cleanup: {str(e)}")

    def should_process_file(self, file_path: str) -> bool:
        """Check if a file should be processed based on included/excluded directories."""
        rel_path = os.path.relpath(file_path, self.repo_path)
        
        for excluded_dir in self.settings.excluded_dirs:
            if excluded_dir and rel_path.startswith(excluded_dir):
                return False
        
        for included_dir in self.settings.included_dirs:
            if included_dir and rel_path.startswith(included_dir):
                return True
        
        return False

    def extract_headings(self, content: str) -> List[str]:
        """Extract headings from markdown content."""
        headings = []
        for line in content.split('\n'):
            if line.startswith('#'):
                headings.append(line)
        return headings

    def process_file(self, file_path: str):
        """Process a single markdown file and extract its content."""
        if file_path in self.processed_files:
            return
        
        self.processed_files.add(file_path)
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Extract and convert headings to subheadings
            headings = self.extract_headings(content)
            
            # Add file path as a heading
            rel_path = os.path.relpath(file_path, self.repo_path)
            self.combined_content.append(f"# {rel_path}\n\n")
            
            # Add subheadings summary
            if headings:
                self.combined_content.append("## Subheadings in this file:\n")
                for heading in headings:
                    # Extract the text part of the heading for the summary
                    heading_text = heading.lstrip('#').strip()
                    self.combined_content.append(f"- {heading_text}\n")
                self.combined_content.append("\n")
            
            # Process content to convert headings to subheadings and links
            processed_content = []
            for line in content.split('\n'):
                if line.startswith('#'):
                    # Convert to subheading by adding one more #
                    level = len(line) - len(line.lstrip('#'))
                    heading_text = line.lstrip('#').strip()
                    processed_content.append(f"{'#' * (level + 1)} {heading_text}")
                else:
                    # Convert relative links to IDs and handle GitHub links
                    processed_line = self.convert_relative_links_to_ids(line)
                    processed_content.append(processed_line)
            
            # Add the processed content
            self.combined_content.append('\n'.join(processed_content))
            self.combined_content.append("\n---\n\n")
            
        except Exception as e:
            print(f"Error processing file {file_path}: {str(e)}")

    def process_directory(self, directory: str):
        """Process all markdown files in a directory recursively."""
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.md'):
                    file_path = os.path.join(root, file)
                    if self.should_process_file(file_path):
                        self.process_file(file_path)

    def generate_combined_document(self):
        """Generate the combined documentation file."""
        try:
            self.clone_repository()
            self.process_directory(self.repo_path)
            self.save_combined_documentation()
            print(f"Successfully generated combined documentation at {self.settings.output_file}")
        finally:
            self.cleanup()

    def fetch_github_raw_content(self, github_url: str) -> str:
        """Fetch raw content from a GitHub URL."""
        # Convert GitHub URL to raw content URL
        parsed_url = urlparse(github_url)
        if 'github.com' not in parsed_url.netloc:
            return ""
            
        # Convert to raw content URL
        path_parts = parsed_url.path.split('/')
        if len(path_parts) < 5:  # Need at least owner/repo/blob/branch/path
            return ""
            
        # Remove 'blob' from path
        if 'blob' in path_parts:
            path_parts.remove('blob')
            
        # Reconstruct raw URL
        raw_url = f"https://raw.githubusercontent.com/{'/'.join(path_parts[1:])}"
        
        try:
            response = requests.get(raw_url)
            response.raise_for_status()
            return response.text
        except Exception as e:
            print(f"Error fetching GitHub content from {raw_url}: {str(e)}")
            return ""

    def convert_relative_links_to_ids(self, content: str) -> str:
        """Convert relative path links to absolute IDs in markdown content."""
        # Pattern to match markdown links with relative paths
        pattern = r'\[([^\]]+)\]\(([^)]+)\)'
        
        def replace_link(match):
            link_text = match.group(1)
            link_path = match.group(2)
            
            # Handle GitHub links
            if 'github.com' in link_path and '/blob/' in link_path:
                # Generate a unique ID for this GitHub file
                file_id = f"github-{len(self.github_files)}"
                # Fetch and store the content
                raw_content = self.fetch_github_raw_content(link_path)
                if raw_content:
                    self.github_files[file_id] = {
                        'content': raw_content,
                        'title': link_text,
                        'url': link_path
                    }
                # Keep the original link
                return match.group(0)
            
            # Keep all other links unchanged
            return match.group(0)
        
        # Replace all relative links in the content
        return re.sub(pattern, replace_link, content)

    def save_combined_documentation(self):
        """Save the combined documentation to a file."""
        with open(self.settings.output_file, 'w', encoding='utf-8') as f:
            # Write main content
            f.write(''.join(self.combined_content))
            
            # Add GitHub files content at the end if any exist
            if self.github_files:
                f.write("\n# GitHub Files\n\n")
                for file_id, file_data in self.github_files.items():
                    f.write(f"## {file_data['title']}\n\n")
                    f.write(f"Source: [{file_data['url']}]({file_data['url']})\n\n")
                    f.write("```kotlin\n")
                    f.write(file_data['content'])
                    f.write("\n```\n\n")
                    f.write("---\n\n") 


================================================
File: document_parser/utils/__init__.py
================================================
"""
Utility functions for the document parser.
"""

__all__ = []


