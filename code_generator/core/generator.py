"""
Generates code using the Gemini model based on documentation.
"""

import json
import os
import subprocess
import shutil
from typing import Dict, List, Optional, Callable
import asyncio

from fastapi import WebSocket
import google.genai as genai
from google.genai import types
from code_generator.config import Settings
from code_generator.core.project_creator import ProjectCreator
from .constants import BUILD_CONFIG_FILES
from document_ingest.ingest import ingest_repo

class CodeGenerator:
    """Generates code using the Gemini model based on documentation."""

    def __init__(self, settings: Settings, docs_path: str, sdk_code_path: str):
        """Initialize the code generator with settings."""
        self.settings = settings
        self.docs_path = docs_path
        self.sdk_code_path = sdk_code_path
        self.project_creator = ProjectCreator(settings)
        
        # Configure Gemini
        self.client = genai.Client(
            api_key=settings.gemini_api_key,
            http_options=types.HttpOptions(api_version='v1alpha')
        )

    def run(self):
        """Run the code generator in interactive mode."""
        print("Welcome to the LikeMinds Android Feed SDK Code Generator!")
        print("Type 'exit' to quit.")
        print("--------------------------------------------------")
        
        while True:
            user_input = input("\nWhat project would you like to generate? ")
            
            if user_input.lower() == 'exit':
                break
                
            try:
                print("\nGenerating project...")
                success = self.create_project(user_input)
                
                if success:
                    print("\nProject generated successfully!")
                else:
                    print("\nFailed to generate project. Please check the error messages above.")
                    
            except Exception as e:
                print(f"\nAn error occurred: {str(e)}")
                break

    async def _create_fix_error_prompt(self, project_dir: str, error_message: str) -> str:
        """Create a prompt for fixing compilation errors."""
        try:
            # Ingest the project to get its content
            summary, tree, content, output_file = await ingest_repo(
                project_dir,
                exclude_dirs=['app/build']
            )
            
            # Read the output file content
            def read_file():
                with open(output_file, 'r', encoding='utf-8') as f:
                    return f.read()
            
            project_content = await asyncio.to_thread(read_file)
            
            # Read documentation and SDK code
            def read_docs():
                with open(self.docs_path, 'r', encoding='utf-8') as f:
                    return f.read()
            
            def read_sdk():
                with open(self.sdk_code_path, 'r', encoding='utf-8') as f:
                    return f.read()
            
            documentation = await asyncio.to_thread(read_docs)
            sdk_code = await asyncio.to_thread(read_sdk)
            
            prompt = f"""You are an expert Android developer specializing in the LikeMinds Feed SDK. 
            Your task is to fix the compilation errors in the following Android project.

            Project Content:
            {project_content}

            Compilation Error:
            {error_message}

            CRITICAL: Follow these guidelines:
            1. ONLY fix the compilation errors mentioned above. Do not make any other changes.
            2. Use the correct SDK classes and methods as specified in the documentation reference
            3. Before using any class, field, or method, verify its existence in the SDK code reference
            4. If a class, field, or method is not found in the SDK code reference, DO NOT use it
            5. If you're unsure about a class, field, or method's existence, search the SDK code reference first
            6. Do not make assumptions about class members or methods that are not explicitly shown in the SDK code reference
            7. If there's any mention of .xml resource in any .xml file directly as '@" instead of "@+", make sure the xml resource mentioned after "@" is generated by using SDK code reference
            8. Don't use View binding in any xml file
            9. Do not generate any font files
            10. Do not add any logging, debugging, or error handling code unless it is explicitly shown in the SDK code reference

            Documentation Reference:
            {documentation}

            SDK Code Reference:
            {sdk_code}

            IMPORTANT RESPONSE FORMAT:
            - Return ONLY a valid JSON object
            - The response must be a single, valid JSON object on ONE LINE
            - Do NOT include any markdown formatting, code blocks, or explanations
            - Do not include any line breaks or newlines in the JSON
            - CRITICAL: All special characters in string content must be properly escaped:
              * Newlines must be escaped as \\n
              * Double quotes must be escaped as \\"
              * Backslashes must be escaped as \\\\
              * Tabs must be escaped as \\t
            - Do not include any trailing commas
            - Ensure all strings are properly quoted with double quotes
            - Do not include any comments in the JSON
            - The entire response should be on a single line with no line breaks

            Return a JSON object with the following structure:
            {{
                "files": [
                    {{
                        "path": "string",
                        "content": "string"
                    }}
                ]
            }}

            Example response (formatted for readability, but your response should be on a single line):
            {{
                "files": [
                    {{
                        "path": "app/src/main/java/com/example/socialfeedapp/MainActivity.kt",
                        "content": "package com.example.socialfeedapp\\n\\nimport com.likeminds.feed.android.core.LMFeedCore\\n..."
                    }}
                ]
            }}"""
            
            return prompt
            
        except Exception as e:
            print(f"Error creating fix error prompt: {str(e)}")
            return None

    def _create_prompt(self, user_input: str) -> str:
        """Create a prompt for the Gemini model."""
        # Read documentation and SDK code
        with open(self.docs_path, 'r', encoding='utf-8') as f:
            documentation = f.read()
            
        with open(self.sdk_code_path, 'r', encoding='utf-8') as f:
            sdk_code = f.read()
        
        prompt = f"""You are an expert Android developer specializing in the LikeMinds Feed SDK. 
        Your task is to generate a complete Android project based on the following request: {user_input}

        CRITICAL: Follow these guidelines:
        1. ONLY implement the features and functionality specifically requested by the user. Do not add any additional features from the documentation unless explicitly requested.
        2. Generate ONLY the necessary files for the requested features EXCEPT the following build configuration files: {BUILD_CONFIG_FILES} 
        3. Use the correct SDK classes and methods as specified in the documentation reference, but only for the requested features
        4. Use the default username and API key provided in the settings
        5. The namespace should be in the format: com.example.[project_name_lowercase]
        6. The applicationId should match the namespace
        7. Before using any class, field, or method, verify its existence in the SDK code reference
        8. If a class, field, or method is not found in the SDK code reference, DO NOT use it
        9. If you're unsure about a class, field, or method's existence, search the SDK code reference first
        10. Do not make assumptions about class members or methods that are not explicitly shown in the SDK code reference
        11. If there's any mention of .xml resource in any .xml file directly as '@" instead of "@+", make sure the xml resource mentioned after "@" is generated by using SDK code reference
        12. Don't use View binding in any xml file
        13. Do not generate any font files
        14. Do not add any logging, debugging, or error handling code unless it is explicitly shown in the SDK code reference. This includes Log statements, TAG constants, try-catch blocks, and any other debugging or error handling code.

        Documentation Reference:
        {documentation}

        SDK Code Reference:
        {sdk_code}

        Default Settings:
        - Username: {self.settings.default_username}
        - API Key: {self.settings.default_api_key}

        IMPORTANT RESPONSE FORMAT:
        - Return ONLY a valid JSON object
        - Do NOT include any markdown formatting, code blocks, or explanations
        - The response must be a single, valid JSON object
        - Do not include any line breaks or newlines in the JSON
        - CRITICAL: All special characters in string content must be properly escaped:
          * Newlines must be double-escaped as \\n
          * Quotes must be escaped as \\"
          * Backslashes must be escaped as \\\\
          * Tabs must be escaped as \\t
          * Any other special characters must be properly escaped
        - Do not include any trailing commas
        - Ensure all strings are properly quoted with double quotes
        - Do not include any comments in the JSON
        - The entire response should be on a single line
        - Do not include any whitespace between JSON elements except for readability in the example

        Return a JSON object with the following structure:
        {{
            "project_name": "string",
            "namespace": "string",
            "application_id": "string",
            "files": [
                {{
                    "path": "string",
                    "content": "string"
                }}
            ]
        }}

        Example response (formatted for readability, but your response should be on a single line):
        {{
            "project_name": "SocialFeedApp",
            "namespace": "com.example.socialfeedapp",
            "application_id": "com.example.socialfeedapp",
            "files": [
                {{
                    "path": "app/src/main/java/com/example/socialfeedapp/MainActivity.kt",
                    "content": "package com.example.socialfeedapp\\n\\nimport com.likeminds.feed.android.core.LMFeedCore\\n..."
                }}
            ]
        }}"""
        
        return prompt

    async def generate_code(self, user_input: str, on_chunk: Optional[Callable[[Dict], None]] = None) -> Optional[Dict]:
        """Generate code using the Gemini model."""
        try:
            # Create prompt
            prompt = self._create_prompt(user_input)
            
            # Generate content with streaming
            print("\nGenerating code...")
            response = self.client.models.generate_content_stream(
                model=self.settings.model_name,
                contents=prompt,
            )
            
            # Process streaming response
            full_response = ""
            for chunk in response:
                if chunk.text:
                    chunk_text = chunk.text
                    print(chunk_text, end='', flush=True)
                    full_response += chunk_text
                    if on_chunk:
                        await on_chunk({
                            "type": "Text",
                            "value": chunk_text
                        })
            
            print("\n")  # Add newline after streaming
            
            # Clean up the response to ensure it's valid JSON
            full_response = full_response.strip()
            if full_response.startswith("```json"):
                full_response = full_response[7:]
            if full_response.endswith("```"):
                full_response = full_response[:-3]
            full_response = full_response.strip()
            
            # Print the cleaned response for debugging
            print("Cleaned Response:\n", full_response)
            
            # Parse response
            try:
                return json.loads(full_response)
            except json.JSONDecodeError as e:
                error_msg = f"Error: Invalid JSON response from model. Please try again.\nJSON Parse Error: {str(e)}"
                print(error_msg)
                if on_chunk:
                    await on_chunk({
                        "type": "Error",
                        "value": error_msg
                    })
                return None
                
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            if on_chunk:
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
            return None

    async def fix_compilation_errors(self, project_dir: str, error_message: str, on_chunk: Optional[Callable[[Dict], None]] = None) -> Optional[Dict]:
        """Fix compilation errors in the project."""
        try:
            # Create prompt
            prompt = await self._create_fix_error_prompt(project_dir, error_message)
            if not prompt:
                print("Error: Failed to create fix error prompt")
                return None
            
            # Generate content with streaming
            print("\nFixing compilation errors...")
            response = self.client.models.generate_content_stream(
                model=self.settings.model_name,
                contents=prompt,
            )
            
            # Process streaming response
            full_response = ""
            for chunk in response:
                if chunk.text:
                    chunk_text = chunk.text
                    print(chunk_text, end='', flush=True)
                    full_response += chunk_text
                    if on_chunk:
                        await on_chunk({
                            "type": "Text",
                            "value": chunk_text
                        })
            
            print("\n")  # Add newline after streaming
            
            # Clean up the response to ensure it's valid JSON
            full_response = full_response.strip()
            if full_response.startswith("```json"):
                full_response = full_response[7:]
            if full_response.endswith("```"):
                full_response = full_response[:-3]
            full_response = full_response.strip()
            
            # Parse response
            try:
                return json.loads(full_response)
            except json.JSONDecodeError as e:
                error_msg = f"Error: Invalid JSON response from model. Please try again.\nJSON Parse Error: {str(e)}"
                print(error_msg)
                if on_chunk:
                    await on_chunk({
                        "type": "Error",
                        "value": error_msg
                    })
                return None
                
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            if on_chunk:
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
            return None

    async def create_project(self, user_input: str, on_chunk: Optional[Callable[[Dict], None]] = None) -> bool:
        """
        Generate and create a complete Android project.
        
        Args:
            user_input (str): User's input describing the project to generate
            on_chunk (Optional[Callable[[Dict], None]]): Optional callback function to handle each chunk of output
            
        Returns:
            bool: True if project was created successfully, False otherwise
        """
        try:
            # Generate code
            project_data = await self.generate_code(user_input, on_chunk)
            if not project_data:
                return False
            
            # Create project
            success, error_message = self.project_creator.create_project(project_data, on_chunk)
            
            # If there are compilation errors, try to fix them
            if not success and error_message:
                print("\nAttempting to fix compilation errors...")
                fix_data = await self.fix_compilation_errors(
                    os.path.join(self.project_creator.output_dir, project_data["project_name"]),
                    error_message,
                    on_chunk
                )
                
                if fix_data:
                    # Update the project data with the fixe d files
                    for file_data in fix_data["files"]:
                        # Find and update the corresponding file in project_data
                        for i, existing_file in enumerate(project_data["files"]):
                            if existing_file["path"] == file_data["path"]:
                                project_data["files"][i] = file_data
                                break
                    
                    # Try creating the project again with fixed files
                    success, error_message = self.project_creator.create_project(project_data, on_chunk)
            
            return success
            
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            if on_chunk:
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
            return False