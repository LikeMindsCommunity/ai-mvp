"""
Generates code using the Gemini model based on documentation.
"""

import json
import os
import subprocess
import shutil
from typing import Dict, List, Optional, Callable
import asyncio

from fastapi import WebSocket
import google.genai as genai
from google.genai import types
from code_generator.config import Settings
from code_generator.core.project_creator import ProjectCreator
from .constants import BUILD_CONFIG_FILES
from document_ingest.ingest import ingest_repo

class CodeGenerator:
    """Generates code using the Gemini model based on documentation."""

    def __init__(self, settings: Settings):
        """Initialize the code generator with settings."""
        self.settings = settings
        self.docs_path = settings.docs_path
        self.sdk_code_path = settings.sdk_code_path
        self.project_creator = ProjectCreator(settings)
        
        # Configure Gemini
        self.client = genai.Client(
            api_key=settings.gemini_api_key,
            http_options=types.HttpOptions(api_version='v1alpha')
        )

    async def run(self):
        """Run the code generator in interactive mode."""
        print("Welcome to the LikeMinds Android Feed SDK Code Generator!")
        print("Type 'exit' to quit.")
        print("--------------------------------------------------")
        
        while True:
            user_input = input("\nWhat project would you like to generate? ")
            
            if user_input.lower() == 'exit':
                break
                
            try:
                print("\nGenerating project...")
                success = await self.create_project(user_input)
                
                if success:
                    print("\nProject generated successfully!")
                else:
                    print("\nFailed to generate project. Please check the error messages above.")
                    
            except Exception as e:
                print(f"\nAn error occurred: {str(e)}")
                break

    async def _create_fix_error_prompt(self, project_dir: str, error_message: str) -> str:
        """Create a prompt for fixing compilation errors."""
        try:
            # Ingest the project to get its content
            summary, tree, content, output_file = await ingest_repo(
                project_dir,
                exclude_dirs=['app/build']
            )
            
            # Read the output file content
            def read_file():
                with open(output_file, 'r', encoding='utf-8') as f:
                    return f.read()
            
            project_content = await asyncio.to_thread(read_file)
            
            # Read documentation and SDK code
            def read_docs():
                with open(self.docs_path, 'r', encoding='utf-8') as f:
                    return f.read()
            
            def read_sdk():
                with open(self.sdk_code_path, 'r', encoding='utf-8') as f:
                    return f.read()
            
            documentation = await asyncio.to_thread(read_docs)
            sdk_code = await asyncio.to_thread(read_sdk)
            
            prompt = f"""You are an expert Android developer specializing in the LikeMinds Feed SDK. 
            Your task is to fix the compilation errors in the following Android project.

            Project Content:
            {project_content}

            Compilation Error:
            {error_message}

            CRITICAL: Follow these guidelines:
            1. ONLY fix the compilation errors mentioned above. Do not make any other changes.
            2. Use the correct SDK classes and methods as specified in the documentation reference
            3. Before using any class, field, or method, verify its existence in the SDK code reference
            4. If a class, field, or method is not found in the SDK code reference, DO NOT use it
            5. If you're unsure about a class, field, or method's existence, search the SDK code reference first
            6. Do not make assumptions about class members or methods that are not explicitly shown in the SDK code reference
            7. If there's any mention of .xml resource in any .xml file directly as '@" instead of "@+", make sure the xml resource mentioned after "@" is generated by using SDK code reference
            8. Don't use View binding in any xml file
            9. Do not generate any font files
            10. Do not add any logging, debugging, or error handling code unless it is explicitly shown in the SDK code reference

            Documentation Reference:
            {documentation}

            SDK Code Reference:
            {sdk_code}

            CRITICAL JSON FORMATTING RULES:
            1. The response must be a single, valid JSON object on ONE LINE
            2. All special characters in string content must be properly escaped:
               * Newlines must be escaped as \\n
               * Double quotes must be escaped as \\"
               * Backslashes must be escaped as \\\\
               * Tabs must be escaped as \\t
               * Any other special characters must be properly escaped
            3. For XML content:
               * All XML attributes must have their quotes escaped
               * All XML tags must have their angle brackets escaped
               * All XML content must be on a single line with escaped newlines
               * Example: "<vector xmlns:android=\\"http://schemas.android.com/apk/res/android\\"\\n    android:width=\\"108dp\\"\\n    android:height=\\"108dp\\"\\n    android:viewportWidth=\\"108\\"\\n    android:viewportHeight=\\"108\\">"
            4. Do not include any trailing commas
            5. Ensure all strings are properly quoted with double quotes
            6. Do not include any comments in the JSON
            7. The entire response should be on a single line with no line breaks
            8. Do not include any markdown formatting or code blocks
            9. Do not include any whitespace between JSON elements except for readability in the example

            Return a JSON object with the following structure:
            {{
                "files": [
                    {{
                        "path": "string",
                        "content": "string"
                    }}
                ]
            }}

            Example response (formatted for readability, but your response should be on a single line):
            {{
                "files": [
                    {{
                        "path": "app/src/main/java/com/example/socialfeedapp/MainActivity.kt",
                        "content": "package com.example.socialfeedapp\\n\\nimport com.likeminds.feed.android.core.LMFeedCore\\n..."
                    }},
                    {{
                        "path": "app/src/main/res/layout/activity_main.xml",
                        "content": "<?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>\\n<FrameLayout xmlns:android=\\"http://schemas.android.com/apk/res/android\\"\\n    android:layout_width=\\"match_parent\\"\\n    android:layout_height=\\"match_parent\\">\\n</FrameLayout>"
                    }}
                ]
            }}"""
            
            return prompt
            
        except Exception as e:
            print(f"Error creating fix error prompt: {str(e)}")
            return None

    def _create_prompt(self, user_input: str) -> str:
        """Create a prompt for the Gemini model."""
        # Read documentation and SDK code
        with open(self.docs_path, 'r', encoding='utf-8') as f:
            documentation = f.read()
            
        with open(self.sdk_code_path, 'r', encoding='utf-8') as f:
            sdk_code = f.read()
        
        prompt = f"""You are an expert Android developer specializing in the LikeMinds Feed SDK. 
        Your task is to generate a complete Android project based on the following request: {user_input}

        CRITICAL: Follow these guidelines:
        1. ONLY implement the features and functionality specifically requested by the user. Do not add any additional features from the documentation unless explicitly requested.
        2. Generate ONLY the necessary files for the requested features EXCEPT the following build configuration files: {BUILD_CONFIG_FILES} 
        3. Use the correct SDK classes and methods as specified in the documentation reference, but only for the requested features
        4. Use the default username and API key provided in the settings
        5. The namespace should be in the format: com.example.[project_name_lowercase]
        6. The applicationId should match the namespace
        7. Before using any class, field, or method, verify its existence in the SDK code reference
        8. If a class, field, or method is not found in the SDK code reference, DO NOT use it
        9. If you're unsure about a class, field, or method's existence, search the SDK code reference first
        10. Do not make assumptions about class members or methods that are not explicitly shown in the SDK code reference
        11. If there's any mention of .xml resource in any .xml file directly as '@" instead of "@+", make sure the xml resource mentioned after "@" is generated by using SDK code reference
        12. Don't use View binding in any xml file
        13. Do not generate any font files
        14. Do not add any logging, debugging, or error handling code unless it is explicitly shown in the SDK code reference. This includes Log statements, TAG constants, try-catch blocks, and any other debugging or error handling code.
        15. Use Theme.Material3.Light.NoActionBar as the parent theme for the app
        16. For drawables, ONLY generate XML files (vector drawables, shape drawables, etc.). DO NOT generate any WebP, PNG, or other image format files.
        17. All drawables must be created using XML definitions (vector, shape, layer-list, etc.)
        18. Generate default launcher icons (`ic_launcher` and `ic_launcher_round`) in the `mipmap` directories with appropriate XML vector drawable definitions.
        19. Validate all generated resources and ensure they are properly referenced in the manifest and code.

        Documentation Reference:
        {documentation}

        SDK Code Reference:
        {sdk_code}

        Default Settings:
        - Username: {self.settings.default_username}
        - API Key: {self.settings.default_api_key}

        CRITICAL JSON FORMATTING RULES:
        1. The response must be a single, valid JSON object on ONE LINE
        2. All special characters in string content must be properly escaped:
            * Newlines must be escaped as \\n
            * Double quotes must be escaped as \\"
            * Backslashes must be escaped as \\\\
            * Tabs must be escaped as \\t
            * Any other special characters must be properly escaped
        3. For XML content (very important):
            * All XML attributes must use consistently escaped double quotes (\\" at both start and end)
            * Never mix quote styles within XML attributes (e.g., no "value\\" or \"value")
            * All XML tags must use proper angle brackets (< and >)
            * All XML content must be on a single line with escaped newlines (\\n)
            * Example: "<vector xmlns:android=\\"http://schemas.android.com/apk/res/android\\"\\n    android:width=\\"108dp\\"\\n    android:height=\\"108dp\\"\\n    android:viewportWidth=\\"108\\"\\n    android:viewportHeight=\\"108\\">"
        4. Do not include any trailing commas
        5. Ensure all strings are properly quoted with double quotes
        6. Do not include any comments in the JSON
        7. The entire response should be on a single line with no line breaks
        8. Do not include any markdown formatting or code blocks
        9. Do not include any whitespace between JSON elements except for readability in the example
        10. After each file object in the files array, there MUST be a comma (,) except for the last one
        11. The JSON must be valid and parseable - validate EACH file's content individually before assembling the final JSON
        12. The response must start with {{ and end with }}
        13. All property names must be in double quotes
        14. All string values must be in double quotes
        15. No trailing commas after the last element in arrays or objects
        16. Before returning the final response, verify that all XML attributes have properly matched opening and closing quotes
        17. Pay special attention to XML attributes like android:id, android:layout_width, etc. to ensure quote consistency

        IMPORTANT: Before finalizing your response, verify that:
        - All XML attributes have properly escaped opening AND closing quotes
        - There are no unbalanced quotes in any string
        - Every open bracket has a matching close bracket
        - All file paths are properly escaped
        - Each file's content is valid for its file type

        Return a JSON object with the following structure:
        {{
            "project_name": "string",
            "namespace": "string",
            "application_id": "string",
            "files": [
                {{
                    "path": "string",
                    "content": "string"
                }},
                {{
                    "path": "string",
                    "content": "string"
                }}
            ]
        }}

        Example response (formatted for readability, but your response should be on a single line):
        {{
            "project_name": "SocialFeedApp",
            "namespace": "com.example.socialfeedapp",
            "application_id": "com.example.socialfeedapp",
            "files": [
                {{
                    "path": "app/src/main/java/com/example/socialfeedapp/MainActivity.kt",
                    "content": "package com.example.socialfeedapp\\n\\nimport com.likeminds.feed.android.core.LMFeedCore\\n..."
                }},
                {{
                    "path": "app/src/main/res/layout/activity_main.xml",
                    "content": "<?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>\\n<FrameLayout xmlns:android=\\"http://schemas.android.com/apk/res/android\\"\\n    android:layout_width=\\"match_parent\\"\\n    android:layout_height=\\"match_parent\\">\\n</FrameLayout>"
                }},
                {{
                    "path": "app/src/main/res/drawable/ic_background.xml",
                    "content": "<?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>\\n<vector xmlns:android=\\"http://schemas.android.com/apk/res/android\\"\\n    android:width=\\"24dp\\"\\n    android:height=\\"24dp\\"\\n    android:viewportWidth=\\"24\\"\\n    android:viewportHeight=\\"24\\">\\n    <path android:fillColor=\\"#FF000000\\" android:pathData=\\"M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2z\\"/>\\n</vector>"
                }}
            ]
        }}"""
        
        return prompt

    async def generate_code(self, user_input: str, on_chunk: Optional[Callable[[Dict], None]] = None) -> Optional[Dict]:
        """Generate code using the Gemini model."""
        try:
            # Create prompt
            prompt = self._create_prompt(user_input)
            
            # Generate content with streaming
            print("\nGenerating code...")
            response = self.client.models.generate_content_stream(
                model=self.settings.gemini_model_name,
                contents=prompt,
            )
            
            # Process streaming response
            full_response = ""
            for chunk in response:
                if chunk.text:
                    chunk_text = chunk.text
                    print(chunk_text, end='', flush=True)
                    full_response += chunk_text
                    if on_chunk:
                        await on_chunk({
                            "type": "Text",
                            "value": chunk_text
                        })
            
            print("\n")  # Add newline after streaming
            
            # Clean up the response to ensure it's valid JSON
            full_response = full_response.strip()
            if full_response.startswith("```json"):
                full_response = full_response[7:]
            if full_response.endswith("```"):
                full_response = full_response[:-3]
            full_response = full_response.strip()
            
            # Print the cleaned response for debugging
            print("Cleaned Response:\n", full_response)
            
            # Parse response
            try:
                return json.loads(full_response)
            except json.JSONDecodeError as e:
                error_msg = f"Error: Invalid JSON response from model. Please try again.\nJSON Parse Error: {str(e)}"
                print(error_msg)
                if on_chunk:
                    await on_chunk({
                        "type": "Error",
                        "value": error_msg
                    })
                return None
                
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            if on_chunk:
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
            return None

    async def fix_compilation_errors(self, project_dir: str, error_message: str, on_chunk: Optional[Callable[[Dict], None]] = None) -> Optional[Dict]:
        """Fix compilation errors in the project."""
        try:
            # Create prompt
            prompt = await self._create_fix_error_prompt(project_dir, error_message)
            if not prompt:
                print("Error: Failed to create fix error prompt")
                return None
            
            # Generate content with streaming
            print("\nFixing compilation errors...")
            response = self.client.models.generate_content_stream(
                model=self.settings.gemini_model_name,
                contents=prompt,
            )
            
            # Process streaming response
            full_response = ""
            for chunk in response:
                if chunk.text:
                    chunk_text = chunk.text
                    print(chunk_text, end='', flush=True)
                    full_response += chunk_text
                    if on_chunk:
                        await on_chunk({
                            "type": "Text",
                            "value": chunk_text
                        })
            
            print("\n")  # Add newline after streaming
            
            # Clean up the response to ensure it's valid JSON
            full_response = full_response.strip()
            if full_response.startswith("```json"):
                full_response = full_response[7:]
            if full_response.endswith("```"):
                full_response = full_response[:-3]
            full_response = full_response.strip()
            
            # Parse response
            try:
                return json.loads(full_response)
            except json.JSONDecodeError as e:
                error_msg = f"Error: Invalid JSON response from model. Please try again.\nJSON Parse Error: {str(e)}"
                print(error_msg)
                if on_chunk:
                    await on_chunk({
                        "type": "Error",
                        "value": error_msg
                    })
                return None
                
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            if on_chunk:
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
            return None

    async def create_project(self, user_input: str, on_chunk: Optional[Callable[[Dict], None]] = None) -> bool:
        """
        Generate and create a complete Android project.
        
        Args:
            user_input (str): User's input describing the project to generate
            on_chunk (Optional[Callable[[Dict], None]]): Optional callback function to handle each chunk of output
            
        Returns:
            bool: True if project was created successfully, False otherwise
        """
        try:
            # Generate code
            project_data = await self.generate_code(user_input, on_chunk)
            if not project_data:
                return False
            
            # Create project
            success, error_message = self.project_creator.create_project(project_data, on_chunk)
            
            # Keep trying to fix errors until success is achieved or max attempts reached
            max_attempts = 3  # Maximum number of fix attempts
            attempt = 0
            
            while not success and attempt < max_attempts:
                print(f"\nError: {error_message}")
                print(f"\nAttempting to fix compilation errors (attempt {attempt + 1}/{max_attempts})...")
                
                # Get the project directory
                project_dir = os.path.join(self.project_creator.output_dir, project_data["project_name"])
                
                # Try to fix the errors
                fix_data = await self.fix_compilation_errors(
                    project_dir,
                    error_message,
                    on_chunk
                )
                
                if fix_data:
                    # Update the project data with the fixed files
                    for file_data in fix_data["files"]:
                        # Find and update the corresponding file in project_data
                        for i, existing_file in enumerate(project_data["files"]):
                            if existing_file["path"] == file_data["path"]:
                                project_data["files"][i] = file_data
                                break
                    
                    # Try creating the project again with fixed files
                    success, error_message = self.project_creator.create_project(project_data, on_chunk)
                else:
                    print("Failed to generate fix data. Moving to next attempt...")
                    error_message = "Failed to generate fix data"
                
                attempt += 1
            
            if not success and attempt >= max_attempts:
                print("\nMaximum fix attempts reached. Could not resolve all errors.")
                if on_chunk:
                    await on_chunk({
                        "type": "Error",
                        "value": "Maximum fix attempts reached. Could not resolve all errors."
                    })
            
            return success
            
        except Exception as e:
            error_msg = f"\nError: {str(e)}"
            print(error_msg)
            if on_chunk:
                await on_chunk({
                    "type": "Error",
                    "value": error_msg
                })
            return False